---
title: О необработанном вводе
description: В этом разделе обсуждаются пользовательские данные с устройств, таких как джойстики, сенсорные экраны и микрофоны.
ms.assetid: 013ed309-f667-47ed-ade0-5e7ca5a0997a
keywords:
- Ввод данных пользователем, необработанный ввод
- запись вводимых пользователем данных, необработанные входные данные
- необработанный ввод
- регистрация необработанных входных данных
- чтение необработанного ввода
- необработанные входные данные джойстика
- Ввод необработанного сенсорного экрана
- Ввод необработанного микрофона
- Устройство HID
- HID (устройство HID)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b3535e5601ec63a254c76060611999a1a2f08aeb
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2020
ms.locfileid: "104069997"
---
# <a name="about-raw-input"></a>О необработанном вводе

Рядом с традиционной клавиатурой и мышью имеется много пользовательских устройств ввода. Например, вводимые пользователем данные могут поступать из джойстика, сенсорного экрана, микрофона или других устройств, которые обеспечивают большую гибкость при вводе данных пользователем. Эти устройства в совокупности называются устройствами с человеческим интерфейсом (Хидс). API необработанных входных данных обеспечивает устойчивый и надежный способ приема необработанных данных от любых HID-приложений, включая клавиатуру и мышь.

В этом разделе описываются следующие темы:

-   [Необработанная входная модель](#raw-input-model)
-   [Регистрация для ввода необработанных данных](#registration-for-raw-input)
-   [Чтение необработанного ввода](#reading-raw-input)

## <a name="raw-input-model"></a>Необработанная входная модель

Ранее, клавиатура и мышь, как правило, генерируют входные данные. Система интерпретирует данные, поступающие с этих устройств, таким образом, чтобы исключить сведения об необработанных данных для конкретных устройств. Например, клавиатура создает код проверки для конкретного устройства, но система предоставляет приложению код виртуального ключа. Помимо скрытия сведений необработанного ввода, диспетчер окон не поддерживал все новые Хидс. Чтобы получить входные данные из неподдерживаемого Хидс, приложению пришлось делать многие вещи: открыть устройство, управлять общим режимом, периодически читать устройство или настроить порт завершения ввода-вывода и т. д. Модель необработанных входных данных и соответствующие API были разработаны, чтобы обеспечить простой доступ к необработанным данным со всех устройств ввода, включая клавиатуру и мышь.

Необработанная входная модель отличается от исходной модели ввода Windows для клавиатуры и мыши. В исходной входной модели приложение получает ненезависимые от устройства входные данные в форме сообщений, которые отправляются или передаются в окнах, например [**WM \_ char**](wm-char.md), [**WM \_ MOUSEMOVE**](wm-mousemove.md)и [**WM \_ аппкомманд**](wm-appcommand.md). В отличие от необработанных входных данных приложение должно зарегистрировать устройства, из которых требуется получить данные. Кроме того, приложение получает необработанный ввод с помощью сообщения [**\_ ввода WM**](wm-input.md) .

Модель необработанных входных данных имеет несколько преимуществ.

-   Приложению не требуется обнаруживать или открывать входное устройство.
-   Приложение получает данные непосредственно с устройства и обрабатывает их потребности.
-   Приложение может отличать источник входных данных, даже если он относится к одному типу устройства. Например, два устройства мыши.
-   Приложение управляет трафиком данных путем указания данных из коллекции устройств или только конкретных типов устройств.
-   Устройства HID можно использовать по мере их появления в Marketplace, не дожидаясь поступления новых типов сообщений или обновленной операционной системы для использования новых команд в [**WM \_ аппкомманд**](wm-appcommand.md).

Обратите внимание, что [**WM \_ аппкомманд**](wm-appcommand.md) предоставляет для некоторых HID устройств. Однако **WM \_ аппкомманд** — это независимое от устройства входное событие, а [**\_ Вход WM**](wm-input.md) отправляет необработанные данные низкого уровня, характерные для устройства.

## <a name="registration-for-raw-input"></a>Регистрация для ввода необработанных данных

По умолчанию приложение не получает необработанные входные данные. Чтобы получить необработанные данные с устройства, приложение должно зарегистрировать устройство.

Для регистрации устройств приложение сначала создает массив структур [**равинпутдевице**](/windows/win32/api/winuser/ns-winuser-rawinputdevice) , задающих [коллекцию верхнего уровня](/windows-hardware/drivers/hid/top-level-collections) (ТЛК) для нужных устройств. ТЛК определяется [страницей использования](/windows-hardware/drivers/hid/hid-usages#usage-page) (класс устройства) и [идентификатором использования](/windows-hardware/drivers/hid/hid-usages#usage-id) (устройством в классе). Например, чтобы получить клавиатуру ТЛК, задайте Усажепаже = 0x01 и Усажеид = 0x06. Приложение вызывает [**регистерравинпутдевицес**](/windows/win32/api/winuser/nf-winuser-registerrawinputdevices) для регистрации устройств.

Обратите внимание, что приложение может зарегистрировать устройство, которое в настоящее время не подключено к системе. Когда устройство подключено, Диспетчер Windows автоматически отправляет необработанные входные данные в приложение. Чтобы получить список устройств ввода необработанных данных в системе, приложение вызывает [**жетравинпутдевицелист**](/windows/win32/api/winuser/nf-winuser-getrawinputdevicelist). Используя *хдевице* из этого вызова, приложение вызывает [**жетравинпутдевицеинфо**](/windows/win32/api/winuser/nf-winuser-getrawinputdeviceinfoa) для получения сведений об устройстве.

С помощью члена **dwFlags** в [**равинпутдевице**](/windows/win32/api/winuser/ns-winuser-rawinputdevice)приложение может выбрать устройства для прослушивания, а также те, которые требуется игнорировать. Например, приложение может запросить входные данные со всех устройств телефонии, за исключением ответов на компьютеры. Пример кода см. в разделе [Регистрация для ввода необработанных данных](using-raw-input.md).

Обратите внимание, что мышь и клавиатура также являются Хидс, поэтому данные из них могут быть получены как с помощью HID-сообщений [**WM \_ , так**](wm-input.md) и из традиционных сообщений. Приложение может выбрать любой из методов в [**равинпутдевице**](/windows/win32/api/winuser/ns-winuser-rawinputdevice).

Чтобы получить состояние регистрации приложения, вызовите [**жетрегистередравинпутдевицес**](/windows/win32/api/winuser/nf-winuser-getregisteredrawinputdevices) в любое время.

## <a name="reading-raw-input"></a>Чтение необработанного ввода

Приложение получает необработанный ввод из любой HID, чей [коллекция верхнего уровня](/windows-hardware/drivers/hid/top-level-collections) (ТЛК) соответствует ТЛК из регистрации. Когда приложение получает необработанный ввод, его очередь сообщений получает [**\_ входное сообщение WM**](wm-input.md) и флаг состояния очереди **QS \_ равинпут** (**\_ Вход QS** также включает этот флаг). Приложение может принимать данные, когда оно находится на переднем плане, и когда оно находится в фоновом режиме.

Существует два способа чтения необработанных данных: метод без буферизации (или стандартный) и буферизованный метод. Небуферизованный метод получает необработанные данные по одной структуре [**равинпут**](/windows/win32/api/winuser/ns-winuser-rawinput) за раз и подходит для многих хидс. В этом случае приложение вызывает метод [**onmessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) для получения [**\_ входного сообщения WM**](wm-input.md) . Затем приложение вызывает [**жетравинпутдата**](/windows/win32/api/winuser/nf-winuser-getrawinputdata) с помощью обработчика **равинпут** , содержащегося в **\_ входных данных WM**. Пример см. в разделе [Выполнение стандартного чтения необработанных данных](using-raw-input.md).

В отличие от этого, буферизованный метод получает массив структур [**равинпут**](/windows/win32/api/winuser/ns-winuser-rawinput) за раз. Он предоставляется для устройств, которые могут создавать большие объемы необработанных данных. В этом методе приложение вызывает [**жетравинпутбуффер**](/windows/win32/api/winuser/nf-winuser-getrawinputbuffer) для получения массива структур **равинпут** . Обратите внимание, что макрос [**некстравинпутблокк**](/windows/win32/api/winuser/nf-winuser-nextrawinputblock) используется для прохода по массиву структур **равинпут** . Пример см. в разделе [выполнение буферизованного чтения необработанных входных данных](using-raw-input.md).

Для интерпретации необработанного ввода необходимо получить подробные сведения о Хидс. Приложение получает сведения об устройстве, вызывая [**жетравинпутдевицеинфо**](/windows/win32/api/winuser/nf-winuser-getrawinputdeviceinfoa) с помощью обработчика устройства. Этот обработчик может поступать либо [**из \_ входных данных WM**](wm-input.md) , либо из члена **хдевице** [**равинпусеадер**](/windows/win32/api/winuser/ns-winuser-rawinputheader).