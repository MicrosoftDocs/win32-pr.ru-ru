---
description: Память, принадлежащая процессу, неявно защищается его частным виртуальным адресным пространством.
ms.assetid: 70ded07a-7be6-4189-a1ae-281917f42a1e
title: Защита памяти
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bd30df8084c91a62c28414f4a8142397ee777e52
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104156882"
---
# <a name="memory-protection"></a><span data-ttu-id="16192-103">Защита памяти</span><span class="sxs-lookup"><span data-stu-id="16192-103">Memory Protection</span></span>

<span data-ttu-id="16192-104">Память, принадлежащая процессу, неявно защищается его частным виртуальным адресным пространством.</span><span class="sxs-lookup"><span data-stu-id="16192-104">Memory that belongs to a process is implicitly protected by its private virtual address space.</span></span> <span data-ttu-id="16192-105">Кроме того, Windows обеспечивает защиту памяти с помощью аппаратного обеспечения виртуальной памяти.</span><span class="sxs-lookup"><span data-stu-id="16192-105">In addition, Windows provides memory protection by using the virtual memory hardware.</span></span> <span data-ttu-id="16192-106">Реализация этой защиты зависит от процессора, например, кодовые страницы в адресном пространстве процесса могут быть помечены только для чтения и защищены от изменения потоками пользовательского режима.</span><span class="sxs-lookup"><span data-stu-id="16192-106">The implementation of this protection varies with the processor, for example, code pages in the address space of a process can be marked read-only and protected from modification by user-mode threads.</span></span>

<span data-ttu-id="16192-107">Полный список атрибутов см. в разделе [константы защиты памяти](memory-protection-constants.md).</span><span class="sxs-lookup"><span data-stu-id="16192-107">For the complete list of attributes, see [Memory Protection Constants](memory-protection-constants.md).</span></span>

## <a name="copy-on-write-protection"></a><span data-ttu-id="16192-108">Защита от копирования при записи</span><span class="sxs-lookup"><span data-stu-id="16192-108">Copy-on-Write Protection</span></span>

<span data-ttu-id="16192-109">Защита от копирования при записи — это оптимизация, которая позволяет нескольким процессам сопоставлять свои виртуальные адресные пространства таким образом, что они совместно используют физическую страницу, пока один из процессов не изменит страницу.</span><span class="sxs-lookup"><span data-stu-id="16192-109">Copy-on-write protection is an optimization that allows multiple processes to map their virtual address spaces such that they share a physical page until one of the processes modifies the page.</span></span> <span data-ttu-id="16192-110">Это часть метода, называемого *отложенным вычислением*, который позволяет системе экономить физическую память и время, не выполняя операции до абсолютной необходимости.</span><span class="sxs-lookup"><span data-stu-id="16192-110">This is part of a technique called *lazy evaluation*, which allows the system to conserve physical memory and time by not performing an operation until absolutely necessary.</span></span>

<span data-ttu-id="16192-111">Например, предположим, что два процесса загружают страницы из одной и той же библиотеки DLL в виртуальные пространства памяти.</span><span class="sxs-lookup"><span data-stu-id="16192-111">For example, suppose two processes load pages from the same DLL into their virtual memory spaces.</span></span> <span data-ttu-id="16192-112">Эти страницы виртуальной памяти сопоставлены с одними и теми же страницами физической памяти для обоих процессов.</span><span class="sxs-lookup"><span data-stu-id="16192-112">These virtual memory pages are mapped to the same physical memory pages for both processes.</span></span> <span data-ttu-id="16192-113">Если ни один из процессов не выполняет запись на эти страницы, они могут сопоставляться с теми же физическими страницами и предоставлять к ним общий доступ, как показано на следующей схеме.</span><span class="sxs-lookup"><span data-stu-id="16192-113">As long as neither process writes to these pages, they can map to and share, the same physical pages, as shown in the following diagram.</span></span>

![поля и стрелки страниц Process 1 и 2, сопоставленные с одинаковой физической памятью](images/mem1.png)

<span data-ttu-id="16192-115">Если процесс 1 записывает данные на одну из этих страниц, содержимое физической страницы копируется на другую физическую страницу, а таблица виртуальной памяти обновляется для процесса 1.</span><span class="sxs-lookup"><span data-stu-id="16192-115">If Process 1 writes to one of these pages, the contents of the physical page are copied to another physical page and the virtual memory map is updated for Process 1.</span></span> <span data-ttu-id="16192-116">Оба процесса теперь имеют свой собственный экземпляр страницы в физической памяти.</span><span class="sxs-lookup"><span data-stu-id="16192-116">Both processes now have their own instance of the page in physical memory.</span></span> <span data-ttu-id="16192-117">Таким образом, один процесс не может выполнить запись на общую физическую страницу, и для просмотра изменений другим процессом.</span><span class="sxs-lookup"><span data-stu-id="16192-117">Therefore, it is not possible for one process to write to a shared physical page and for the other process to see the changes.</span></span>

![поля и стрелки процессов и перераспределение физической памяти](images/mem2.png)

## <a name="loading-applications-and-dlls"></a><span data-ttu-id="16192-119">Загрузка приложений и библиотек DLL</span><span class="sxs-lookup"><span data-stu-id="16192-119">Loading Applications and DLLs</span></span>

<span data-ttu-id="16192-120">При загрузке нескольких экземпляров одного приложения на основе Windows каждый экземпляр выполняется в собственном защищенном виртуальном адресном пространстве.</span><span class="sxs-lookup"><span data-stu-id="16192-120">When multiple instances of the same Windows-based application are loaded, each instance is run in its own protected virtual address space.</span></span> <span data-ttu-id="16192-121">Однако дескрипторы экземпляров (*HINSTANCE*) обычно имеют одинаковое значение.</span><span class="sxs-lookup"><span data-stu-id="16192-121">However, their instance handles (*hInstance*) typically have the same value.</span></span> <span data-ttu-id="16192-122">Это значение представляет базовый адрес приложения в его виртуальном адресном пространстве.</span><span class="sxs-lookup"><span data-stu-id="16192-122">This value represents the base address of the application in its virtual address space.</span></span> <span data-ttu-id="16192-123">Если каждый экземпляр можно загрузить в базовый адрес по умолчанию, он может сопоставляться с другими экземплярами и совместно использовать одни и те же физические страницы, используя защиту от копирования при записи.</span><span class="sxs-lookup"><span data-stu-id="16192-123">If each instance can be loaded into its default base address, it can map to and share the same physical pages with the other instances, using copy-on-write protection.</span></span> <span data-ttu-id="16192-124">Система позволяет этим экземплярам совместно использовать одни и те же физические страницы, пока один из них не изменит страницу.</span><span class="sxs-lookup"><span data-stu-id="16192-124">The system allows these instances to share the same physical pages until one of them modifies a page.</span></span> <span data-ttu-id="16192-125">Если по какой бы то ни было причине не удается загрузить один из этих экземпляров в нужный базовый адрес, он получает собственные физические страницы.</span><span class="sxs-lookup"><span data-stu-id="16192-125">If for some reason one of these instances cannot be loaded in the desired base address, it receives its own physical pages.</span></span>

<span data-ttu-id="16192-126">Библиотеки DLL создаются с базовым адресом по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="16192-126">DLLs are created with a default base address.</span></span> <span data-ttu-id="16192-127">Каждый процесс, использующий библиотеку DLL, попытается загрузить библиотеку DLL в своем собственном адресном пространстве по виртуальному адресу по умолчанию для библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="16192-127">Every process that uses a DLL will try to load the DLL within its own address space at the default virtual address for the DLL.</span></span> <span data-ttu-id="16192-128">Если несколько приложений могут загрузить библиотеку DLL по виртуальному адресу по умолчанию, они могут использовать одни и те же физические страницы для библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="16192-128">If multiple applications can load a DLL at its default virtual address, they can share the same physical pages for the DLL.</span></span> <span data-ttu-id="16192-129">Если по какой-либо причине процессу не удается загрузить библиотеку DLL по адресу по умолчанию, то библиотека DLL загружается в другое место.</span><span class="sxs-lookup"><span data-stu-id="16192-129">If for some reason a process cannot load the DLL at the default address, it loads the DLL elsewhere.</span></span> <span data-ttu-id="16192-130">Защита от копирования при записи принудительно копирует некоторые страницы библиотеки DLL на разные физические страницы для этого процесса, поскольку исправления для инструкций перехода записываются в страницы библиотеки DLL, и для этого процесса они будут отличаться.</span><span class="sxs-lookup"><span data-stu-id="16192-130">Copy-on-write protection forces some of the DLL's pages to be copied into different physical pages for this process, because the fixes for jump instructions are written within the DLL's pages, and they will be different for this process.</span></span> <span data-ttu-id="16192-131">Если раздел кода содержит много ссылок на раздел данных, это может привести к тому, что весь раздел кода будет скопирован на новые физические страницы.</span><span class="sxs-lookup"><span data-stu-id="16192-131">If the code section contains many references to the data section, this can cause the entire code section to be copied to new physical pages.</span></span>

 

 



