---
title: Зачем нужны ресурсы мозаичного заполнения
description: Требуется выполнить мозаичное выделение ресурсов, так что память с графическим процессором не тратится на хранение областей поверхностей, к которым известно приложение, и оборудование может понять, как выполнять фильтрацию по смежным плиткам.
ms.assetid: E2179D65-56D3-481F-A5F3-B9C45A11A179
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d42ccccf66a73d224d8bab9a9d10c87cc330be43
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104983988"
---
# <a name="why-are-tiled-resources-needed"></a><span data-ttu-id="2e0d4-103">Зачем нужны мозаичные ресурсы?</span><span class="sxs-lookup"><span data-stu-id="2e0d4-103">Why are tiled resources needed?</span></span>

<span data-ttu-id="2e0d4-104">Требуется выполнить мозаичное выделение ресурсов, так что память с графическим процессором не тратится на хранение областей поверхностей, к которым известно приложение, и оборудование может понять, как выполнять фильтрацию по смежным плиткам.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-104">Tiled resources are needed so less graphics processing unit (GPU) memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles.</span></span>

<span data-ttu-id="2e0d4-105">В графической системе (то есть операционной системе, видеодрайвере и графическом оборудовании) без поддержки мозаичных ресурсов графическая система управляет всеми выделениями памяти Direct3D во время гранулярности подресурсов.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-105">In a graphics system (that is, the operating system, display driver, and graphics hardware) without tiled resource support, the graphics system manages all Direct3D memory allocations at subresource granularity.</span></span> <span data-ttu-id="2e0d4-106">Для [буфера](overviews-direct3d-11-resources-buffers.md)весь буфер является подресурсом.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-106">For a [Buffer](overviews-direct3d-11-resources-buffers.md), the entire Buffer is the subresource.</span></span> <span data-ttu-id="2e0d4-107">Для [текстуры](overviews-direct3d-11-resources-textures.md) (например, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)) каждый уровень MIP является подресурсом. для массива текстуры (например, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)) каждый уровень MIP в заданном срезе массива является подресурсом.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-107">For a [Texture](overviews-direct3d-11-resources-textures.md) (for example, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)), each mip level is a subresource; for a texture array (for example, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), each mip level at a given array slice is a subresource.</span></span> <span data-ttu-id="2e0d4-108">Графическая система лишь предоставляет возможность управлять сопоставлениями выделения памяти на этом уровне вложенных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-108">The graphics system only exposes the ability to manage the mapping of allocations at this subresource granularity.</span></span> <span data-ttu-id="2e0d4-109">В контексте мозаичных ресурсов "сопоставление" означает, что данные видны GPU.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-109">In the context of tiled resources, "mapping" refers to making data visible to the GPU.</span></span>

<span data-ttu-id="2e0d4-110">Предположим, что приложение знает, что определенной операции отрисовки необходим доступ лишь к небольшой части цепочки MIP-карт (возможно, даже не к полной области определенной MIP-карты).</span><span class="sxs-lookup"><span data-stu-id="2e0d4-110">Suppose an application knows that a particular rendering operation only needs to access a small portion of an image mipmap chain (perhaps not even the full area of a given mipmap).</span></span> <span data-ttu-id="2e0d4-111">В идеале приложение должно сообщить графической системе об этой потребности.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-111">Ideally, the app could inform the graphics system about this need.</span></span> <span data-ttu-id="2e0d4-112">Тогда графическая система обеспечит сопоставление лишь необходимого количества памяти графического процессора, не задействуя лишнюю память.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-112">The graphics system would then only bother to ensure that the needed memory is mapped on the GPU without paging in too much memory.</span></span> <span data-ttu-id="2e0d4-113">В реальности, без поддержки мозаичных ресурсов, графическая система может сообщить только о памяти, которая должна быть сопоставлена с GPU во время гранулярности подресурсов (например, диапазон полного уровня mipmap, к которому можно получить доступ).</span><span class="sxs-lookup"><span data-stu-id="2e0d4-113">In reality, without tiled resource support, the graphics system can only be informed about the memory that needs to be mapped on the GPU at subresource granularity (for example, a range of full mipmap levels that could be accessed).</span></span> <span data-ttu-id="2e0d4-114">В графической системе также невозможен отказ от требования выделения памяти, поэтому возможно использование излишне большого количества памяти графического процессора для полного сопоставления всех вложенных ресурсов перед выполнением команды отрисовки, ссылающейся на какую-либо часть памяти.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-114">There is no demand faulting in the graphics system either, so potentially a lot of excess GPU memory must be used to make full subresources mapped before a rendering command that references any part of the memory is executed.</span></span> <span data-ttu-id="2e0d4-115">Это лишь одна проблема, которая затрудняет использование больших объемов памяти в Direct3D без поддержки мозаичного размещения ресурсов.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-115">This is just one issue that makes the use of large memory allocations difficult in Direct3D without tiled resource support.</span></span>

<span data-ttu-id="2e0d4-116">Direct3D 11 поддерживает [**Texture2Dные**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) поверхности на заданной стороне до 16384 пикселей.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-116">Direct3D 11 supports [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) surfaces with up to 16384 pixels on a given side.</span></span> <span data-ttu-id="2e0d4-117">Изображение, размером 16 384 пкс в ширину, 16 384 в высоту и 4 байтами на пиксель потребляет 1 ГБ видеопамяти (и добавление MIP-карт удваивает это значение).</span><span class="sxs-lookup"><span data-stu-id="2e0d4-117">An image that is 16384 wide by 16384 tall and 4 bytes per pixel would consume 1GB of video memory (and adding mipmaps would double that amount).</span></span> <span data-ttu-id="2e0d4-118">На практике редко возникает необходимость использовать в одной операции отрисовки весь 1 ГБ памяти.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-118">In practice, all 1GB would rarely need to be referenced in a single rendering operation.</span></span>

<span data-ttu-id="2e0d4-119">Некоторые разработчики игр создают модели поверхностей ландшафтов размером плоть до 128 на 128 тыс. пикселей.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-119">Some game developers model terrain surfaces as large as 128K by 128K.</span></span> <span data-ttu-id="2e0d4-120">На существующих графических процессорах это становится возможным благодаря разбиению поверхности на плитки, которые достаточно малы для обработки оборудованием.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-120">The way they get this to work on existing GPUs is to break the surface into tiles that are small enough for hardware to handle.</span></span> <span data-ttu-id="2e0d4-121">Приложение должно определить, какие плитки могут потребоваться, и загрузить их в кэш текстур графического процессора — систему программной подкачки.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-121">The application must figure out which tiles might be needed and load them into a cache of textures on the GPU - a software paging system.</span></span> <span data-ttu-id="2e0d4-122">Существенный недостаток этого подхода состоит в том, что оборудование не знает о том, что происходит при разбиении на страницы: когда часть изображения должна отображаться на экране, на которой находятся плитки, оборудование не узнает, как выполнять фиксированную функцию (то есть эффективную) фильтрацию по плиткам.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-122">A significant downside to this approach comes from the hardware not knowing anything about the paging that is going on: When a part of an image needs to be shown on screen that straddles tiles, the hardware does not know how to perform fixed function (that is, efficient) filtering across tiles.</span></span> <span data-ttu-id="2e0d4-123">Это означает, что приложение, управляющее собственным программным разбиением на плитки, вынуждено использовать ручную фильтрацию текстур в коде шейдера (что требует очень большого количества ресурсов, если требуется высококачественная анизотропная фильтрация) и (или) тратить память на создание вокруг плиток полей, которые содержат данные из соседних плиток, чтобы аппаратная фильтрация с фиксированной функцией могла продолжать оказывать некоторую помощь.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-123">This means the application managing its own software tiling must resort to manual texture filtering in shader code (which becomes very expensive if a good quality anisotropic filter is desired) and/or waste memory authoring gutters around tiles that contain data from neighboring tiles so that fixed function hardware filtering can continue to provide some assistance.</span></span>

<span data-ttu-id="2e0d4-124">Если мозаичное представление выделения поверхности может быть первым классом в графической системе, приложение может сообщить оборудованию, какие плитки сделать доступными.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-124">If a tiled representation of surface allocations could be a first class feature in the graphics system, the application could tell the hardware which tiles to make available.</span></span> <span data-ttu-id="2e0d4-125">Таким образом меньшее количество памяти графического процессора тратится на хранение областей поверхности, доступ к которым, как известно приложению, осуществляться не будет. Оборудованию при этом известно, как производить фильтрацию соседних плиток, чтобы разрешить часть проблем, с которыми сталкиваются разработчики, выполняющие программное разделение на плитки самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-125">In this way, less GPU memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles, alleviating some of the pain experienced by developers who perform software tiling on their own.</span></span>

<span data-ttu-id="2e0d4-126">Однако для того, чтобы решение было полнофункциональным, необходимо каким-то образом решить проблему того, что вне зависимости от наличия поддержки разбиения поверхности на плитки максимальные размеры поверхности в данный момент составляют 16 384 пикселей, что значительно меньше 128 тысяч, которые уже требуются приложениям.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-126">But to provide a complete solution, something must be done to deal with the fact that, independent of whether tiling within a surface is supported, the maximum surface dimension is currently 16384 - nowhere near the 128K+ that applications already want.</span></span> <span data-ttu-id="2e0d4-127">Одним из подходов может быть просто требование поддержки текстур большего размера оборудованием, однако такой подход связан с значительными расходами и компромиссами.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-127">Just requiring the hardware to support larger texture sizes is one approach, however there are significant costs and/or tradeoffs to going this route.</span></span> <span data-ttu-id="2e0d4-128">Путь для фильтра текстур Direct3D 11 и путь подготовки к просмотру уже насыщены с точки зрения точности в соответствии с другими требованиями, такими как вспомогательные области окна просмотра, которые выходят за пределы поверхности во время подготовки к просмотру, или поддерживают отработку текстуры от края поверхности во время фильтрации.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-128">Direct3D 11's texture filter path and rendering path are already saturated in terms of precision in supporting 16K textures with the other requirements, such as supporting viewport extents falling off the surface during rendering, or supporting texture wrapping off the surface edge during filtering.</span></span> <span data-ttu-id="2e0d4-129">Существует возможность найти компромисс так, чтобы по мере увеличения размера текстуры за пределы 16 тысяч пикселей определенным образом снижались функциональные возможности или точность.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-129">A possibility is to define a tradeoff such that as the texture size increases beyond 16K, functionality/precision is given up in some manner.</span></span> <span data-ttu-id="2e0d4-130">Однако даже при этой уступке могут потребоваться дополнительные затраты на оборудование в плане способности всей аппаратной системы к переходу к текстурам увеличенного размера.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-130">Even with this concession however, additional hardware costs might be required in terms of addressing capability throughout the hardware system to go to larger texture sizes.</span></span>

<span data-ttu-id="2e0d4-131">Со значительным увеличением размера текстур возникает проблема, состоящая в том, что координаты текстуры одинарной точности с плавающей запятой (и связанные интерполяторы для поддержки растеризации) не располагают достаточной точностью, чтобы безошибочно указывать расположение на поверхности.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-131">One issue that comes into play as textures get very large is that single precision floating point texture coordinates (and the associated interpolators to support rasterization) run out of precision to specify locations on the surface accurately.</span></span> <span data-ttu-id="2e0d4-132">Это приводит к дрожанию при фильтрации текстур.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-132">Jittery texture filtering would ensue.</span></span> <span data-ttu-id="2e0d4-133">Затратным решением является требование поддержки интерполятора двойной точности, но при наличии разумной альтернативы оно представляется избыточным.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-133">One expensive option would be to require double precision interpolator support, though that could be overkill given a reasonable alternative.</span></span>

<span data-ttu-id="2e0d4-134">Альтернативное имя для мозаичных ресурсов — «разреженная текстура».</span><span class="sxs-lookup"><span data-stu-id="2e0d4-134">An alternate name for tiled resources is "sparse texture."</span></span> <span data-ttu-id="2e0d4-135">"Делимые" означает одновременно мозаичный характер ресурсов, а также, возможно, основную причину разбиения их на плитки — не все из них должны сопоставляться одновременно.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-135">"Sparse" conveys both the tiled nature of the resources as well as perhaps the primary reason for tiling them - that not all of them are expected to be mapped at once.</span></span> <span data-ttu-id="2e0d4-136">На самом деле, приложение может создать мозаичный ресурс, в котором никакие данные не создаются для всех регионов и MIPS ресурса, намеренно.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-136">In fact, an application could conceivably author a tiled resource in which no data is authored for all regions+mips of the resource, intentionally.</span></span> <span data-ttu-id="2e0d4-137">Таким образом, само содержимое может быть разреженным, а сопоставление содержимого в памяти GPU в заданное время будет подмножеством этого (еще более разреженным).</span><span class="sxs-lookup"><span data-stu-id="2e0d4-137">So, the content itself could be sparse, and the mapping of the content in GPU memory at a given time would be a subset of that (even more sparse).</span></span>

<span data-ttu-id="2e0d4-138">Другой сценарий, который может быть обслужен мозаичными ресурсами, включает несколько ресурсов различных измерений и форматов для совместного использования одной и той же памяти.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-138">Another scenario that could be served by tiled resources is enabling multiple resources of different dimensions/formats to share the same memory.</span></span> <span data-ttu-id="2e0d4-139">Иногда приложения имеют особые наборы ресурсов, которые не должны использоваться одновременно, или ресурсы, которые создаются только для очень краткого использования и затем удаляются, после чего создаются другие ресурсы.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-139">Sometimes applications have exclusive sets of resources that are known not to be used at the same time, or resources that are created only for very brief use and then destroyed, followed by creation of other resources.</span></span> <span data-ttu-id="2e0d4-140">Форма универсальности, которая может выдаваться из "мозаичных ресурсов", заключается в том, что можно разрешить пользователю указывать несколько различных ресурсов в одной (перекрывающей) памяти.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-140">A form of generality that can fall out of "tiled resources" is that it is possible to allow the user to point multiple different resources at the same (overlapping) memory.</span></span> <span data-ttu-id="2e0d4-141">Другими словами, создание и уничтожение "ресурсов" (которые определяют размер, формат и т. д.) может быть отделено от управления памятью, выделяемой для этих ресурсов, с точки зрения приложения.</span><span class="sxs-lookup"><span data-stu-id="2e0d4-141">In other words, the creation and destruction of "resources" (which define a dimension/format and so on) can be decoupled from the management of the memory underlying the resources from the application's point of view.</span></span>

## <a name="related-topics"></a><span data-ttu-id="2e0d4-142">См. также</span><span class="sxs-lookup"><span data-stu-id="2e0d4-142">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="2e0d4-143">Мозаичные ресурсы</span><span class="sxs-lookup"><span data-stu-id="2e0d4-143">Tiled resources</span></span>](tiled-resources.md)
</dt> </dl>

 

 