---
title: Этап шейдера пикселей
description: Этап построителя текстуры (PS) обеспечивает широкие возможности заливки, такие как освещение на уровне пикселов и последующей обработку.
ms.assetid: 09831B10-4FD1-41E7-8D81-5AA63DC90020
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 57142e9c32919a6959a7fac14bf544cca1dacd79
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104134318"
---
# <a name="pixel-shader-stage"></a><span data-ttu-id="2c81f-103">Этап шейдера пикселей</span><span class="sxs-lookup"><span data-stu-id="2c81f-103">Pixel Shader Stage</span></span>

<span data-ttu-id="2c81f-104">Этап построителя текстуры (PS) обеспечивает широкие возможности заливки, такие как освещение на уровне пикселов и последующей обработку.</span><span class="sxs-lookup"><span data-stu-id="2c81f-104">The pixel-shader stage (PS) enables rich shading techniques such as per-pixel lighting and post-processing.</span></span> <span data-ttu-id="2c81f-105">Шейдер пикселей — это программа, объединяющая константные переменные, данные текстур, интерполированные значения вершин и другие данные для получения отдельных пикселей.</span><span class="sxs-lookup"><span data-stu-id="2c81f-105">A pixel shader is a program that combines constant variables, texture data, interpolated per-vertex values, and other data to produce per-pixel outputs.</span></span> <span data-ttu-id="2c81f-106">Этап средства создания программной прорисовки вызывает шейдер пикселей один раз для каждого пикселя, охваченного примитивом, однако можно указать шейдер **null** , чтобы избежать запуска шейдера.</span><span class="sxs-lookup"><span data-stu-id="2c81f-106">The rasterizer stage invokes a pixel shader once for each pixel covered by a primitive, however, it is possible to specify a **NULL** shader to avoid running a shader.</span></span>

## <a name="the-pixel-shader"></a><span data-ttu-id="2c81f-107">Шейдер пикселей</span><span class="sxs-lookup"><span data-stu-id="2c81f-107">The Pixel Shader</span></span>

<span data-ttu-id="2c81f-108">При множественной дискретизации текстуры шейдер пикселей вызывается один раз для каждого охваченного пикселя, а тестирование глубины трафарета выполняется для каждого объекта множественной дискретизации.</span><span class="sxs-lookup"><span data-stu-id="2c81f-108">When multisampling a texture, a pixel shader is invoked once per-covered pixel while a depth/stencil test occurs for each covered multisample.</span></span> <span data-ttu-id="2c81f-109">Образцы которые проходят проверку глубины трафарета, обновляются с использованием выходного цвета шейдера пикселей.</span><span class="sxs-lookup"><span data-stu-id="2c81f-109">Samples that pass the depth/stencil test are updated with the pixel shader output color.</span></span>

<span data-ttu-id="2c81f-110">Встроенные функции шейдера пикселей создают или используют производные от количества относительно экранного пространства x и y.</span><span class="sxs-lookup"><span data-stu-id="2c81f-110">The pixel shader intrinsic functions produce or use derivatives of quantities with respect to screen space x and y.</span></span> <span data-ttu-id="2c81f-111">Самый распространенный способ использования производных — вычисления уровня детализации для дискретизации текстур, а в случае с анизотропной фильтрацией — выбор образцов по оси анизотропии.</span><span class="sxs-lookup"><span data-stu-id="2c81f-111">The most common use for derivatives is to compute level-of-detail calculations for texture sampling and in the case of anisotropic filtering, selecting samples along the axis of anisotropy.</span></span> <span data-ttu-id="2c81f-112">Как правило, аппаратная реализации запускает шейдер пикселей на нескольких пикселях (например, в сетке 2x2) одновременно, чтобы производные количества, вычисленные в шейдере, можно было аппроксимировать текстуры как дельты значений в той же точке выполнения в соседних пикселях.</span><span class="sxs-lookup"><span data-stu-id="2c81f-112">Typically, a hardware implementation runs a pixel shader on multiple pixels (for example a 2x2 grid) simultaneously, so that derivatives of quantities computed in the pixel shader can be reasonably approximated as deltas of the values at the same point of execution in adjacent pixels.</span></span>

### <a name="inputs"></a><span data-ttu-id="2c81f-113">Входные данные</span><span class="sxs-lookup"><span data-stu-id="2c81f-113">Inputs</span></span>

<span data-ttu-id="2c81f-114">Если конвейер настроен без шейдера геометрии, шейдер текстуры ограничивается 16 32-разрядными и 4-компонентными входными данными.</span><span class="sxs-lookup"><span data-stu-id="2c81f-114">When the pipeline is configured without a geometry shader, a pixel shader is limited to 16, 32-bit, 4-component inputs.</span></span> <span data-ttu-id="2c81f-115">В противном случае шейдер пикселей может принимать до 32 32-разрядных, 4-компонентных входных данных.</span><span class="sxs-lookup"><span data-stu-id="2c81f-115">Otherwise, a pixel shader can take up to 32, 32-bit, 4-component inputs.</span></span>

<span data-ttu-id="2c81f-116">Входные данные шейдера пикселей включают атрибуты вершин (которые можно интерполировать с коррекцией перспективы или без нее) или могут рассматриваться как константы примитивов.</span><span class="sxs-lookup"><span data-stu-id="2c81f-116">Pixel shader input data includes vertex attributes (that can be interpolated with or without perspective correction) or can be treated as per-primitive constants.</span></span> <span data-ttu-id="2c81f-117">Входные данные шейдера пикселей интерполируются на основе атрибутов вершин растеризуемого примитива в зависимости от объявленного режима интерполяции.</span><span class="sxs-lookup"><span data-stu-id="2c81f-117">Pixel shader inputs are interpolated from the vertex attributes of the primitive being rasterized, based on the interpolation mode declared.</span></span> <span data-ttu-id="2c81f-118">Если примитив обрезается до растеризации, режим интерполяции также учитывается в процессе обрезки.</span><span class="sxs-lookup"><span data-stu-id="2c81f-118">If a primitive gets clipped before rasterization, the interpolation mode is honored during the clipping process as well.</span></span>

<span data-ttu-id="2c81f-119">Атрибуты вершин интерполируются (или оцениваются) в центральных расположениях шейдера пикселей.</span><span class="sxs-lookup"><span data-stu-id="2c81f-119">Vertex attributes are interpolated (or evaluated) at pixel shader center locations.</span></span> <span data-ttu-id="2c81f-120">Режимы интерполяции атрибутов шейдера пикселей указываются в объявлении регистрация входных данных отдельно для каждого элемента в [аргументе](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-function-parameters) или [входной структуре](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-struct).</span><span class="sxs-lookup"><span data-stu-id="2c81f-120">Pixel shader attribute interpolation modes are declared in an input register declaration, on a per-element basis in either an [argument](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-function-parameters) or an [input structure](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-struct).</span></span> <span data-ttu-id="2c81f-121">Атрибуты можно интерполяции линейно или с помощью [центроид выборки](https://msdn.microsoft.com/library/Ee415231(v=VS.85).aspx).</span><span class="sxs-lookup"><span data-stu-id="2c81f-121">Attributes can be interpolated linearly, or with [centroid sampling](https://msdn.microsoft.com/library/Ee415231(v=VS.85).aspx).</span></span> <span data-ttu-id="2c81f-122">Центроидная дискретизация учитывается только во время множественной дискретизации, чтобы охватить случаи, когда пиксель покрывается примитивом, а центр пикселя — нет. Центроидная оценка происходит максимально близко к центру пикселя (не охваченного примитивом).</span><span class="sxs-lookup"><span data-stu-id="2c81f-122">Centroid evaluation is relevant only during multisampling to cover cases where a pixel is covered by a primitive but a pixel center may not be; centroid evaluation occurs as close as possible to the (non-covered) pixel center.</span></span>

<span data-ttu-id="2c81f-123">Входные данные также можно объявить с помощью [семантики системного значения](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics), которая помечает параметр, используемый на других этапах конвейера.</span><span class="sxs-lookup"><span data-stu-id="2c81f-123">Inputs may also be declared with a [system-value semantic](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics), which marks a parameter that is consumed by other pipeline stages.</span></span> <span data-ttu-id="2c81f-124">Например, пиксельное расположение должно быть отмечено семантикой «ОКП» \_ .</span><span class="sxs-lookup"><span data-stu-id="2c81f-124">For instance, a pixel position should be marked with the SV\_Position semantic.</span></span> <span data-ttu-id="2c81f-125">На этапе IA можно создать один скаляр для построителя текстуры (с помощью SV \_ примитивеид); этап средства прорисовки также может создавать один скаляр для построителя текстуры (с помощью SV \_ исфронтфаце).</span><span class="sxs-lookup"><span data-stu-id="2c81f-125">The IA stage can produce one scalar for a pixel shader (using SV\_PrimitiveID); the rasterizer stage can also generate one scalar for a pixel shader (using SV\_IsFrontFace).</span></span>

### <a name="outputs"></a><span data-ttu-id="2c81f-126">Выходные данные</span><span class="sxs-lookup"><span data-stu-id="2c81f-126">Outputs</span></span>

<span data-ttu-id="2c81f-127">Пиксельный шейдер может вывести до 8 32-разрядных 4-компонентных цветов (если пиксель отклоняется, цвет не предоставляется).</span><span class="sxs-lookup"><span data-stu-id="2c81f-127">A pixel shader can output up to 8, 32-bit, 4-component colors, or no color if the pixel is discarded.</span></span> <span data-ttu-id="2c81f-128">Компоненты регистрация выходных данных шейдера пикселей следует объявить перед использованием. У каждого регистра может быть отдельная маска вывода записи.</span><span class="sxs-lookup"><span data-stu-id="2c81f-128">Pixel shader output register components must be declared before they can be used; each register is allowed a distinct output-write mask.</span></span>

<span data-ttu-id="2c81f-129">Используйте состояние глубины-Write-Enable (на стадии слияния), чтобы определить, записываются ли данные глубины в буфер глубины (или используйте инструкцию отмены для удаления данных для этого пикселя).</span><span class="sxs-lookup"><span data-stu-id="2c81f-129">Use the depth-write-enable state (in the output-merger stage) to control whether depth data gets written to a depth buffer (or use the discard instruction to discard data for that pixel).</span></span> <span data-ttu-id="2c81f-130">Шейдер пикселей также может выводить необязательный 32-разрядный, 1-компонент, параметр глубины с плавающей запятой для глубокого тестирования (с использованием \_ семантики глубины SV).</span><span class="sxs-lookup"><span data-stu-id="2c81f-130">A pixel shader can also output an optional 32-bit, 1-component, floating-point, depth value for depth testing (using the SV\_Depth semantic).</span></span> <span data-ttu-id="2c81f-131">Значение глубины выводится в регистре oDepth и заменяет интерполированное значение для тестирования глубины (если тестирование глубины включено).</span><span class="sxs-lookup"><span data-stu-id="2c81f-131">The depth value is output in the oDepth register, and replaces the interpolated depth value for depth testing (assuming depth testing is enabled).</span></span> <span data-ttu-id="2c81f-132">Не существует способа для динамического переключения между глубиной с фиксированной функцией и oDepth шейдера.</span><span class="sxs-lookup"><span data-stu-id="2c81f-132">There is no way to dynamically change between using fixed-function depth or shader oDepth.</span></span>

<span data-ttu-id="2c81f-133">Шейдер пикселей не может выводить значение трафарета.</span><span class="sxs-lookup"><span data-stu-id="2c81f-133">A pixel shader cannot output a stencil value.</span></span>

## <a name="related-topics"></a><span data-ttu-id="2c81f-134">См. также</span><span class="sxs-lookup"><span data-stu-id="2c81f-134">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="2c81f-135">Графический конвейер</span><span class="sxs-lookup"><span data-stu-id="2c81f-135">Graphics Pipeline</span></span>](overviews-direct3d-11-graphics-pipeline.md)
</dt> <dt>

[<span data-ttu-id="2c81f-136">Этапы конвейера (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="2c81f-136">Pipeline Stages (Direct3D 10)</span></span>](/windows/desktop/direct3d10/d3d10-graphics-programming-guide-pipeline-stages)
</dt> </dl>

 

 