---
title: Правила с плавающей точкой (Direct3D 11)
description: Direct3D 11 поддерживает несколько представлений с плавающей запятой. Все вычисления с плавающей запятой выполняются в определенном подмножестве 32-битных правил с плавающей запятой одинарной точности IEEE 754.
ms.assetid: 33F21BD0-FDF8-4D35-95C0-0A3920814CB6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d83c87db0daa69c0393d0399ece5bdb6cf01d519
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104413075"
---
# <a name="floating-point-rules-direct3d-11"></a><span data-ttu-id="4e07f-104">Правила с плавающей точкой (Direct3D 11)</span><span class="sxs-lookup"><span data-stu-id="4e07f-104">Floating-point rules (Direct3D 11)</span></span>

<span data-ttu-id="4e07f-105">Direct3D 11 поддерживает несколько представлений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="4e07f-105">Direct3D 11 supports several floating-point representations.</span></span> <span data-ttu-id="4e07f-106">Все вычисления с плавающей запятой выполняются в определенном подмножестве 32-битных правил с плавающей запятой одинарной точности IEEE 754.</span><span class="sxs-lookup"><span data-stu-id="4e07f-106">All floating-point computations operate under a defined subset of the IEEE 754 32-bit single precision floating-point rules.</span></span>

-   [<span data-ttu-id="4e07f-107">32-разрядные правила с плавающей точкой</span><span class="sxs-lookup"><span data-stu-id="4e07f-107">32-bit floating-point rules</span></span>](#32-bit-floating-point-rules)
    -   [<span data-ttu-id="4e07f-108">Принятые правила IEEE-754</span><span class="sxs-lookup"><span data-stu-id="4e07f-108">Honored IEEE-754 rules</span></span>](#honored-ieee-754-rules)
    -   [<span data-ttu-id="4e07f-109">Отклонения или дополнительные требования из правил IEEE-754</span><span class="sxs-lookup"><span data-stu-id="4e07f-109">Deviations or additional requirements from IEEE-754 rules</span></span>](#deviations-or-additional-requirements-from-ieee-754-rules)
-   [<span data-ttu-id="4e07f-110">64-разрядная (двойная точность) правила с плавающей запятой</span><span class="sxs-lookup"><span data-stu-id="4e07f-110">64-bit (double precision) floating point rules</span></span>](#64-bit-double-precision-floating-point-rules)
-   [<span data-ttu-id="4e07f-111">16-разрядные правила с плавающей точкой</span><span class="sxs-lookup"><span data-stu-id="4e07f-111">16-bit floating-point rules</span></span>](#16-bit-floating-point-rules)
-   [<span data-ttu-id="4e07f-112">11-битовые и 10-разрядные правила с плавающей точкой</span><span class="sxs-lookup"><span data-stu-id="4e07f-112">11-bit and 10-bit floating-point rules</span></span>](#11-bit-and-10-bit-floating-point-rules)
-   [<span data-ttu-id="4e07f-113">См. также</span><span class="sxs-lookup"><span data-stu-id="4e07f-113">Related topics</span></span>](#related-topics)

## <a name="32-bit-floating-point-rules"></a><span data-ttu-id="4e07f-114">32-разрядные правила с плавающей запятой</span><span class="sxs-lookup"><span data-stu-id="4e07f-114">32-bit floating-point rules</span></span>

<span data-ttu-id="4e07f-115">Существует два набора правил: тех, что соответствуют стандарту IEEE-754, и тех, что отклоняются от него.</span><span class="sxs-lookup"><span data-stu-id="4e07f-115">There are two sets of rules: those that conform to IEEE-754, and those that deviate from the standard.</span></span>

### <a name="honored-ieee-754-rules"></a><span data-ttu-id="4e07f-116">Соблюдаемые правила IEEE-754</span><span class="sxs-lookup"><span data-stu-id="4e07f-116">Honored IEEE-754 rules</span></span>

<span data-ttu-id="4e07f-117">Некоторые из этих правил безальтернативны, если стандарт IEEE-754 предоставляет несколько вариантов.</span><span class="sxs-lookup"><span data-stu-id="4e07f-117">Some of these rules are a single option where IEEE-754 offers choices.</span></span>

-   <span data-ttu-id="4e07f-118">При делении на ноль получается положительное или отрицательное бесконечное число, за исключением деления нуля на ноль, в результате которого получается не число.</span><span class="sxs-lookup"><span data-stu-id="4e07f-118">Divide by 0 produces +/- INF, except 0/0 which results in NaN.</span></span>
-   <span data-ttu-id="4e07f-119">Результатом логарифма положительного или отрицательного нуля является отрицательное бесконечное число.</span><span class="sxs-lookup"><span data-stu-id="4e07f-119">log of (+/-) 0 produces -INF.</span></span> <span data-ttu-id="4e07f-120">Результатом логарифма отрицательного значения (отличного от отрицательного нуля) является не число.</span><span class="sxs-lookup"><span data-stu-id="4e07f-120">log of a negative value (other than -0) produces NaN.</span></span>
-   <span data-ttu-id="4e07f-121">Результатом извлечения обратного квадратного корня (rsq) или квадратного корня (sqrt) из отрицательного числа является не число.</span><span class="sxs-lookup"><span data-stu-id="4e07f-121">Reciprocal square root (rsq) or square root (sqrt) of a negative number produces NaN.</span></span> <span data-ttu-id="4e07f-122">Исключение — отрицательный ноль; результатом sqrt(-0) является -0, а результатом rsq(-0) — отрицательное бесконечное число.</span><span class="sxs-lookup"><span data-stu-id="4e07f-122">The exception is -0; sqrt(-0) produces -0, and rsq(-0) produces -INF.</span></span>
-   <span data-ttu-id="4e07f-123">Разностью двух бесконечных чисел является не число.</span><span class="sxs-lookup"><span data-stu-id="4e07f-123">INF - INF = NaN</span></span>
-   <span data-ttu-id="4e07f-124">Отношением между положительным или отрицательным бесконечным числом и вторым таким же числом является не число.</span><span class="sxs-lookup"><span data-stu-id="4e07f-124">(+/-)INF / (+/-)INF = NaN</span></span>
-   <span data-ttu-id="4e07f-125">(+/-) INF \* 0 = NaN</span><span class="sxs-lookup"><span data-stu-id="4e07f-125">(+/-)INF \* 0 = NaN</span></span>
-   <span data-ttu-id="4e07f-126">Результатом любой операции между не числом и любым значением является не число.</span><span class="sxs-lookup"><span data-stu-id="4e07f-126">NaN (any OP) any-value = NaN</span></span>
-   <span data-ttu-id="4e07f-127">Сравнения EQ, GT, GE, LT и LE, в которых один или оба операнда являются не числами, возвращают **FALSE**.</span><span class="sxs-lookup"><span data-stu-id="4e07f-127">The comparisons EQ, GT, GE, LT, and LE, when either or both operands is NaN returns **FALSE**.</span></span>
-   <span data-ttu-id="4e07f-128">В сравнениях знак нуля игнорируется (то есть положительный ноль равен отрицательному).</span><span class="sxs-lookup"><span data-stu-id="4e07f-128">Comparisons ignore the sign of 0 (so +0 equals -0).</span></span>
-   <span data-ttu-id="4e07f-129">Сравнение NE, в котором один или оба операнда являются не числами, возвращает **TRUE**.</span><span class="sxs-lookup"><span data-stu-id="4e07f-129">The comparison NE, when either or both operands is NaN returns **TRUE**.</span></span>
-   <span data-ttu-id="4e07f-130">Сравнение любого значения, не являющегося не числом, с положительным или отрицательным бесконечным числом возвращает верный результат.</span><span class="sxs-lookup"><span data-stu-id="4e07f-130">Comparisons of any non-NaN value against +/- INF return the correct result.</span></span>

### <a name="deviations-or-additional-requirements-from-ieee-754-rules"></a><span data-ttu-id="4e07f-131">Отклонения или дополнительные требования правил IEEE-754</span><span class="sxs-lookup"><span data-stu-id="4e07f-131">Deviations or additional requirements from IEEE-754 rules</span></span>

-   <span data-ttu-id="4e07f-132">По условиям стандарта IEEE-754, результатом операций с плавающей точкой должно быть представляемое значение, ближайшее к бесконечно точному результату, известное как округление к ближайшему четному числу.</span><span class="sxs-lookup"><span data-stu-id="4e07f-132">IEEE-754 requires floating-point operations to produce a result that is the nearest representable value to an infinitely-precise result, known as round-to-nearest-even.</span></span> <span data-ttu-id="4e07f-133">Direct3D 11 определяет одно и то же требование: 32-разрядные операции с плавающей запятой дают результат, который находится в пределах 0,5 единицы измерения (ULP) с бесконечной точностью.</span><span class="sxs-lookup"><span data-stu-id="4e07f-133">Direct3D 11 defines the same requirement: 32-bit floating-point operations produce a result that is within 0.5 unit-last-place (ULP) of the infinitely-precise result.</span></span> <span data-ttu-id="4e07f-134">Это означает, что, например, оборудованию разрешено усекать результаты до 32-разрядного, а не выполнять округление до ближайшего значения, как это приведет к ошибке не более 0,5 ULP. Это правило применяется только к операциям сложения, вычитания и умножения.</span><span class="sxs-lookup"><span data-stu-id="4e07f-134">This means that, for example, hardware is allowed to truncate results to 32-bit rather than perform round-to-nearest-even, as that would result in error of at most 0.5 ULP.This rule applies only to addition, subtraction, and multiplication.</span></span>
-   <span data-ttu-id="4e07f-135">Исключения, биты состояния и ловушки с плавающей точкой не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="4e07f-135">There is no support for floating-point exceptions, status bits or traps.</span></span>
-   <span data-ttu-id="4e07f-136">Денормализованные числа приводятся к нулю с сохранением знака при вводе и выводе любой математической операции с плавающей точкой.</span><span class="sxs-lookup"><span data-stu-id="4e07f-136">Denorms are flushed to sign-preserved zero on input and output of any floating-point mathematical operation.</span></span> <span data-ttu-id="4e07f-137">Исключения делаются для любой операции ввода-вывода или перемещения данных, которая не изменяет данные.</span><span class="sxs-lookup"><span data-stu-id="4e07f-137">Exceptions are made for any I/O or data movement operation that doesn't manipulate the data.</span></span>
-   <span data-ttu-id="4e07f-138">Состояния, содержащие значения с плавающей запятой, такие как окна просмотра Миндепс/MaxDepth, значения BorderColor, могут быть предоставлены в виде значений для денормы, а также могут или не быть сброшены до того, как оборудование их использует.</span><span class="sxs-lookup"><span data-stu-id="4e07f-138">States that contain floating-point values, such as Viewport MinDepth/MaxDepth, BorderColor values, may be provided as denorm values and may or may not be flushed before the hardware uses them.</span></span>
-   <span data-ttu-id="4e07f-139">Операции минимизации или максимизации сбрасывают денормализованные числа для сравнения, но результат в виде денормализованного числа может не быть сброшен.</span><span class="sxs-lookup"><span data-stu-id="4e07f-139">Min or max operations flush denorms for comparison, but the result may or may not be denorm flushed.</span></span>
-   <span data-ttu-id="4e07f-140">Если входными данными для операции является не число, выходными данными обязательно будет не число.</span><span class="sxs-lookup"><span data-stu-id="4e07f-140">NaN input to an operation always produces NaN on output.</span></span> <span data-ttu-id="4e07f-141">Но точный битовый шаблон не числа не обязательно должен оставаться неизменным (если только выполняемая операция не является инструкцией перемещения необработанных данных, при которой данные не изменяются.)</span><span class="sxs-lookup"><span data-stu-id="4e07f-141">But the exact bit pattern of the NaN is not required to stay the same (unless the operation is a raw move instruction - which doesn't alter data.)</span></span>
-   <span data-ttu-id="4e07f-142">Операции минимизации или максимизации, в которых только один операнд является не числом, возвращают другой операнд в качестве результата (вопреки рассмотренным ранее правилам сравнения).</span><span class="sxs-lookup"><span data-stu-id="4e07f-142">Min or max operations for which only one operand is NaN return the other operand as the result (contrary to comparison rules we looked at earlier).</span></span> <span data-ttu-id="4e07f-143">Это правило IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="4e07f-143">This is a IEEE 754R rule.</span></span>

    <span data-ttu-id="4e07f-144">Согласно спецификации IEEE-754R для операций минимизации и максимизации с плавающей точкой, если одна из частей входных данных для минимизации или максимизации является значением в виде несигнального не числа (QNaN), результатом операции будет второй параметр.</span><span class="sxs-lookup"><span data-stu-id="4e07f-144">The IEEE-754R specification for floating point min and max operations states that if one of the inputs to min or max is a quiet QNaN value, the result of the operation is the other parameter.</span></span> <span data-ttu-id="4e07f-145">Например:</span><span class="sxs-lookup"><span data-stu-id="4e07f-145">For example:</span></span>

    ```C++
    min(x,QNaN) == min(QNaN,x) == x (same for max)
    ```

    

    <span data-ttu-id="4e07f-146">В одной из редакций спецификации IEEE-754R было принято другое поведение для минимального и максимального значений, если одна часть входных данных является значением в виде "сигнального" не числа (SNaN), а вторая — значением QNaN.</span><span class="sxs-lookup"><span data-stu-id="4e07f-146">A revision of the IEEE-754R specification adopted a different behavior for min and max when one input is a "signaling" SNaN value versus a QNaN value:</span></span>

    ```C++
    min(x,SNaN) == min(SNaN,x) == QNaN (same for max)
     
    ```

    

    <span data-ttu-id="4e07f-147">Как правило, Direct3D следует стандартам арифметических действий: IEEE-754 и IEEE-754R.</span><span class="sxs-lookup"><span data-stu-id="4e07f-147">Generally, Direct3D follows the standards for arithmetic: IEEE-754 and IEEE-754R.</span></span> <span data-ttu-id="4e07f-148">Но в этом случае происходит отклонение.</span><span class="sxs-lookup"><span data-stu-id="4e07f-148">But in this case, we have a deviation.</span></span>

    <span data-ttu-id="4e07f-149">Арифметические правила в Direct3D 10 и более поздних версиях не проводят различия между значениями в виде несигнальных и сигнальных не чисел (QNaN и SNaN).</span><span class="sxs-lookup"><span data-stu-id="4e07f-149">The arithmetic rules in Direct3D 10 and later don't make any distinctions between quiet and signaling NaN values (QNaN versus SNaN).</span></span> <span data-ttu-id="4e07f-150">Все значения в виде не чисел обрабатываются одинаково.</span><span class="sxs-lookup"><span data-stu-id="4e07f-150">All NaN values are handled the same way.</span></span> <span data-ttu-id="4e07f-151">В случае с минимизацией и максимизацией поведение Direct3D относительно любого значения в виде не числа аналогично обработке QNaN по определению IEEE-754R.</span><span class="sxs-lookup"><span data-stu-id="4e07f-151">In the case of min and max, the Direct3D behavior for any NaN value is like how QNaN is handled in the IEEE-754R definition.</span></span> <span data-ttu-id="4e07f-152">(Для полноты: если обе части входных данных являются не числами, возвращается любое значение в виде не числа.)</span><span class="sxs-lookup"><span data-stu-id="4e07f-152">(For completeness - if both inputs are NaN, any NaN value is returned.)</span></span>

-   <span data-ttu-id="4e07f-153">Еще одно правило IEEE 754R таково: min(-0,+0) == min(+0,-0) == -0, а max(-0,+0) == max(+0,-0) == +0. При этом учитывается знак, в отличие от правил сравнения для нуля со знаком (как было указано ранее).</span><span class="sxs-lookup"><span data-stu-id="4e07f-153">Another IEEE 754R rule is that min(-0,+0) == min(+0,-0) == -0, and max(-0,+0) == max(+0,-0) == +0, which honors the sign, in contrast to the comparison rules for signed zero (as we saw earlier).</span></span> <span data-ttu-id="4e07f-154">В этом случае Direct3D рекомендует поведение в соответствии с IEEE 754R, но это необязательно. Результат сравнения нулей может зависеть от порядка параметров при использовании сравнения, в котором игнорируются знаки.</span><span class="sxs-lookup"><span data-stu-id="4e07f-154">Direct3D recommends the IEEE 754R behavior here, but doesn't enforce it; it is permissible for the result of comparing zeros to be dependent on the order of parameters, using a comparison that ignores the signs.</span></span>
-   <span data-ttu-id="4e07f-155">x \* 1.0 f всегда приводит к x (за исключением очистки с очисткой).</span><span class="sxs-lookup"><span data-stu-id="4e07f-155">x\*1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="4e07f-156">x/1,0f всегда выдает x (за исключением сброса к денормализованному числу).</span><span class="sxs-lookup"><span data-stu-id="4e07f-156">x/1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="4e07f-157">x +/ -0,0f всегда выдает x (за исключением сброса к денормализованному числу).</span><span class="sxs-lookup"><span data-stu-id="4e07f-157">x +/- 0.0f always results in x (except denorm flushed).</span></span> <span data-ttu-id="4e07f-158">Но -0 + 0 = +0.</span><span class="sxs-lookup"><span data-stu-id="4e07f-158">But -0 + 0 = +0.</span></span>
-   <span data-ttu-id="4e07f-159">Совмещенные операции (например, mad, dp3) выдают не менее точные результаты, чем худшее возможное последовательное упорядочение вычисления несовмещенного расширения операции.</span><span class="sxs-lookup"><span data-stu-id="4e07f-159">Fused operations (such as mad, dp3) produce results that are no less accurate than the worst possible serial ordering of evaluation of the unfused expansion of the operation.</span></span> <span data-ttu-id="4e07f-160">Определение худшего возможного упорядочения, в целях допуска, не является фиксированным определением для данной совмещенной операции. Оно зависит от конкретных значений входных данных.</span><span class="sxs-lookup"><span data-stu-id="4e07f-160">The definition of the worst possible ordering, for the purpose of tolerance, is not a fixed definition for a given fused operation; it depends on the particular values of the inputs.</span></span> <span data-ttu-id="4e07f-161">Для каждого отдельного этапа несовмещенного расширения разрешен допуск в 1 ULP (для любых инструкций, вызываемых Direct3D с допуском больше 1 ULP, разрешен больший допуск).</span><span class="sxs-lookup"><span data-stu-id="4e07f-161">The individual steps in the unfused expansion are each allowed 1 ULP tolerance (or for any instructions Direct3D calls out with a more lax tolerance than 1 ULP, the more lax tolerance is allowed).</span></span>
-   <span data-ttu-id="4e07f-162">Совмещенные операции следуют тем же правилам относительно не чисел, что и несовмещенные операции.</span><span class="sxs-lookup"><span data-stu-id="4e07f-162">Fused operations adhere to the same NaN rules as non-fused operations.</span></span>
-   <span data-ttu-id="4e07f-163">Допуск для sqrt и rcp составляет 1 ULP.</span><span class="sxs-lookup"><span data-stu-id="4e07f-163">sqrt and rcp have 1 ULP tolerance.</span></span> <span data-ttu-id="4e07f-164">Для инструкций обратного числа шейдера и обратного квадратного корня, [**rcp**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) и [**rsq**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), действует особое требование со сниженной точностью.</span><span class="sxs-lookup"><span data-stu-id="4e07f-164">The shader reciprocal and reciprocal square-root instructions, [**rcp**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) and [**rsq**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), have their own separate relaxed precision requirement.</span></span>
-   <span data-ttu-id="4e07f-165">Умножение и деление выполняются на 32-разрядном уровне точности с плавающей точкой (точность до 0,5 ULP при умножении, 1 ULP при получении обратного числа).</span><span class="sxs-lookup"><span data-stu-id="4e07f-165">Multiply and divide each operate at the 32-bit floating-point precision level (accuracy to 0.5 ULP for multiply, 1.0 ULP for reciprocal).</span></span> <span data-ttu-id="4e07f-166">При прямой реализации x/y точность результатов должна быть выше, чем при двухшаговом методе, или идентична ему.</span><span class="sxs-lookup"><span data-stu-id="4e07f-166">If x/y is implemented directly, results must be of greater or equal accuracy than a two-step method.</span></span>

## <a name="64-bit-double-precision-floating-point-rules"></a><span data-ttu-id="4e07f-167">64-разрядные правила с плавающей точкой (двойной точности)</span><span class="sxs-lookup"><span data-stu-id="4e07f-167">64-bit (double precision) floating point rules</span></span>

<span data-ttu-id="4e07f-168">Драйверы оборудования и дисплея могут поддерживать операции с плавающей точкой двойной точности.</span><span class="sxs-lookup"><span data-stu-id="4e07f-168">Hardware and display drivers optionally support double-precision floating-point.</span></span> <span data-ttu-id="4e07f-169">Чтобы обозначить поддержку, при вызове [**ID3D11Device:: чеккфеатуресуппорт**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) с [**D3D11ом \_ функции \_ Double**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature)драйвер задает  для даублепреЦисионфлоатшадеропс [**\_ данных функции \_ \_ D3D11**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) значение true.</span><span class="sxs-lookup"><span data-stu-id="4e07f-169">To indicate support, when you call [**ID3D11Device::CheckFeatureSupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) with [**D3D11\_FEATURE\_DOUBLES**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature), the driver sets **DoublePrecisionFloatShaderOps** of [**D3D11\_FEATURE\_DATA\_DOUBLES**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) to TRUE.</span></span> <span data-ttu-id="4e07f-170">В этом случае драйвер и оборудование должны поддерживать все инструкции с плавающей точкой двойной точности.</span><span class="sxs-lookup"><span data-stu-id="4e07f-170">The driver and hardware must then support all double-precision floating-point instructions.</span></span>

<span data-ttu-id="4e07f-171">Инструкции двойной точности соответствуют требованиям к поведению IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="4e07f-171">Double-precision instructions follow IEEE 754R behavior requirements.</span></span>

<span data-ttu-id="4e07f-172">Для данных двойной точности (без сброса до нуля) требуется поддержка генерирования денормализованных значений.</span><span class="sxs-lookup"><span data-stu-id="4e07f-172">Support for generation of denormalized values is required for double-precision data (no flush-to-zero behavior).</span></span> <span data-ttu-id="4e07f-173">Подобным образом, инструкции не считывают денормализованные данные как ноль со знаком, а учитывают денормализованное значение.</span><span class="sxs-lookup"><span data-stu-id="4e07f-173">Likewise, instructions don't read denormalized data as a signed zero, they honor the denorm value.</span></span>

## <a name="16-bit-floating-point-rules"></a><span data-ttu-id="4e07f-174">16-разрядные правила с плавающей запятой</span><span class="sxs-lookup"><span data-stu-id="4e07f-174">16-bit floating-point rules</span></span>

<span data-ttu-id="4e07f-175">Direct3D 11 также поддерживает 16-разрядные представления чисел с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="4e07f-175">Direct3D 11 also supports 16-bit representations of floating-point numbers.</span></span>

<span data-ttu-id="4e07f-176">Формат:</span><span class="sxs-lookup"><span data-stu-id="4e07f-176">Format:</span></span>

-   <span data-ttu-id="4e07f-177">1 бит знака (s) в положении старшего разряда;</span><span class="sxs-lookup"><span data-stu-id="4e07f-177">1 sign bit (s)in the MSB bit position</span></span>
-   <span data-ttu-id="4e07f-178">5 битов смещенного порядка (e);</span><span class="sxs-lookup"><span data-stu-id="4e07f-178">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="4e07f-179">10 дробных битов (f) с дополнительным скрытым битом.</span><span class="sxs-lookup"><span data-stu-id="4e07f-179">10 bits of fraction (f), with an additional hidden bit</span></span>

<span data-ttu-id="4e07f-180">Значение float16 (v) соответствует следующим правилам:</span><span class="sxs-lookup"><span data-stu-id="4e07f-180">A float16 value (v) follows these rules:</span></span>

-   <span data-ttu-id="4e07f-181">если e == 31 и f != 0, то v — не число независимо от s;</span><span class="sxs-lookup"><span data-stu-id="4e07f-181">if e == 31 and f != 0, then v is NaN regardless of s</span></span>
-   <span data-ttu-id="4e07f-182">Если e = = 31 и f = = 0, то v = (-1) s \* бесконечность (бесконечность со знаком)</span><span class="sxs-lookup"><span data-stu-id="4e07f-182">if e == 31 and f == 0, then v = (-1)s\*infinity (signed infinity)</span></span>
-   <span data-ttu-id="4e07f-183">Если значение e находится в диапазоне от 0 до 31, то v = (-1) s \* 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="4e07f-183">if e is between 0 and 31, then v = (-1)s\*2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="4e07f-184">Если e = = 0 и f! = 0, то v = (-1) s \* 2 (e-14) \* (0. f) (денормализованные числа)</span><span class="sxs-lookup"><span data-stu-id="4e07f-184">if e == 0 and f != 0, then v = (-1)s\*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="4e07f-185">Если e = = 0 и f = = 0, то v = (-1) s \* 0 (ноль со знаком)</span><span class="sxs-lookup"><span data-stu-id="4e07f-185">if e == 0 and f == 0, then v = (-1)s\*0 (signed zero)</span></span>

<span data-ttu-id="4e07f-186">32-разрядные правила с плавающей точкой также действуют для 16-разрядных чисел с плавающей точкой с корректировкой для описанной ранее структуры битов.</span><span class="sxs-lookup"><span data-stu-id="4e07f-186">32-bit floating-point rules also hold for 16-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="4e07f-187">Но есть следующие исключения:</span><span class="sxs-lookup"><span data-stu-id="4e07f-187">Exceptions to this include:</span></span>

-   <span data-ttu-id="4e07f-188">Точность. Несовмещенные операции над 16-разрядными числами с плавающей точкой выдают результат в виде представляемого значения, ближайшего к бесконечно точному результату (согласно IEEE-754, округление к ближайшему четному числу применяется к 16-разрядным значениям).</span><span class="sxs-lookup"><span data-stu-id="4e07f-188">Precision: Unfused operations on 16-bit floating-point numbers produce a result that is the nearest representable value to an infinitely-precise result (round to nearest even, per IEEE-754, applied to 16-bit values).</span></span> <span data-ttu-id="4e07f-189">32-разрядные правила с плавающей точкой придерживаются допуска в 1 ULP, 16-разрядные правила с плавающей точкой придерживаются допуска в 0,5 ULP для несовмещенных операций и 0,6 ULP для совмещенных операций.</span><span class="sxs-lookup"><span data-stu-id="4e07f-189">32-bit floating-point rules adhere to 1 ULP tolerance, 16-bit floating-point rules adhere to 0.5 ULP for unfused operations, and 0.6 ULP for fused operations.</span></span>
-   <span data-ttu-id="4e07f-190">16-разрядные числа с плавающей тачкой сохраняют денормализованные значения.</span><span class="sxs-lookup"><span data-stu-id="4e07f-190">16-bit floating-point numbers preserve denorms.</span></span>

## <a name="11-bit-and-10-bit-floating-point-rules"></a><span data-ttu-id="4e07f-191">11-разрядные и 10-разрядные правила с плавающей точкой</span><span class="sxs-lookup"><span data-stu-id="4e07f-191">11-bit and 10-bit floating-point rules</span></span>

<span data-ttu-id="4e07f-192">Direct3D 11 также поддерживает 11-разрядные и 10-разрядные форматы с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="4e07f-192">Direct3D 11 also supports 11-bit and 10-bit floating-point formats.</span></span>

<span data-ttu-id="4e07f-193">Формат:</span><span class="sxs-lookup"><span data-stu-id="4e07f-193">Format:</span></span>

-   <span data-ttu-id="4e07f-194">бит знака отсутствует;</span><span class="sxs-lookup"><span data-stu-id="4e07f-194">No sign bit</span></span>
-   <span data-ttu-id="4e07f-195">5 битов смещенного порядка (e);</span><span class="sxs-lookup"><span data-stu-id="4e07f-195">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="4e07f-196">6 дробных битов (f) в 11-разрядном формате, 5 дробных битов (f) в 10-разрядном формате с дополнительным скрытом битом в обоих случаях.</span><span class="sxs-lookup"><span data-stu-id="4e07f-196">6 bits of fraction (f) for an 11-bit format, 5 bits of fraction (f) for a 10-bit format, with an additional hidden bit in either case.</span></span>

<span data-ttu-id="4e07f-197">Значение float11/float10 (v) соответствует следующим правилам:</span><span class="sxs-lookup"><span data-stu-id="4e07f-197">A float11/float10 value (v) follows the following rules:</span></span>

-   <span data-ttu-id="4e07f-198">если e == 31 и f != 0, то v — не число;</span><span class="sxs-lookup"><span data-stu-id="4e07f-198">if e == 31 and f != 0, then v is NaN</span></span>
-   <span data-ttu-id="4e07f-199">если e == 31 и f == 0, то v = положительная бесконечность</span><span class="sxs-lookup"><span data-stu-id="4e07f-199">if e == 31 and f == 0, then v = +infinity</span></span>
-   <span data-ttu-id="4e07f-200">Если значение e находится в диапазоне от 0 до 31, то v = 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="4e07f-200">if e is between 0 and 31, then v = 2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="4e07f-201">Если e = = 0 и f! = 0, то v = \* 2 (e-14) \* (0. f) (денормализованные числа)</span><span class="sxs-lookup"><span data-stu-id="4e07f-201">if e == 0 and f != 0, then v = \*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="4e07f-202">если e == 0 и f == 0, то v = 0 (ноль)</span><span class="sxs-lookup"><span data-stu-id="4e07f-202">if e == 0 and f == 0, then v = 0 (zero)</span></span>

<span data-ttu-id="4e07f-203">32-разрядные правила с плавающей точкой также действуют для 11-разрядных и 10-разрядных чисел с плавающей точкой с корректировкой для описанной ранее структуры битов.</span><span class="sxs-lookup"><span data-stu-id="4e07f-203">32-bit floating-point rules also hold for 11-bit and 10-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="4e07f-204">Исключения:</span><span class="sxs-lookup"><span data-stu-id="4e07f-204">Exceptions include:</span></span>

-   <span data-ttu-id="4e07f-205">Точность. 32-разрядные правила с плавающей точкой придерживаются допуска в 0,5 ULP.</span><span class="sxs-lookup"><span data-stu-id="4e07f-205">Precision: 32-bit floating-point rules adhere to 0.5 ULP.</span></span>
-   <span data-ttu-id="4e07f-206">10/11-разрядные числа с плавающей тачкой сохраняют денормализованные значения.</span><span class="sxs-lookup"><span data-stu-id="4e07f-206">10/11-bit floating-point numbers preserve denorms.</span></span>
-   <span data-ttu-id="4e07f-207">Любая операция, в результате которой получается число меньше нуля, прикрепляется к нулю.</span><span class="sxs-lookup"><span data-stu-id="4e07f-207">Any operation that would result in a number less than zero is clamped to zero.</span></span>

## <a name="related-topics"></a><span data-ttu-id="4e07f-208">См. также</span><span class="sxs-lookup"><span data-stu-id="4e07f-208">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="4e07f-209">Ресурсы</span><span class="sxs-lookup"><span data-stu-id="4e07f-209">Resources</span></span>](overviews-direct3d-11-resources.md)
</dt> <dt>

[<span data-ttu-id="4e07f-210">Текстуры</span><span class="sxs-lookup"><span data-stu-id="4e07f-210">Textures</span></span>](overviews-direct3d-11-resources-textures.md)
</dt> </dl>

 

 