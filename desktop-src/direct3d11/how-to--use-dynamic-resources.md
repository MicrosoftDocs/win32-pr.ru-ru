---
title: Использование динамических ресурсов
description: Вы создаете и используете динамические ресурсы, когда приложению требуется изменить данные в этих ресурсах. Можно создавать текстуры и буферы для динамического использования.
ms.assetid: E73EA4B0-BD14-430C-89CA-4CFCF92C7548
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d85933490d1e3bbbd09cc83720651c4fd634012f8e5aa70562396e87c096ebc
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119633104"
---
# <a name="how-to-use-dynamic-resources"></a>Как использовать динамические ресурсы

**Важные API**

-   [**Ссылку ID3D11DeviceContext:: Map**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-map)
-   [**Ссылку ID3D11DeviceContext:: отмена сопоставления**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-unmap)
-   [**\_Использование D3D11**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_usage)

Вы создаете и используете динамические ресурсы, когда приложению требуется изменить данные в этих ресурсах. Можно создавать текстуры и буферы для динамического использования.

## <a name="what-you-need-to-know"></a>Это важно знать

### <a name="technologies"></a>Технологии

-   [Как создать текстуру](overviews-direct3d-11-resources-textures-create.md)
-   [Как программно инициализировать текстуру](overviews-direct3d-11-resources-textures-how-to-fill-manually.md)
-   [Как создать буфер константы](overviews-direct3d-11-resources-buffers-constant-how-to.md)

### <a name="prerequisites"></a>Предварительные требования

Предполагается, что вы знакомы с C++. Также вы должны быть знакомы с основными принципами программирования графики.

## <a name="instructions"></a>Инструкции

### <a name="step-1-specify-dynamic-usage"></a>Шаг 1. Указание динамического использования

Если вы хотите, чтобы приложение могло вносить изменения в ресурсы, необходимо указать эти ресурсы как динамические и доступные для записи при их создании.

**Указание динамического использования**

1.  Укажите динамическое использование ресурсов. Например, укажите [**\_ \_ динамическое значение D3D11 Usage**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_usage) в элементе **Usage** в [**\_ буфере D3D11 \_ DESC**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_buffer_desc) для вершины или буфера констант и укажите **\_ \_ динамическое значение использования D3D11** в элементе **Usage** [**D3D11 \_ TEXTURE2D \_ DESC**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_texture2d_desc) для двухмерной текстуры.
2.  Укажите ресурс как доступный для записи. Например, укажите значение [**D3D11 \_ ЦП \_ доступ \_ для записи**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_cpu_access_flag) в **кпуакцессфлагс** члене [**D3D11 \_ буфера \_ DESC**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_buffer_desc) или [**D3D11 \_ TEXTURE2D \_ DESC**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_texture2d_desc).
3.  Передайте описание ресурса в функцию создания. Например, передайте адрес [**D3D11 \_ буфера \_ DESC**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_buffer_desc) в [**ID3D11Device:: CreateBuffer**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-createbuffer) и передайте адрес [**D3D11 \_ TEXTURE2D \_ DESC**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_texture2d_desc) в [**ID3D11Device:: CreateTexture2D**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-createtexture2d).

Ниже приведен пример создания динамического буфера вершин.


```C++
    // Create a vertex buffer for a triangle.

    float2 triangleVertices[] =
    {
        float2(-0.5f, -0.5f),
        float2(0.0f, 0.5f),
        float2(0.5f, -0.5f),
    };

    D3D11_BUFFER_DESC vertexBufferDesc = { 0 };
    vertexBufferDesc.ByteWidth = sizeof(float2)* ARRAYSIZE(triangleVertices);
    vertexBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
    vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    vertexBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
    vertexBufferDesc.MiscFlags = 0;
    vertexBufferDesc.StructureByteStride = 0;

    D3D11_SUBRESOURCE_DATA vertexBufferData;
    vertexBufferData.pSysMem = triangleVertices;
    vertexBufferData.SysMemPitch = 0;
    vertexBufferData.SysMemSlicePitch = 0;

    DX::ThrowIfFailed(
        m_d3dDevice->CreateBuffer(
        &vertexBufferDesc,
        &vertexBufferData,
        &vertexBuffer2
        )
        );

```



### <a name="step-2-change-a-dynamic-resource"></a>Шаг 2. изменение динамического ресурса

Если вы указали ресурс как динамический и доступный для записи, то позднее можно внести изменения в этот ресурс.

**Изменение данных в динамическом ресурсе**

1.  Настройте новые данные для ресурса. Объявите переменную [**D3D11 \_ сопоставленного типа \_ подресурса**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_mapped_subresource) и инициализируйте ее нулем. Эта переменная будет использоваться для изменения ресурса.
2.  Отключите доступ графического процессора к данным, которые необходимо изменить, и получите указатель на память, содержащую данные. Чтобы получить этот указатель, передайте при вызове [**ссылку ID3D11DeviceContext:: Map**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-map)параметр *маптипе* [**Write D3D11, \_ \_ отменяющий запись \_ Map**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_map) . Установите этот указатель на адрес [**D3D11 \_ сопоставленной переменной \_ подресурса**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_mapped_subresource) из предыдущего шага.
3.  Запишите новые данные в память.
4.  Вызовите метод [**ссылку ID3D11DeviceContext::**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-unmap) uncall, чтобы снова включить доступ GPU к данным после завершения записи новых данных.

Ниже приведен пример изменения динамического буфера вершин.


```C++
// This might get called as the result of a click event to double the size of the triangle.
void TriangleRenderer::MapDoubleVertices()
{
    D3D11_MAPPED_SUBRESOURCE mappedResource;
    ZeroMemory(&mappedResource, sizeof(D3D11_MAPPED_SUBRESOURCE));
    float2 vertices[] =
    {
        float2(-1.0f, -1.0f),
        float2(0.0f, 1.0f),
        float2(1.0f, -1.0f),
    };
    //  Disable GPU access to the vertex buffer data.
    auto m_d3dContext = m_deviceResources->GetD3DDeviceContext();
    m_d3dContext->Map(vertexBuffer2.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
    //  Update the vertex buffer here.
    memcpy(mappedResource.pData, vertices, sizeof(vertices));
    //  Reenable GPU access to the vertex buffer data.
    m_d3dContext->Unmap(vertexBuffer2.Get(), 0);
}
```



## <a name="remarks"></a>Remarks

### <a name="using-dynamic-textures"></a>Использование динамических текстур

Рекомендуется создавать только одну динамическую текстуру для каждого формата и, возможно, для каждого размера. Не рекомендуется создавать динамические MIP-карты, Кубы и тома из-за дополнительных затрат на сопоставление каждого уровня. Для MIP-карты можно указать, что [**D3D11 \_ будет \_ записывать \_**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_map) только на верхнем уровне. Все уровни отбрасываются путем сопоставления только верхнего уровня. Это поведение одинаково для томов и кубов. Для кубов сопоставление верхнего уровня и лицевой стороны 0 сопоставляется.

### <a name="using-dynamic-buffers"></a>Использование динамических буферов

При вызове [**Map**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-map) в статическом буфере вершин, пока GPU использует буфер, существенно снижается производительность. В этом случае **Map** должен подождать, пока GPU не закончит чтение данных вершин или индексов из буфера, прежде чем **Map** может вернуться к вызывающему приложению, что приводит к значительной задержке. Вызов **Map** и последующее отображение из статического буфера несколько раз в кадре также предотвращает буферизацию команд GPU, поскольку перед возвратом указателя на карту необходимо закончить выполнение команд. Без буферизованных команд GPU остается неактивным до тех пор, пока приложение не завершит заполнение буфера вершин или буфера индексов и выдаст команду подготовки к просмотру.

В идеале данные вершин или индексов никогда не изменяются, но это не всегда возможно. Существует множество ситуаций, в которых приложению необходимо изменить данные вершины или индекса для каждого кадра, возможно даже несколько раз в кадре. В таких ситуациях рекомендуется создавать буфер вершин или индексов с [**\_ \_ динамическим использованием D3D11**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_usage). Этот флаг использования приводит к оптимизации среды выполнения для часто выполняемых операций с картой. **D3D11 \_ \_Динамическое использование** полезно только в том случае, когда буфер сопоставляется часто. Если данные должны оставаться постоянными, поместите их в статический буфер вершин или индекс.

Чтобы получить улучшение производительности при использовании динамических буферов вершин, приложение должно вызвать [**Map**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-map) с соответствующими значениями [**D3D11 \_ Map**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_map) . [**D3D11 \_ \_ \_ Отмена записи на карту**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_map) означает, что приложению не нужно сохранять в буфере старые данные вершин или индексов. Если графический процессор все еще использует буфер при вызове **Map** с **D3D11ной \_ \_ записью \_ отказа**, среда выполнения возвращает указатель на новый регион памяти вместо старых данных буфера. Это позволяет GPU продолжать использовать старые данные, пока приложение помещает данные в новый буфер. В приложении не требуется дополнительное управление памятью; Старый буфер повторно используется или уничтожается автоматически после завершения работы графического процессора.

> [!Note]  
> При сопоставлении буфера с [**D3D11ной \_ \_ записью \_**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_map)на отброшенную карту среда выполнения всегда удаляет весь буфер. Невозможно сохранить сведения в несопоставленных областях буфера, указав ненулевое смещение или поле с ограниченным размером.

 

Бывают случаи, когда объем данных, которые приложение должно хранить на карте, невелик, например добавление четырех вершин для отрисовки спрайта. [**D3D11 \_ \_Запись Map \_ без \_ перезаписи**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_map) указывает, что приложение не будет перезаписывать данные, уже используемые в динамическом буфере. Вызов [**Map**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-map) вернет указатель на старые данные, что позволит приложению добавлять новые данные в неиспользуемые области вершин или буфера индекса. Приложение не должно изменять вершины или индексы, используемые в операции рисования, так как они по-прежнему используются графическим процессором. Рекомендуется, чтобы приложение использовало [**D3D11 \_ Map \_ Write \_**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_map) , после того как динамический буфер полон для получения нового региона памяти, который удаляет старую вершину или данные индекса после завершения GPU.

Механизм асинхронных запросов полезен для определения того, используются ли в GPU вершины. Выдайте запрос на [**\_ \_ событие типа D3D11**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_query) после последнего вызова Draw, использующего вершины. Вершины больше не используются, если [**ссылку ID3D11DeviceContext:: GetData**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-getdata) возвращает значение S \_ ОК. При сопоставлении буфера с [**D3D11 \_ \_ записи \_**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_map) или без значений Map всегда гарантируется, что вершины будут правильно синхронизированы с графическим процессором. Но при сопоставлении без значений сопоставлений вам будет присвоено снижение производительности, описанное выше.

> [!Note]  
> среда выполнения Direct3D 11,1, которая доступна начиная с Windows 8, позволяет сопоставлять динамические буферы констант и представления ресурсов шейдеров (срвс) динамических буферов с [**D3D11 \_ MAP \_ \_ без \_ перезаписи**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_map). Среда выполнения Direct3D 11 и более ранних версий не ограничивает-overwrite частично-Update сопоставление с буферами вершин или индексов. Чтобы определить, поддерживает ли устройство Direct3D эти функции, вызовите [**ID3D11Device:: чеккфеатуресуппорт**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) с [**\_ функцией D3D11 \_ D3D11 \_ Options**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature). **Чеккфеатуресуппорт** заполняет элементы [**D3D11 \_ \_ данных функций \_ D3D11 \_**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_d3d11_options) в структуре параметров с помощью функций устройства. Ниже приведены соответствующие элементы **мапнувервритеондинамикконстантбуффер** и **мапнувервритеондинамикбуфферсрв**.

 

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Использование Direct3D 11](how-to-use-direct3d-11.md)
</dt> </dl>

 

 




