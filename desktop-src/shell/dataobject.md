---
description: Объект данных является центральным для всех операций передачи данных оболочки.
ms.assetid: c63d339e-ac62-4da1-b5ce-22d45a6a3413
title: Объект данных оболочки
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 812e5c18f5a2120fbf22682c6e768dc005128630
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104262911"
---
# <a name="shell-data-object"></a><span data-ttu-id="a97a0-103">Объект данных оболочки</span><span class="sxs-lookup"><span data-stu-id="a97a0-103">Shell Data Object</span></span>

<span data-ttu-id="a97a0-104">Объект данных является центральным для всех операций передачи данных оболочки.</span><span class="sxs-lookup"><span data-stu-id="a97a0-104">The data object is central to all Shell data transfers.</span></span> <span data-ttu-id="a97a0-105">В основном это контейнер для хранения передаваемых данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-105">It is primarily a container to hold the transferred data.</span></span> <span data-ttu-id="a97a0-106">Однако целевой объект также может взаимодействовать с объектом данных, чтобы упростить некоторые специализированные типы передачи данных оболочки, такие как оптимизированные перемещения.</span><span class="sxs-lookup"><span data-stu-id="a97a0-106">However, the target can also communicate with the data object to facilitate some specialized types of Shell data transfer such as optimized moves.</span></span> <span data-ttu-id="a97a0-107">В этом разделе приводятся общие сведения о работе объектов данных оболочки, их создании в источнике и о том, как они обрабатываются целевым объектом.</span><span class="sxs-lookup"><span data-stu-id="a97a0-107">This topic provides a general discussion of how Shell data objects work, how they are constructed by a source, and how they are handled by a target.</span></span> <span data-ttu-id="a97a0-108">Подробное описание использования объектов данных для перемещения различных типов данных оболочки см. в разделе [Обработка сценариев передача данных оболочки](datascenarios.md).</span><span class="sxs-lookup"><span data-stu-id="a97a0-108">For a detailed discussion of how to use data objects to transfer different types of Shell data, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

-   [<span data-ttu-id="a97a0-109">Как работают объекты данных</span><span class="sxs-lookup"><span data-stu-id="a97a0-109">How Data Objects Work</span></span>](#how-data-objects-work)
    -   [<span data-ttu-id="a97a0-110">Форматы буфера обмена</span><span class="sxs-lookup"><span data-stu-id="a97a0-110">Clipboard Formats</span></span>](#clipboard-formats)
    -   [<span data-ttu-id="a97a0-111">Структура ФОРМАТЕТК</span><span class="sxs-lookup"><span data-stu-id="a97a0-111">FORMATETC Structure</span></span>](#formatetc-structure)
    -   [<span data-ttu-id="a97a0-112">Структура СТГМЕДИУМ</span><span class="sxs-lookup"><span data-stu-id="a97a0-112">STGMEDIUM structure</span></span>](#stgmedium-structure)
-   [<span data-ttu-id="a97a0-113">Как источник создает объект данных</span><span class="sxs-lookup"><span data-stu-id="a97a0-113">How a Source Creates a Data Object</span></span>](#how-a-source-creates-a-data-object)
    -   [<span data-ttu-id="a97a0-114">Добавление объекта глобальной памяти в объект данных</span><span class="sxs-lookup"><span data-stu-id="a97a0-114">How to Add a Global Memory Object to a Data Object</span></span>](#how-to-add-a-global-memory-object-to-a-data-object)
    -   [<span data-ttu-id="a97a0-115">Реализация интерфейса IDataObject</span><span class="sxs-lookup"><span data-stu-id="a97a0-115">Implementing IDataObject</span></span>](#implementing-idataobject)
    -   [<span data-ttu-id="a97a0-116">Реализация Идропсаурце</span><span class="sxs-lookup"><span data-stu-id="a97a0-116">Implementing IDropSource</span></span>](#implementing-idropsource)
-   [<span data-ttu-id="a97a0-117">Обработка объектом данных целевым объектом</span><span class="sxs-lookup"><span data-stu-id="a97a0-117">How a Target Handles a Data Object</span></span>](#how-a-target-handles-a-data-object)
    -   [<span data-ttu-id="a97a0-118">Извлечение данных оболочки из объекта данных</span><span class="sxs-lookup"><span data-stu-id="a97a0-118">Extracting Shell Data from a Data Object</span></span>](#extracting-shell-data-from-a-data-object)
    -   [<span data-ttu-id="a97a0-119">Реализация интерфейс IDropTarget</span><span class="sxs-lookup"><span data-stu-id="a97a0-119">Implementing IDropTarget</span></span>](#implementing-idroptarget)
-   [<span data-ttu-id="a97a0-120">Использование вспомогательного объекта перетаскивания</span><span class="sxs-lookup"><span data-stu-id="a97a0-120">Using the Drag-and-Drop Helper Object</span></span>](#using-the-drag-and-drop-helper-object)
    -   [<span data-ttu-id="a97a0-121">Использование интерфейса Идрагсаурцехелпер</span><span class="sxs-lookup"><span data-stu-id="a97a0-121">Using the IDragSourceHelper Interface</span></span>](#using-the-idragsourcehelper-interface)
    -   [<span data-ttu-id="a97a0-122">Использование интерфейса Идроптаржеселпер</span><span class="sxs-lookup"><span data-stu-id="a97a0-122">Using the IDropTargetHelper Interface</span></span>](#using-the-idroptargethelper-interface)

## <a name="how-data-objects-work"></a><span data-ttu-id="a97a0-123">Как работают объекты данных</span><span class="sxs-lookup"><span data-stu-id="a97a0-123">How Data Objects Work</span></span>

<span data-ttu-id="a97a0-124">Объекты данных являются объектами модели COM, созданными источником данных для перемещения данных в целевой объект.</span><span class="sxs-lookup"><span data-stu-id="a97a0-124">Data objects are Component Object Model (COM) objects, created by the data source to transfer data to a target.</span></span> <span data-ttu-id="a97a0-125">Обычно они содержат более одного элемента данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-125">They typically carry more than one item of data.</span></span> <span data-ttu-id="a97a0-126">Для этого используется две причины.</span><span class="sxs-lookup"><span data-stu-id="a97a0-126">There are two reasons for this practice:</span></span>

-   <span data-ttu-id="a97a0-127">Хотя практически любой тип данных можно передать с помощью объекта данных, источник, как правило, не знает, какой тип данных может принимать целевой объект.</span><span class="sxs-lookup"><span data-stu-id="a97a0-127">While almost any type of data can be transferred with a data object, the source typically does not know what kind of data the target can accept.</span></span> <span data-ttu-id="a97a0-128">Например, данные могут быть частью форматированного текстового документа.</span><span class="sxs-lookup"><span data-stu-id="a97a0-128">For instance, the data might be a portion of a formatted text document.</span></span> <span data-ttu-id="a97a0-129">Хотя целевой объект может обрабатывать сложные сведения о форматировании, он может также принимать только текст в формате ANSI.</span><span class="sxs-lookup"><span data-stu-id="a97a0-129">While the target might be able to handle complex formatting information, it might also be able to accept only ANSI text.</span></span> <span data-ttu-id="a97a0-130">По этой причине объекты данных часто содержат одни и те же данные в нескольких разных форматах.</span><span class="sxs-lookup"><span data-stu-id="a97a0-130">For this reason, data objects often include the same data in several different formats.</span></span> <span data-ttu-id="a97a0-131">Затем целевой объект может извлекать данные в формате, который может быть обработано.</span><span class="sxs-lookup"><span data-stu-id="a97a0-131">The target can then extract the data in a format that it can handle.</span></span>
-   <span data-ttu-id="a97a0-132">Объекты данных также могут содержать вспомогательные элементы данных, не являющиеся версиями исходных данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-132">Data objects can also contain auxiliary data items that are not versions of source data.</span></span> <span data-ttu-id="a97a0-133">Этот тип элементов данных обычно предоставляет дополнительные сведения о операции обмена данными.</span><span class="sxs-lookup"><span data-stu-id="a97a0-133">This type of data item typically provides additional information about the data transfer operation.</span></span> <span data-ttu-id="a97a0-134">Например, оболочка использует вспомогательные элементы данных, чтобы указать, следует ли копировать или перемещать файл.</span><span class="sxs-lookup"><span data-stu-id="a97a0-134">For instance, the Shell uses auxiliary data items to indicate whether a file is to be copied or moved.</span></span>

### <a name="clipboard-formats"></a><span data-ttu-id="a97a0-135">Форматы буфера обмена</span><span class="sxs-lookup"><span data-stu-id="a97a0-135">Clipboard Formats</span></span>

<span data-ttu-id="a97a0-136">Каждый элемент данных в объекте данных имеет связанный формат, обычно называемый *форматом буфера обмена*.</span><span class="sxs-lookup"><span data-stu-id="a97a0-136">Each item of data in a data object has an associated format, usually called a *clipboard format*.</span></span> <span data-ttu-id="a97a0-137">Существует ряд стандартных форматов буфера обмена, объявленных в файле WinUser. h, которые соответствуют часто используемым типам данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-137">There are a number of standard clipboard formats, declared in Winuser.h, that correspond to commonly used types of data.</span></span> <span data-ttu-id="a97a0-138">Форматы буфера обмена — это целые числа, но обычно они называются их эквивалентными именами, которые имеют форму CF \_ *xxx*.</span><span class="sxs-lookup"><span data-stu-id="a97a0-138">Clipboard formats are integers, but they are normally referred to by their equivalent name, which has the form CF\_*XXX*.</span></span> <span data-ttu-id="a97a0-139">Например, формат буфера обмена для текста ANSI — текст CF \_ .</span><span class="sxs-lookup"><span data-stu-id="a97a0-139">For instance, the clipboard format for ANSI text is CF\_TEXT.</span></span>

<span data-ttu-id="a97a0-140">Приложения могут расширять диапазон доступных форматов буфера обмена, определяя закрытые форматы.</span><span class="sxs-lookup"><span data-stu-id="a97a0-140">Applications can extend the range of available clipboard formats by defining private formats.</span></span> <span data-ttu-id="a97a0-141">Чтобы определить частный формат, приложение вызывает [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) со строкой, определяющей формат.</span><span class="sxs-lookup"><span data-stu-id="a97a0-141">To define a private format, an application calls [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) with a string that identifies the format.</span></span> <span data-ttu-id="a97a0-142">Целое число без знака, возвращаемое функцией, является допустимым значением формата, которое может использоваться так же, как стандартный формат буфера обмена.</span><span class="sxs-lookup"><span data-stu-id="a97a0-142">The unsigned integer that the function returns is a valid format value that can be used just like a standard clipboard format.</span></span> <span data-ttu-id="a97a0-143">Однако исходный и целевой объекты должны зарегистрировать формат, чтобы его можно было использовать.</span><span class="sxs-lookup"><span data-stu-id="a97a0-143">However, both source and target must register the format in order to use it.</span></span> <span data-ttu-id="a97a0-144">За одним исключением —[CF \_ HDROP](clipboard.md)— форматы буфера обмена, используемые для перемещения данных оболочки, определяются как частные форматы.</span><span class="sxs-lookup"><span data-stu-id="a97a0-144">With one exception—[CF\_HDROP](clipboard.md)—the clipboard formats used to transfer Shell data are defined as private formats.</span></span> <span data-ttu-id="a97a0-145">Они должны быть зарегистрированы исходным и целевым объектом, прежде чем их можно будет использовать.</span><span class="sxs-lookup"><span data-stu-id="a97a0-145">They must be registered by the source and target before they can be used.</span></span> <span data-ttu-id="a97a0-146">Описание доступных форматов буфера обмена оболочки см. в разделе форматы буфера обмена оболочки.</span><span class="sxs-lookup"><span data-stu-id="a97a0-146">For a description of the available Shell clipboard formats, see Shell Clipboard Formats.</span></span>

<span data-ttu-id="a97a0-147">Хотя существуют некоторые исключения, объекты данных обычно содержат только один элемент данных для каждого поддерживаемого формата буфера обмена.</span><span class="sxs-lookup"><span data-stu-id="a97a0-147">Although there are some exceptions, data objects normally contain only one item of data for each clipboard format they support.</span></span> <span data-ttu-id="a97a0-148">Эта корреляция "один к одному" между форматом и данными позволяет использовать значение формата в качестве идентификатора для связанного элемента данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-148">This one-to-one correlation between format and data allows the format value to be used as an identifier for the associated data item.</span></span> <span data-ttu-id="a97a0-149">Фактически, при обсуждении содержимого объекта данных конкретный элемент данных обычно называется "форматом" и на него ссылается имя формата.</span><span class="sxs-lookup"><span data-stu-id="a97a0-149">In fact, when discussing the contents of a data object, a particular item of data is typically called a "format" and is referred to by its format name.</span></span> <span data-ttu-id="a97a0-150">Например, такие фразы, как «извлечение \_ текстового формата CF...» обычно используются при обсуждении текстового элемента данных ANSI объекта данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-150">For example, phrases such as "Extract the CF\_TEXT format..." are typically used when discussing a data object's ANSI text data item.</span></span>

<span data-ttu-id="a97a0-151">Когда целевой объект перетаскивания получает указатель на объект данных, цель перетаскивания перечисляет доступные форматы, чтобы определить, какие типы данных доступны.</span><span class="sxs-lookup"><span data-stu-id="a97a0-151">When the drop target receives the pointer to the data object, the drop target enumerates the available formats to determine what types of data are available.</span></span> <span data-ttu-id="a97a0-152">Затем он запрашивает один или несколько доступных форматов и извлекает данные.</span><span class="sxs-lookup"><span data-stu-id="a97a0-152">It then requests one or more of the available formats and extracts the data.</span></span> <span data-ttu-id="a97a0-153">Конкретный способ, которым целевой объект извлекает данные оболочки из объекта данных, зависит от формата. Это подробно описано в разделе [Обработка объектом данных целевым](#how-a-target-handles-a-data-object)объектом.</span><span class="sxs-lookup"><span data-stu-id="a97a0-153">The specific way that the target extracts Shell data from a data object varies with the format; this is discussed in detail in [How a Target Handles a Data Object](#how-a-target-handles-a-data-object).</span></span>

<span data-ttu-id="a97a0-154">При простой передаче данных в буфер обмена данные помещаются в глобальный объект памяти.</span><span class="sxs-lookup"><span data-stu-id="a97a0-154">With simple clipboard data transfers, the data is placed in a global memory object.</span></span> <span data-ttu-id="a97a0-155">Адрес этого объекта помещается в буфер обмена вместе с его форматом.</span><span class="sxs-lookup"><span data-stu-id="a97a0-155">The address of that object is placed on the Clipboard, along with its format.</span></span> <span data-ttu-id="a97a0-156">Формат буфера обмена сообщает целевому объекту, какой тип данных будет найден по соответствующему адресу.</span><span class="sxs-lookup"><span data-stu-id="a97a0-156">The clipboard format tells the target what kind of data it will find at the associated address.</span></span> <span data-ttu-id="a97a0-157">Хотя простые передачи в буфере обмена просты в реализации:</span><span class="sxs-lookup"><span data-stu-id="a97a0-157">While simple clipboard transfers are easy to implement:</span></span>

-   <span data-ttu-id="a97a0-158">Объекты данных предоставляют гораздо более гибкий способ передачи данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-158">Data objects provide a much more flexible way to transfer data.</span></span>
-   <span data-ttu-id="a97a0-159">Объекты данных лучше подходят для передачи больших объемов данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-159">Data objects are better suited for transferring large amounts of data.</span></span>
-   <span data-ttu-id="a97a0-160">Объекты данных должны использоваться для перемещения данных с помощью операции перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-160">Data objects must be used to transfer data with a drag-and-drop operation.</span></span>

<span data-ttu-id="a97a0-161">По этим причинам все передачи данных в оболочке используют объекты данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-161">For these reasons, all Shell data transfers use data objects.</span></span> <span data-ttu-id="a97a0-162">При использовании объектов данных форматы буфера обмена не используются напрямую.</span><span class="sxs-lookup"><span data-stu-id="a97a0-162">With data objects, clipboard formats are not used directly.</span></span> <span data-ttu-id="a97a0-163">Вместо этого элементы данных определяются обобщением формата буфера обмена, структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-163">Instead, data items are identified with a generalization of the clipboard format, a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span>

### <a name="formatetc-structure"></a><span data-ttu-id="a97a0-164">Структура ФОРМАТЕТК</span><span class="sxs-lookup"><span data-stu-id="a97a0-164">FORMATETC Structure</span></span>

<span data-ttu-id="a97a0-165">Структура [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) является расширенной версией формата буфера обмена.</span><span class="sxs-lookup"><span data-stu-id="a97a0-165">The [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure is an extended version of a clipboard format.</span></span> <span data-ttu-id="a97a0-166">Структура **форматетк** , используемая для передачи данных оболочки, имеет следующие характеристики.</span><span class="sxs-lookup"><span data-stu-id="a97a0-166">As used for Shell data transfers, the **FORMATETC** structure has the following characteristics:</span></span>

-   <span data-ttu-id="a97a0-167">Элемент данных по-прежнему определяется форматом буфера обмена в элементе **кфформат** .</span><span class="sxs-lookup"><span data-stu-id="a97a0-167">A data item is still identified by its clipboard format, in the **cfFormat** member.</span></span>
-   <span data-ttu-id="a97a0-168">Передаваемые данные не ограничиваются глобальными объектами памяти.</span><span class="sxs-lookup"><span data-stu-id="a97a0-168">Data transfer is not limited to global memory objects.</span></span> <span data-ttu-id="a97a0-169">Элемент **тимед** используется для указания механизма обмена данными, содержащегося в связанной структуре [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-169">The **tymed** member is used to indicate the data transfer mechanism contained in the associated [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="a97a0-170">Для него задано одно из значений [**тимед \_ xxx**](/windows/win32/api/objidl/ne-objidl-tymed) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-170">It is set to one of the [**TYMED\_XXX**](/windows/win32/api/objidl/ne-objidl-tymed) values.</span></span>
-   <span data-ttu-id="a97a0-171">Оболочка использует элемент **Линдекс** с его форматом [кфстр \_ филеконтентс](clipboard.md) , чтобы разрешить объекту данных содержать более одного элемента данных в каждом формате.</span><span class="sxs-lookup"><span data-stu-id="a97a0-171">The Shell uses the **lIndex** member with its [CFSTR\_FILECONTENTS](clipboard.md) format to allow a data object to contain more than one data item per format.</span></span> <span data-ttu-id="a97a0-172">Обсуждение того, как использовать этот формат, см. в разделе *Использование формата кфстр \_ Филеконтентс для извлечения данных из* раздела [Обработка передача данных сценариев оболочки](datascenarios.md).</span><span class="sxs-lookup"><span data-stu-id="a97a0-172">For a discussion of how to use this format, see the *Using the CFSTR\_FILECONTENTS Format to Extract Data from a File* section of [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>
-   <span data-ttu-id="a97a0-173">Для члена **дваспект** обычно задается \_ содержимое дваспект.</span><span class="sxs-lookup"><span data-stu-id="a97a0-173">The **dwAspect** member is typically set to DVASPECT\_CONTENT.</span></span> <span data-ttu-id="a97a0-174">Однако в Шлобж. h есть три значения, которые можно использовать для обмена данными в оболочке.</span><span class="sxs-lookup"><span data-stu-id="a97a0-174">However, there are three values defined in Shlobj.h that can be used for Shell data transfer.</span></span> 

    |                     |                                                                                                   |
    |---------------------|---------------------------------------------------------------------------------------------------|
    | <span data-ttu-id="a97a0-175">\_копирование дваспект</span><span class="sxs-lookup"><span data-stu-id="a97a0-175">DVASPECT\_COPY</span></span>      | <span data-ttu-id="a97a0-176">Используется для указания того, что формат представляет копию данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-176">Used to indicate that the format represents a copy of the data.</span></span>                                   |
    | <span data-ttu-id="a97a0-177">Ссылка на ДВАСПЕКТ \_</span><span class="sxs-lookup"><span data-stu-id="a97a0-177">DVASPECT\_LINK</span></span>      | <span data-ttu-id="a97a0-178">Используется для указания того, что формат представляет ярлык данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-178">Used to indicate that the format represents a shortcut to the data.</span></span>                               |
    | <span data-ttu-id="a97a0-179">ДВАСПЕКТ ( \_ SHORTNAME)</span><span class="sxs-lookup"><span data-stu-id="a97a0-179">DVASPECT\_SHORTNAME</span></span> | <span data-ttu-id="a97a0-180">Используется с \_ форматом CF HDROP для запроса пути к файлу с именами, сокращенными до формата 8,3.</span><span class="sxs-lookup"><span data-stu-id="a97a0-180">Used with the CF\_HDROP format to request a file path with the names shortened to the 8.3 format.</span></span> |

    

     

-   <span data-ttu-id="a97a0-181">Элемент **ПТД** не используется для передачи данных оболочки и обычно имеет значение **null**.</span><span class="sxs-lookup"><span data-stu-id="a97a0-181">The **ptd** member is not used for Shell data transfers and is normally set to **NULL**.</span></span>

### <a name="stgmedium-structure"></a><span data-ttu-id="a97a0-182">Структура СТГМЕДИУМ</span><span class="sxs-lookup"><span data-stu-id="a97a0-182">STGMEDIUM structure</span></span>

<span data-ttu-id="a97a0-183">Структура [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) предоставляет доступ к передаваемым данным.</span><span class="sxs-lookup"><span data-stu-id="a97a0-183">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure provides access to the data being transferred.</span></span> <span data-ttu-id="a97a0-184">Для данных оболочки поддерживаются три механизма обмена данными:</span><span class="sxs-lookup"><span data-stu-id="a97a0-184">Three data transfer mechanisms are supported for Shell data:</span></span>

-   <span data-ttu-id="a97a0-185">Глобальный объект памяти.</span><span class="sxs-lookup"><span data-stu-id="a97a0-185">A global memory object.</span></span>
-   <span data-ttu-id="a97a0-186">Интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-186">An [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface.</span></span>
-   <span data-ttu-id="a97a0-187">Интерфейс [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-187">An [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span>

<span data-ttu-id="a97a0-188">Элемент **тимед** структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) — это значение [**тимед \_ xxx**](/windows/win32/api/objidl/ne-objidl-tymed) , идентифицирующее механизм обмена данными.</span><span class="sxs-lookup"><span data-stu-id="a97a0-188">The **tymed** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure is a [**TYMED\_XXX**](/windows/win32/api/objidl/ne-objidl-tymed) value that identifies the data transfer mechanism.</span></span> <span data-ttu-id="a97a0-189">Второй элемент — это указатель, используемый целевым объектом для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-189">The second member is a pointer that is used by the target to extract the data.</span></span> <span data-ttu-id="a97a0-190">Указатель может быть одним из множества типов, в зависимости от значения **тимед** .</span><span class="sxs-lookup"><span data-stu-id="a97a0-190">The pointer can be one of a variety of types, depending on the **tymed** value.</span></span> <span data-ttu-id="a97a0-191">Три значения **тимед** , используемые для передачи данных оболочки, приведены в следующей таблице вместе с соответствующим именем **стгмедиум** элемента.</span><span class="sxs-lookup"><span data-stu-id="a97a0-191">The three **tymed** values that are used for Shell data transfers are summarized in the following table, along with their corresponding **STGMEDIUM** member name.</span></span>



| <span data-ttu-id="a97a0-192">Значение тимед</span><span class="sxs-lookup"><span data-stu-id="a97a0-192">tymed Value</span></span>     | <span data-ttu-id="a97a0-193">Имя участника</span><span class="sxs-lookup"><span data-stu-id="a97a0-193">Member name</span></span> | <span data-ttu-id="a97a0-194">Описание</span><span class="sxs-lookup"><span data-stu-id="a97a0-194">Description</span></span>                                                                                                                                                                                                                                                                                                       |
|-----------------|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="a97a0-195">ТИМЕД \_ хглобал</span><span class="sxs-lookup"><span data-stu-id="a97a0-195">TYMED\_HGLOBAL</span></span>  | <span data-ttu-id="a97a0-196">**хглобал**</span><span class="sxs-lookup"><span data-stu-id="a97a0-196">**hGlobal**</span></span> | <span data-ttu-id="a97a0-197">Указатель на объект глобальной памяти.</span><span class="sxs-lookup"><span data-stu-id="a97a0-197">A pointer to a global memory object.</span></span> <span data-ttu-id="a97a0-198">Этот тип указателя обычно используется для передачи небольших объемов данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-198">This pointer type is typically used for transferring small amounts of data.</span></span> <span data-ttu-id="a97a0-199">Например, оболочка использует объекты глобальной памяти для обмена короткими текстовыми строками, такими как имена файлов или URL-адреса.</span><span class="sxs-lookup"><span data-stu-id="a97a0-199">For instance, the Shell uses global memory objects to transfer short text strings such as file names or URLs.</span></span>                                                                                    |
| <span data-ttu-id="a97a0-200">ТИМЕД \_ ISTREAM</span><span class="sxs-lookup"><span data-stu-id="a97a0-200">TYMED\_ISTREAM</span></span>  | <span data-ttu-id="a97a0-201">**пстм**</span><span class="sxs-lookup"><span data-stu-id="a97a0-201">**pstm**</span></span>    | <span data-ttu-id="a97a0-202">Указатель на интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-202">A pointer to an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface.</span></span> <span data-ttu-id="a97a0-203">Этот тип указателя предпочтителен для большинства операций передачи данных оболочки, так как он требует относительно мало памяти по сравнению с ТИМЕД \_ хглобал.</span><span class="sxs-lookup"><span data-stu-id="a97a0-203">This pointer type is preferred for most Shell data transfers because it requires relatively little memory compared to TYMED\_HGLOBAL.</span></span> <span data-ttu-id="a97a0-204">Кроме того, \_ механизму обмена данными тимед ISTREAM не требуется, чтобы источник хранят свои данные каким бы то ни было определенным образом.</span><span class="sxs-lookup"><span data-stu-id="a97a0-204">Also, the TYMED\_ISTREAM data transfer mechanism does not require the source to store its data in any particular way.</span></span> |
| <span data-ttu-id="a97a0-205">ТИМЕД \_ ISTORAGE</span><span class="sxs-lookup"><span data-stu-id="a97a0-205">TYMED\_ISTORAGE</span></span> | <span data-ttu-id="a97a0-206">**пстг**</span><span class="sxs-lookup"><span data-stu-id="a97a0-206">**pstg**</span></span>    | <span data-ttu-id="a97a0-207">Указатель на интерфейс [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-207">A pointer to an [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span> <span data-ttu-id="a97a0-208">Целевой объект вызывает методы интерфейса для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-208">The target calls the interface methods to extract the data.</span></span> <span data-ttu-id="a97a0-209">Как и в ТИМЕД \_ ISTREAM, этот тип указателя требует относительно мало памяти.</span><span class="sxs-lookup"><span data-stu-id="a97a0-209">Like TYMED\_ISTREAM, this pointer type requires relatively little memory.</span></span> <span data-ttu-id="a97a0-210">Однако поскольку ТИМЕД \_ ISTORAGE менее гибок, чем тимед \_ ISTREAM, он не так часто используется.</span><span class="sxs-lookup"><span data-stu-id="a97a0-210">However, because TYMED\_ISTORAGE is less flexible than TYMED\_ISTREAM, it is not as commonly used.</span></span>                  |



 

## <a name="how-a-source-creates-a-data-object"></a><span data-ttu-id="a97a0-211">Как источник создает объект данных</span><span class="sxs-lookup"><span data-stu-id="a97a0-211">How a Source Creates a Data Object</span></span>

<span data-ttu-id="a97a0-212">Когда пользователь инициирует передаваемые данные оболочки, источник отвечает за создание объекта данных и его загрузку с данными.</span><span class="sxs-lookup"><span data-stu-id="a97a0-212">When a user initiates a Shell data transfer, the source is responsible for creating a data object and loading it with data.</span></span> <span data-ttu-id="a97a0-213">Следующая процедура обобщает процесс:</span><span class="sxs-lookup"><span data-stu-id="a97a0-213">The following procedure summarizes the process:</span></span>

1.  <span data-ttu-id="a97a0-214">Вызовите [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) , чтобы получить допустимое значение формата буфера обмена для каждого формата оболочки, который будет включаться в объект данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-214">Call [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) to obtain a valid clipboard format value for each Shell format that will be included in the data object.</span></span> <span data-ttu-id="a97a0-215">Помните, [что \_ HDROP CF](clipboard.md) уже является допустимым форматом буфера обмена и не требует регистрации.</span><span class="sxs-lookup"><span data-stu-id="a97a0-215">Remember that [CF\_HDROP](clipboard.md) is already a valid clipboard format and does not need to be registered.</span></span>
2.  <span data-ttu-id="a97a0-216">Для каждого формата, который должен быть передан, следует либо поместить связанные данные в глобальный объект памяти, либо создать объект, предоставляющий доступ к этим данным через интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) или [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-216">For each format to be transferred, either put the associated data into a global memory object or create an object that provides access to that data through an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) or [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span> <span data-ttu-id="a97a0-217">Интерфейсы **IStream** и **IStorage** создаются с помощью стандартных методов COM.</span><span class="sxs-lookup"><span data-stu-id="a97a0-217">The **IStream** and **IStorage** interfaces are created using standard COM techniques.</span></span> <span data-ttu-id="a97a0-218">Обсуждение способов управления объектами глобальной памяти см. в разделе [Добавление объекта глобальной памяти в объект данных](#how-to-add-a-global-memory-object-to-a-data-object).</span><span class="sxs-lookup"><span data-stu-id="a97a0-218">For a discussion of how to handle global memory objects, see [How to Add a Global Memory Object to a Data Object](#how-to-add-a-global-memory-object-to-a-data-object).</span></span>
3.  <span data-ttu-id="a97a0-219">Создайте структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) и [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) для каждого формата.</span><span class="sxs-lookup"><span data-stu-id="a97a0-219">Create [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures for each format.</span></span>
4.  <span data-ttu-id="a97a0-220">Создайте экземпляр объекта данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-220">Instantiate a data object.</span></span>
5.  <span data-ttu-id="a97a0-221">Загрузите данные в объект данных, вызвав метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) для каждого поддерживаемого формата и передав структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) и [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) формата.</span><span class="sxs-lookup"><span data-stu-id="a97a0-221">Load the data into the data object by calling the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method for each supported format and passing in the format's [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures.</span></span>
6.  <span data-ttu-id="a97a0-222">При передаче данных из буфера обмена вызовите [**олесетклипбоард**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) , чтобы поместить указатель на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных в буфер обмена.</span><span class="sxs-lookup"><span data-stu-id="a97a0-222">With clipboard data transfers, call [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) to place a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface on the Clipboard.</span></span> <span data-ttu-id="a97a0-223">Для перемещения с помощью перетаскивания инициируйте *цикл перетаскивания* путем вызова [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span><span class="sxs-lookup"><span data-stu-id="a97a0-223">For drag-and-drop transfers, initiate a *drag loop* by calling [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span> <span data-ttu-id="a97a0-224">Указатель **IDataObject** будет передан в цель перетаскивания при удалении данных, завершая цикл перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-224">The **IDataObject** pointer will be passed to the drop target when the data is dropped, ending the drag loop.</span></span>

<span data-ttu-id="a97a0-225">Теперь объект данных готов к передаче в цель.</span><span class="sxs-lookup"><span data-stu-id="a97a0-225">The data object is now ready to be transferred to the target.</span></span> <span data-ttu-id="a97a0-226">Для передачи данных из буфера обмена объект просто удерживается, пока целевой объект не запросит его, вызвав [**олежетклипбоард**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span><span class="sxs-lookup"><span data-stu-id="a97a0-226">For clipboard data transfers, the object is simply held until the target requests it by calling [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span></span> <span data-ttu-id="a97a0-227">Для передачи данных при перетаскивании объект данных отвечает за создание значка для представления данных и их перемещение по мере того, как пользователь перемещает курсор.</span><span class="sxs-lookup"><span data-stu-id="a97a0-227">For drag-and-drop data transfers, the data object is responsible for creating an icon to represent the data and moving it as the user moves the cursor.</span></span> <span data-ttu-id="a97a0-228">Пока объект находится в цикле перетаскивания, источник получает сведения о состоянии через свой интерфейс [**идропсаурце**](/windows/win32/api/oleidl/nn-oleidl-idropsource) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-228">While the object is in the drag loop, the source receives status information through its [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface.</span></span> <span data-ttu-id="a97a0-229">Дополнительные сведения см. в статье [Реализация идропсаурце](#implementing-idropsource).</span><span class="sxs-lookup"><span data-stu-id="a97a0-229">For further discussion, see [Implementing IDropSource](#implementing-idropsource).</span></span>

<span data-ttu-id="a97a0-230">Источник не получает уведомления, если объект данных извлекается из буфера обмена целевым объектом.</span><span class="sxs-lookup"><span data-stu-id="a97a0-230">The source receives no notification if the data object is retrieved from the Clipboard by a target.</span></span> <span data-ttu-id="a97a0-231">При удалении объекта в целевой объект с помощью операции перетаскивания функция [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) , которая была вызвана для инициации цикла перетаскивания, вернет.</span><span class="sxs-lookup"><span data-stu-id="a97a0-231">When an object is dropped on a target by a drag-and-drop operation, the [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) function that was called to initiate the drag loop will return.</span></span>

### <a name="how-to-add-a-global-memory-object-to-a-data-object"></a><span data-ttu-id="a97a0-232">Добавление объекта глобальной памяти в объект данных</span><span class="sxs-lookup"><span data-stu-id="a97a0-232">How to Add a Global Memory Object to a Data Object</span></span>

<span data-ttu-id="a97a0-233">Многие форматы данных оболочки представлены в виде объекта глобальной памяти.</span><span class="sxs-lookup"><span data-stu-id="a97a0-233">Many of the Shell data formats are in the form of a global memory object.</span></span> <span data-ttu-id="a97a0-234">Используйте следующую процедуру, чтобы создать формат, содержащий объект глобальной памяти, и загрузить его в объект данных:</span><span class="sxs-lookup"><span data-stu-id="a97a0-234">Use the following procedure to create a format containing a global memory object and load it into the data object:</span></span>

1.  <span data-ttu-id="a97a0-235">Создайте структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-235">Create a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span> <span data-ttu-id="a97a0-236">Задайте для элемента **кфформат** соответствующее значение формата буфера обмена, а для элемента **тимед** — тимед \_ хглобал.</span><span class="sxs-lookup"><span data-stu-id="a97a0-236">Set the **cfFormat** member to the appropriate clipboard format value and the **tymed** member to TYMED\_HGLOBAL.</span></span>
2.  <span data-ttu-id="a97a0-237">Создайте структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-237">Create an [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="a97a0-238">Задайте для элемента **тимед** значение тимед \_ хглобал.</span><span class="sxs-lookup"><span data-stu-id="a97a0-238">Set the **tymed** member to TYMED\_HGLOBAL.</span></span>
3.  <span data-ttu-id="a97a0-239">Создайте объект глобальной памяти, вызвав [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc) для размещения блока памяти подходящего размера.</span><span class="sxs-lookup"><span data-stu-id="a97a0-239">Create a global memory object by calling [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc) to allocate a suitably sized block of memory.</span></span>
4.  <span data-ttu-id="a97a0-240">Назначьте блок данных для передачи в адрес, возвращенный [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc).</span><span class="sxs-lookup"><span data-stu-id="a97a0-240">Assign the block of data to be transferred to the address returned by [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc).</span></span>
5.  <span data-ttu-id="a97a0-241">Назначьте адрес объекта глобальной памяти элементу **хглобал** структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-241">Assign the global memory object's address to the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>
6.  <span data-ttu-id="a97a0-242">Загрузите формат в объект данных, вызвав [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) и передав структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) и [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) , созданные на предыдущих шагах.</span><span class="sxs-lookup"><span data-stu-id="a97a0-242">Load the format into the data object by calling [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) and passing in the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures created in the previous steps.</span></span>

<span data-ttu-id="a97a0-243">Следующий пример функции создает объект глобальной памяти, содержащий значение **DWORD** , и загружает его в объект данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-243">The following sample function creates a global memory object containing a **DWORD** value and loads it into a data object.</span></span> <span data-ttu-id="a97a0-244">Параметр **пдтобж** — это указатель на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных, **CF** — это значение формата буфера обмена, а **DW** — это значение данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-244">The **pdtobj** parameter is a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface, **cf** is the clipboard format value, and **dw** is the data value.</span></span>


```C++
STDAPI DataObj_SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw)
{
    FORMATETC fmte = {(CLIPFORMAT) cf, 
                      NULL, 
                      DVASPECT_CONTENT, 
                      -1, 
                      TYMED_HGLOBAL};
    STGMEDIUM medium;

    HRESULT hres = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));
    
    if (pdw)
    {
        *pdw = dw;       
        medium.tymed = TYMED_HGLOBAL;
        medium.hGlobal = pdw;
        medium.pUnkForRelease = NULL;

        hres = pdtobj->SetData(&fmte, &medium, TRUE);
 
        if (FAILED(hres))
            GlobalFree((HGLOBAL)pdw);
    }
    return hres;
}
```



### <a name="implementing-idataobject"></a><span data-ttu-id="a97a0-245">Реализация интерфейса IDataObject</span><span class="sxs-lookup"><span data-stu-id="a97a0-245">Implementing IDataObject</span></span>

<span data-ttu-id="a97a0-246">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) является основным интерфейсом объекта данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-246">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) is a data object's primary interface.</span></span> <span data-ttu-id="a97a0-247">Он должен быть реализован всеми объектами данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-247">It must be implemented by all data objects.</span></span> <span data-ttu-id="a97a0-248">Он используется как источником, так и целевым объектом для различных целей, в том числе:</span><span class="sxs-lookup"><span data-stu-id="a97a0-248">It is used by both source and target for a variety of purposes, including:</span></span>

-   <span data-ttu-id="a97a0-249">Загрузка данных в объект данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-249">Loading data into the data object.</span></span>
-   <span data-ttu-id="a97a0-250">Извлечение данных из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-250">Extracting data from the data object.</span></span>
-   <span data-ttu-id="a97a0-251">Определение типов данных, которые находятся в объекте данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-251">Determining what types of data are in the data object.</span></span>
-   <span data-ttu-id="a97a0-252">Предоставление обратной связи с объектом данных в результате передаваемых данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-252">Providing feedback to the data object on outcome of the data transfer.</span></span>

<span data-ttu-id="a97a0-253">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) поддерживает ряд методов.</span><span class="sxs-lookup"><span data-stu-id="a97a0-253">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) supports a number of methods.</span></span> <span data-ttu-id="a97a0-254">В этом разделе описывается, как реализовать три наиболее важных метода для объектов данных оболочки, [SetData](#setdata-method), [енумформатетк](#enumformatetc-method)и [GetData](#getdata-method).</span><span class="sxs-lookup"><span data-stu-id="a97a0-254">This section discusses how to implement the three most important methods for Shell data objects, [SetData](#setdata-method), [EnumFormatEtc](#enumformatetc-method), and [GetData](#getdata-method).</span></span> <span data-ttu-id="a97a0-255">Обсуждение других методов см. в справочнике по **IDataObject** .</span><span class="sxs-lookup"><span data-stu-id="a97a0-255">For a discussion of the other methods, see the **IDataObject** reference.</span></span>

### <a name="setdata-method"></a><span data-ttu-id="a97a0-256">SetData - метод</span><span class="sxs-lookup"><span data-stu-id="a97a0-256">SetData method</span></span>

<span data-ttu-id="a97a0-257">Основная функция метода [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) заключается в том, чтобы разрешить источнику загрузку данных в объект данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-257">The primary function of the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method is to allow the source to load data into the data object.</span></span> <span data-ttu-id="a97a0-258">Для каждого включаемого формата источник создает структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) , которая определяет формат и структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) для хранения указателя на данные.</span><span class="sxs-lookup"><span data-stu-id="a97a0-258">For each format to be included, the source creates a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to identify the format and an [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure to hold a pointer to the data.</span></span> <span data-ttu-id="a97a0-259">Затем источник вызывает метод **IDataObject:: SetData** объекта и передается в структурах **форматетк** и **стгмедиум** формата.</span><span class="sxs-lookup"><span data-stu-id="a97a0-259">The source then calls the object's **IDataObject::SetData** method and passes in the format's **FORMATETC** and **STGMEDIUM** structures.</span></span> <span data-ttu-id="a97a0-260">Метод должен сохранять эти сведения, чтобы они были доступны, когда целевой объект вызывает метод [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) для извлечения данных из объекта.</span><span class="sxs-lookup"><span data-stu-id="a97a0-260">The method must store this information so that it is available when the target calls [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) to extract data from the object.</span></span>

<span data-ttu-id="a97a0-261">Однако при передаче файлов оболочка часто помещает данные для каждого файла в отдельный формат [ \_ филеконтентс кфстр](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-261">However, when transferring files, the Shell often puts the information for each file to be transferred into a separate [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="a97a0-262">Чтобы отличить различные файлы, элементу **Линдекс** в структуре [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) каждого файла присваивается значение индекса, идентифицирующее конкретный файл.</span><span class="sxs-lookup"><span data-stu-id="a97a0-262">To distinguish the different files, the **lIndex** member of each file's [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure is set to an index value that identifies the particular file.</span></span> <span data-ttu-id="a97a0-263">Реализация [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) должна поддерживать хранение нескольких \_ форматов кфстр филеконтентс, которые отличаются только их членами **Линдекс** .</span><span class="sxs-lookup"><span data-stu-id="a97a0-263">Your [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) implementation must be capable of storing multiple CFSTR\_FILECONTENTS formats that differ only by their **lIndex** members.</span></span>

<span data-ttu-id="a97a0-264">Пока курсор находится над целевым окном, цель может использовать [вспомогательный объект перетаскивания](#using-the-drag-and-drop-helper-object) для указания изображения перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-264">While the cursor is over the target window, the target can use the [drag-and-drop helper object](#using-the-drag-and-drop-helper-object) to specify the drag image.</span></span> <span data-ttu-id="a97a0-265">Вспомогательный объект перетаскивания вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) для загрузки закрытых форматов в объект данных, используемый для поддержки между процессами.</span><span class="sxs-lookup"><span data-stu-id="a97a0-265">The drag-and-drop helper object calls [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to load private formats into the data object that are used for cross-process support.</span></span> <span data-ttu-id="a97a0-266">Для поддержки вспомогательного объекта, поддерживающего перетаскивание, реализация **IDataObject:: SetData** должна иметь возможность принимать и сохранять произвольные закрытые форматы.</span><span class="sxs-lookup"><span data-stu-id="a97a0-266">To support the drag-and-drop helper object, your **IDataObject::SetData** implementation must be able to accept and store arbitrary private formats.</span></span>

<span data-ttu-id="a97a0-267">После удаления данных некоторые типы передачи данных оболочки должны вызывать функцию [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) , чтобы предоставить объекту данных сведения о результате операции удаления.</span><span class="sxs-lookup"><span data-stu-id="a97a0-267">After the data has been dropped, some types of Shell data transfer require the target to call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to provide the data object with information about the outcome of the drop operation.</span></span> <span data-ttu-id="a97a0-268">Например, при перемещении файлов с оптимизированной операцией перемещения целевой объект обычно удаляет исходные файлы, но это не является обязательным.</span><span class="sxs-lookup"><span data-stu-id="a97a0-268">For example, when moving files with an optimized move operation, the target normally deletes the original files, but it is not required to do so.</span></span> <span data-ttu-id="a97a0-269">Цель информирует объект данных о том, удалили ли они файлы путем вызова функции **IDataObject:: SetData** с форматом [ \_ логикалперформеддропеффект кфстр](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-269">The target informs the data object whether it deleted the files by calling **IDataObject::SetData** with a [CFSTR\_LOGICALPERFORMEDDROPEFFECT](clipboard.md) format.</span></span> <span data-ttu-id="a97a0-270">Существует несколько других [форматов буфера обмена оболочки](clipboard.md) , которые также используются целевым объектом для передачи данных в объект данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-270">There are several other [Shell Clipboard Formats](clipboard.md) that are also used by the target to pass information to the data object.</span></span> <span data-ttu-id="a97a0-271">Реализация **IDataObject:: SetData** должна иметь возможность распознать эти форматы и ответить соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="a97a0-271">Your **IDataObject::SetData** implementation must be able to recognize these formats and respond appropriately.</span></span> <span data-ttu-id="a97a0-272">Дополнительные сведения см. в статье [Обработка сценариев передача данных оболочки](datascenarios.md).</span><span class="sxs-lookup"><span data-stu-id="a97a0-272">For further discussion, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

### <a name="enumformatetc-method"></a><span data-ttu-id="a97a0-273">Метод Енумформатетк</span><span class="sxs-lookup"><span data-stu-id="a97a0-273">EnumFormatEtc method</span></span>

<span data-ttu-id="a97a0-274">Когда цель получает объект данных, она обычно вызывает [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) , чтобы определить, какие форматы содержит объект.</span><span class="sxs-lookup"><span data-stu-id="a97a0-274">When the target receives a data object, it commonly calls [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) to determine what formats the object contains.</span></span> <span data-ttu-id="a97a0-275">Метод создает объект перечисления OLE и возвращает указатель на интерфейс [**иенумформатетк**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) объекта.</span><span class="sxs-lookup"><span data-stu-id="a97a0-275">The method creates an OLE enumeration object and returns a pointer to the object's [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) interface.</span></span> <span data-ttu-id="a97a0-276">Затем целевой объект использует интерфейс для перечисления доступных форматов.</span><span class="sxs-lookup"><span data-stu-id="a97a0-276">The target then uses the interface to enumerate the available formats.</span></span>

<span data-ttu-id="a97a0-277">Объект перечисления всегда должен перечислять доступные форматы в порядке их качества, начиная с наилучшего.</span><span class="sxs-lookup"><span data-stu-id="a97a0-277">An enumeration object should always enumerate the available formats in order of quality, starting with the best.</span></span> <span data-ttu-id="a97a0-278">Относительное качество форматов определяется источником перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-278">The relative quality of formats is defined by the drop source.</span></span> <span data-ttu-id="a97a0-279">Как правило, форматы самого высокого качества содержат самые широкие и наиболее полные данные.</span><span class="sxs-lookup"><span data-stu-id="a97a0-279">In general, the highest-quality formats contain the richest and most complete data.</span></span> <span data-ttu-id="a97a0-280">Например, 24-разрядное изображение, как правило, будет считаться более высоким качеством, чем серая версия этого изображения.</span><span class="sxs-lookup"><span data-stu-id="a97a0-280">For instance, a 24-bit color image would normally be considered higher quality than a gray-scale version of that image.</span></span> <span data-ttu-id="a97a0-281">Причина перечисления форматов в порядке их качества заключается в том, что целевые объекты обычно перечисляются до тех пор, пока они не получат поддерживаемый формат, а затем используют этот формат для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-281">The reason for enumerating formats in order of their quality is that targets typically enumerate until they get to a format that they support, and then they use that format to extract the data.</span></span> <span data-ttu-id="a97a0-282">Для этой процедуры, чтобы получить наилучший доступный формат, который может поддерживаться целью, необходимо перечислить форматы в порядке их качества.</span><span class="sxs-lookup"><span data-stu-id="a97a0-282">For this procedure to produce the best available format that the target can support, the formats must be enumerated in order of their quality.</span></span>

<span data-ttu-id="a97a0-283">Объект перечисления для данных оболочки реализуется во многом так же, как и для других типов обмена данными, с одним заметным исключением.</span><span class="sxs-lookup"><span data-stu-id="a97a0-283">An enumeration object for Shell data is implemented in much the same way as for other types of data transfer, with one notable exception.</span></span> <span data-ttu-id="a97a0-284">Поскольку объекты данных обычно содержат только один элемент данных в каждом формате, они обычно перечисляют каждый формат, который передается в [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata).</span><span class="sxs-lookup"><span data-stu-id="a97a0-284">Because data objects typically contain only one data item per format, they normally enumerate every format that is passed to [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata).</span></span> <span data-ttu-id="a97a0-285">Однако, как обсуждалось в разделе [метод SetData](#setdata-method) , объекты данных оболочки могут содержать несколько форматов [кфстр \_ филеконтентс](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-285">However, as discussed in the [SetData method](#setdata-method) section, Shell data objects can contain multiple [CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span>

<span data-ttu-id="a97a0-286">Так как для интерфейса [**IDataObject:: енумформатетк**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) можно разрешить целевому объекту определять, какие типы данных присутствуют, нет необходимости перечислять более одного формата [ \_ филеконтентс кфстр](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-286">Because the purpose of [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) is to allow the target to determine what types of data are present, there is no need to enumerate more than one [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="a97a0-287">Если целевому объекту необходимо узнать, сколько из этих форматов содержит объект данных, целевой объект может получить эту информацию из соответствующего \_ формата кфстр филедескриптор.</span><span class="sxs-lookup"><span data-stu-id="a97a0-287">If the target needs to know how many of these formats the data object contains, the target can retrieve that information from the accompanying CFSTR\_FILEDESCRIPTOR format.</span></span> <span data-ttu-id="a97a0-288">Более подробное описание реализации интерфейса **IDataObject:: енумформатетк** см. в справочной документации по методу.</span><span class="sxs-lookup"><span data-stu-id="a97a0-288">For further discussion of how to implement **IDataObject::EnumFormatEtc**, see the method's reference documentation.</span></span>

### <a name="getdata-method"></a><span data-ttu-id="a97a0-289">Метод GetData</span><span class="sxs-lookup"><span data-stu-id="a97a0-289">GetData method</span></span>

<span data-ttu-id="a97a0-290">Цель вызывает метод [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) для извлечения определенного формата данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-290">The target calls [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) to extract a particular data format.</span></span> <span data-ttu-id="a97a0-291">Целевой объект определяет формат, передавая соответствующую структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-291">The target specifies the format by passing in the appropriate [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span> <span data-ttu-id="a97a0-292">**IDataObject:: GetData** возвращает структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) формата.</span><span class="sxs-lookup"><span data-stu-id="a97a0-292">**IDataObject::GetData** returns the format's [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>

<span data-ttu-id="a97a0-293">Целевой объект может задать для элемента **тимед** структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) конкретное значение тимед \_ *xxx* , чтобы указать, какой механизм переноса данных будет использоваться для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-293">The target can set the **tymed** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to a specific TYMED\_*XXX* value to specify which data transfer mechanism it will use to extract the data.</span></span> <span data-ttu-id="a97a0-294">Однако целевой объект также может сделать более общий запрос и позволить объекту данных принять решение.</span><span class="sxs-lookup"><span data-stu-id="a97a0-294">However, the target can also make a more generic request and let the data object decide.</span></span> <span data-ttu-id="a97a0-295">Чтобы задать для объекта данных механизм обмена данными, целевой объект устанавливает все \_ поддерживаемые им значения тимед *xxx* .</span><span class="sxs-lookup"><span data-stu-id="a97a0-295">To ask the data object to select the data transfer mechanism, the target sets all the TYMED\_*XXX* values that it supports.</span></span> <span data-ttu-id="a97a0-296">[**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) выбирает один из этих механизмов обмена данными и возвращает соответствующую структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-296">[**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) selects one of these data transfer mechanisms and returns the appropriate [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="a97a0-297">Например, **тимед** обычно имеет значение тимед \_ хглобал \| тимед \_ ISTREAM \| тимед \_ ISTORAGE, чтобы запросить любой из трех механизмов обмена данными оболочки.</span><span class="sxs-lookup"><span data-stu-id="a97a0-297">For instance, **tymed** is commonly set to TYMED\_HGLOBAL \| TYMED\_ISTREAM \| TYMED\_ISTORAGE to request any of the three Shell data transfer mechanisms.</span></span>

> [!Note]  
> <span data-ttu-id="a97a0-298">Поскольку может существовать несколько форматов [кфстр \_ филеконтентс](clipboard.md) , члены **Кфформат** и **тимед** структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) недостаточно, чтобы указать, какая [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) структура [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) должна возвращать.</span><span class="sxs-lookup"><span data-stu-id="a97a0-298">Because there can be multiple [CFSTR\_FILECONTENTS](clipboard.md) formats, the **cfFormat** and **tymed** members of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure are not sufficient to indicate which [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) should return.</span></span> <span data-ttu-id="a97a0-299">Для \_ формата ФИЛЕКОНТЕНТС Кфстр **IDataObject:: GetData** должен также изучить элемент **Линдекс** структуры **форматетк** , чтобы получить правильную структуру **стгмедиум** .</span><span class="sxs-lookup"><span data-stu-id="a97a0-299">For the CFSTR\_FILECONTENTS format, **IDataObject::GetData** must also examine the **FORMATETC** structure's **lIndex** member in order to return the correct **STGMEDIUM** structure.</span></span>

 

<span data-ttu-id="a97a0-300">Формат [кфстр \_ индраглуп](clipboard.md) помещается в объекты данных, чтобы разрешить целевым объектам проверять состояние цикла перетаскивания, избегая интенсивного отображения данных объекта.</span><span class="sxs-lookup"><span data-stu-id="a97a0-300">The [CFSTR\_INDRAGLOOP](clipboard.md) format is placed in data objects to allow targets to check the status of the drag-and-drop loop while avoiding memory intensive rendering of the object's data.</span></span> <span data-ttu-id="a97a0-301">Данные формата — это значение **типа DWORD** , равное ненулевому значению, если объект данных находится в пределах цикла перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-301">The format's data is a **DWORD** value that is set to a nonzero value if the data object is within a drag loop.</span></span> <span data-ttu-id="a97a0-302">Значение данных формата задается равным нулю, если данные были удалены.</span><span class="sxs-lookup"><span data-stu-id="a97a0-302">The format's data value is set to zero if the data has been dropped.</span></span> <span data-ttu-id="a97a0-303">Если целевой объект запрашивает этот формат и не был загружен источником, метод [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) должен реагировать так, как если бы источник загрузил формат со значением, равным нулю.</span><span class="sxs-lookup"><span data-stu-id="a97a0-303">If a target requests this format and it has not been loaded by the source, [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) should respond as if the source had loaded the format with a value of zero.</span></span>

<span data-ttu-id="a97a0-304">Пока курсор находится над целевым окном, цель может использовать [вспомогательный объект перетаскивания](#using-the-drag-and-drop-helper-object) для указания изображения перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-304">While the cursor is over the target window, the target can use the [drag-and-drop helper object](#using-the-drag-and-drop-helper-object) to specify the drag image.</span></span> <span data-ttu-id="a97a0-305">Вспомогательный объект перетаскивания вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) для загрузки закрытых форматов в объект данных, используемый для поддержки между процессами.</span><span class="sxs-lookup"><span data-stu-id="a97a0-305">The drag-and-drop helper object calls [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to load private formats into the data object that are used for cross-process support.</span></span> <span data-ttu-id="a97a0-306">Позже он вызывает метод [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) , чтобы получить их.</span><span class="sxs-lookup"><span data-stu-id="a97a0-306">It later calls [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) to retrieve them.</span></span> <span data-ttu-id="a97a0-307">Для поддержки вспомогательного объекта перетаскивания реализация объекта данных оболочки должна иметь возможность возвращать произвольные закрытые форматы при их запросе.</span><span class="sxs-lookup"><span data-stu-id="a97a0-307">To support the drag-and-drop helper object, your Shell Data Object implementation must be able to return arbitrary private formats when they are requested.</span></span>

### <a name="implementing-idropsource"></a><span data-ttu-id="a97a0-308">Реализация Идропсаурце</span><span class="sxs-lookup"><span data-stu-id="a97a0-308">Implementing IDropSource</span></span>

<span data-ttu-id="a97a0-309">Источник должен создать объект, предоставляющий интерфейс [**идропсаурце**](/windows/win32/api/oleidl/nn-oleidl-idropsource) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-309">The source must create an object that exposes an [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface.</span></span> <span data-ttu-id="a97a0-310">Этот интерфейс позволяет источнику обновить *изображение перетаскивания* , указывающее текущую позицию курсора, и предоставить отзыв системе о том, как завершить операцию перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-310">This interface allows the source to update the *drag image* that indicates the current position of the cursor and to provide feedback to the system on how to terminate a drag-and-drop operation.</span></span> <span data-ttu-id="a97a0-311">**Идропсаурце** имеет два метода: [**GiveFeedback**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) и [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag).</span><span class="sxs-lookup"><span data-stu-id="a97a0-311">**IDropSource** has two methods: [**GiveFeedback**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) and [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag).</span></span>

### <a name="givefeedback-method"></a><span data-ttu-id="a97a0-312">GiveFeedback - метод</span><span class="sxs-lookup"><span data-stu-id="a97a0-312">GiveFeedback method</span></span>

<span data-ttu-id="a97a0-313">В цикле перетаскивания источник перетаскивания отвечает за отслеживание положения курсора и отображение соответствующего изображения перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-313">While in the drag loop, a drop source is responsible for keeping track of the cursor position and displaying an appropriate drag image.</span></span> <span data-ttu-id="a97a0-314">Однако в некоторых случаях может потребоваться изменить внешний вид изображения перетаскивания, если оно находится над окном назначения перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-314">However, in some cases you might want to change the appearance of the drag image when it is over the drop target's window.</span></span>

<span data-ttu-id="a97a0-315">Когда курсор попадает в целевое окно или покидает его, а перемещается в целевое окно, система периодически вызывает интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="a97a0-315">When the cursor enters or leaves the target window and while it is moving over the target window, the system periodically calls the target's [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span> <span data-ttu-id="a97a0-316">Целевой объект реагирует на значение [**дропеффект**](../com/dropeffect-constants.md) , которое перенаправляется в источник с помощью метода [**GiveFeedback**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-316">The target responds with a [**DROPEFFECT**](../com/dropeffect-constants.md) value that is forwarded to the source through the [**GiveFeedback**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) method.</span></span> <span data-ttu-id="a97a0-317">При необходимости источник может изменить внешний вид курсора на основе значения **дропеффект** .</span><span class="sxs-lookup"><span data-stu-id="a97a0-317">If appropriate, the source can modify the appearance of the cursor based on the **DROPEFFECT** value.</span></span> <span data-ttu-id="a97a0-318">Дополнительные сведения см. в справочниках по **GiveFeedback** и [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-318">For further details, see the **GiveFeedback** and [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) references.</span></span>

### <a name="querycontinuedrag-method"></a><span data-ttu-id="a97a0-319">QueryContinueDrag - метод</span><span class="sxs-lookup"><span data-stu-id="a97a0-319">QueryContinueDrag method</span></span>

<span data-ttu-id="a97a0-320">Этот метод вызывается при изменении состояния кнопки мыши или клавиатуры, когда объект данных находится в цикле перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-320">This method is called if the mouse button or keyboard state changes while the data object is in the drag loop.</span></span> <span data-ttu-id="a97a0-321">Он уведомляет источник о нажатии клавиши ESC и предоставляет текущее состояние клавиш с модификатором клавиатуры, таких как CTRL или SHIFT.</span><span class="sxs-lookup"><span data-stu-id="a97a0-321">It notifies the source whether the ESC key has been pressed and provides the current state of the keyboard modifier keys, such as CTRL or SHIFT.</span></span> <span data-ttu-id="a97a0-322">Возвращаемое значение метода [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) указывает одно из трех действий:</span><span class="sxs-lookup"><span data-stu-id="a97a0-322">The [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) method's return value specifies one of three actions:</span></span>

-   <span data-ttu-id="a97a0-323">\_ОК.</span><span class="sxs-lookup"><span data-stu-id="a97a0-323">S\_OK.</span></span> <span data-ttu-id="a97a0-324">Продолжить операцию перетаскивания</span><span class="sxs-lookup"><span data-stu-id="a97a0-324">Continue the drag operation</span></span>
-   <span data-ttu-id="a97a0-325">\_Удаление DRAGDROP \_ .</span><span class="sxs-lookup"><span data-stu-id="a97a0-325">DRAGDROP\_S\_DROP.</span></span> <span data-ttu-id="a97a0-326">Удалите данные.</span><span class="sxs-lookup"><span data-stu-id="a97a0-326">Drop the data.</span></span> <span data-ttu-id="a97a0-327">Затем система вызывает метод [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="a97a0-327">The system then calls the target's [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method.</span></span>
-   <span data-ttu-id="a97a0-328">DRAGDROP \_ S \_ Отмена.</span><span class="sxs-lookup"><span data-stu-id="a97a0-328">DRAGDROP\_S\_CANCEL.</span></span> <span data-ttu-id="a97a0-329">Завершите цикл перетаскивания без удаления данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-329">Terminate the drag loop without dropping the data.</span></span> <span data-ttu-id="a97a0-330">Это значение обычно возвращается при нажатии клавиши ESCAPE.</span><span class="sxs-lookup"><span data-stu-id="a97a0-330">This value is normally returned if the ESCAPE key was pressed.</span></span>

<span data-ttu-id="a97a0-331">Дополнительные сведения см. в справочниках по [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) и [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-331">For further discussion, see the [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) and [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) references.</span></span>

## <a name="how-a-target-handles-a-data-object"></a><span data-ttu-id="a97a0-332">Обработка объектом данных целевым объектом</span><span class="sxs-lookup"><span data-stu-id="a97a0-332">How a Target Handles a Data Object</span></span>

<span data-ttu-id="a97a0-333">Цель получает объект данных, когда он либо получает объект данных из буфера обмена, либо отбрасывается пользователем в целевое окно.</span><span class="sxs-lookup"><span data-stu-id="a97a0-333">The target receives a data object when it either retrieves the data object from the Clipboard or has it dropped on the target window by the user.</span></span> <span data-ttu-id="a97a0-334">Затем целевой объект может извлекать данные из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-334">The target can then extract data from the data object.</span></span> <span data-ttu-id="a97a0-335">При необходимости цель также может уведомлять объект данных о результате операции.</span><span class="sxs-lookup"><span data-stu-id="a97a0-335">If necessary, the target can also notify the data object of the outcome of the operation.</span></span> <span data-ttu-id="a97a0-336">Прежде чем передавать данные оболочки, цель перетаскивания должна подготовиться для выполнения операции:</span><span class="sxs-lookup"><span data-stu-id="a97a0-336">Prior to a Shell data transfer, a drop target must prepare itself for the operation:</span></span>

1.  <span data-ttu-id="a97a0-337">Цель должна вызвать [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) , чтобы получить допустимое значение формата буфера обмена для всех форматов оболочки, отличных от [CF \_ HDROP](clipboard.md), которые могут быть добавлены в объект данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-337">The target must call [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) to obtain a valid clipboard format value for all Shell formats, other than [CF\_HDROP](clipboard.md), that might be included in the data object.</span></span> <span data-ttu-id="a97a0-338">CF \_ HDROP уже является допустимым форматом буфера обмена и не требует регистрации.</span><span class="sxs-lookup"><span data-stu-id="a97a0-338">CF\_HDROP is already a valid clipboard format and does not need to be registered.</span></span>
2.  <span data-ttu-id="a97a0-339">Для поддержки операции перетаскивания целевой объект должен реализовывать интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) и регистрировать целевое окно.</span><span class="sxs-lookup"><span data-stu-id="a97a0-339">To support a drag-and-drop operation, the target must implement an [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface and register a target window.</span></span> <span data-ttu-id="a97a0-340">Чтобы зарегистрировать целевое окно, целевой объект вызывает [**регистердрагдроп**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) и передает маркер окна и указатель интерфейса **интерфейс IDropTarget** .</span><span class="sxs-lookup"><span data-stu-id="a97a0-340">To register a target window, the target calls [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) and passes in the window's handle and the **IDropTarget** interface pointer.</span></span>

<span data-ttu-id="a97a0-341">Для перемещений из буфера обмена целевой объект не получает уведомления о том, что в буфере обмена помещены объекты данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-341">For clipboard transfers, the target does not receive any notification that a data object has been placed on the Clipboard.</span></span> <span data-ttu-id="a97a0-342">Как правило, приложение уведомляет о том, что объект находится в буфере обмена с помощью действия пользователя, например нажатием кнопки Вставить на панели инструментов приложения.</span><span class="sxs-lookup"><span data-stu-id="a97a0-342">Typically, an application is notified that an object is on the Clipboard by a user action, such as clicking the Paste button on the application's toolbar.</span></span> <span data-ttu-id="a97a0-343">Затем целевой объект получает указатель [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных из буфера обмена путем вызова [**олежетклипбоард**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span><span class="sxs-lookup"><span data-stu-id="a97a0-343">The target then retrieves the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) pointer from the Clipboard by calling [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span></span> <span data-ttu-id="a97a0-344">Для передачи данных с помощью перетаскивания система использует интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) целевого объекта для предоставления целевой информации о ходе передачи данных:</span><span class="sxs-lookup"><span data-stu-id="a97a0-344">For drag-and-drop data transfers, the system uses the target's [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface to provide the target with information about the progress of the data transfer:</span></span>

-   <span data-ttu-id="a97a0-345">Система вызывает [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) , когда курсор попадает в целевое окно.</span><span class="sxs-lookup"><span data-stu-id="a97a0-345">The system calls [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) when the cursor enters the target window.</span></span>
-   <span data-ttu-id="a97a0-346">Система периодически вызывает [**интерфейс IDropTarget::D раговер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) по мере прохождения курсора в целевом окне, чтобы предоставить целевой объект текущей позиции курсора.</span><span class="sxs-lookup"><span data-stu-id="a97a0-346">The system periodically calls [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) as the cursor passes over the target window, to give the target the current cursor position.</span></span>
-   <span data-ttu-id="a97a0-347">Система вызывает [**интерфейс IDropTarget::D раглеаве**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragleave) , когда курсор покидает целевое окно.</span><span class="sxs-lookup"><span data-stu-id="a97a0-347">The system calls [**IDropTarget::DragLeave**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragleave) when the cursor leaves the target window.</span></span>
-   <span data-ttu-id="a97a0-348">Система вызывает [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , когда пользователь удаляет объект данных в целевом окне.</span><span class="sxs-lookup"><span data-stu-id="a97a0-348">The system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) when the user drops the data object on the target window.</span></span>

<span data-ttu-id="a97a0-349">Обсуждение реализации этих методов см. в разделе [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget).</span><span class="sxs-lookup"><span data-stu-id="a97a0-349">For a discussion of how to implement these methods, see [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget).</span></span>

<span data-ttu-id="a97a0-350">При удалении данных [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) предоставляет целевой объект с указателем на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-350">When the data is dropped, [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) provides the target with a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="a97a0-351">Затем целевой объект использует этот интерфейс для извлечения данных из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-351">The target then uses this interface to extract data from the data object.</span></span>

### <a name="extracting-shell-data-from-a-data-object"></a><span data-ttu-id="a97a0-352">Извлечение данных оболочки из объекта данных</span><span class="sxs-lookup"><span data-stu-id="a97a0-352">Extracting Shell Data from a Data Object</span></span>

<span data-ttu-id="a97a0-353">После удаления или извлечения объекта данных из буфера обмена целевой объект может извлекать необходимые данные.</span><span class="sxs-lookup"><span data-stu-id="a97a0-353">Once a data object has been dropped or retrieved from the Clipboard, the target can extract the data it needs.</span></span> <span data-ttu-id="a97a0-354">Первым шагом процесса извлечения обычно является перечисление форматов, содержащихся в объекте данных:</span><span class="sxs-lookup"><span data-stu-id="a97a0-354">The first step in the extraction process is typically to enumerate the formats contained by the data object:</span></span>

-   <span data-ttu-id="a97a0-355">Вызовите [**IDataObject:: енумформатетк**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc).</span><span class="sxs-lookup"><span data-stu-id="a97a0-355">Call [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc).</span></span> <span data-ttu-id="a97a0-356">Объект данных создает стандартный объект перечисления OLE и возвращает указатель на его интерфейс [**иенумформатетк**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-356">The data object creates a standard OLE enumeration object and returns a pointer to its [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) interface.</span></span>
-   <span data-ttu-id="a97a0-357">Используйте методы [**иенумформатетк**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) для перечисления форматов, содержащихся в объекте данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-357">Use the [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) methods to enumerate the formats contained by the data object.</span></span> <span data-ttu-id="a97a0-358">Эта операция обычно получает одну структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) для каждого формата, который содержит объект.</span><span class="sxs-lookup"><span data-stu-id="a97a0-358">This operation usually retrieves one [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure for each format that the object contains.</span></span> <span data-ttu-id="a97a0-359">Однако объект перечисления обычно возвращает только одну структуру **форматетк** для формата [кфстр \_ филеконтентс](clipboard.md) , независимо от того, сколько таких форматов содержится в объекте данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-359">However, the enumeration object normally returns only a single **FORMATETC** structure for the [CFSTR\_FILECONTENTS](clipboard.md) format, regardless of how many such formats are contained by the data object.</span></span>
-   <span data-ttu-id="a97a0-360">Выберите один или несколько форматов для извлечения и сохраните их структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-360">Select one or more formats to be extracted, and store their [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structures.</span></span>

<span data-ttu-id="a97a0-361">Чтобы получить определенный формат, передайте связанную структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) в [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span><span class="sxs-lookup"><span data-stu-id="a97a0-361">To retrieve a particular format, pass the associated [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span></span> <span data-ttu-id="a97a0-362">Этот метод возвращает структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) , которая предоставляет доступ к данным.</span><span class="sxs-lookup"><span data-stu-id="a97a0-362">This method returns an [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that provides access to the data.</span></span> <span data-ttu-id="a97a0-363">Чтобы указать определенный механизм обмена данными, установите значение **тимед** структуры **форматетк** в соответствующее значение тимед \_ *xxx* .</span><span class="sxs-lookup"><span data-stu-id="a97a0-363">To specify a particular data transfer mechanism, set the **tymed** value of the **FORMATETC** structure to the corresponding TYMED\_*XXX* value.</span></span> <span data-ttu-id="a97a0-364">Чтобы задать для объекта данных способ выбора механизма обмена данными, целевой объект устанавливает значения ТИМЕД \_ *xxx* для каждого механизма обмена данными, который может быть обработано целевым объектом.</span><span class="sxs-lookup"><span data-stu-id="a97a0-364">To ask the data object to select a data transfer mechanism, the target sets the TYMED\_*XXX* values for every data transfer mechanism that the target can handle.</span></span> <span data-ttu-id="a97a0-365">Объект данных выбирает один из этих механизмов обмена данными и возвращает соответствующую структуру **стгмедиум** .</span><span class="sxs-lookup"><span data-stu-id="a97a0-365">The data object selects one of these data transfer mechanisms and returns the appropriate **STGMEDIUM** structure.</span></span>

<span data-ttu-id="a97a0-366">Для большинства форматов целевой объект может получить данные, передав структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) , полученную при перечислении доступных форматов.</span><span class="sxs-lookup"><span data-stu-id="a97a0-366">For most formats, the target can retrieve the data by passing the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure that it received when it enumerated the available formats.</span></span> <span data-ttu-id="a97a0-367">Единственным исключением из этого правила является [кфстр \_ филеконтентс](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="a97a0-367">One exception to this rule is [CFSTR\_FILECONTENTS](clipboard.md).</span></span> <span data-ttu-id="a97a0-368">Поскольку объект данных может содержать несколько экземпляров этого формата, структура **форматетк** , возвращаемая перечислителем, может не соответствовать конкретному формату, который необходимо извлечь.</span><span class="sxs-lookup"><span data-stu-id="a97a0-368">Because a data object can contain multiple instances of this format, the **FORMATETC** structure returned by the enumerator might not correspond to the particular format you want to extract.</span></span> <span data-ttu-id="a97a0-369">Помимо указания членов **кфформат** и **тимед** , необходимо также задать для элемента **Линдекс** значение индекса файла.</span><span class="sxs-lookup"><span data-stu-id="a97a0-369">In addition to specifying the **cfFormat** and **tymed** members, you must also set the **lIndex** member to the file's index value.</span></span> <span data-ttu-id="a97a0-370">Дополнительные сведения см. в разделе *Использование формата кфстр \_ Филеконтентс для извлечения данных из файла* , посвященного [обработке сценариев передача данных оболочки](datascenarios.md) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-370">For further discussion, see the *Using the CFSTR\_FILECONTENTS Format to Extract Data from a File* section of [Handling Shell Data Transfer Scenarios](datascenarios.md)</span></span>

<span data-ttu-id="a97a0-371">Процесс извлечения данных зависит от типа указателя, содержащегося в возвращаемой структуре [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-371">The data extraction process depends on the type of pointer contained by the returned [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="a97a0-372">Если структура содержит указатель на интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) или [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) , используйте методы интерфейса для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-372">If the structure contains a pointer to an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) or [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface, use the interface methods to extract the data.</span></span> <span data-ttu-id="a97a0-373">Процесс извлечения данных из глобального объекта памяти обсуждается в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="a97a0-373">The process of extracting data from a global memory object is discussed in the next section.</span></span>

### <a name="extracting-a-global-memory-object-from-a-data-object"></a><span data-ttu-id="a97a0-374">Извлечение объекта глобальной памяти из объекта данных</span><span class="sxs-lookup"><span data-stu-id="a97a0-374">Extracting a global memory object from a data object</span></span>

<span data-ttu-id="a97a0-375">Многие форматы данных оболочки представлены в виде объекта глобальной памяти.</span><span class="sxs-lookup"><span data-stu-id="a97a0-375">Many of the Shell data formats are in the form of a global memory object.</span></span> <span data-ttu-id="a97a0-376">Следующая процедура используется для извлечения формата, содержащего объект глобальной памяти из объекта данных, и назначения его данных локальной переменной:</span><span class="sxs-lookup"><span data-stu-id="a97a0-376">Use the following procedure to extract a format containing a global memory object from a data object and assign its data to a local variable:</span></span>

1.  <span data-ttu-id="a97a0-377">Создайте структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-377">Create a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span> <span data-ttu-id="a97a0-378">Задайте для элемента **кфформат** соответствующее значение формата буфера обмена, а для элемента **тимед** — тимед \_ хглобал.</span><span class="sxs-lookup"><span data-stu-id="a97a0-378">Set the **cfFormat** member to the appropriate clipboard format value and the **tymed** member to TYMED\_HGLOBAL.</span></span>
2.  <span data-ttu-id="a97a0-379">Создайте пустую структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-379">Create an empty [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>
3.  <span data-ttu-id="a97a0-380">Вызовите [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata)и передайте указатели на структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) и [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-380">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata), and pass in pointers to the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures.</span></span>

    <span data-ttu-id="a97a0-381">Когда функция [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) возвращает значение, структура [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) будет содержать указатель на глобальный объект памяти, содержащий данные.</span><span class="sxs-lookup"><span data-stu-id="a97a0-381">When [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns, the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure will contain a pointer to the global memory object that contains the data.</span></span>

4.  <span data-ttu-id="a97a0-382">Назначьте данные локальной переменной, вызвав [**глобаллокк**](/windows/win32/api/winbase/nf-winbase-globallock) и передав элемент **хглобал** структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-382">Assign the data to a local variable by calling [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) and passing in the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>
5.  <span data-ttu-id="a97a0-383">Вызовите [**глобалунлокк**](/windows/win32/api/winbase/nf-winbase-globalunlock) , чтобы снять блокировку объекта глобальной памяти.</span><span class="sxs-lookup"><span data-stu-id="a97a0-383">Call [**GlobalUnlock**](/windows/win32/api/winbase/nf-winbase-globalunlock) to release the lock on the global memory object.</span></span>
6.  <span data-ttu-id="a97a0-384">Вызовите [**релеасестгмедиум**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) , чтобы освободить глобальный объект памяти.</span><span class="sxs-lookup"><span data-stu-id="a97a0-384">Call [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) to release the global memory object.</span></span>

> [!Note]  
> <span data-ttu-id="a97a0-385">Для освобождения объекта глобальной памяти, а не [**GlobalFree**](/windows/win32/api/winbase/nf-winbase-globalfree), необходимо использовать [**релеасестгмедиум**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-385">You must use [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) to release the global memory object, not [**GlobalFree**](/windows/win32/api/winbase/nf-winbase-globalfree).</span></span>

 

<span data-ttu-id="a97a0-386">В следующем примере показано извлечение значения **DWORD** , хранящегося в виде объекта глобальной памяти, из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-386">The following example shows how to extract a **DWORD** value stored as a global memory object from a data object.</span></span> <span data-ttu-id="a97a0-387">Параметр **пдтобж** является указателем на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных, **CF** — это формат буфера обмена, который определяет нужные данные, а **пдваут** используется для возвращения значения данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-387">The **pdtobj** parameter is a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface, **cf** is the clipboard format that identifies the desired data, and **pdwOut** is used to return the data value.</span></span>


```C++
STDAPI DataObj_GetDWORD(IDataObject *pdtobj, UINT cf, DWORD *pdwOut)
{    STGMEDIUM medium;
   FORMATETC fmte = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, 
       TYMED_HGLOBAL};
    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hres))
   {
       DWORD *pdw = (DWORD *)GlobalLock(medium.hGlobal);
       if (pdw)
       {
           *pdwOut = *pdw;
           GlobalUnlock(medium.hGlobal);
       }
       else
       {
           hres = E_UNEXPECTED;
       }
       ReleaseStgMedium(&medium);
   }
   return hres;
}
```



### <a name="implementing-idroptarget"></a><span data-ttu-id="a97a0-388">Реализация интерфейс IDropTarget</span><span class="sxs-lookup"><span data-stu-id="a97a0-388">Implementing IDropTarget</span></span>

<span data-ttu-id="a97a0-389">Система использует интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) для связи с целевым объектом, пока курсор находится над целевым окном.</span><span class="sxs-lookup"><span data-stu-id="a97a0-389">The system uses the [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface to communicate with the target while the cursor is over the target window.</span></span> <span data-ttu-id="a97a0-390">Ответы целевого объекта перенаправляются в источник через его интерфейс [**идропсаурце**](/windows/win32/api/oleidl/nn-oleidl-idropsource) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-390">The target's responses are forwarded to the source through its [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface.</span></span> <span data-ttu-id="a97a0-391">В зависимости от ответа источник может изменить значок, представляющий данные.</span><span class="sxs-lookup"><span data-stu-id="a97a0-391">Depending on the response, the source can modify the icon that represents the data.</span></span> <span data-ttu-id="a97a0-392">Если цель перетаскивания должна указать значок данных, это можно сделать, создав [вспомогательный объект перетаскивания](#using-the-drag-and-drop-helper-object).</span><span class="sxs-lookup"><span data-stu-id="a97a0-392">If the drop target needs to specify the data icon, it can do so by creating a [drag-and-drop helper object](#using-the-drag-and-drop-helper-object).</span></span>

<span data-ttu-id="a97a0-393">С помощью обычных операций перетаскивания целевой объект сообщает объекту данных о результате операции, устанавливая для параметра *Пдвеффект* [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) соответствующее значение [**дропеффект**](../com/dropeffect-constants.md) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-393">With conventional drag-and-drop operations, the target informs the data object of the outcome of the operation by setting the *pdwEffect* parameter of [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) to the appropriate [**DROPEFFECT**](../com/dropeffect-constants.md) value.</span></span> <span data-ttu-id="a97a0-394">Для объектов данных оболочки целевому объекту может также потребоваться вызов интерфейса [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata).</span><span class="sxs-lookup"><span data-stu-id="a97a0-394">With Shell data objects, the target might also need to call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata).</span></span> <span data-ttu-id="a97a0-395">Обсуждение того, как целевые объекты должны отвечать на различные сценарии обмена данными, см. в разделе [Обработка сценариев передача данных оболочки](datascenarios.md).</span><span class="sxs-lookup"><span data-stu-id="a97a0-395">For a discussion of how targets should respond for different data transfer scenarios, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

<span data-ttu-id="a97a0-396">В следующих разделах кратко описано, как реализовать методы [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter), [**интерфейс IDropTarget::D раговер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover)и [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-396">The following sections briefly discuss how to implement the [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter), [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover), and [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) methods.</span></span> <span data-ttu-id="a97a0-397">Дополнительные сведения см. в справочной документации.</span><span class="sxs-lookup"><span data-stu-id="a97a0-397">For further details, see the reference documentation.</span></span>

### <a name="dragenter-method"></a><span data-ttu-id="a97a0-398">Метод DragEnter</span><span class="sxs-lookup"><span data-stu-id="a97a0-398">DragEnter method</span></span>

<span data-ttu-id="a97a0-399">Система вызывает метод [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) , когда курсор попадает в целевое окно.</span><span class="sxs-lookup"><span data-stu-id="a97a0-399">The system calls the [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) method when the cursor enters the target window.</span></span> <span data-ttu-id="a97a0-400">Его параметры предоставляют целевому объекту расположение курсора, состояние клавиш с модификатором клавиатуры, например клавишу CTRL, и указатель на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-400">Its parameters provide the target with the location of the cursor, the state of keyboard modifier keys such as the CTRL key, and a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="a97a0-401">Цель несет ответственность за использование этого интерфейса, чтобы определить, может ли он принимать любой из форматов, содержащихся в объекте данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-401">The target is responsible for using that interface to determine whether it can accept any of the formats contained by the data object.</span></span> <span data-ttu-id="a97a0-402">Если это возможно, значение *пдвеффект* остается неизменным.</span><span class="sxs-lookup"><span data-stu-id="a97a0-402">If it can, it normally leaves the value of *pdwEffect* unchanged.</span></span> <span data-ttu-id="a97a0-403">Если он не может принимать какие бы то ни было данные из объекта данных, он устанавливает для параметра *пдвеффект* значение дропеффект \_ None.</span><span class="sxs-lookup"><span data-stu-id="a97a0-403">If it cannot accept any data from the data object, it sets the *pdwEffect* parameter to DROPEFFECT\_NONE.</span></span> <span data-ttu-id="a97a0-404">Система передает значение этого параметра интерфейсу [**идропсаурце**](/windows/win32/api/oleidl/nn-oleidl-idropsource) объекта данных, чтобы позволить ему отображать соответствующее изображение перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-404">The system passes the value of this parameter to the data object's [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface to allow it to display the appropriate drag image.</span></span>

<span data-ttu-id="a97a0-405">Целевые объекты не должны использовать метод [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) для отображения данных оболочки перед их удалением.</span><span class="sxs-lookup"><span data-stu-id="a97a0-405">Targets should not use the [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) method to render Shell data before it has been dropped.</span></span> <span data-ttu-id="a97a0-406">Полная визуализация данных объекта для каждого такого экземпляра может привести к зависанию курсора перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-406">Fully rendering the object's data for each such occurrence might cause the drag cursor to stall.</span></span> <span data-ttu-id="a97a0-407">Чтобы избежать этой проблемы, некоторые объекты оболочки содержат формат [кфстр \_ индраглуп](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-407">To avoid this problem, some Shell objects contain a [CFSTR\_INDRAGLOOP](clipboard.md) format.</span></span> <span data-ttu-id="a97a0-408">Извлекая этот формат, целевые объекты могут проверить состояние цикла перетаскивания и избежать интенсивного отображения данных объекта в памяти.</span><span class="sxs-lookup"><span data-stu-id="a97a0-408">By extracting this format, targets can check the status of the drag loop while avoiding memory intensive rendering of the object's data.</span></span> <span data-ttu-id="a97a0-409">Значение данных формата — **DWORD** , для которого задано ненулевое значение, если объект данных находится в пределах цикла перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-409">The format's data value is a **DWORD** that is set to a nonzero value if the data object is within a drag loop.</span></span> <span data-ttu-id="a97a0-410">Значение данных формата задается равным нулю, если данные были удалены.</span><span class="sxs-lookup"><span data-stu-id="a97a0-410">The format's data value is set to zero if the data has been dropped.</span></span>

<span data-ttu-id="a97a0-411">Если целевой объект может принимать данные из объекта данных, необходимо проверить **грфкэйстате** , чтобы определить, были ли нажаты клавиши CTRL для изменения нормального поведения при перетаскивании.</span><span class="sxs-lookup"><span data-stu-id="a97a0-411">If the target can accept data from the data object, it should examine **grfKeyState** to determine whether any modifier keys have been pressed to modify the normal drop behavior.</span></span> <span data-ttu-id="a97a0-412">Например, операция по умолчанию обычно является перемещением, но нажатие клавиши CTRL обычно означает операцию копирования.</span><span class="sxs-lookup"><span data-stu-id="a97a0-412">For instance, the default operation is typically a move, but depressing the CTRL key usually indicates a copy operation.</span></span>

<span data-ttu-id="a97a0-413">Пока курсор находится над целевым окном, цель может использовать [вспомогательный объект перетаскивания](#using-the-drag-and-drop-helper-object) для замены изображения перетаскивания объекта данных своим собственным.</span><span class="sxs-lookup"><span data-stu-id="a97a0-413">While the cursor is over the target window, the target can use the [drag-and-drop helper object](#using-the-drag-and-drop-helper-object) to replace the data object's drag image with its own.</span></span> <span data-ttu-id="a97a0-414">Если это так, [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) должен вызвать [**Идроптаржеселпер::D ражентер**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter) , чтобы передать сведения, содержащиеся в параметрах *DragEnter* , в вспомогательный объект перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-414">If so, [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) should call [**IDropTargetHelper::DragEnter**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter) to pass the information contained in the *DragEnter* parameters to the drag-and-drop helper object.</span></span>

### <a name="dragover-method"></a><span data-ttu-id="a97a0-415">Метод DragOver</span><span class="sxs-lookup"><span data-stu-id="a97a0-415">DragOver method</span></span>

<span data-ttu-id="a97a0-416">Когда курсор перемещается в целевое окно, система периодически вызывает метод [**интерфейс IDropTarget::D раговер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-416">As the cursor moves within the target window, the system periodically calls the [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) method.</span></span> <span data-ttu-id="a97a0-417">Его параметры предоставляют целевому объекту расположение курсора и состояние клавиш с модификатором клавиатуры, например клавишу CTRL.</span><span class="sxs-lookup"><span data-stu-id="a97a0-417">Its parameters provide the target with the location of the cursor and the state of keyboard modifier keys such as the CTRL key.</span></span> <span data-ttu-id="a97a0-418">**Интерфейс IDropTarget::D раговер** имеет почти те же обязанности, что и [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter), и реализации обычно очень похожи.</span><span class="sxs-lookup"><span data-stu-id="a97a0-418">**IDropTarget::DragOver** has much the same responsibilities as [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter), and the implementations are usually very similar.</span></span>

<span data-ttu-id="a97a0-419">Если цель использует вспомогательный объект перетаскивания, [**интерфейс IDropTarget::D раговер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) должен вызывать [**Идроптаржеселпер::D раговер**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) для пересылки сведений, содержащихся в параметрах *DragOver* , в вспомогательный объект перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-419">If the target is using the drag-and-drop helper object, [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) should call [**IDropTargetHelper::DragOver**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) to forward the information contained in the *DragOver* parameters to the drag-and-drop helper object.</span></span>

### <a name="drop-method"></a><span data-ttu-id="a97a0-420">Drop, метод</span><span class="sxs-lookup"><span data-stu-id="a97a0-420">Drop method</span></span>

<span data-ttu-id="a97a0-421">Система вызывает метод [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , чтобы уведомить целевой объект о том, что пользователь удалил данные, обычно отпустив кнопку мыши.</span><span class="sxs-lookup"><span data-stu-id="a97a0-421">The system calls the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to notify the target that the user has dropped the data, typically by releasing the mouse button.</span></span> <span data-ttu-id="a97a0-422">**Интерфейс IDropTarget::D верхнем** имеет те же параметры, что и [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span><span class="sxs-lookup"><span data-stu-id="a97a0-422">**IDropTarget::Drop** has the same parameters as [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span></span> <span data-ttu-id="a97a0-423">Целевой объект обычно отвечает путем извлечения одного или нескольких форматов из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-423">The target normally responds by extracting one or more formats from the data object.</span></span> <span data-ttu-id="a97a0-424">По завершении целевой объект должен присвоить параметру *пдвеффект* значение [**дропеффект**](../com/dropeffect-constants.md) , указывающее результат операции.</span><span class="sxs-lookup"><span data-stu-id="a97a0-424">When finished, the target should set the *pdwEffect* parameter to a [**DROPEFFECT**](../com/dropeffect-constants.md) value that indicates the outcome of the operation.</span></span> <span data-ttu-id="a97a0-425">Для некоторых типов передачи данных оболочки целевой объект должен также вызывать метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) , чтобы передать формат с дополнительной информацией о результате операции в объект данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-425">For some types of Shell data transfer, the target must also call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to pass a format with additional information on the outcome of the operation to the data object.</span></span> <span data-ttu-id="a97a0-426">Подробное обсуждение см. в разделе [Обработка сценариев передача данных оболочки](datascenarios.md).</span><span class="sxs-lookup"><span data-stu-id="a97a0-426">For a detailed discussion, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

<span data-ttu-id="a97a0-427">Если цель использует вспомогательный объект для перетаскивания, [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) должен вызывать [**идроптаржеселпер::D верхнем**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop) для пересылки сведений, содержащихся в параметрах идроптаржеселпер [**::D раговер**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) , в вспомогательный объект перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-427">If the target is using the drag-and-drop helper object, [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) should call [**IDropTargetHelper::Drop**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop) to forward the information contained in the [**IDropTargetHelper::DragOver**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) parameters to the drag-and-drop helper object.</span></span>

## <a name="using-the-drag-and-drop-helper-object"></a><span data-ttu-id="a97a0-428">Использование вспомогательного объекта перетаскивания</span><span class="sxs-lookup"><span data-stu-id="a97a0-428">Using the Drag-and-Drop Helper Object</span></span>

<span data-ttu-id="a97a0-429">Вспомогательный объект перетаскивания (CLSID \_ DragDropHelper) экспортируется оболочкой, чтобы разрешить целевым объектам указывать изображение перетаскивания, пока оно находится над целевым окном.</span><span class="sxs-lookup"><span data-stu-id="a97a0-429">The drag-and-drop helper object (CLSID\_DragDropHelper) is exported by the Shell to allow targets to specify the drag image while it is over the target window.</span></span> <span data-ttu-id="a97a0-430">Чтобы использовать вспомогательный объект для перетаскивания, создайте объект внутрипроцессного сервера, вызвав [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) с идентификатором класса (CLSID) CLSID \_ DragDropHelper.</span><span class="sxs-lookup"><span data-stu-id="a97a0-430">To use the drag-and-drop helper object, create an in-process server object by calling [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) with a class identifier (CLSID) of CLSID\_DragDropHelper.</span></span> <span data-ttu-id="a97a0-431">Вспомогательный объект перетаскивания предоставляет два интерфейса, которые используются следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a97a0-431">The drag-and-drop helper object exposes two interfaces that are used in the following way:</span></span>

-   <span data-ttu-id="a97a0-432">Интерфейс [**идрагсаурцехелпер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper) позволяет цели перетаскивания указать значок, который будет представлять объект данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-432">The [**IDragSourceHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper) interface allows the drop target to specify an icon to represent the data object.</span></span>
-   <span data-ttu-id="a97a0-433">Интерфейс [**идроптаржеселпер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) позволяет цели перетаскивания уведомлять объект вспомогательной операции перетаскивания к положению курсора, а также отображать или скрывать значок данных.</span><span class="sxs-lookup"><span data-stu-id="a97a0-433">The [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) interface allows the drop target to inform the drag-and-drop helper object of the cursor location, and to show or hide the data icon.</span></span>

### <a name="using-the-idragsourcehelper-interface"></a><span data-ttu-id="a97a0-434">Использование интерфейса Идрагсаурцехелпер</span><span class="sxs-lookup"><span data-stu-id="a97a0-434">Using the IDragSourceHelper Interface</span></span>

<span data-ttu-id="a97a0-435">Интерфейс [**идрагсаурцехелпер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper) предоставляется вспомогательным объектом перетаскивания, чтобы предоставить целевому объекту перетаскивания изображение, которое будет отображаться, пока курсор находится над целевым окном.</span><span class="sxs-lookup"><span data-stu-id="a97a0-435">The [**IDragSourceHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper) interface is exposed by the drag-and-drop helper object to allow a drop target to provide the image that will be displayed while the cursor is over the target window.</span></span> <span data-ttu-id="a97a0-436">**Идрагсаурцехелпер** предоставляет два альтернативных способа указания точечного рисунка для использования в качестве изображения перетаскивания:</span><span class="sxs-lookup"><span data-stu-id="a97a0-436">**IDragSourceHelper** provides two alternative ways to specify the bitmap to be used as a drag image:</span></span>

-   <span data-ttu-id="a97a0-437">Объекты перетаскивания, которые содержат окно, могут зарегистрировать \_ для него сообщение окна di жетдрагимаже, инициализируя вспомогательный объект перетаскивания с помощью [**идрагсаурцехелпер:: инитиализефромвиндов**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefromwindow).</span><span class="sxs-lookup"><span data-stu-id="a97a0-437">Drop targets that have a window can register a DI\_GETDRAGIMAGE window message for it by initializing the drag-and-drop helper object with [**IDragSourceHelper::InitializeFromWindow**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefromwindow).</span></span> <span data-ttu-id="a97a0-438">Когда целевой объект получает сообщение DI \_ жетдрагимаже, обработчик помещает сведения об точечном рисунке изображения в структуру [**шдрагимаже**](/windows/desktop/api/Shobjidl_core/ns-shobjidl_core-shdragimage) , которая передается как значение *lParam* сообщения.</span><span class="sxs-lookup"><span data-stu-id="a97a0-438">When the target receives a DI\_GETDRAGIMAGE message, the handler puts the drag image bitmap information in the [**SHDRAGIMAGE**](/windows/desktop/api/Shobjidl_core/ns-shobjidl_core-shdragimage) structure that is passed as the message's *lParam* value.</span></span>
-   <span data-ttu-id="a97a0-439">Цели перетаскивания без окон указывают точечный рисунок при инициализации вспомогательного объекта перетаскивания с помощью [**идрагсаурцехелпер:: инитиализефромбитмап**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefrombitmap).</span><span class="sxs-lookup"><span data-stu-id="a97a0-439">Windowless drop targets specify a bitmap when they initialize the drag-and-drop helper object with [**IDragSourceHelper::InitializeFromBitmap**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefrombitmap).</span></span>

### <a name="using-the-idroptargethelper-interface"></a><span data-ttu-id="a97a0-440">Использование интерфейса Идроптаржеселпер</span><span class="sxs-lookup"><span data-stu-id="a97a0-440">Using the IDropTargetHelper Interface</span></span>

<span data-ttu-id="a97a0-441">Этот интерфейс позволяет целевому объекту перетаскивания уведомлять объект вспомогательной операции перетаскивания, когда курсор переходит или выходит из целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="a97a0-441">This interface allows the drop target to notify the drag-and-drop helper object when the cursor enters or leaves the target.</span></span> <span data-ttu-id="a97a0-442">Пока курсор находится над целевым окном, [**идроптаржеселпер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) позволяет целевому объекту предоставить вспомогательной стороне перетаскивания сведения, получаемые целевым объектом через его интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) .</span><span class="sxs-lookup"><span data-stu-id="a97a0-442">While the cursor is over the target window, [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) allows the target to give the drag-and-drop helper object the information that the target receives through its [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span>

<span data-ttu-id="a97a0-443">Четыре метода [**идроптаржеселпер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) —[**Идроптаржеселпер::D ражентер**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter), [**идроптаржеселпер::D Раглеаве**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragleave), [**идроптаржеселпер::D ragover**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover)и [**IDropTargetHelper::D верхнем**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop)— связаны с методом [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="a97a0-443">Four of the [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) methods—[**IDropTargetHelper::DragEnter**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter), [**IDropTargetHelper::DragLeave**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragleave), [**IDropTargetHelper::DragOver**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover), and [**IDropTargetHelper::Drop**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop)—are associated with the [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) method of the same name.</span></span> <span data-ttu-id="a97a0-444">Чтобы использовать вспомогательный объект для перетаскивания, каждый из методов **интерфейс IDropTarget** должен вызывать соответствующий метод **идроптаржеселпер** для пересылки информации в вспомогательный объект перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-444">To use the drag-and-drop helper object, each of the **IDropTarget** methods should call the corresponding **IDropTargetHelper** method to forward the information to the drag-and-drop helper object.</span></span> <span data-ttu-id="a97a0-445">Пятый метод **идроптаржеселпер** , [**Идроптаржеселпер:: Показать**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-show), уведомляет вспомогательный объект перетаскивания, чтобы показать или скрыть изображение перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="a97a0-445">The fifth **IDropTargetHelper** method, [**IDropTargetHelper::Show**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-show), notifies the drag-and-drop helper object to show or hide the drag image.</span></span> <span data-ttu-id="a97a0-446">Этот метод используется при перетаскивании на целевое окно в режиме низкого цветового изображения с глубиной цвета.</span><span class="sxs-lookup"><span data-stu-id="a97a0-446">This method is used when dragging over a target window in a low color-depth video mode.</span></span> <span data-ttu-id="a97a0-447">Она позволяет целевому объекту скрывать изображение перетаскивания во время рисования окна.</span><span class="sxs-lookup"><span data-stu-id="a97a0-447">It allows the target to hide the drag image while it is painting the window.</span></span>

 

 
