---
description: Внутрипроцессный расширения загружаются в любые процессы, которые их инициируют.
title: Руководство по реализации расширений In-Process
ms.topic: article
ms.date: 05/31/2018
ms.assetid: FE830DBF-3F18-453c-9A51-91E10559D0E8
api_name: ''
api_type: ''
api_location: ''
topic_type:
- kbArticle
ms.openlocfilehash: e4dc9fd0573f3f98f0ec1110079f95f56a8c42e1
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "103999621"
---
# <a name="guidance-for-implementing-in-process-extensions"></a>Руководство по реализации расширений In-Process

Внутрипроцессный расширения загружаются в любые процессы, которые их инициируют. Например, расширение пространства имен оболочки может быть загружено в любой процесс, который обращается к пространству имен оболочки напрямую или косвенно. Пространство имен оболочки используется многими операциями оболочки, такими как отображение общего файла диалогового окна, запуск документа через связанное приложение или получение значка, используемого для представления файла. Так как добавочные расширения могут загружаться в произвольные процессы, следует соблюдать осторожность, чтобы они не влияли на ведущее приложение или другие внутрипроцессный расширения.

Одной из сред выполнения определенной заметки является *общеязыковая среда выполнения (CLR)*, также известная как *управляемый код* или *платформа .NET Framework*. **Корпорация Майкрософт рекомендует писать управляемые встроенные расширения в проводнике Windows или Windows Internet Explorer и не считать их поддерживаемым сценарием.**

В этом разделе обсуждаются факторы, которые следует учитывать при определении того, подходит ли любая среда выполнения, отличная от среды CLR, для использования в внутрипроцессного расширениях. Примерами других сред выполнения являются Java, Visual Basic, JavaScript, ECMAScript, Delphi и библиотека времени выполнения C/C++. В этом разделе также приведены некоторые причины, по которым управляемый код не поддерживается в внутрипроцессного расширениях.

## <a name="version-conflicts"></a>Конфликты версий

Конфликт версий может возникать в среде выполнения, которая не поддерживает загрузку нескольких версий среды выполнения в рамках одного процесса. Версии среды CLR до версии 4,0 попадают в эту категорию. Если загрузка одной версии среды выполнения препятствует загрузке других версий этой же среды выполнения, это может создать конфликт, если ведущее приложение или другое внутрипроцессный расширение использует конфликтующую версию. В случае конфликта версий с другим внутрипроцессный расширением конфликт может быть трудно воспроизвести, так как при сбое требуются правильные расширения, а режим сбоя зависит от порядка, в котором загружаются конфликтующие расширения.

Рассмотрим внутрипроцессный модуль, написанный с помощью версии CLR до версии 4,0. Каждое приложение на компьютере, использующем диалоговое окно **открытия** файла, потенциально может иметь управляемый код диалогового окна и зависимость CLR от его участника, загруженного в процесс приложения. Приложение или расширение, которое сначала загружает 4,0 предварительную версию среды CLR в процесс приложения, ограничены тем, какие версии среды CLR могут использоваться этим процессом в дальнейшем. Если управляемое приложение с **открытым** диалоговым окном построено на основе конфликтующей версии среды CLR, то расширение может завершиться неудачно и может привести к сбоям в работе приложения. И наоборот, если расширение является первым для загрузки в процессе, а конфликтующая версия управляемого кода пытается запуститься после этого (возможно, управляемое приложение или запущенное приложение загружает CLR по требованию), операция завершается ошибкой. Пользователю кажется, что некоторые функции приложения случайным образом перестают работать или приложение мистериаусли аварийно завершает работу.

Обратите внимание, что версии CLR, равные или более поздние, чем версия 4,0, обычно не подвержены проблеме с управлением версиями, так как они предназначены для совместного использования и с большинством предварительно 4,0 версий среды CLR (за исключением версии 1,0, которая не может сосуществовать с другими версиями). Однако в оставшейся части этого раздела могут возникнуть проблемы, отличные от конфликтов версий.

## <a name="performance-issues"></a>Проблемы с производительностью

Проблемы с производительностью могут возникать в средах выполнения, которые приводят к значительному снижению производительности при загрузке в процесс. Снижение производительности может быть в виде использования памяти, загрузки ЦП, затраченного времени или даже использования адресного пространства. CLR, JavaScript, ECMAScript и Java известны как среды выполнения с высокой степенью влияния. Так как добавочные расширения могут загружаться во многие процессы и часто выполняются с учетом времени, зависящего от производительности (например, при подготовке меню к отображению пользователя), среда выполнения с высокой степенью влияния может негативно повлиять на общую скорость реагирования.

Среда выполнения с высоким уровнем влияния, которая потребляет значительные ресурсы, может вызвать сбой в хост-процессе или другом внутрипроцессного расширении. Например, среда выполнения с высоким уровнем влияния, которая потребляет сотни мегабайт адресного пространства для кучи, может привести к тому, что ведущему приложению не удастся загрузить большой набор данных. Более того, так как добавочные расширения могут загружаться в несколько процессов, высокое потребление ресурсов в одном расширении может быстро преноситься к общему потреблению ресурсов во всей системе.

Если среда выполнения остается загруженной или продолжает потреблять ресурсы, даже если расширение, использующее эту среду выполнения, выгружено, то среда выполнения не подходит для использования в расширении.

## <a name="issues-specific-to-the-net-framework"></a>Проблемы, характерные для платформа .NET Framework

В следующих разделах рассматриваются примеры проблем, обнаруженных с помощью управляемого кода для расширений. Они не являются полным списком возможных проблем, которые могут возникнуть. Обсуждаемые здесь проблемы являются причиной того, что управляемый код не поддерживается в расширениях и моменты, которые следует учитывать при оценке использования других сред выполнения.

### <a name="re-entrancy"></a>Повторный вход

Если среда CLR блокирует поток однопотокового подразделения (STA), например из-за оператора Monitor. Enter, WaitHandle. WaitOne или инструкции [**Lock**](https://msdn.microsoft.com/library/c5kehkcz(v=VS.71).aspx) , среда CLR, в своей стандартной конфигурации, вводит вложенный цикл обработки сообщений в ожидании. Многие методы расширения запрещают обработку сообщений, и этот непредсказуемый и непредвиденный повторный вход может привести к аномальному поведению, что сложно воспроизвести и диагностировать.

### <a name="the-multithreaded-apartment"></a>Многопоточный апартамент

Среда CLR создает *вызываемые обертки среды выполнения* для COM-объектов. Эти же вызываемые оболочки времени выполнения уничтожаются позже методом завершения среды CLR, который является частью многопоточного подразделения (MTA). Для перемещения прокси-сервера из STA в MTA требуется маршалинг, но не все интерфейсы, используемые расширениями, могут быть упакованы.

### <a name="non-deterministic-object-lifetimes"></a>Недетерминированные времена жизни объектов

Среда CLR обеспечивает более слабое время существования объектов, чем машинный код. Многие расширения имеют требования к количеству ссылок на объекты и интерфейсы, а модель сбора мусора, используемая средой CLR, не может удовлетворить эти требования.

-   Если объект CLR получает ссылку на COM-объект, ссылка на COM-объект, удерживаемая вызываемой оболочкой времени выполнения, не освобождается до тех пор, пока вызываемая оболочка не будет собрана сборщиком мусора. Недетерминированное поведение выпуска может конфликтовать с некоторыми контрактами интерфейса. Например, метод [**IPersistPropertyBag:: Load**](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa768206(v=vs.85)) требует, чтобы ссылка на контейнер свойств не сохранялась объектом при возврате из метода **Load** .
-   Если ссылка на объект CLR возвращается в машинный код, вызываемая оболочка времени выполнения освобождает ссылку на объект CLR, [**когда выполняется окончательный**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) вызов вызываемой оболочки времени выполнения, но базовый объект CLR не завершается до тех пор, пока не будет собран сборщик мусора. Недетерминированная финализация может конфликтовать с некоторыми контрактами интерфейса. Например, обработчики эскизов должны освобождать все ресурсы немедленно, если их счетчик ссылок становится равным нулю.

## <a name="acceptable-uses-of-managed-code-and-other-runtimes"></a>Допустимые варианты использования управляемого кода и других сред выполнения

Для реализации необработанных расширений допустимо использовать управляемый код и другие среды выполнения. Ниже приведены примеры расширений вне процесса оболочки.

-   Обработчики просмотра
-   Действия на основе командной строки, такие как зарегистрированные в  \\  \\ подразделах **команд** оболочки.
-   COM-объекты, реализованные на локальном сервере, для точек расширения оболочки, допускающих незавершенную активацию.

Некоторые расширения могут быть реализованы либо как внутрипроцессный, либо вне процесса. Эти расширения можно реализовать как необработанные расширения, если они не соответствуют этим требованиям для внутрипроцессного расширения. В следующем списке приведены примеры расширений, которые могут быть реализованы как в внутрипроцессный, так и в необработанных расширениях.

-   [**Иексекутекомманд**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-iexecutecommand) , связанная с записью **делегатиксекуте** , зарегистрированной в  \\  \\ подразделе **Командная команда** оболочки.
-   [**Интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) , связанный с CLSID, зарегистрированным в \\  \\ подразделе оболочки **дроптаржет** .
-   [**Иексплореркоммандстате**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-iexplorercommandstate) , связанный с записью **коммандстатехандлер** , зарегистрированной в  \\ подразделе *команды* оболочки.

 

 
