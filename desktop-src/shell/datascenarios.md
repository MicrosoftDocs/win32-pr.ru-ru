---
description: В этом документе представлены распространенные сценарии обмена данными оболочки и обсуждается реализация каждого из них в приложении.
ms.assetid: 7fce555c-a93d-4414-9119-7ae9acdd4d89
title: Обработка сценариев передачи данных оболочки
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 35855b66e4108580d5bac305855837563ca59785
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104984317"
---
# <a name="handling-shell-data-transfer-scenarios"></a><span data-ttu-id="8008a-103">Обработка сценариев передачи данных оболочки</span><span class="sxs-lookup"><span data-stu-id="8008a-103">Handling Shell Data Transfer Scenarios</span></span>

<span data-ttu-id="8008a-104">Документ [объекта данных оболочки](dataobject.md) , который обсуждал общий подход, используемый для переноса данных оболочки с помощью перетаскивания или буфера обмена.</span><span class="sxs-lookup"><span data-stu-id="8008a-104">The [Shell Data Object](dataobject.md) document discussed the general approach that is used to transfer Shell data with drag-and-drop or the Clipboard.</span></span> <span data-ttu-id="8008a-105">Однако, чтобы реализовать передачу данных оболочки в приложение, необходимо также понять, как применять эти общие принципы и методики к различным способам передачи данных оболочки.</span><span class="sxs-lookup"><span data-stu-id="8008a-105">However, to implement Shell data transfer in your application, you must also understand how to apply these general principles and techniques to the variety of ways that Shell data can be transferred.</span></span> <span data-ttu-id="8008a-106">В этом документе представлены распространенные сценарии обмена данными оболочки и обсуждается реализация каждого из них в приложении.</span><span class="sxs-lookup"><span data-stu-id="8008a-106">This document presents common Shell data transfer scenarios and discusses how to implement each one in your application.</span></span>

-   [<span data-ttu-id="8008a-107">Общие рекомендации</span><span class="sxs-lookup"><span data-stu-id="8008a-107">General Guidelines</span></span>](#general-guidelines)
-   [<span data-ttu-id="8008a-108">Копирование имен файлов из буфера обмена в приложение</span><span class="sxs-lookup"><span data-stu-id="8008a-108">Copying File Names from the Clipboard to an Application</span></span>](#copying-file-names-from-the-clipboard-to-an-application)
    -   [<span data-ttu-id="8008a-109">Извлечение имен файлов из объекта данных</span><span class="sxs-lookup"><span data-stu-id="8008a-109">Extracting the File Names from the Data Object</span></span>](#extracting-the-file-names-from-the-data-object)
-   [<span data-ttu-id="8008a-110">Копирование содержимого удаленного файла в приложение</span><span class="sxs-lookup"><span data-stu-id="8008a-110">Copying the Contents of a Dropped File into an Application</span></span>](#copying-the-contents-of-a-dropped-file-into-an-application)
    -   [<span data-ttu-id="8008a-111">Использование формата КФСТР \_ филеконтентс для извлечения данных из файла</span><span class="sxs-lookup"><span data-stu-id="8008a-111">Using the CFSTR\_FILECONTENTS Format to Extract Data from a File</span></span>](/windows)
-   [<span data-ttu-id="8008a-112">Обработка оптимизированных операций перемещения</span><span class="sxs-lookup"><span data-stu-id="8008a-112">Handling Optimized Move Operations</span></span>](#handling-optimized-move-operations)
-   [<span data-ttu-id="8008a-113">Обработка операций удаления при вставке</span><span class="sxs-lookup"><span data-stu-id="8008a-113">Handling Delete-on-Paste Operations</span></span>](#handling-delete-on-paste-operations)
-   [<span data-ttu-id="8008a-114">Перенос данных в виртуальные папки и из них</span><span class="sxs-lookup"><span data-stu-id="8008a-114">Transfering Data to and from Virtual Folders</span></span>](#transfering-data-to-and-from-virtual-folders)
    -   [<span data-ttu-id="8008a-115">Прием данных из виртуальной папки</span><span class="sxs-lookup"><span data-stu-id="8008a-115">Accepting Data from a Virtual Folder</span></span>](#accepting-data-from-a-virtual-folder)
    -   [<span data-ttu-id="8008a-116">Передача данных в расширение пространства имен и обратно</span><span class="sxs-lookup"><span data-stu-id="8008a-116">Transferring Data to and from a NameSpace Extension</span></span>](#transferring-data-to-and-from-a-namespace-extension)
-   [<span data-ttu-id="8008a-117">Удаление файлов в корзине</span><span class="sxs-lookup"><span data-stu-id="8008a-117">Dropping Files on the Recycle Bin</span></span>](#dropping-files-on-the-recycle-bin)
-   [<span data-ttu-id="8008a-118">Создание и импорт файлов отходов</span><span class="sxs-lookup"><span data-stu-id="8008a-118">Creating and Importing Scrap Files</span></span>](#creating-and-importing-scrap-files)
    -   [<span data-ttu-id="8008a-119">Поддержка приема-передачи</span><span class="sxs-lookup"><span data-stu-id="8008a-119">Round-trip Support</span></span>](#round-trip-support)
    -   [<span data-ttu-id="8008a-120">Форматы кэшированных данных</span><span class="sxs-lookup"><span data-stu-id="8008a-120">Cached Data Formats</span></span>](#cached-data-formats)
    -   [<span data-ttu-id="8008a-121">Отложенная визуализация</span><span class="sxs-lookup"><span data-stu-id="8008a-121">Delayed Rendering</span></span>](#delayed-rendering)
-   [<span data-ttu-id="8008a-122">Асинхронное перетаскивание объектов оболочки</span><span class="sxs-lookup"><span data-stu-id="8008a-122">Dragging and Dropping Shell Objects Asynchronously</span></span>](#dragging-and-dropping-shell-objects-asynchronously)
    -   [<span data-ttu-id="8008a-123">Использование IASyncOperation и Идатаобжектасинккапабилити</span><span class="sxs-lookup"><span data-stu-id="8008a-123">Using IASyncOperation/IDataObjectAsyncCapability</span></span>](#using-iasyncoperationidataobjectasynccapability)

> [!Note]  
> <span data-ttu-id="8008a-124">Несмотря на то, что каждый из этих сценариев обсуждает конкретную операцию по переносу данных, многие из них применяются к различным связанным сценариям.</span><span class="sxs-lookup"><span data-stu-id="8008a-124">Although each of these scenarios discusses a specific data transfer operation, many of them apply to a variety of related scenarios.</span></span> <span data-ttu-id="8008a-125">Например, основное различие между большинством буферов обмена и перемещением по операциям перетаскивания заключается в том, как объект данных прибывает в целевом объекте.</span><span class="sxs-lookup"><span data-stu-id="8008a-125">For instance, the primary difference between most Clipboard and drag-and-drop transfers is in how the data object arrives at the target.</span></span> <span data-ttu-id="8008a-126">После того как целевой объект имеет указатель на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных, процедуры извлечения данных в основном одинаковы для обоих типов переноса данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-126">Once the target has a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface, the procedures for extracting information are largely the same for both types of data transfer.</span></span> <span data-ttu-id="8008a-127">Однако некоторые сценарии ограничены определенным типом операции.</span><span class="sxs-lookup"><span data-stu-id="8008a-127">However, some of the scenarios are limited to a specific type of operation.</span></span> <span data-ttu-id="8008a-128">Дополнительные сведения см. в отдельном сценарии.</span><span class="sxs-lookup"><span data-stu-id="8008a-128">Refer to the individual scenario for details.</span></span>

 

## <a name="general-guidelines"></a><span data-ttu-id="8008a-129">Общие рекомендации</span><span class="sxs-lookup"><span data-stu-id="8008a-129">General Guidelines</span></span>

<span data-ttu-id="8008a-130">В каждом из следующих разделов обсуждается один, довольно конкретный сценарий для обмена данными.</span><span class="sxs-lookup"><span data-stu-id="8008a-130">Each of the following sections discusses a single, fairly specific data transfer scenario.</span></span> <span data-ttu-id="8008a-131">Однако передача данных часто более сложна и может затрагивать различные сценарии.</span><span class="sxs-lookup"><span data-stu-id="8008a-131">However, data transfers are often more complex and might involve aspects of several scenarios.</span></span> <span data-ttu-id="8008a-132">Как правило, вы не умеете знать, какой сценарий вам действительно нужно обменять.</span><span class="sxs-lookup"><span data-stu-id="8008a-132">You typically do not know, in advance, which scenario you will actually need to handle.</span></span> <span data-ttu-id="8008a-133">Ниже приведены некоторые общие рекомендации, которые следует учитывать.</span><span class="sxs-lookup"><span data-stu-id="8008a-133">Here are a few general guidelines to keep in mind.</span></span>

<span data-ttu-id="8008a-134">Для источников данных:</span><span class="sxs-lookup"><span data-stu-id="8008a-134">For data sources:</span></span>

-   <span data-ttu-id="8008a-135">Форматы буфера обмена оболочки, за исключением [CF \_ HDROP](clipboard.md), не являются стандартными.</span><span class="sxs-lookup"><span data-stu-id="8008a-135">The Shell Clipboard formats, with the exception of [CF\_HDROP](clipboard.md), are not predefined.</span></span> <span data-ttu-id="8008a-136">Каждый формат, который вы хотите использовать, должен быть зарегистрирован путем вызова [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span><span class="sxs-lookup"><span data-stu-id="8008a-136">Each format you want to use must be registered by calling [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span></span>
-   <span data-ttu-id="8008a-137">Форматы объектов данных предоставляются в порядке предпочтения источника.</span><span class="sxs-lookup"><span data-stu-id="8008a-137">The formats in the data objects are provided in the order of preference from the source.</span></span> <span data-ttu-id="8008a-138">Перечислите объект данных и выберите первый из них, который вы можете использовать.</span><span class="sxs-lookup"><span data-stu-id="8008a-138">Enumerate the data object and pick the first one you can consume.</span></span>
-   <span data-ttu-id="8008a-139">Включите столько форматов, сколько вы можете поддерживать.</span><span class="sxs-lookup"><span data-stu-id="8008a-139">Include as many formats as you can support.</span></span> <span data-ttu-id="8008a-140">Обычно неизвестно, куда будет удален объект данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-140">You generally do not know where the data object will be dropped.</span></span> <span data-ttu-id="8008a-141">Такой подход повышает вероятность того, что объект данных будет содержать формат, который может быть принят целью перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="8008a-141">This practice improves the odds that the data object will contain a format that the drop target can accept.</span></span>
-   <span data-ttu-id="8008a-142">Существующие файлы должны быть предложены в формате [CF \_ HDROP](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-142">Existing files should be offered with the [CF\_HDROP](clipboard.md) format.</span></span>
-   <span data-ttu-id="8008a-143">Предлагают данные, схожие с файлами, с форматами [кфстр \_ филеконтентс](clipboard.md) / [кфстр \_ филедескриптор](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-143">Offer file-like data with [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md) formats.</span></span> <span data-ttu-id="8008a-144">Такой подход позволяет целевому объекту создать файл из объекта данных, не зная ничего о базовом хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-144">This approach allows the target to create a file from a data object without needing to know anything about the underlying data storage.</span></span> <span data-ttu-id="8008a-145">Обычно данные следует представлять как интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) .</span><span class="sxs-lookup"><span data-stu-id="8008a-145">You should normally present the data as an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface.</span></span> <span data-ttu-id="8008a-146">Этот механизм обмена данными более гибок, чем глобальный объект памяти, и использует гораздо меньше памяти.</span><span class="sxs-lookup"><span data-stu-id="8008a-146">This data transfer mechanism is more flexible than a global memory object and uses much less memory.</span></span>
-   <span data-ttu-id="8008a-147">При перетаскивании элементов оболочки источники перетаскивания должны предлагать формат [кфстр \_ шеллидлист](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-147">Drag sources should offer the [CFSTR\_SHELLIDLIST](clipboard.md) format when dragging Shell items.</span></span> <span data-ttu-id="8008a-148">Объекты данных для элементов можно получить с помощью методов [**ишеллфолдер:: жетуиобжектоф**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) или [**интерфейса IShellItem:: биндтохандлер**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem-bindtohandler) .</span><span class="sxs-lookup"><span data-stu-id="8008a-148">Data objects for items can be acquired through either the [**IShellFolder::GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) or [**IShellItem::BindToHandler**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem-bindtohandler) methods.</span></span> <span data-ttu-id="8008a-149">Источники данных могут создать стандартную реализацию объекта данных, которая поддерживает [Формат \_ шеллидлист кфстр](clipboard.md) с помощью [**шкреатедатаобжект**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedataobject).</span><span class="sxs-lookup"><span data-stu-id="8008a-149">Data sources can create a standard data object implementation that supports the [CFSTR\_SHELLIDLIST](clipboard.md) format by using [**SHCreateDataObject**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedataobject).</span></span>
-   <span data-ttu-id="8008a-150">Целевые объекты перетаскивания, которые хотят попытаться перетаскивать элементы с помощью модели программирования элемента оболочки, могут преобразовать IDataObject в [**ишеллитемаррай**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray) с помощью [**шкреатешеллитемаррайфромдатаобжект**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject).</span><span class="sxs-lookup"><span data-stu-id="8008a-150">Drop targets that want to reason about the items being dragged using the shell item programming model can convert an IDataObject into an [**IShellItemArray**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray) using [**SHCreateShellItemArrayFromDataObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject).</span></span>
-   <span data-ttu-id="8008a-151">Используйте стандартные курсоры обратной связи.</span><span class="sxs-lookup"><span data-stu-id="8008a-151">Use standard feedback cursors.</span></span>
-   <span data-ttu-id="8008a-152">Поддержка перетаскивания слева и справа.</span><span class="sxs-lookup"><span data-stu-id="8008a-152">Support left and right drag.</span></span>
-   <span data-ttu-id="8008a-153">Используйте сам объект данных из внедренного объекта.</span><span class="sxs-lookup"><span data-stu-id="8008a-153">Use the data object itself from an embedded object.</span></span> <span data-ttu-id="8008a-154">Такой подход позволяет приложению извлекать любые дополнительные форматы, которые должен предоставить объект данных, и избегать создания дополнительного уровня вложения.</span><span class="sxs-lookup"><span data-stu-id="8008a-154">This approach allows your application to retrieve any extra formats the data object has to offer and avoids creating an extra layer of containment.</span></span> <span data-ttu-id="8008a-155">Например, внедренный объект с сервера A перетаскивается с сервера или контейнера B и удаляется в контейнере C. C следует создать внедренный объект сервера A, а не внедренный объект сервера B, содержащий внедренный объект сервера A.</span><span class="sxs-lookup"><span data-stu-id="8008a-155">For instance, an embedded object from server A is dragged from server/container B and dropped on container C. C should create an embedded object of server A, not an embedded object of server B containing an embedded object of server A.</span></span>
-   <span data-ttu-id="8008a-156">Помните, что оболочка может использовать [оптимизированные операции перемещения](#handling-optimized-move-operations) или [удаления](#handling-delete-on-paste-operations) при перемещении файлов.</span><span class="sxs-lookup"><span data-stu-id="8008a-156">Remember that the Shell might use [optimized moves](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operations when moving files.</span></span> <span data-ttu-id="8008a-157">Приложение должно уметь распознавать эти операции и реагировать соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="8008a-157">Your application should be able to recognize these operations and respond appropriately.</span></span>

<span data-ttu-id="8008a-158">Для целевых объектов данных:</span><span class="sxs-lookup"><span data-stu-id="8008a-158">For data targets:</span></span>

-   <span data-ttu-id="8008a-159">Форматы буфера обмена оболочки, за исключением [CF \_ HDROP](clipboard.md), не являются стандартными.</span><span class="sxs-lookup"><span data-stu-id="8008a-159">The Shell Clipboard formats, with the exception of [CF\_HDROP](clipboard.md), are not predefined.</span></span> <span data-ttu-id="8008a-160">Каждый формат, который вы хотите использовать, должен быть зарегистрирован путем вызова [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span><span class="sxs-lookup"><span data-stu-id="8008a-160">Each format you want to use must be registered by calling [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span></span>
-   <span data-ttu-id="8008a-161">Реализация и регистрация целевого объекта OLE Drop.</span><span class="sxs-lookup"><span data-stu-id="8008a-161">Implement and register an OLE drop target.</span></span> <span data-ttu-id="8008a-162">Старайтесь не использовать целевые объекты Windows 3,1 или сообщение [**WM \_ дропфилес**](wm-dropfiles.md) , если это возможно.</span><span class="sxs-lookup"><span data-stu-id="8008a-162">Avoid using Windows 3.1 targets or the [**WM\_DROPFILES**](wm-dropfiles.md) message, if possible.</span></span>
-   <span data-ttu-id="8008a-163">Форматы, содержащиеся в объекте данных, зависят от того, откуда берется объект.</span><span class="sxs-lookup"><span data-stu-id="8008a-163">The formats contained by a data object vary, depending on where the object comes from.</span></span> <span data-ttu-id="8008a-164">Так как вы, как правило, не умеете заранее известно, откуда берется объект данных, не следует думать, какой формат будет представлен.</span><span class="sxs-lookup"><span data-stu-id="8008a-164">Since you generally do not know in advance where a data object comes from, do not assume that a particular format will be present.</span></span> <span data-ttu-id="8008a-165">Объект данных должен перечислять форматы в порядке их качества, начиная с лучшего.</span><span class="sxs-lookup"><span data-stu-id="8008a-165">The data object should enumerate the formats in order of quality, starting with the best.</span></span> <span data-ttu-id="8008a-166">Таким образом, чтобы получить наилучший доступный формат, приложения обычно перечисляют доступные форматы и используют первый формат в перечислении, которое они могут поддерживать.</span><span class="sxs-lookup"><span data-stu-id="8008a-166">Thus, to get the best available format, applications normally enumerate the available formats and use the first format in the enumeration that they can support.</span></span>
-   <span data-ttu-id="8008a-167">Поддерживает перетаскивание правой кнопкой мыши.</span><span class="sxs-lookup"><span data-stu-id="8008a-167">Support right-drag.</span></span> <span data-ttu-id="8008a-168">Контекстное меню перетаскивания можно настроить, создав [обработчик перетаскивания](context-menu-handlers.md).</span><span class="sxs-lookup"><span data-stu-id="8008a-168">You can customize the drag shortcut menu by creating a [drag-and-drop handler](context-menu-handlers.md).</span></span>
-   <span data-ttu-id="8008a-169">Если приложение будет принимать существующие файлы, оно должно иметь возможность обрабатывать формат [ \_ HDROP CF](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-169">If your application will accept existing files, it must be able to handle the [CF\_HDROP](clipboard.md) format.</span></span>
-   <span data-ttu-id="8008a-170">Как правило, приложения, принимающие файлы, должны также обрабатывать форматы [кфстр \_ филеконтентс](clipboard.md) / [кфстр \_ филедескриптор](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-170">In general, applications that accept files should also handle the [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md) formats.</span></span> <span data-ttu-id="8008a-171">Хотя файлы из файловой системы имеют формат [CF \_ HDROP](clipboard.md) , файлы из поставщиков, например расширения пространства имен, обычно используют [кфстр \_ филеконтентс](clipboard.md) / [кфстр \_ филедескриптор](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="8008a-171">While files from the file system have the [CF\_HDROP](clipboard.md) format, files from providers such as namespace extensions generally use [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md).</span></span> <span data-ttu-id="8008a-172">К примерам относятся Windows CE папки, папки протокол FTP (FTP), веб-папки и папки CAB.</span><span class="sxs-lookup"><span data-stu-id="8008a-172">Examples include Windows CE folders, File Transfer Protocol (FTP) folders, web folders, and CAB folders.</span></span> <span data-ttu-id="8008a-173">Источник обычно реализует интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) для представления данных из своего хранилища в виде файла.</span><span class="sxs-lookup"><span data-stu-id="8008a-173">The source normally implements an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface to present data from its storage as a file.</span></span>
-   <span data-ttu-id="8008a-174">Помните, что оболочка может использовать [оптимизированные операции перемещения](#handling-optimized-move-operations) или [удаления](#handling-delete-on-paste-operations) при перемещении файлов.</span><span class="sxs-lookup"><span data-stu-id="8008a-174">Remember that the Shell might use [optimized moves](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operations when moving files.</span></span> <span data-ttu-id="8008a-175">Приложение должно уметь распознавать эти операции и реагировать соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="8008a-175">Your application should be able to recognize these operations and respond appropriately.</span></span>

## <a name="copying-file-names-from-the-clipboard-to-an-application"></a><span data-ttu-id="8008a-176">Копирование имен файлов из буфера обмена в приложение</span><span class="sxs-lookup"><span data-stu-id="8008a-176">Copying File Names from the Clipboard to an Application</span></span>

<span data-ttu-id="8008a-177">**Сценарий:** Пользователь выбирает один или несколько файлов в проводнике Windows и копирует их в буфер обмена.</span><span class="sxs-lookup"><span data-stu-id="8008a-177">**Scenario:** A user selects one or more files in Windows Explorer and copies them to the Clipboard.</span></span> <span data-ttu-id="8008a-178">Приложение извлекает имена файлов и вставляет их в документ.</span><span class="sxs-lookup"><span data-stu-id="8008a-178">Your application extracts the file names and pastes them into the document.</span></span>

<span data-ttu-id="8008a-179">Этот сценарий можно использовать, например, чтобы разрешить пользователю создавать HTML-ссылки, выполнив копирование файла в приложение.</span><span class="sxs-lookup"><span data-stu-id="8008a-179">This scenario could be used, for instance, to allow a user to create an HTML link by cutting and pasting the file to your application.</span></span> <span data-ttu-id="8008a-180">Приложение может извлечь имя файла из объекта данных и обработать его для создания тега привязки.</span><span class="sxs-lookup"><span data-stu-id="8008a-180">Your application can then extract the file name from the data object and process it to create an anchor tag.</span></span>

<span data-ttu-id="8008a-181">Когда пользователь выбирает файл в проводнике Windows и копирует его в буфер обмена, оболочка создает объект данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-181">When a user selects a file in Windows Explorer and copies it to the Clipboard, the Shell creates a data object.</span></span> <span data-ttu-id="8008a-182">Затем он вызывает [**олесетклипбоард**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) , чтобы поместить указатель на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных в буфер обмена.</span><span class="sxs-lookup"><span data-stu-id="8008a-182">It then calls [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) to place a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface on the Clipboard.</span></span>

<span data-ttu-id="8008a-183">Когда пользователь выбирает команду **Вставить** в меню или на панели инструментов приложения:</span><span class="sxs-lookup"><span data-stu-id="8008a-183">When the user selects the **Paste** command from your application's menu or toolbar:</span></span>

1.  <span data-ttu-id="8008a-184">Вызовите [**олежетклипбоард**](/windows/win32/api/ole2/nf-ole2-olegetclipboard) , чтобы получить интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-184">Call [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard) to retrieve the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span>
2.  <span data-ttu-id="8008a-185">Вызовите [**IDataObject:: енумформатетк**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) , чтобы запросить объект перечислителя.</span><span class="sxs-lookup"><span data-stu-id="8008a-185">Call [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) to request an enumerator object.</span></span>
3.  <span data-ttu-id="8008a-186">Используйте интерфейс [**иенумформатетк**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) объекта Enumerator для перечисления форматов, содержащихся в объекте данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-186">Use the enumerator object's [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) interface to enumerate the formats contained by the data object.</span></span>

> [!Note]  
> <span data-ttu-id="8008a-187">Последние два шага в этой процедуре включены для полноты.</span><span class="sxs-lookup"><span data-stu-id="8008a-187">The final two steps in this procedure are included for completeness.</span></span> <span data-ttu-id="8008a-188">Обычно они не требуются для простой передачи файлов.</span><span class="sxs-lookup"><span data-stu-id="8008a-188">They are typically not necessary for simple file transfers.</span></span> <span data-ttu-id="8008a-189">Все объекты данных, используемые для этого типа, должны содержать формат [CF \_ HDROP](clipboard.md) , который можно использовать для определения имен файлов, содержащихся в объекте.</span><span class="sxs-lookup"><span data-stu-id="8008a-189">All data objects used for this type of data transfer should contain the [CF\_HDROP](clipboard.md) format, which can be used to determine the names of the files contained by the object.</span></span> <span data-ttu-id="8008a-190">Однако для более общих операций передачи данных следует перечислить форматы и выбрать наилучший из них, который может быть обработано приложением.</span><span class="sxs-lookup"><span data-stu-id="8008a-190">However, for more general data transfers, you should enumerate the formats and select the best one that your application can handle.</span></span>

 

### <a name="extracting-the-file-names-from-the-data-object"></a><span data-ttu-id="8008a-191">Извлечение имен файлов из объекта данных</span><span class="sxs-lookup"><span data-stu-id="8008a-191">Extracting the File Names from the Data Object</span></span>

<span data-ttu-id="8008a-192">Следующим шагом является извлечение из объекта данных одного или нескольких имен файлов и их вставка в приложение.</span><span class="sxs-lookup"><span data-stu-id="8008a-192">The next step is to extract one or more file names from the data object and paste them into your application.</span></span> <span data-ttu-id="8008a-193">Обратите внимание, что процедура, описанная в этом разделе, для извлечения имени файла из объекта данных также применяется к передаче операций перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="8008a-193">Note that the procedure discussed in this section for extracting a file name from a data object applies equally well to drag-and-drop transfers.</span></span>

<span data-ttu-id="8008a-194">Самым простым способом получения имен файлов из объекта данных является формат [CF \_ HDROP](clipboard.md) :</span><span class="sxs-lookup"><span data-stu-id="8008a-194">The simplest way to retrieve file names from a data object is the [CF\_HDROP](clipboard.md) format:</span></span>

1.  <span data-ttu-id="8008a-195">Вызовите [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span><span class="sxs-lookup"><span data-stu-id="8008a-195">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span></span> <span data-ttu-id="8008a-196">Задайте для элемента **кфформат** структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) значение [CF \_ HDROP](clipboard.md) , а для элемента **тимед** — [тимед \_ хглобал](dataobject.md).</span><span class="sxs-lookup"><span data-stu-id="8008a-196">Set the **cfFormat** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to [CF\_HDROP](clipboard.md) and the **tymed** member to [TYMED\_HGLOBAL](dataobject.md).</span></span> <span data-ttu-id="8008a-197">Обычно для элемента **дваспект** задано содержимое дваспект \_ .</span><span class="sxs-lookup"><span data-stu-id="8008a-197">The **dwAspect** member is normally set to DVASPECT\_CONTENT.</span></span> <span data-ttu-id="8008a-198">Однако если необходимо, чтобы путь к файлу был в кратком формате (8,3), задайте для параметра **дваспект** значение дваспект \_ Short.</span><span class="sxs-lookup"><span data-stu-id="8008a-198">However, if you need to have the file's path in short (8.3) format, set **dwAspect** to DVASPECT\_SHORT.</span></span>

    <span data-ttu-id="8008a-199">Когда функция [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) возвращает значение, элемент **хглобал** структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) указывает на глобальный объект памяти, содержащий данные.</span><span class="sxs-lookup"><span data-stu-id="8008a-199">When [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns, the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure points to a global memory object that contains the data.</span></span>

2.  <span data-ttu-id="8008a-200">Создайте переменную HDROP и задайте ее элементу **хглобал** структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="8008a-200">Create an HDROP variable and set it to the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="8008a-201">Переменная HDROP теперь является обработчиком структуры [**дропфилес**](/windows/desktop/api/shlobj_core/ns-shlobj_core-dropfiles) , за которой следует строка с абсолютным нулем, которая содержит полные пути к файлам копируемых файлов.</span><span class="sxs-lookup"><span data-stu-id="8008a-201">The HDROP variable is now a handle to a [**DROPFILES**](/windows/desktop/api/shlobj_core/ns-shlobj_core-dropfiles) structure followed by a double null-terminated string containing the fully qualified file paths of the copied files.</span></span>
3.  <span data-ttu-id="8008a-202">Определите, сколько путей к файлам находится в списке, вызвав [**драгкуерифиле**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) с параметром *ифиле* , имеющим значение 0xFFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="8008a-202">Determine how many file paths are in the list by calling [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) with the *iFile* parameter set to 0xFFFFFFFF.</span></span> <span data-ttu-id="8008a-203">Функция возвращает число путей к файлам в списке.</span><span class="sxs-lookup"><span data-stu-id="8008a-203">The function returns the number of file paths in the list.</span></span> <span data-ttu-id="8008a-204">Отсчитываемый от нуля индекс пути к файлу в этом списке используется на следующем шаге для задания определенного пути.</span><span class="sxs-lookup"><span data-stu-id="8008a-204">The file path's zero-based index in this list is used in the next step to identify a particular path.</span></span>
4.  <span data-ttu-id="8008a-205">Извлеките пути к файлам из объекта глобальной памяти, вызвав [**драгкуерифиле**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) один раз для каждого файла, где *ифиле* задается в индексе файла.</span><span class="sxs-lookup"><span data-stu-id="8008a-205">Extract the file paths from the global memory object by calling [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) once for each file, with *iFile* set to the file's index.</span></span>
5.  <span data-ttu-id="8008a-206">Обработайте пути к файлам по мере необходимости и вставьте их в приложение.</span><span class="sxs-lookup"><span data-stu-id="8008a-206">Process the file paths as needed and paste them into your application.</span></span>
6.  <span data-ttu-id="8008a-207">Вызовите [**релеасестгмедиум**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) и передайте указатель на структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) , которую вы передали в [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) на шаге 1.</span><span class="sxs-lookup"><span data-stu-id="8008a-207">Call [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) and pass in the pointer to the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that you passed to [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) in step 1.</span></span> <span data-ttu-id="8008a-208">После выпуска структуры значение HDROP, созданное на шаге 2, больше не является допустимым и не должно использоваться.</span><span class="sxs-lookup"><span data-stu-id="8008a-208">Once you have released the structure, the HDROP value that you created in step 2 is no longer valid and should not be used.</span></span>

## <a name="copying-the-contents-of-a-dropped-file-into-an-application"></a><span data-ttu-id="8008a-209">Копирование содержимого удаленного файла в приложение</span><span class="sxs-lookup"><span data-stu-id="8008a-209">Copying the Contents of a Dropped File into an Application</span></span>

<span data-ttu-id="8008a-210">**Сценарий:** Пользователь перетаскивает один или несколько файлов из проводника Windows и удаляет их в окне приложения.</span><span class="sxs-lookup"><span data-stu-id="8008a-210">**Scenario:** A user drags one or more files from Windows Explorer and drops them on your application's window.</span></span> <span data-ttu-id="8008a-211">Ваше приложение извлекает содержимое файлов и вставляет его в приложение.</span><span class="sxs-lookup"><span data-stu-id="8008a-211">Your application extracts the content of the file (s) and pastes it into the application.</span></span>

<span data-ttu-id="8008a-212">В этом сценарии для переноса файлов из проводника Windows в приложение используется перетаскивание.</span><span class="sxs-lookup"><span data-stu-id="8008a-212">This scenario uses drag-and-drop to transfer the files from Windows Explorer to the application.</span></span> <span data-ttu-id="8008a-213">Перед выполнением операции приложение должно:</span><span class="sxs-lookup"><span data-stu-id="8008a-213">Prior to the operation, your application must:</span></span>

1.  <span data-ttu-id="8008a-214">Вызовите [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) , чтобы зарегистрировать необходимые форматы буфера обмена оболочки.</span><span class="sxs-lookup"><span data-stu-id="8008a-214">Call [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) to register any needed Shell Clipboard formats.</span></span>
2.  <span data-ttu-id="8008a-215">Вызовите [**регистердрагдроп**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) , чтобы зарегистрировать целевое окно и интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="8008a-215">Call [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) to register a target window and your application's [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span>

<span data-ttu-id="8008a-216">После того, как пользователь инициирует операцию, выбрав один или несколько файлов и начав их перетаскивание:</span><span class="sxs-lookup"><span data-stu-id="8008a-216">After the user initiates the operation by selecting one or more files and starting to drag them:</span></span>

1.  <span data-ttu-id="8008a-217">Проводник Windows создает объект данных и загружает в него Поддерживаемые форматы.</span><span class="sxs-lookup"><span data-stu-id="8008a-217">Windows Explorer creates a data object and loads the supported formats into it.</span></span>
2.  <span data-ttu-id="8008a-218">Проводник Windows вызывает [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) для инициации цикла перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="8008a-218">Windows Explorer calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) to initiate the drag loop.</span></span>
3.  <span data-ttu-id="8008a-219">Когда изображение перетаскивания достигает целевого окна, система уведомляет вас, вызывая [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span><span class="sxs-lookup"><span data-stu-id="8008a-219">When the drag image reaches your target window, the system notifies you by calling [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span></span>
4.  <span data-ttu-id="8008a-220">Чтобы определить, что содержит объект данных, вызовите метод [**IDataObject:: енумформатетк**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) объекта данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-220">To determine what the data object contains, call the data object's [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) method.</span></span> <span data-ttu-id="8008a-221">Используйте объект перечислителя, возвращенный методом, для перечисления форматов, содержащихся в объекте данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-221">Use the enumerator object returned by the method to enumerate the formats contained by the data object.</span></span> <span data-ttu-id="8008a-222">Если приложению не требуется принимать какие либо из этих форматов, возвратите ДРОПЕФФЕКТ \_ None.</span><span class="sxs-lookup"><span data-stu-id="8008a-222">If your application does not want to accept any of these formats, return DROPEFFECT\_NONE.</span></span> <span data-ttu-id="8008a-223">В этом сценарии приложение должно игнорировать любые объекты данных, которые не содержат форматы, используемые для перемещения файлов, например [CF \_ HDROP](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="8008a-223">For the purposes of this scenario, your application should ignore any data objects that do not contain formats used to transfer files, such as [CF\_HDROP](clipboard.md).</span></span>
5.  <span data-ttu-id="8008a-224">Когда пользователь удаляет данные, система вызывает [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop).</span><span class="sxs-lookup"><span data-stu-id="8008a-224">When the user drops the data, the system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop).</span></span>
6.  <span data-ttu-id="8008a-225">Используйте интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) для извлечения содержимого файлов.</span><span class="sxs-lookup"><span data-stu-id="8008a-225">Use the [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface to extract the contents of the files.</span></span>

<span data-ttu-id="8008a-226">Существует несколько различных способов извлечения содержимого объекта оболочки из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-226">There are several different ways to extract the contents of a Shell object from a data object.</span></span> <span data-ttu-id="8008a-227">В общем случае используйте следующий порядок:</span><span class="sxs-lookup"><span data-stu-id="8008a-227">In general, use the following order:</span></span>

-   <span data-ttu-id="8008a-228">Если файл содержит текстовый формат [CF \_ ](clipboard.md) , то данные содержат текст ANSI.</span><span class="sxs-lookup"><span data-stu-id="8008a-228">If the file contains a [CF\_TEXT](clipboard.md) format, the data is ANSI text.</span></span> <span data-ttu-id="8008a-229">Можно использовать \_ текстовый формат CF для извлечения данных, вместо того чтобы открывать сам файл.</span><span class="sxs-lookup"><span data-stu-id="8008a-229">You can use the CF\_TEXT format to extract the data, rather than opening the file itself.</span></span>
-   <span data-ttu-id="8008a-230">Если файл содержит связанный или внедренный OLE-объект, объект данных содержит \_ Формат CF ембеддедобжект.</span><span class="sxs-lookup"><span data-stu-id="8008a-230">If the file contains a linked or embedded OLE object, the data object contains a CF\_EMBEDDEDOBJECT format.</span></span> <span data-ttu-id="8008a-231">Для извлечения данных используйте стандартные приемы OLE.</span><span class="sxs-lookup"><span data-stu-id="8008a-231">Use standard OLE techniques to extract the data.</span></span> <span data-ttu-id="8008a-232">[Файлы брака/отхода](#creating-and-importing-scrap-files) всегда содержат \_ Формат CF ембеддедобжект.</span><span class="sxs-lookup"><span data-stu-id="8008a-232">[Scrap files](#creating-and-importing-scrap-files) always contain a CF\_EMBEDDEDOBJECT format.</span></span>
-   <span data-ttu-id="8008a-233">Если объект оболочки находится в файловой системе, объект данных содержит формат [CF \_ HDROP](clipboard.md) с именами файлов.</span><span class="sxs-lookup"><span data-stu-id="8008a-233">If the Shell object is from the file system, the data object contains a [CF\_HDROP](clipboard.md) format with the names of the files.</span></span> <span data-ttu-id="8008a-234">Извлеките имя файла из [CF \_ HDROP](clipboard.md) и вызовите [**олекреатефромфиле**](/windows/win32/api/ole2/nf-ole2-olecreatefromfile) , чтобы создать новый связанный или внедренный объект.</span><span class="sxs-lookup"><span data-stu-id="8008a-234">Extract the file name from [CF\_HDROP](clipboard.md) and call [**OleCreateFromFile**](/windows/win32/api/ole2/nf-ole2-olecreatefromfile) to create a new linked or embedded object.</span></span> <span data-ttu-id="8008a-235">Обсуждение того, как получить имя файла из формата [ \_ HDROP CF](clipboard.md) , см. в разделе [Копирование имен файлов из буфера обмена в приложение](#copying-file-names-from-the-clipboard-to-an-application).</span><span class="sxs-lookup"><span data-stu-id="8008a-235">For a discussion of how to retrieve a file name from a [CF\_HDROP](clipboard.md) format, see [Copying File Names from the Clipboard to an Application](#copying-file-names-from-the-clipboard-to-an-application).</span></span>
-   <span data-ttu-id="8008a-236">Если объект данных содержит формат [ \_ филедескриптор кфстр](clipboard.md) , содержимое файла можно извлечь из формата файла [кфстр \_ филеконтентс](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-236">If the data object contains a [CFSTR\_FILEDESCRIPTOR](clipboard.md) format, you can extract a file's contents from the file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="8008a-237">Описание этой процедуры см. в разделе [использование \_ формата кфстр Филеконтентс для извлечения данных из файла](/windows).</span><span class="sxs-lookup"><span data-stu-id="8008a-237">For a discussion of this procedure, see [Using the CFSTR\_FILECONTENTS Format to Extract Data from a File](/windows).</span></span>
-   <span data-ttu-id="8008a-238">До версии оболочки [4,71](versions.md)приложение указывало на то, что оно передавало тип файлов ярлыков, установив параметр филедескриптор **\_ линкуи** в элементе **dwFlags** структуры [](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) .</span><span class="sxs-lookup"><span data-stu-id="8008a-238">Prior to Shell [version 4.71](versions.md), an application indicated that it was transferring a shortcut file type by setting **FD\_LINKUI** in the **dwFlags** member of the [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structure.</span></span> <span data-ttu-id="8008a-239">Для более поздних версий оболочки предпочтительным способом указания того, что передаются ярлыки, является использование [кфстр \_ преферреддропеффект](clipboard.md) Format Set to дропеффект \_ Link.</span><span class="sxs-lookup"><span data-stu-id="8008a-239">For later versions of the Shell, the preferred way to indicate that shortcuts are being transferred is to use the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_LINK.</span></span> <span data-ttu-id="8008a-240">Этот подход гораздо эффективнее, чем извлечение структуры **филедескриптор** только для проверки флага.</span><span class="sxs-lookup"><span data-stu-id="8008a-240">This approach is much more efficient than extracting the **FILEDESCRIPTOR** structure just to check a flag.</span></span>

<span data-ttu-id="8008a-241">Если процесс извлечения данных будет длительным, может потребоваться асинхронная операция в фоновом потоке.</span><span class="sxs-lookup"><span data-stu-id="8008a-241">If the data extraction process will be lengthy, you might want to do the operation asynchronously on a background thread.</span></span> <span data-ttu-id="8008a-242">Основной поток может продолжать работу без задержек.</span><span class="sxs-lookup"><span data-stu-id="8008a-242">Your primary thread can then proceed without unnecessary delays.</span></span> <span data-ttu-id="8008a-243">Сведения об обработке асинхронного извлечения данных см. в статье [асинхронное перетаскивание объектов оболочки](#dragging-and-dropping-shell-objects-asynchronously).</span><span class="sxs-lookup"><span data-stu-id="8008a-243">For a discussion of how to handle asynchronous data extraction, see [Dragging and Dropping Shell Objects Asynchronously](#dragging-and-dropping-shell-objects-asynchronously).</span></span>

### <a name="using-the-cfstr_filecontents-format-to-extract-data-from-a-file"></a><span data-ttu-id="8008a-244">Использование формата КФСТР \_ филеконтентс для извлечения данных из файла</span><span class="sxs-lookup"><span data-stu-id="8008a-244">Using the CFSTR\_FILECONTENTS Format to Extract Data from a File</span></span>

<span data-ttu-id="8008a-245">Формат [кфстр \_ филеконтентс](clipboard.md) предоставляет очень гибкий и эффективный способ перемещения содержимого файла.</span><span class="sxs-lookup"><span data-stu-id="8008a-245">The [CFSTR\_FILECONTENTS](clipboard.md) format provides a very flexible and powerful way to transfer the contents of a file.</span></span> <span data-ttu-id="8008a-246">Даже не требуется, чтобы данные сохранялись в одном файле.</span><span class="sxs-lookup"><span data-stu-id="8008a-246">It is not even necessary for the data to be stored as a single file.</span></span> <span data-ttu-id="8008a-247">Все, что необходимо для этого формата, заключается в том, что объект данных предоставляет данные целевому объекту, как если бы он был файлом.</span><span class="sxs-lookup"><span data-stu-id="8008a-247">All that is required for this format is that the data object present the data to the target as if it were a file.</span></span> <span data-ttu-id="8008a-248">Например, фактические данные могут быть частью текстового документа или блоком данных, извлеченных из базы данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-248">For instance, the actual data might be a section of a text document or a block of data extracted from a database.</span></span> <span data-ttu-id="8008a-249">Целевой объект может рассматривать данные как файл и не должен знать какие-либо сведения о базовом механизме хранения.</span><span class="sxs-lookup"><span data-stu-id="8008a-249">The target can treat the data as a file and does not need to know anything about the underlying storage mechanism.</span></span>

<span data-ttu-id="8008a-250">Расширения пространства имен обычно используют [кфстр \_ филеконтентс](clipboard.md) для перемещения данных, так как этот формат не предполагает какой-либо конкретный механизм хранения.</span><span class="sxs-lookup"><span data-stu-id="8008a-250">Namespace extensions normally use [CFSTR\_FILECONTENTS](clipboard.md) to transfer data because this format does not assume any particular storage mechanism.</span></span> <span data-ttu-id="8008a-251">Расширение пространства имен может использовать любой механизм хранения, и использовать этот формат для представления своих объектов приложениям, как если бы они были файлами.</span><span class="sxs-lookup"><span data-stu-id="8008a-251">A namespace extension can use whatever storage mechanism is convenient, and use this format to present its objects to applications as if they were files.</span></span>

<span data-ttu-id="8008a-252">Механизмом обмена данными для [кфстр \_ филеконтентс](clipboard.md) обычно является [тимед \_ ISTREAM](dataobject.md).</span><span class="sxs-lookup"><span data-stu-id="8008a-252">The data transfer mechanism for [CFSTR\_FILECONTENTS](clipboard.md) is normally [TYMED\_ISTREAM](dataobject.md).</span></span> <span data-ttu-id="8008a-253">Передача указателя интерфейса [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) требует гораздо меньше памяти, чем загрузка данных в глобальный объект памяти, а **IStream** является более простым способом представления данных, чем [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span><span class="sxs-lookup"><span data-stu-id="8008a-253">Transferring an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface pointer requires much less memory than loading the data into a global memory object, and **IStream** is a simpler way to represent data than [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span></span>

<span data-ttu-id="8008a-254">Формат [ \_ филеконтентс кфстр](clipboard.md) всегда сопровождается форматом [кфстр \_ филедескриптор](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-254">A [CFSTR\_FILECONTENTS](clipboard.md) format is always accompanied by a [CFSTR\_FILEDESCRIPTOR](clipboard.md) format.</span></span> <span data-ttu-id="8008a-255">Сначала необходимо изучить содержимое этого формата.</span><span class="sxs-lookup"><span data-stu-id="8008a-255">You must examine the contents of this format first.</span></span> <span data-ttu-id="8008a-256">Если передается несколько файлов, объект данных фактически будет содержать несколько [кфстр \_ филеконтентс](clipboard.md) форматов, по одному для каждого файла.</span><span class="sxs-lookup"><span data-stu-id="8008a-256">If more than one file is being transferred, the data object will actually contain multiple [CFSTR\_FILECONTENTS](clipboard.md) formats, one for each file.</span></span> <span data-ttu-id="8008a-257">Формат [кфстр \_ филедескриптор](clipboard.md) содержит имя и атрибуты каждого файла, а также предоставляет значение индекса для каждого файла, необходимого для извлечения формата [кфстр \_ филеконтентс](clipboard.md) определенного файла.</span><span class="sxs-lookup"><span data-stu-id="8008a-257">The [CFSTR\_FILEDESCRIPTOR](clipboard.md) format contains the name and attributes of each file, and provides an index value for each file that is needed to extract a particular file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span>

<span data-ttu-id="8008a-258">Чтобы извлечь формат [ \_ филеконтентс кфстр](clipboard.md) , выполните следующие действия.</span><span class="sxs-lookup"><span data-stu-id="8008a-258">To extract a [CFSTR\_FILECONTENTS](clipboard.md) format:</span></span>

1.  <span data-ttu-id="8008a-259">Извлеките формат [кфстр \_ филедескриптор](clipboard.md) как значение [тимед \_ хглобал](dataobject.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-259">Extract the [CFSTR\_FILEDESCRIPTOR](clipboard.md) format as a [TYMED\_HGLOBAL](dataobject.md) value.</span></span>
2.  <span data-ttu-id="8008a-260">Элемент **хглобал** возвращенной структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) указывает на объект глобальной памяти.</span><span class="sxs-lookup"><span data-stu-id="8008a-260">The **hGlobal** member of the returned [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure points to a global memory object.</span></span> <span data-ttu-id="8008a-261">Заблокируйте этот объект, передав значение **хглобал** в [**глобаллокк**](/windows/win32/api/winbase/nf-winbase-globallock).</span><span class="sxs-lookup"><span data-stu-id="8008a-261">Lock that object by passing the **hGlobal** value to [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock).</span></span>
3.  <span data-ttu-id="8008a-262">Приведите указатель, возвращенный функцией [**глобаллокк**](/windows/win32/api/winbase/nf-winbase-globallock) , к указателю [**филеграупдескриптор**](/windows/win32/api/shlobj_core/ns-shlobj_core-filegroupdescriptora) .</span><span class="sxs-lookup"><span data-stu-id="8008a-262">Cast the pointer returned by [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) to a [**FILEGROUPDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filegroupdescriptora) pointer.</span></span> <span data-ttu-id="8008a-263">Он будет указывать на структуру **филеграупдескриптор** , за которой следует одна или несколько структур [**филедескриптор**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) .</span><span class="sxs-lookup"><span data-stu-id="8008a-263">It will point to a **FILEGROUPDESCRIPTOR** structure followed by one or more [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structures.</span></span> <span data-ttu-id="8008a-264">Каждая структура **филедескриптор** содержит описание файла, который содержится в одном из соответствующих форматов [кфстр \_ филеконтентс](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-264">Each **FILEDESCRIPTOR** structure contains a description of a file that is contained by one of the accompanying [CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span>
4.  <span data-ttu-id="8008a-265">Изучите структуры [**филедескриптор**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) , чтобы определить, какая из них соответствует файлу, который необходимо извлечь.</span><span class="sxs-lookup"><span data-stu-id="8008a-265">Examine the [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structures to determine which one corresponds to the file you want to extract.</span></span> <span data-ttu-id="8008a-266">Отсчитываемый от нуля индекс этой структуры **филедескриптор** используется для задания формата файла [кфстр \_ филеконтентс](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-266">The zero-based index of that **FILEDESCRIPTOR** structure is used to identify the file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="8008a-267">Поскольку размер глобального блока памяти не является точным, используйте члены структуры **нфилесизелов** и **нфилесизехигх** , чтобы определить, сколько байт представляет файл в глобальном объекте памяти.</span><span class="sxs-lookup"><span data-stu-id="8008a-267">Because the size of a global memory block is not byte-precise, use the structure's **nFileSizeLow** and **nFileSizeHigh** members to determine how many bytes represent the file in the global memory object.</span></span>
5.  <span data-ttu-id="8008a-268">Вызовите [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) с элементом **кфформат** структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) , для которого задано значение [Кфстр \_ филеконтентс](clipboard.md) , а в качестве элемента **Линдекс** — индекс, определенный на предыдущем шаге.</span><span class="sxs-lookup"><span data-stu-id="8008a-268">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) with the **cfFormat** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure set to the [CFSTR\_FILECONTENTS](clipboard.md) value and the **lIndex** member set to the index that you determined in the previous step.</span></span> <span data-ttu-id="8008a-269">Обычно элемент **тимед** имеет значение [тимед \_ хглобал](dataobject.md) \| тимед \_ ISTREAM \| тимед \_ ISTORAGE.</span><span class="sxs-lookup"><span data-stu-id="8008a-269">The **tymed** member is typically set to [TYMED\_HGLOBAL](dataobject.md) \| TYMED\_ISTREAM \| TYMED\_ISTORAGE.</span></span> <span data-ttu-id="8008a-270">Затем объект данных может выбрать предпочтительный механизм обмена данными.</span><span class="sxs-lookup"><span data-stu-id="8008a-270">The data object can then choose its preferred data transfer mechanism.</span></span>
6.  <span data-ttu-id="8008a-271">Структура [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) , возвращаемая файлом [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) , будет содержать указатель на данные файла.</span><span class="sxs-lookup"><span data-stu-id="8008a-271">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns will contain a pointer to the file's data.</span></span> <span data-ttu-id="8008a-272">Изучите элемент **тимед** структуры, чтобы определить механизм обмена данными.</span><span class="sxs-lookup"><span data-stu-id="8008a-272">Examine the **tymed** member of the structure to determine the data transfer mechanism.</span></span>
7.  <span data-ttu-id="8008a-273">Если **тимед** имеет значение [ТИМЕД \_ ISTREAM](dataobject.md) или тимед \_ ISTORAGE, используйте интерфейс для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-273">If **tymed** is set to [TYMED\_ISTREAM](dataobject.md) or TYMED\_ISTORAGE, use the interface to extract the data.</span></span> <span data-ttu-id="8008a-274">Если **тимед** имеет значение тимед \_ хглобал, данные содержатся в глобальном объекте памяти.</span><span class="sxs-lookup"><span data-stu-id="8008a-274">If **tymed** is set to TYMED\_HGLOBAL, the data is contained in a global memory object.</span></span> <span data-ttu-id="8008a-275">Обсуждение извлечения данных из глобального объекта памяти см. в разделе *Извлечение объекта глобальной памяти из раздела объекта* данных [оболочки](dataobject.md).</span><span class="sxs-lookup"><span data-stu-id="8008a-275">For a discussion of how to extract data from a global memory object, see the *Extracting a global memory object from a data object* section of [Shell Data Object](dataobject.md).</span></span>
8.  <span data-ttu-id="8008a-276">Вызовите [**глобаллокк**](/windows/win32/api/winbase/nf-winbase-globallock) , чтобы разблокировать объект глобальной памяти, заблокированный на шаге 2.</span><span class="sxs-lookup"><span data-stu-id="8008a-276">Call [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) to unlock the global memory object that you locked in step 2.</span></span>

## <a name="handling-optimized-move-operations"></a><span data-ttu-id="8008a-277">Обработка оптимизированных операций перемещения</span><span class="sxs-lookup"><span data-stu-id="8008a-277">Handling Optimized Move Operations</span></span>

<span data-ttu-id="8008a-278">**Сценарий:** Файл перемещается из файловой системы в расширение пространства имен с помощью оптимизированного перемещения.</span><span class="sxs-lookup"><span data-stu-id="8008a-278">**Scenario:** A file is moved from the file system to a namespace extension using an optimized move.</span></span>

<span data-ttu-id="8008a-279">В обычной операции перемещения целевой объект создает копию данных, а источник удаляет оригинал.</span><span class="sxs-lookup"><span data-stu-id="8008a-279">In a conventional move operation, the target makes a copy of the data and the source deletes the original.</span></span> <span data-ttu-id="8008a-280">Эта процедура может быть неэффективной, так как требует наличия двух копий данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-280">This procedure can be inefficient because it requires two copies of the data.</span></span> <span data-ttu-id="8008a-281">При использовании больших объектов, таких как базы данных, обычная операция перемещения может оказаться даже непрактичной.</span><span class="sxs-lookup"><span data-stu-id="8008a-281">With large objects such as databases, a conventional move operation might not even be practical.</span></span>

<span data-ttu-id="8008a-282">При оптимизированном перемещении целевой объект использует понимание того, как хранятся данные для обработки всей операции перемещения.</span><span class="sxs-lookup"><span data-stu-id="8008a-282">With an optimized move, the target uses its understanding of how the data is stored to handle the entire move operation.</span></span> <span data-ttu-id="8008a-283">Вторая копия данных никогда не используется, и источник для удаления исходных данных не требуется.</span><span class="sxs-lookup"><span data-stu-id="8008a-283">There is never a second copy of the data, and there is no need for the source to delete the original data.</span></span> <span data-ttu-id="8008a-284">Данные оболочки хорошо подходят для оптимизированных перемещений, так как целевой объект может выполнять всю операцию с помощью API оболочки.</span><span class="sxs-lookup"><span data-stu-id="8008a-284">Shell data is well suited to optimized moves because the target can handle the entire operation using the Shell API.</span></span> <span data-ttu-id="8008a-285">Типичным примером является перемещение файлов.</span><span class="sxs-lookup"><span data-stu-id="8008a-285">A typical example is moving files.</span></span> <span data-ttu-id="8008a-286">Если целевой объект содержит путь к перемещаемому файлу, он может использовать [**шфилеоператион**](/windows/desktop/api/Shellapi/nf-shellapi-shfileoperationa) для перемещения.</span><span class="sxs-lookup"><span data-stu-id="8008a-286">Once the target has the path of a file to be moved, it can use [**SHFileOperation**](/windows/desktop/api/Shellapi/nf-shellapi-shfileoperationa) to move it.</span></span> <span data-ttu-id="8008a-287">Источник для удаления исходного файла не требуется.</span><span class="sxs-lookup"><span data-stu-id="8008a-287">There is no need for the source to delete the original file.</span></span>

> [!Note]  
> <span data-ttu-id="8008a-288">Для перемещения файлов оболочка обычно использует оптимизированное перемещение.</span><span class="sxs-lookup"><span data-stu-id="8008a-288">The Shell normally uses an optimized move to move files.</span></span> <span data-ttu-id="8008a-289">Для правильной обработки передачи данных в оболочке приложение должно иметь возможность обнаружения и обработки оптимизированного перемещения.</span><span class="sxs-lookup"><span data-stu-id="8008a-289">To handle Shell data transfer properly, your application must be capable of detecting and handling an optimized move.</span></span>

 

<span data-ttu-id="8008a-290">Оптимизированные перемещения обрабатываются следующим образом:</span><span class="sxs-lookup"><span data-stu-id="8008a-290">Optimized moves are handled in the following way:</span></span>

1.  <span data-ttu-id="8008a-291">Источник вызывает [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) с параметром *двеффект* , установленным в дропеффект \_ Move, чтобы указать, что исходные объекты можно перемещать.</span><span class="sxs-lookup"><span data-stu-id="8008a-291">The source calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) with the *dwEffect* parameter set to DROPEFFECT\_MOVE to indicate that the source objects can be moved.</span></span>
2.  <span data-ttu-id="8008a-292">Целевой объект получает \_ значение перемещения дропеффект через один из своих методов [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) , указывая, что перемещение разрешено.</span><span class="sxs-lookup"><span data-stu-id="8008a-292">The target receives the DROPEFFECT\_MOVE value through one of its [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) methods, indicating that a move is allowed.</span></span>
3.  <span data-ttu-id="8008a-293">Цель либо копирует объект (неоптимизированное перемещение), либо перемещает объект (оптимизированное перемещение).</span><span class="sxs-lookup"><span data-stu-id="8008a-293">The target either copies the object (unoptimized move) or moves the object (optimized move).</span></span>
4.  <span data-ttu-id="8008a-294">Целевой объект сообщает источнику, нужно ли удалять исходные данные.</span><span class="sxs-lookup"><span data-stu-id="8008a-294">The target then tells the source whether it needs to delete the original data.</span></span>

    <span data-ttu-id="8008a-295">Оптимизированное перемещение — это операция по умолчанию с данными, удаленными целевым объектом.</span><span class="sxs-lookup"><span data-stu-id="8008a-295">An optimized move is the default operation, with the data deleted by the target.</span></span> <span data-ttu-id="8008a-296">Чтобы сообщить источнику, что было выполнено оптимизированное перемещение:</span><span class="sxs-lookup"><span data-stu-id="8008a-296">To inform the source that an optimized move was performed:</span></span>

    -   -   <span data-ttu-id="8008a-297">Целевой объект задает значение *пдвеффект* , полученное через его метод [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , к значению, отличному от дропеффект \_ Move.</span><span class="sxs-lookup"><span data-stu-id="8008a-297">The target sets the *pdwEffect* value it received through its [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to some value other than DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="8008a-298">Обычно для него задано значение ДРОПЕФФЕКТ \_ None или дропеффект \_ Copy.</span><span class="sxs-lookup"><span data-stu-id="8008a-298">It is typically set to either DROPEFFECT\_NONE or DROPEFFECT\_COPY.</span></span> <span data-ttu-id="8008a-299">Значение будет возвращено в источник с помощью [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span><span class="sxs-lookup"><span data-stu-id="8008a-299">The value will be returned to the source by [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span>
        -   <span data-ttu-id="8008a-300">Целевой объект также вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) объекта данных и передает ему идентификатор формата [ \_ перформеддропеффект кфстр](clipboard.md) , установленный в дропеффект \_ None.</span><span class="sxs-lookup"><span data-stu-id="8008a-300">The target also calls the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method and passes it a [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format identifier set to DROPEFFECT\_NONE.</span></span> <span data-ttu-id="8008a-301">Этот вызов метода необходим, так как некоторые целевые объекты Drop не могут правильно установить параметр *Пдвеффект* [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) .</span><span class="sxs-lookup"><span data-stu-id="8008a-301">This method call is necessary because some drop targets might not set the *pdwEffect* parameter of [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) properly.</span></span> <span data-ttu-id="8008a-302">Формат [кфстр \_ перформеддропеффект](clipboard.md) является надежным способом указать, что было выполнено оптимизированное перемещение.</span><span class="sxs-lookup"><span data-stu-id="8008a-302">The [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format is the reliable way to indicate that an optimized move has taken place.</span></span>

    <span data-ttu-id="8008a-303">Если целевой объект выполнил неоптимизированный перенос, данные должны быть удалены источником.</span><span class="sxs-lookup"><span data-stu-id="8008a-303">If the target did an unoptimized move, the data must be deleted by the source.</span></span> <span data-ttu-id="8008a-304">Чтобы сообщить источнику о том, что было выполнено неоптимизированное перемещение:</span><span class="sxs-lookup"><span data-stu-id="8008a-304">To inform the source that an unoptimized move was performed:</span></span>

    -   -   <span data-ttu-id="8008a-305">Целевой объект задает значение *пдвеффект* , полученное с помощью метода [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) дропеффект \_ Move.</span><span class="sxs-lookup"><span data-stu-id="8008a-305">The target sets the *pdwEffect* value it received through its [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="8008a-306">Значение будет возвращено в источник с помощью [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span><span class="sxs-lookup"><span data-stu-id="8008a-306">The value will be returned to the source by [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span>
        -   <span data-ttu-id="8008a-307">Целевой объект также вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) объекта данных и передает ему идентификатор формата [ \_ перформеддропеффект кфстр](clipboard.md) , установленный в дропеффект \_ Move.</span><span class="sxs-lookup"><span data-stu-id="8008a-307">The target also calls the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method and passes it a [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format identifier set to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="8008a-308">Этот вызов метода необходим, так как некоторые целевые объекты Drop не могут правильно установить параметр *Пдвеффект* [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) .</span><span class="sxs-lookup"><span data-stu-id="8008a-308">This method call is necessary because some drop targets might not set the *pdwEffect* parameter of [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) properly.</span></span> <span data-ttu-id="8008a-309">Формат [кфстр \_ перформеддропеффект](clipboard.md) является надежным способом указать, что было выполнено неоптимизированное перемещение.</span><span class="sxs-lookup"><span data-stu-id="8008a-309">The [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format is the reliable way to indicate that an unoptimized move has taken place.</span></span>

5.  <span data-ttu-id="8008a-310">Источник проверяет два значения, которые могут быть возвращены целевым объектом.</span><span class="sxs-lookup"><span data-stu-id="8008a-310">The source inspects the two values that can be returned by the target.</span></span> <span data-ttu-id="8008a-311">Если для обоих свойств задано значение ДРОПЕФФЕКТ \_ Move, то он завершает неоптимизированное перемещение, удаляя исходные данные.</span><span class="sxs-lookup"><span data-stu-id="8008a-311">If both are set to DROPEFFECT\_MOVE, it completes the unoptimized move by deleting the original data.</span></span> <span data-ttu-id="8008a-312">В противном случае в целевом объекте было оптимизировано перемещение, а исходные данные удалены.</span><span class="sxs-lookup"><span data-stu-id="8008a-312">Otherwise, the target did an optimized move and the original data has been deleted.</span></span>

## <a name="handling-delete-on-paste-operations"></a><span data-ttu-id="8008a-313">Обработка операций удаления при вставке</span><span class="sxs-lookup"><span data-stu-id="8008a-313">Handling Delete-on-Paste Operations</span></span>

<span data-ttu-id="8008a-314">**Сценарий:** Один или несколько файлов будут вырезаны из папки в проводнике Windows и вставлены в расширение пространства имен.</span><span class="sxs-lookup"><span data-stu-id="8008a-314">**Scenario:** One or more files are cut from a folder in Windows Explorer and pasted into a namespace extension.</span></span> <span data-ttu-id="8008a-315">Проводник Windows оставляет выделенные файлы до тех пор, пока не получит отзыв о результатах операции вставки.</span><span class="sxs-lookup"><span data-stu-id="8008a-315">Windows Explorer leaves the files highlighted until it receives feedback on the outcome of the paste operation.</span></span>

<span data-ttu-id="8008a-316">Обычно, когда пользователь вырезает данные, он сразу исчезает из представления.</span><span class="sxs-lookup"><span data-stu-id="8008a-316">Traditionally, when a user cuts data it immediately disappears from view.</span></span> <span data-ttu-id="8008a-317">Это может оказаться неэффективным и может привести к проблемам с удобством использования, если пользователь позаботится о том, что произошло с данными.</span><span class="sxs-lookup"><span data-stu-id="8008a-317">This might not be efficient, and it can lead to usability problems if the user becomes concerned about what has happened to the data.</span></span> <span data-ttu-id="8008a-318">Альтернативный подход заключается в использовании операции удаления при вставке.</span><span class="sxs-lookup"><span data-stu-id="8008a-318">An alternative approach is to use a delete-on-paste operation.</span></span>

<span data-ttu-id="8008a-319">При использовании операции удаления при вставке выбранные данные не сразу удаляются из представления.</span><span class="sxs-lookup"><span data-stu-id="8008a-319">With a delete-on-paste operation, the selected data is not immediately removed from view.</span></span> <span data-ttu-id="8008a-320">Вместо этого исходное приложение помечает его как выбранное, возможно, путем изменения цвета шрифта или фона.</span><span class="sxs-lookup"><span data-stu-id="8008a-320">Instead, the source application marks it as selected, perhaps by changing the font or background color.</span></span> <span data-ttu-id="8008a-321">После того как целевое приложение вставило данные, оно уведомляет источник о результатах операции.</span><span class="sxs-lookup"><span data-stu-id="8008a-321">After the target application has pasted the data, it notifies the source about the outcome of the operation.</span></span> <span data-ttu-id="8008a-322">Если целевой объект выполнил [оптимизированное перемещение](#handling-optimized-move-operations), источник может просто обновить его отображение.</span><span class="sxs-lookup"><span data-stu-id="8008a-322">If the target performed an [optimized move](#handling-optimized-move-operations), the source can simply update its display.</span></span> <span data-ttu-id="8008a-323">Если целевой объект выполнил нормальное перемещение, то источник должен также удалить свою копию данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-323">If the target performed a normal move, the source must also delete its copy of the data.</span></span> <span data-ttu-id="8008a-324">Если вставка завершается неудачно, исходное приложение восстанавливает исходный вид данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-324">If the paste fails, the source application restores the selected data to its original appearance.</span></span>

> [!Note]  
> <span data-ttu-id="8008a-325">Оболочка обычно использует функцию «удалить при вставке», если для перемещения файлов используется операция вырезания или вставки.</span><span class="sxs-lookup"><span data-stu-id="8008a-325">The Shell normally uses delete-on-paste when a cut/paste operation is used to move files.</span></span> <span data-ttu-id="8008a-326">Операции удаления при вставке с помощью объектов оболочки обычно используют [оптимизированную операцию перемещения](#handling-optimized-move-operations) для перемещения файлов.</span><span class="sxs-lookup"><span data-stu-id="8008a-326">Delete-on-paste operations with Shell objects normally use an [optimized move](#handling-optimized-move-operations) to move the files.</span></span> <span data-ttu-id="8008a-327">Для правильной обработки данных оболочки приложение должно уметь обнаруживать и обрабатывать операции удаления операций вставки.</span><span class="sxs-lookup"><span data-stu-id="8008a-327">To handle Shell data transfer properly, your application must be capable of detecting and handling delete-on-paste operations.</span></span>

 

<span data-ttu-id="8008a-328">Основным требованием для удаления при вставке является то, что целевой объект должен сообщить результат операции с источником.</span><span class="sxs-lookup"><span data-stu-id="8008a-328">The essential requirement for delete-on-paste is that the target must report the outcome of the operation to the source.</span></span> <span data-ttu-id="8008a-329">Однако стандартные методы буфера обмена нельзя использовать для реализации удаления при вставке, так как они не обеспечивают способ взаимодействия целевого объекта с источником.</span><span class="sxs-lookup"><span data-stu-id="8008a-329">However, standard Clipboard techniques cannot be used to implement delete-on-paste because they do not provide a way for the target to communicate with the source.</span></span> <span data-ttu-id="8008a-330">Вместо этого целевое приложение использует метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) объекта данных для передачи результата в объект данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-330">Instead, the target application uses the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method to report the outcome to the data object.</span></span> <span data-ttu-id="8008a-331">Затем объект данных может взаимодействовать с источником через частный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="8008a-331">The data object can then communicate with the source through a private interface.</span></span>

<span data-ttu-id="8008a-332">Ниже приведена базовая процедура для операции удаления при вставке.</span><span class="sxs-lookup"><span data-stu-id="8008a-332">The basic procedure for a delete-on-paste operation is as follows:</span></span>

1.  <span data-ttu-id="8008a-333">Источник отмечает отображение выбранных данных на экране.</span><span class="sxs-lookup"><span data-stu-id="8008a-333">The source marks the screen display of the selected data.</span></span>
2.  <span data-ttu-id="8008a-334">Источник создает объект данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-334">The source creates a data object.</span></span> <span data-ttu-id="8008a-335">Он указывает на операцию вырезания путем добавления формата [кфстр \_ преферреддропеффект](clipboard.md) со значением данных дропеффект \_ Move.</span><span class="sxs-lookup"><span data-stu-id="8008a-335">It indicates a cut operation by adding the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) format with a data value of DROPEFFECT\_MOVE.</span></span>
3.  <span data-ttu-id="8008a-336">Источник помещает объект данных в буфер обмена с помощью [**олесетклипбоард**](/windows/win32/api/ole2/nf-ole2-olesetclipboard).</span><span class="sxs-lookup"><span data-stu-id="8008a-336">The source places the data object on the Clipboard using [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard).</span></span>
4.  <span data-ttu-id="8008a-337">Цель получает объект данных из буфера обмена с помощью [**олежетклипбоард**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span><span class="sxs-lookup"><span data-stu-id="8008a-337">The target retrieves the data object from the Clipboard using [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span></span>
5.  <span data-ttu-id="8008a-338">Целевой объект извлекает данные [ \_ преферреддропеффект кфстр](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-338">The target extracts the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) data.</span></span> <span data-ttu-id="8008a-339">Если задано только \_ Перемещение дропеффект, целевой объект может либо выполнить оптимизированное перемещение, либо просто скопировать данные.</span><span class="sxs-lookup"><span data-stu-id="8008a-339">If it is set to only DROPEFFECT\_MOVE, the target can either do an optimized move or simply copy the data.</span></span>
6.  <span data-ttu-id="8008a-340">Если целевой объект не выполняет оптимизированное перемещение, он вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) с форматом [ \_ перформеддропеффект кфстр](clipboard.md) , установленным в дропеффект \_ Move.</span><span class="sxs-lookup"><span data-stu-id="8008a-340">If the target does not do an optimized move, it calls the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with the [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span>
7.  <span data-ttu-id="8008a-341">После завершения вставки целевой объект вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) с форматом [ \_ пастесукцеедед кфстр](clipboard.md) , установленным в дропеффект \_ Move.</span><span class="sxs-lookup"><span data-stu-id="8008a-341">When the paste is complete, the target calls the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with the [CFSTR\_PASTESUCCEEDED](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span>
8.  <span data-ttu-id="8008a-342">При вызове метода [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) с форматом [кфстр \_ пастесукцеедед](clipboard.md) , установленным в дропеффект \_ Move, он должен проверить, получен ли также формат [кфстр \_ перформеддропеффект](clipboard.md) , установленный в дропеффект \_ Move.</span><span class="sxs-lookup"><span data-stu-id="8008a-342">When the source's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method is called with the [CFSTR\_PASTESUCCEEDED](clipboard.md) format set to DROPEFFECT\_MOVE, it must check to see if it also received the [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="8008a-343">Если целевой объект отправляет оба формата, источнику потребуется удалить данные.</span><span class="sxs-lookup"><span data-stu-id="8008a-343">If both formats are sent by the target, the source will have to delete the data.</span></span> <span data-ttu-id="8008a-344">Если получен только формат [кфстр \_ пастесукцеедед](clipboard.md) , источник может просто удалить данные из его дисплея.</span><span class="sxs-lookup"><span data-stu-id="8008a-344">If only the [CFSTR\_PASTESUCCEEDED](clipboard.md) format is received, the source can simply remove the data from its display.</span></span> <span data-ttu-id="8008a-345">Если перемещение завершается неудачей, источник обновляет изображение до исходного вида.</span><span class="sxs-lookup"><span data-stu-id="8008a-345">If the transfer fails, the source updates the display to its original appearance.</span></span>

## <a name="transfering-data-to-and-from-virtual-folders"></a><span data-ttu-id="8008a-346">Перенос данных в виртуальные папки и из них</span><span class="sxs-lookup"><span data-stu-id="8008a-346">Transfering Data to and from Virtual Folders</span></span>

<span data-ttu-id="8008a-347">**Сценарий:** Пользователь перетаскивает объект из виртуальной папки или удаляет его.</span><span class="sxs-lookup"><span data-stu-id="8008a-347">**Scenario:** A user drags an object from or drops it on a virtual folder.</span></span>

<span data-ttu-id="8008a-348">Виртуальные папки содержат объекты, которые обычно не являются частью файловой системы.</span><span class="sxs-lookup"><span data-stu-id="8008a-348">Virtual folders contain objects that are generally not part of the file system.</span></span> <span data-ttu-id="8008a-349">Некоторые виртуальные папки, например корзина, могут представлять данные, которые хранятся на жестком диске, но не являются обычными объектами файловой системы.</span><span class="sxs-lookup"><span data-stu-id="8008a-349">Some virtual folders, such as the Recycle Bin, can represent data that is stored on the hard disk but not as ordinary file system objects.</span></span> <span data-ttu-id="8008a-350">Некоторые могут представлять сохраненные данные, находящиеся в удаленной системе, например на карманном ПК или на FTP-сайте.</span><span class="sxs-lookup"><span data-stu-id="8008a-350">Some can represent stored data that is on a remote system, such as a handheld PC, or an FTP site.</span></span> <span data-ttu-id="8008a-351">Другие, например папка «Принтеры», содержат объекты, не представляющие сохраненные данные.</span><span class="sxs-lookup"><span data-stu-id="8008a-351">Others, such as the Printers folder, contain objects that do not represent stored data at all.</span></span> <span data-ttu-id="8008a-352">Хотя некоторые виртуальные папки являются частью системы, разработчики также могут создавать и устанавливать настраиваемые виртуальные папки, реализуя расширение пространства имен.</span><span class="sxs-lookup"><span data-stu-id="8008a-352">While some virtual folders are part of the system, developers can also create and install custom virtual folders by implementing a namespace extension.</span></span>

<span data-ttu-id="8008a-353">Независимо от типа данных и способа их хранения, файлы папок и файлов, содержащиеся в виртуальной папке, представляются оболочкой, как будто они являются обычными файлами и папками.</span><span class="sxs-lookup"><span data-stu-id="8008a-353">Regardless of the type of data or how it is stored, the folder and file objects that are contained by a virtual folder are presented by the Shell as if they were normal files and folders.</span></span> <span data-ttu-id="8008a-354">Она отвечает за то, что виртуальная папка принимает все содержащиеся в ней данные и представляет ее в оболочке соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="8008a-354">It is the responsibility of the virtual folder to take whatever data it contains and present it to the Shell appropriately.</span></span> <span data-ttu-id="8008a-355">Это требование означает, что виртуальные папки обычно поддерживают перетаскивание и передачу данных в буфер обмена.</span><span class="sxs-lookup"><span data-stu-id="8008a-355">This requirement means that virtual folders normally support drag-and-drop and Clipboard data transfers.</span></span>

<span data-ttu-id="8008a-356">В связи с этим две группы разработчиков, которым необходимо заботиться о переносе данных в виртуальные папки и из них:</span><span class="sxs-lookup"><span data-stu-id="8008a-356">There are thus two groups of developers who need to be concerned with data transfer to and from virtual folders:</span></span>

-   <span data-ttu-id="8008a-357">Разработчики, чьи приложения должны принимать данные, передаваемые из виртуальной папки.</span><span class="sxs-lookup"><span data-stu-id="8008a-357">Developers whose applications need to accept data that is transferred from a virtual folder.</span></span>
-   <span data-ttu-id="8008a-358">Разработчики, расширения пространства имен которых должны должным образом поддерживать перенос данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-358">Developers whose namespace extensions need to properly support data transfer.</span></span>

### <a name="accepting-data-from-a-virtual-folder"></a><span data-ttu-id="8008a-359">Прием данных из виртуальной папки</span><span class="sxs-lookup"><span data-stu-id="8008a-359">Accepting Data from a Virtual Folder</span></span>

<span data-ttu-id="8008a-360">Виртуальные папки могут представлять практически любой тип данных и могут хранить эти данные любым способом.</span><span class="sxs-lookup"><span data-stu-id="8008a-360">Virtual folders can represent virtually any type of data and can store that data in any way they choose.</span></span> <span data-ttu-id="8008a-361">Некоторые виртуальные папки могут фактически содержать обычные файлы и папки файловой системы.</span><span class="sxs-lookup"><span data-stu-id="8008a-361">Some virtual folders might actually contain normal file system files and folders.</span></span> <span data-ttu-id="8008a-362">Другие могут, например, упаковать все свои объекты в один документ или базу данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-362">Others might, for instance, pack all their objects into a single document or database.</span></span>

<span data-ttu-id="8008a-363">При передаче объекта файловой системы в приложение объект данных обычно содержит формат [CF \_ HDROP](clipboard.md) с полным путем к объекту.</span><span class="sxs-lookup"><span data-stu-id="8008a-363">When a file system object is transferred to an application, the data object normally contains a [CF\_HDROP](clipboard.md) format with the object's fully qualified path.</span></span> <span data-ttu-id="8008a-364">Приложение может извлекать эту строку и использовать обычные функции файловой системы для открытия файла и извлечения его данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-364">Your application can extract this string and use the normal file system functions to open the file and extract its data.</span></span> <span data-ttu-id="8008a-365">Однако так как виртуальные папки обычно не содержат обычные объекты файловой системы, они обычно не используют [CF \_ HDROP](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="8008a-365">However, because virtual folders typically do not contain normal file system objects, they generally do not use [CF\_HDROP](clipboard.md).</span></span>

<span data-ttu-id="8008a-366">Вместо [CF \_ HDROP](clipboard.md)данные обычно передаются из виртуальных папок с помощью форматов [кфстр \_ филедескриптор](clipboard.md) / [кфстр \_ филеконтентс](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-366">Instead of [CF\_HDROP](clipboard.md), data is normally transferred from virtual folders with the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span> <span data-ttu-id="8008a-367">Формат [ \_ филеконтентс кфстр](clipboard.md) имеет два преимущества по сравнению с [CF \_ HDROP](clipboard.md):</span><span class="sxs-lookup"><span data-stu-id="8008a-367">The [CFSTR\_FILECONTENTS](clipboard.md) format has two advantages over [CF\_HDROP](clipboard.md):</span></span>

-   <span data-ttu-id="8008a-368">Определенный метод хранения данных не предполагается.</span><span class="sxs-lookup"><span data-stu-id="8008a-368">No particular method of data storage is assumed.</span></span>
-   <span data-ttu-id="8008a-369">Формат является более гибким.</span><span class="sxs-lookup"><span data-stu-id="8008a-369">The format is more flexible.</span></span> <span data-ttu-id="8008a-370">Он поддерживает три механизма обмена данными: глобальный объект памяти, интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) или интерфейс [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="8008a-370">It supports three data transfer mechanisms: a global memory object, an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface, or an [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span>

<span data-ttu-id="8008a-371">Объекты глобальной памяти редко используются для перемещения данных в виртуальные объекты или из них, поскольку данные должны быть скопированы в память целиком.</span><span class="sxs-lookup"><span data-stu-id="8008a-371">Global memory objects are rarely used to transfer data to or from virtual objects because the data must be copied into memory in its entirety.</span></span> <span data-ttu-id="8008a-372">Для передачи указателя интерфейса требуется почти не столько же памяти, что и более эффективно.</span><span class="sxs-lookup"><span data-stu-id="8008a-372">Transferring an interface pointer requires almost no memory and is much more efficient.</span></span> <span data-ttu-id="8008a-373">При наличии очень больших файлов указатель интерфейса может быть единственным практическим механизмом для обмена данными.</span><span class="sxs-lookup"><span data-stu-id="8008a-373">With very large files, an interface pointer might be the only practical data transfer mechanism.</span></span> <span data-ttu-id="8008a-374">Как правило, данные представлены указателем [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) , так как этот интерфейс несколько более гибок, чем [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span><span class="sxs-lookup"><span data-stu-id="8008a-374">Typically, data is represented by an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) pointer, because that interface is somewhat more flexible than [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span></span> <span data-ttu-id="8008a-375">Целевой объект извлекает указатель из объекта данных и использует методы интерфейса для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-375">The target extracts the pointer from the data object and uses the interface methods to extract the data.</span></span>

<span data-ttu-id="8008a-376">Дополнительные сведения о том, как обрабатывать форматы [кфстр \_ филедескриптор](clipboard.md) / [кфстр \_ филеконтентс](clipboard.md) , см. в статье [использование \_ формата кфстр филеконтентс для извлечения данных из файла](/windows).</span><span class="sxs-lookup"><span data-stu-id="8008a-376">For further discussion of how to handle the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats, see [Using the CFSTR\_FILECONTENTS Format to Extract Data from a File](/windows).</span></span>

### <a name="transferring-data-to-and-from-a-namespace-extension"></a><span data-ttu-id="8008a-377">Передача данных в расширение пространства имен и обратно</span><span class="sxs-lookup"><span data-stu-id="8008a-377">Transferring Data to and from a NameSpace Extension</span></span>

<span data-ttu-id="8008a-378">При реализации расширения пространства имен обычно требуется поддержка возможностей перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="8008a-378">When you implement a namespace extension, you will normally want to support drag-and-drop capabilities.</span></span> <span data-ttu-id="8008a-379">Следуйте рекомендациям по удалению источников и целевых объектов, описанным в разделе [Общие рекомендации](#general-guidelines).</span><span class="sxs-lookup"><span data-stu-id="8008a-379">Follow the recommendations for drop sources and targets discussed in [General Guidelines](#general-guidelines).</span></span> <span data-ttu-id="8008a-380">В частности, расширение пространства имен должно:</span><span class="sxs-lookup"><span data-stu-id="8008a-380">In particular, a namespace extension must:</span></span>

-   <span data-ttu-id="8008a-381">Иметь возможность обрабатывать форматы [кфстр \_ филедескриптор](clipboard.md) / [кфстр \_ филеконтентс](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-381">Be able to handle the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span> <span data-ttu-id="8008a-382">Эти два формата обычно используются для перемещения объектов в расширения пространства имен и из них.</span><span class="sxs-lookup"><span data-stu-id="8008a-382">These two formats are normally used to transfer objects to and from namespace extensions.</span></span>
-   <span data-ttu-id="8008a-383">Возможность обработки [оптимизированных перемещений](#handling-optimized-move-operations).</span><span class="sxs-lookup"><span data-stu-id="8008a-383">Be able to handle [optimized moves](#handling-optimized-move-operations).</span></span> <span data-ttu-id="8008a-384">Оболочка ждет, что объекты оболочки будут перемещены с оптимизированным перемещением.</span><span class="sxs-lookup"><span data-stu-id="8008a-384">The Shell expects that Shell objects will be moved with an optimized move.</span></span>
-   <span data-ttu-id="8008a-385">Иметь возможность обрабатывать операции [удаления при вставке](#handling-delete-on-paste-operations) .</span><span class="sxs-lookup"><span data-stu-id="8008a-385">Be able to handle a [delete-on-paste](#handling-delete-on-paste-operations) operation.</span></span> <span data-ttu-id="8008a-386">Оболочка использует функцию "удалить при вставке" при перемещении объектов из оболочки в операцию вырезания или вставки.</span><span class="sxs-lookup"><span data-stu-id="8008a-386">The Shell uses delete-on-paste when objects are moved from the Shell with a cut/paste operation.</span></span>
-   <span data-ttu-id="8008a-387">Возможность обрабатывать обмен данными через интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) или [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="8008a-387">Be able to handle data transfer through an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) or [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span> <span data-ttu-id="8008a-388">Передача данных в виртуальную папку или из нее обычно обрабатывается путем передачи одного из этих двух указателей интерфейса, обычно указателя **IStream** .</span><span class="sxs-lookup"><span data-stu-id="8008a-388">Data transfer to or from a virtual folder is normally handled by transferring one of these two interface pointers, typically an **IStream** pointer.</span></span> <span data-ttu-id="8008a-389">Затем целевой объект вызывает методы интерфейса для извлечения данных:</span><span class="sxs-lookup"><span data-stu-id="8008a-389">The target then calls the interface methods to extract the data:</span></span>
    -   -   <span data-ttu-id="8008a-390">В качестве источника сброса расширение пространства имен должно извлекать данные из хранилища и передавать их в целевой объект через этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="8008a-390">As a drop source, the namespace extension must extract the data from storage and pass it through this interface to the target.</span></span>
        -   <span data-ttu-id="8008a-391">В качестве цели перетаскивания расширение пространства имен должно принимать данные из источника через этот интерфейс и сохранять их должным образом.</span><span class="sxs-lookup"><span data-stu-id="8008a-391">As a drop target, a namespace extension must accept data from a source through this interface and store it properly.</span></span>

## <a name="dropping-files-on-the-recycle-bin"></a><span data-ttu-id="8008a-392">Удаление файлов в корзине</span><span class="sxs-lookup"><span data-stu-id="8008a-392">Dropping Files on the Recycle Bin</span></span>

<span data-ttu-id="8008a-393">**Сценарий:** Пользователь удаляет файл в **корзине**.</span><span class="sxs-lookup"><span data-stu-id="8008a-393">**Scenario:** The user drops a file on the **Recycle Bin**.</span></span> <span data-ttu-id="8008a-394">Расширение приложения или пространства имен удаляет исходный файл.</span><span class="sxs-lookup"><span data-stu-id="8008a-394">Your application or namespace extension deletes the original file.</span></span>

<span data-ttu-id="8008a-395">Корзина — это виртуальная папка, которая используется в качестве репозитория для файлов, которые больше не нужны.</span><span class="sxs-lookup"><span data-stu-id="8008a-395">The Recycle Bin is a virtual folder that is used as a repository for files that are no longer needed.</span></span> <span data-ttu-id="8008a-396">Пока корзина не была очищена, пользователь может позже восстановить файл и вернуть его в файловую систему.</span><span class="sxs-lookup"><span data-stu-id="8008a-396">As long as the Recycle Bin has not been emptied, the user can later recover the file and return it to the file system.</span></span>

<span data-ttu-id="8008a-397">В большинстве случаев передача объектов оболочки в корзину работает во многом аналогично любой другой папке.</span><span class="sxs-lookup"><span data-stu-id="8008a-397">For the most part, transferring Shell objects to the Recycle Bin works much like any other folder.</span></span> <span data-ttu-id="8008a-398">Однако когда пользователь удаляет файл в **корзине**, источник должен удалить оригинал, даже если обратная связь из папки указывает на операцию копирования.</span><span class="sxs-lookup"><span data-stu-id="8008a-398">However, when a user drops a file on the **Recycle Bin**, the source needs to delete the original, even if the feedback from the folder indicates a copy operation.</span></span> <span data-ttu-id="8008a-399">Как правило, источник перетаскивания не может узнать, в какой папке был удален объект данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-399">Normally, a drop source has no way of knowing which folder its data object has been dropped on.</span></span> <span data-ttu-id="8008a-400">Однако для систем Windows 2000 и более поздних версий при удалении объекта данных в **корзине** оболочка вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) объекта данных с форматом [кфстр \_ таржетклсид](clipboard.md) , установленным в идентификатор класса корзины (CLSID \_ RecycleBin).</span><span class="sxs-lookup"><span data-stu-id="8008a-400">However, for Windows 2000 and later systems, when a data object is dropped on the **Recycle Bin**, the Shell will call the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with a [CFSTR\_TARGETCLSID](clipboard.md) format set to the Recycle Bin's class identifier (CLSID) (CLSID\_RecycleBin).</span></span> <span data-ttu-id="8008a-401">Чтобы правильно обрабатывать корзину, объект данных должен иметь возможность распознать этот формат и передать информацию в источник через частный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="8008a-401">To handle the Recycle Bin case properly, your data object should be able to recognize this format and communicate the information to the source through a private interface.</span></span>

> [!Note]  
> <span data-ttu-id="8008a-402">Когда метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) вызывается с форматом [ \_ таржетклсид кфстр](clipboard.md) , установленным в значение CLSID \_ RecycleBin, источник данных должен закрыть все открытые дескрипторы объектов, которые передаются перед возвратом из метода.</span><span class="sxs-lookup"><span data-stu-id="8008a-402">When [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) is called with a [CFSTR\_TARGETCLSID](clipboard.md) format set to CLSID\_RecycleBin, the data source should close any open handles to the objects that are being transferred before returning from the method.</span></span> <span data-ttu-id="8008a-403">В противном случае вы можете создать нарушения совместного доступа.</span><span class="sxs-lookup"><span data-stu-id="8008a-403">Otherwise, you might create sharing violations.</span></span>

 

## <a name="creating-and-importing-scrap-files"></a><span data-ttu-id="8008a-404">Создание и импорт файлов отходов</span><span class="sxs-lookup"><span data-stu-id="8008a-404">Creating and Importing Scrap Files</span></span>

<span data-ttu-id="8008a-405">**Сценарий:** Пользователь перетаскивает некоторые данные из файла данных OLE-приложения и удаляет их на рабочем столе или в проводнике Windows.</span><span class="sxs-lookup"><span data-stu-id="8008a-405">**Scenario:** A user drags some data from an OLE application's data file and drops it on the desktop or Windows Explorer.</span></span>

<span data-ttu-id="8008a-406">Windows позволяет пользователям перетащить объект из файла данных OLE-приложения и поместить его на Рабочий стол или в папку файловой системы.</span><span class="sxs-lookup"><span data-stu-id="8008a-406">Windows allows users to drag an object from an OLE application's data file and drop it on the desktop or a file system folder.</span></span> <span data-ttu-id="8008a-407">Эта операция создает *файл брака/отхода*, который содержит данные или ссылку на данные.</span><span class="sxs-lookup"><span data-stu-id="8008a-407">This operation creates a *scrap file*, which contains the data or a link to the data.</span></span> <span data-ttu-id="8008a-408">Имя файла берется из краткого имени, зарегистрированного для идентификатора CLSID объекта и [ \_ текстовых данных CF](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="8008a-408">The file name is taken from the short name registered for the CLSID of the object and the [CF\_TEXT](clipboard.md) data.</span></span> <span data-ttu-id="8008a-409">Чтобы оболочка создали файл брака/отхода, содержащий данные, интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) приложения должен поддерживать \_ Формат буфера обмена CF ембедсаурце.</span><span class="sxs-lookup"><span data-stu-id="8008a-409">For the Shell to create a scrap file containing data, the application's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface must support the CF\_EMBEDSOURCE Clipboard format.</span></span> <span data-ttu-id="8008a-410">Для создания файла, содержащего ссылку, **IDataObject** должен поддерживать \_ Формат CF линксаурце.</span><span class="sxs-lookup"><span data-stu-id="8008a-410">To create a file containing a link, **IDataObject** must support the CF\_LINKSOURCE format.</span></span>

<span data-ttu-id="8008a-411">Существуют также три дополнительные функции, которые приложение может реализовать для поддержки файлов брака/отхода:</span><span class="sxs-lookup"><span data-stu-id="8008a-411">There are also three optional features that an application can implement to support scrap files:</span></span>

-   <span data-ttu-id="8008a-412">Поддержка приема-передачи</span><span class="sxs-lookup"><span data-stu-id="8008a-412">Round-trip support</span></span>
-   <span data-ttu-id="8008a-413">Форматы кэшированных данных</span><span class="sxs-lookup"><span data-stu-id="8008a-413">Cached data formats</span></span>
-   <span data-ttu-id="8008a-414">Отложенная визуализация</span><span class="sxs-lookup"><span data-stu-id="8008a-414">Delayed rendering</span></span>

### <a name="round-trip-support"></a><span data-ttu-id="8008a-415">Поддержка приема-передачи</span><span class="sxs-lookup"><span data-stu-id="8008a-415">Round-trip Support</span></span>

<span data-ttu-id="8008a-416">*Цикл обработки* включает передачу объекта данных в другой контейнер, а затем обратно в исходный документ.</span><span class="sxs-lookup"><span data-stu-id="8008a-416">A *round trip* involves transferring a data object to another container and then back to the original document.</span></span> <span data-ttu-id="8008a-417">Например, пользователь может переместить группу ячеек из электронной таблицы на Рабочий стол, создавая файл брака/отхода с данными.</span><span class="sxs-lookup"><span data-stu-id="8008a-417">For instance, a user could transfer a group of cells from a spreadsheet to the desktop, creating a scrap file with the data.</span></span> <span data-ttu-id="8008a-418">Если пользователь затем перенесет отходы обратно в электронную таблицу, данные должны быть интегрированы в документ в том виде, в котором они находились до первоначальной передачи.</span><span class="sxs-lookup"><span data-stu-id="8008a-418">If the user then transfers the scrap back to the spreadsheet, the data needs to be integrated into the document as it was before the original transfer.</span></span>

<span data-ttu-id="8008a-419">Когда оболочка создает файл брака/отхода, он представляет данные как объект внедрения.</span><span class="sxs-lookup"><span data-stu-id="8008a-419">When the Shell creates the scrap file, it represents the data as an embedding object.</span></span> <span data-ttu-id="8008a-420">Когда отходы передаются в другой контейнер, он передается как объект внедрения, даже если он возвращается в исходный документ.</span><span class="sxs-lookup"><span data-stu-id="8008a-420">When the scrap is transferred to another container, it is transferred as an embedding object, even if it is being returned to the original document.</span></span> <span data-ttu-id="8008a-421">Приложение отвечает за определение формата данных, содержащегося в отходах, и перевод данных обратно в собственный формат при необходимости.</span><span class="sxs-lookup"><span data-stu-id="8008a-421">Your application is responsible for determining the data format contained in the scrap and putting the data back into its native format if necessary.</span></span>

<span data-ttu-id="8008a-422">Чтобы установить формат внедренного объекта, определите его идентификатор CLSID, извлекая \_ Формат обжектдескриптор объекта CF.</span><span class="sxs-lookup"><span data-stu-id="8008a-422">To establish the format of the embedded object, determine its CLSID by retrieving the object's CF\_OBJECTDESCRIPTOR format.</span></span> <span data-ttu-id="8008a-423">Если идентификатор CLSID указывает на формат данных, принадлежащий приложению, он должен переносить собственные данные вместо вызова [**олекреатефромдата**](/windows/win32/api/ole2/nf-ole2-olecreatefromdata).</span><span class="sxs-lookup"><span data-stu-id="8008a-423">If the CLSID indicates a data format that belongs to the application, it should transfer the native data instead of calling [**OleCreateFromData**](/windows/win32/api/ole2/nf-ole2-olecreatefromdata).</span></span>

### <a name="cached-data-formats"></a><span data-ttu-id="8008a-424">Форматы кэшированных данных</span><span class="sxs-lookup"><span data-stu-id="8008a-424">Cached Data Formats</span></span>

<span data-ttu-id="8008a-425">Когда оболочка создает файл брака/отхода, он проверяет реестр на наличие списка доступных форматов.</span><span class="sxs-lookup"><span data-stu-id="8008a-425">When the Shell creates a scrap file, it checks the registry for the list of available formats.</span></span> <span data-ttu-id="8008a-426">По умолчанию доступны два формата: CF \_ ембедсаурце и CF \_ линксаурце.</span><span class="sxs-lookup"><span data-stu-id="8008a-426">By default, there are two formats available: CF\_EMBEDSOURCE and CF\_LINKSOURCE.</span></span> <span data-ttu-id="8008a-427">Однако существует ряд сценариев, в которых приложениям могут потребоваться файлы брака/отхода в разных форматах:</span><span class="sxs-lookup"><span data-stu-id="8008a-427">However, there are a number of scenarios where applications might need to have scrap files in different formats:</span></span>

-   <span data-ttu-id="8008a-428">Значение, чтобы разрешить передачу отходов в контейнеры, отличные от OLE, которые не могут принимать внедренные форматы объектов.</span><span class="sxs-lookup"><span data-stu-id="8008a-428">To allow scraps to be transferred to non-OLE containers, which cannot accepted embedded object formats.</span></span>
-   <span data-ttu-id="8008a-429">Для обеспечения взаимодействия наборов приложений с частным форматом.</span><span class="sxs-lookup"><span data-stu-id="8008a-429">To allow suites of applications to communicate with a private format.</span></span>
-   <span data-ttu-id="8008a-430">, Чтобы упростить обработку циклов обработки.</span><span class="sxs-lookup"><span data-stu-id="8008a-430">To make round trips easier to handle.</span></span>

<span data-ttu-id="8008a-431">Приложения могут добавлять форматы в отходы путем их кэширования в реестре.</span><span class="sxs-lookup"><span data-stu-id="8008a-431">Applications can add formats to the scrap by caching them in the registry.</span></span> <span data-ttu-id="8008a-432">Существует два типа кэшированных форматов:</span><span class="sxs-lookup"><span data-stu-id="8008a-432">There are two types of cached formats:</span></span>

-   <span data-ttu-id="8008a-433">Форматы кэша приоритета.</span><span class="sxs-lookup"><span data-stu-id="8008a-433">Priority cache formats.</span></span> <span data-ttu-id="8008a-434">Для этих форматов данные копируются целиком в отходы из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-434">For these formats, the data is copied in its entirety into the scrap from the data object.</span></span>
-   <span data-ttu-id="8008a-435">Форматы отложенной визуализации.</span><span class="sxs-lookup"><span data-stu-id="8008a-435">Delay-rendered formats.</span></span> <span data-ttu-id="8008a-436">Для этих форматов объект данных не копируется в отходы.</span><span class="sxs-lookup"><span data-stu-id="8008a-436">For these formats, the data object is not copied to the scrap.</span></span> <span data-ttu-id="8008a-437">Вместо этого отрисовка откладывается до тех пор, пока целевой объект не запросит данные.</span><span class="sxs-lookup"><span data-stu-id="8008a-437">Instead, rendering is delayed until a target requests the data.</span></span> <span data-ttu-id="8008a-438">Более подробно в следующем разделе описывается отложенная визуализация.</span><span class="sxs-lookup"><span data-stu-id="8008a-438">Delay-rendering is discussed in more detail in the next section.</span></span>

<span data-ttu-id="8008a-439">Чтобы добавить в кэш приоритета или формат с отложенной отработкой, создайте подраздел " **Формат** данных" в ключе **CLSID** приложения, которое является исходным данными.</span><span class="sxs-lookup"><span data-stu-id="8008a-439">To add a priority cache or delay-rendered format, create a **DataFormat** subkey under the **CLSID** key of the application that is the source of the data.</span></span> <span data-ttu-id="8008a-440">В этом подразделе создайте подраздел **приоритикачеформатс** или **делайрендерформатс** .</span><span class="sxs-lookup"><span data-stu-id="8008a-440">Under that subkey, create a **PriorityCacheFormats** or **DelayRenderFormats** subkey.</span></span> <span data-ttu-id="8008a-441">Для каждого кэша приоритетов или формата с отложенной просмотром создайте нумерованный подраздел, начинающийся с нуля.</span><span class="sxs-lookup"><span data-stu-id="8008a-441">For each priority cache or delay-rendered format, create a numbered subkey starting with zero.</span></span> <span data-ttu-id="8008a-442">Установите значение этого параметра в виде строки с зарегистрированным именем формата или \# значения x, где X представляет номер формата стандартного формата буфера обмена.</span><span class="sxs-lookup"><span data-stu-id="8008a-442">Set the value of this key to either a string with the registered name of the format or a \#X value, where X represents the format number of a standard Clipboard format.</span></span>

<span data-ttu-id="8008a-443">В следующем примере показаны кэшированные форматы для двух приложений.</span><span class="sxs-lookup"><span data-stu-id="8008a-443">The following sample shows cached formats for two applications.</span></span> <span data-ttu-id="8008a-444">Приложение MyProg1 имеет форматированный текст в формате кэша приоритетов и частный формат "мой формат" в виде формата с отложенной визуализацией.</span><span class="sxs-lookup"><span data-stu-id="8008a-444">The MyProg1 application has the rich-text format as a priority cache format, and a private format "My Format" as a delay-rendered format.</span></span> <span data-ttu-id="8008a-445">Приложение MyProg2 имеет \_ Формат битовой карты CF ( \# 8) в качестве формата кэша приоритета.</span><span class="sxs-lookup"><span data-stu-id="8008a-445">The MyProg2 application has the CF\_BITMAP format (\#8") as a priority cache format.</span></span>

```
HKEY_CLASSES_ROOT
   CLSID
      {GUID}
         (Default) = MyProg1
         DataFormats
            PriorityCacheFormats
               0
                  (Default) = Rich Text Format
            DelayRenderFormats
               0
                  (Default) = My Format
      {GUID}
         (Default) = MyProg2
         DataFormats
            PriorityCacheFormats
               0
                  (Default) = #8
```

<span data-ttu-id="8008a-446">Дополнительные форматы можно добавить, создав дополнительные нумерованные подразделы.</span><span class="sxs-lookup"><span data-stu-id="8008a-446">Additional formats can be added by creating additional numbered subkeys.</span></span>

### <a name="delayed-rendering"></a><span data-ttu-id="8008a-447">Отложенная визуализация</span><span class="sxs-lookup"><span data-stu-id="8008a-447">Delayed Rendering</span></span>

<span data-ttu-id="8008a-448">Формат отложенной подготовки позволяет приложению создать файл брака/отхода, но отложить расходы на визуализацию данных до тех пор, пока они не будут запрошены целевым объектом.</span><span class="sxs-lookup"><span data-stu-id="8008a-448">A delayed rendering format allows an application to create a scrap file but delay the expense of rendering the data until it is requested by a target.</span></span> <span data-ttu-id="8008a-449">Интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) брака/отхода будет предлагать форматы отложенной отрисовки для целевого объекта вместе с собственными и кэшированными данными.</span><span class="sxs-lookup"><span data-stu-id="8008a-449">The [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface of a scrap will offer the delayed rendering formats to the target along with native and cached data.</span></span> <span data-ttu-id="8008a-450">Если целевой объект запрашивает формат отложенной подготовки, оболочка запустит приложение и предоставит данные целевому объекту из активного объекта.</span><span class="sxs-lookup"><span data-stu-id="8008a-450">If the target requests a delayed rendering format, the Shell will run the application and provide the data to the target from the active object.</span></span>

> [!Note]  
> <span data-ttu-id="8008a-451">Поскольку отложенная визуализация довольно рискованна, ее следует использовать с осторожностью.</span><span class="sxs-lookup"><span data-stu-id="8008a-451">Because delayed rendering is somewhat risky, it should be used with caution.</span></span> <span data-ttu-id="8008a-452">Он не будет работать, если сервер недоступен, или для приложений, не поддерживающих OLE.</span><span class="sxs-lookup"><span data-stu-id="8008a-452">It will not work if the server is not available, or on applications that are not OLE-enabled.</span></span>

 

## <a name="dragging-and-dropping-shell-objects-asynchronously"></a><span data-ttu-id="8008a-453">Асинхронное перетаскивание объектов оболочки</span><span class="sxs-lookup"><span data-stu-id="8008a-453">Dragging and Dropping Shell Objects Asynchronously</span></span>

<span data-ttu-id="8008a-454">**Сценарий:** Пользователь передает большой блок данных из источника в целевую цель.</span><span class="sxs-lookup"><span data-stu-id="8008a-454">**Scenario:** A user transfers a large block of data from source to target.</span></span> <span data-ttu-id="8008a-455">Чтобы предотвратить блокировку обоих приложений в течение значительного промежутка времени, целевой объект извлекает данные асинхронно.</span><span class="sxs-lookup"><span data-stu-id="8008a-455">To avoid blocking both applications for a significant amount of time, the target extracts the data asynchronously.</span></span>

<span data-ttu-id="8008a-456">Как правило, операция перетаскивания выполняется в синхронном режиме.</span><span class="sxs-lookup"><span data-stu-id="8008a-456">Normally, drag-and-drop is a synchronous operation.</span></span> <span data-ttu-id="8008a-457">Краткое описание</span><span class="sxs-lookup"><span data-stu-id="8008a-457">In brief:</span></span>

1.  <span data-ttu-id="8008a-458">Drop Source вызывает [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) и блокирует его основной поток, пока функция не вернет значение.</span><span class="sxs-lookup"><span data-stu-id="8008a-458">The drop source calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) and blocks its primary thread until the function returns.</span></span> <span data-ttu-id="8008a-459">Блокировка основного потока обычно блокирует обработку пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="8008a-459">Blocking the primary thread normally blocks UI processing.</span></span>
2.  <span data-ttu-id="8008a-460">После вызова метода [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) целевой объект извлекает данные из объекта данных в своем основном потоке.</span><span class="sxs-lookup"><span data-stu-id="8008a-460">After the target's [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method is called, the target extracts the data from the data object on its primary thread.</span></span> <span data-ttu-id="8008a-461">Эта процедура обычно блокирует обработку пользовательского интерфейса целевого объекта на протяжении процесса извлечения.</span><span class="sxs-lookup"><span data-stu-id="8008a-461">This procedure normally blocks the target's UI processing for the duration of the extraction process.</span></span>
3.  <span data-ttu-id="8008a-462">После извлечения данных целевой объект возвращает вызов [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , система возвращает [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop), и оба потока могут продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="8008a-462">Once the data has been extracted, the target returns the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) call, the system returns [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop), and both threads can proceed.</span></span>

<span data-ttu-id="8008a-463">В сокращенном случае синхронная передаваемые данные могут блокировать основные потоки обоих приложений в течение значительного промежутка времени.</span><span class="sxs-lookup"><span data-stu-id="8008a-463">In short, synchronous data transfer can block the primary threads of both applications for a significant amount of time.</span></span> <span data-ttu-id="8008a-464">В частности, оба потока должны ждать, пока целевой объект извлечет данные.</span><span class="sxs-lookup"><span data-stu-id="8008a-464">In particular, both threads must wait while the target extracts the data.</span></span> <span data-ttu-id="8008a-465">Для небольших объемов данных время, необходимое для извлечения данных, является небольшим, а синхронная — довольно хорошо.</span><span class="sxs-lookup"><span data-stu-id="8008a-465">For small amounts of data, the time required to extract data is small and synchronous data transfer works quite well.</span></span> <span data-ttu-id="8008a-466">Однако синхронное извлечение больших объемов данных может привести к длительным задержкам и помешать пользовательскому интерфейсу как целевого, так и исходного кода.</span><span class="sxs-lookup"><span data-stu-id="8008a-466">However, synchronously extracting large amounts of data can cause lengthy delays and interfere with the UI of both target and source.</span></span>

<span data-ttu-id="8008a-467">Интерфейс [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) — это необязательный интерфейс, который может быть реализован объектом данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-467">The [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface is an optional interface that can be implemented by a data object.</span></span> <span data-ttu-id="8008a-468">Он дает цели перетаскивания возможность асинхронно извлекать данные из объекта данных в фоновом потоке.</span><span class="sxs-lookup"><span data-stu-id="8008a-468">It gives the drop target the ability to extract data from the data object asynchronously on a background thread.</span></span> <span data-ttu-id="8008a-469">Когда извлечение данных передается в фоновый поток, основные потоки обоих приложений могут быть продолжены.</span><span class="sxs-lookup"><span data-stu-id="8008a-469">Once data extraction is handed off to the background thread, the primary threads of both applications are free to proceed.</span></span>

### <a name="using-iasyncoperationidataobjectasynccapability"></a><span data-ttu-id="8008a-470">Использование IASyncOperation и Идатаобжектасинккапабилити</span><span class="sxs-lookup"><span data-stu-id="8008a-470">Using IASyncOperation/IDataObjectAsyncCapability</span></span>

> [!Note]  
> <span data-ttu-id="8008a-471">Изначально интерфейс назывался [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)), но впоследствии он был изменен на [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span><span class="sxs-lookup"><span data-stu-id="8008a-471">The interface was originally named [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)), but this was later changed to [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span></span> <span data-ttu-id="8008a-472">В противном случае два интерфейса идентичны.</span><span class="sxs-lookup"><span data-stu-id="8008a-472">Otherwise, the two interfaces are identical.</span></span>

 

<span data-ttu-id="8008a-473">Цель [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) заключается в том, чтобы разрешить источнику удаления и цели удаления согласованность данных, которые могут быть извлечены асинхронно.</span><span class="sxs-lookup"><span data-stu-id="8008a-473">The purpose of [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) is to allow the drop source and drop target to negotiate whether data can be extracted asynchronously.</span></span> <span data-ttu-id="8008a-474">В следующей процедуре показано, как источник Drop использует интерфейс:</span><span class="sxs-lookup"><span data-stu-id="8008a-474">The following procedure outlines how the drop source uses the interface:</span></span>

1.  <span data-ttu-id="8008a-475">Создайте объект данных, который предоставляет [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span><span class="sxs-lookup"><span data-stu-id="8008a-475">Create a data object that exposes [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span></span>
2.  <span data-ttu-id="8008a-476">Вызовите [**сетасинкмоде**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode) с параметром *фдупасинк* , указав значение **Variant \_ true** , чтобы указать, что асинхронная операция поддерживается.</span><span class="sxs-lookup"><span data-stu-id="8008a-476">Call [**SetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode) with *fDoOpAsync* set to **VARIANT\_TRUE** to indicate that an asynchronous operation is supported.</span></span>
3.  <span data-ttu-id="8008a-477">После возврата [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) вызовет [**операцию**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation)вызова:</span><span class="sxs-lookup"><span data-stu-id="8008a-477">After [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) returns, call [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation):</span></span>
    -   <span data-ttu-id="8008a-478">Если при выполнении [**операции**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) происходит сбой или возвращается **\_ значение false**, выполняется обычная синхронная отправка данных и процесс извлечения данных завершается.</span><span class="sxs-lookup"><span data-stu-id="8008a-478">If [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) fails or returns **VARIANT\_FALSE**, a normal synchronous data transfer has taken place and the data extraction process is finished.</span></span> <span data-ttu-id="8008a-479">Источник должен выполнить необходимую очистку и продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="8008a-479">The source should do any cleanup that is required, and proceed.</span></span>
    -   <span data-ttu-id="8008a-480">Если функция [**OnOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) возвращает **\_ значение Variant true**, данные извлекаются асинхронно.</span><span class="sxs-lookup"><span data-stu-id="8008a-480">If [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) returns **VARIANT\_TRUE**, the data is being extracted asynchronously.</span></span> <span data-ttu-id="8008a-481">Операции очистки должны обрабатываться [**ендоператион**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span><span class="sxs-lookup"><span data-stu-id="8008a-481">Cleanup operations should be handled by [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span></span>
4.  <span data-ttu-id="8008a-482">Освобождение объекта данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-482">Release the data object.</span></span>
5.  <span data-ttu-id="8008a-483">По завершении асинхронной передаче данных объект данных обычно уведомляет источник через частный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="8008a-483">When the asynchronous data transfer is complete, the data object normally notifies the source through a private interface.</span></span>

<span data-ttu-id="8008a-484">В следующей процедуре показано, как цель Drop использует интерфейс [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) для асинхронного извлечения данных:</span><span class="sxs-lookup"><span data-stu-id="8008a-484">The following procedure outlines how the drop target uses the [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface to extract data asynchronously:</span></span>

1.  <span data-ttu-id="8008a-485">Когда система вызывает [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop), вызовите [**IDataObject:: QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) и запросите интерфейс [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) (IID \_ IAsyncOperation/IID \_ идатаобжектасинккапабилити) из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-485">When the system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop), call [**IDataObject::QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) and request an [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface (IID\_IAsyncOperation/IID\_IDataObjectAsyncCapability) from the data object.</span></span>
2.  <span data-ttu-id="8008a-486">Вызовите [**жетасинкмоде**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode).</span><span class="sxs-lookup"><span data-stu-id="8008a-486">Call [**GetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode).</span></span> <span data-ttu-id="8008a-487">Если метод возвращает **\_ значение true**, объект данных поддерживает асинхронное извлечение данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-487">If the method returns **VARIANT\_TRUE**, the data object supports asynchronous data extraction.</span></span>
3.  <span data-ttu-id="8008a-488">Создайте отдельный поток для обработки извлечения данных и вызова [**стартоператион**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-startoperation).</span><span class="sxs-lookup"><span data-stu-id="8008a-488">Create a separate thread to handle data extraction and call [**StartOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-startoperation).</span></span>
4.  <span data-ttu-id="8008a-489">Возвратите вызов [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , как и для обычной операции передачи данных.</span><span class="sxs-lookup"><span data-stu-id="8008a-489">Return the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) call, as you would for a normal data transfer operation.</span></span> <span data-ttu-id="8008a-490">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) будет возвращать и разблокировать источник удаления.</span><span class="sxs-lookup"><span data-stu-id="8008a-490">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) will return and unblock the drop source.</span></span> <span data-ttu-id="8008a-491">Не вызывайте метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) , чтобы указать результат оптимизированной операции перемещения или удаления.</span><span class="sxs-lookup"><span data-stu-id="8008a-491">Do not call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to indicate the outcome of an optimized move or delete-on-paste operation.</span></span> <span data-ttu-id="8008a-492">Дождитесь завершения операции.</span><span class="sxs-lookup"><span data-stu-id="8008a-492">Wait until the operation is finished.</span></span>
5.  <span data-ttu-id="8008a-493">Извлечение данных в фоновом потоке.</span><span class="sxs-lookup"><span data-stu-id="8008a-493">Extract the data on the background thread.</span></span> <span data-ttu-id="8008a-494">Основной поток целевого объекта разблокирован и свободен для продолжения.</span><span class="sxs-lookup"><span data-stu-id="8008a-494">The target's primary thread is unblocked and free to proceed.</span></span>
6.  <span data-ttu-id="8008a-495">Если при переносе данных была [оптимизирована операция перемещения](#handling-optimized-move-operations) или [удаления при вставке](#handling-delete-on-paste-operations) , вызовите функцию [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) , чтобы указать результат.</span><span class="sxs-lookup"><span data-stu-id="8008a-495">If the data transfer was an [optimized move](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operation, call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to indicate the outcome.</span></span>
7.  <span data-ttu-id="8008a-496">Уведомите объект данных о том, что извлечение завершено путем вызова [**ендоператион**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span><span class="sxs-lookup"><span data-stu-id="8008a-496">Notify the data object that extraction is finished by calling [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span></span>

 

 
