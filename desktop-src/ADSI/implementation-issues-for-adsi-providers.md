---
title: Проблемы реализации поставщиков ADSI
description: Проблемы реализации поставщиков ADSI
ms.assetid: 0be772aa-e7d8-4d34-b55a-162abfb0bfd4
ms.tgt_platform: multiple
keywords:
- Проблемы реализации поставщиков ADSI ADSI
- поставщики ADSI, реализация
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c4c362b04244580e448e7bb7bd78889e66db12fe
ms.sourcegitcommit: b0ebdefc3dcd5c04bede94091833aa1015a2f95c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104413748"
---
# <a name="implementation-issues-for-adsi-providers"></a><span data-ttu-id="88fd3-105">Проблемы реализации поставщиков ADSI</span><span class="sxs-lookup"><span data-stu-id="88fd3-105">Implementation Issues for ADSI Providers</span></span>

<span data-ttu-id="88fd3-106">Чтобы реализовать интерфейсы ADSI, сначала реализуйте COM-интерфейс [**идиректорйобжект**](/windows/desktop/api/Iads/nn-iads-idirectoryobject).</span><span class="sxs-lookup"><span data-stu-id="88fd3-106">To implement ADSI interfaces, first implement the COM interface [**IDirectoryObject**](/windows/desktop/api/Iads/nn-iads-idirectoryobject).</span></span> <span data-ttu-id="88fd3-107">Предоставляя этот интерфейс как минимальный уровень издержек, вы предоставляете клиентским приложениям элемент управления, необходимый для доступа к объектам каталога непосредственно из каталога, а не через кэш ADSI, что оптимизирует производительность сети.</span><span class="sxs-lookup"><span data-stu-id="88fd3-107">By providing this interface as a minimal overhead layer, you supply client applications the control required to access directory objects directly from the directory rather than through the ADSI cache, which optimizes network performance.</span></span> <span data-ttu-id="88fd3-108">Использование этого интерфейса также предоставит собственную реализацию с наибольшей гибкостью.</span><span class="sxs-lookup"><span data-stu-id="88fd3-108">Using this interface will also supply your own implementation with the most flexibility.</span></span>

<span data-ttu-id="88fd3-109">Во вторых, реализуйте основные интерфейсы интерфейса ADSI, [**iAds**](/windows/desktop/api/Iads/nn-iads-iads), [**иадсконтаинер**](/windows/desktop/api/Iads/nn-iads-iadscontainer), [**иадсколлектион**](/windows/desktop/api/Iads/nn-iads-iadscollection)и [**иадспропертивалуе**](/windows/desktop/api/Iads/nn-iads-iadspropertyvalue), [**иадспропертентри**](/windows/desktop/api/Iads/nn-iads-iadspropertyentry), [**иадспропертилист**](/windows/desktop/api/Iads/nn-iads-iadspropertylist) свойства кэша свойств.</span><span class="sxs-lookup"><span data-stu-id="88fd3-109">Second, implement the fundamental ADSI interfaces, [**IADs**](/windows/desktop/api/Iads/nn-iads-iads), [**IADsContainer**](/windows/desktop/api/Iads/nn-iads-iadscontainer), [**IADsCollection**](/windows/desktop/api/Iads/nn-iads-iadscollection), and the [**IADsPropertyValue**](/windows/desktop/api/Iads/nn-iads-iadspropertyvalue), [**IADsPropertyEntry**](/windows/desktop/api/Iads/nn-iads-iadspropertyentry), [**IADsPropertyList**](/windows/desktop/api/Iads/nn-iads-iadspropertylist) property cache interfaces.</span></span> <span data-ttu-id="88fd3-110">[**Иадсграуп**](/windows/desktop/api/Iads/nn-iads-iadsgroup) и [**иадсмемберс**](/windows/desktop/api/Iads/nn-iads-iadsmembers) также являются интерфейсами частого спроса на программное обеспечение системного администрирования.</span><span class="sxs-lookup"><span data-stu-id="88fd3-110">[**IADsGroup**](/windows/desktop/api/Iads/nn-iads-iadsgroup) and [**IADsMembers**](/windows/desktop/api/Iads/nn-iads-iadsmembers) are also interfaces in frequent demand by system administration software.</span></span>

<span data-ttu-id="88fd3-111">В третьих, реализуйте интерфейсы управления схемой, если ваша служба каталогов имеет базовую схему: [**иадскласс**](/windows/desktop/api/Iads/nn-iads-iadsclass), [**иадспроперти**](/windows/desktop/api/Iads/nn-iads-iadsproperty), [**иадссинтакс**](/windows/desktop/api/Iads/nn-iads-iadssyntax).</span><span class="sxs-lookup"><span data-stu-id="88fd3-111">Third, implement the schema management interfaces if your directory service has an underlying schema: [**IADsClass**](/windows/desktop/api/Iads/nn-iads-iadsclass), [**IADsProperty**](/windows/desktop/api/Iads/nn-iads-iadsproperty), [**IADsSyntax**](/windows/desktop/api/Iads/nn-iads-iadssyntax).</span></span> <span data-ttu-id="88fd3-112">Если базовая схема отсутствует, используйте эти интерфейсы для абстракции классов и свойств, используемых службой каталогов.</span><span class="sxs-lookup"><span data-stu-id="88fd3-112">If there is no underlying schema, use these interfaces to abstract the classes and properties used by the directory service.</span></span> <span data-ttu-id="88fd3-113">Схемы можно использовать для публикации функций службы каталогов в клиентах ADSI.</span><span class="sxs-lookup"><span data-stu-id="88fd3-113">Schemas can be used to publish the features of your directory service to ADSI clients.</span></span>

## <a name="collections"></a><span data-ttu-id="88fd3-114">Коллекции</span><span class="sxs-lookup"><span data-stu-id="88fd3-114">Collections</span></span>

<span data-ttu-id="88fd3-115">Компоненты поставщика ADSI могут следовать одной из трех моделей для кэширования коллекций во время перечисления.</span><span class="sxs-lookup"><span data-stu-id="88fd3-115">ADSI provider components can follow one of three models for caching collections during enumeration.</span></span> <span data-ttu-id="88fd3-116">Выбор модели кэширования определяет поведение ADSI при удалении объекта из коллекции из базовой службы каталогов, внешней для ADSI.</span><span class="sxs-lookup"><span data-stu-id="88fd3-116">The choice of a caching model determines the behavior of ADSI when an object in a collection is deleted from the underlying directory service external to ADSI.</span></span>

<span data-ttu-id="88fd3-117">К моделям кэширования относятся:</span><span class="sxs-lookup"><span data-stu-id="88fd3-117">The caching models include:</span></span>

-   <span data-ttu-id="88fd3-118">Предварительно кэшированные коллекции.</span><span class="sxs-lookup"><span data-stu-id="88fd3-118">Collections cached in advance.</span></span> <span data-ttu-id="88fd3-119">Коллекция экземпляров объектов извлекается из базовой службы каталогов целиком при вызове [**иадсколлектион:: Get \_ \_ NewEnum**](/windows/desktop/api/Iads/nf-iads-iadscollection-get__newenum) для создания нового объекта перечислителя.</span><span class="sxs-lookup"><span data-stu-id="88fd3-119">The collection of object instances is retrieved from the underlying directory service in its entirety when [**IADsCollection::get\_\_NewEnum**](/windows/desktop/api/Iads/nf-iads-iadscollection-get__newenum) is called to create a new enumerator object.</span></span> <span data-ttu-id="88fd3-120">Если исходный объект для экземпляра объекта Active Directory в извлеченной коллекции удаляется из базовой службы каталогов, клиент не распознает удаление до тех пор, пока не попытается получить доступ к коллекции с помощью методов [**iAds:: info**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) или [**iAds:: сетинфо**](/windows/desktop/api/Iads/nf-iads-iads-setinfo) .</span><span class="sxs-lookup"><span data-stu-id="88fd3-120">If the source object for an Active Directory object instance in the retrieved collection is deleted from the underlying directory service, the client does not recognize the deletion until a [**IADs::GetInfo**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) or [**IADs::SetInfo**](/windows/desktop/api/Iads/nf-iads-iads-setinfo) attempts to access the collection.</span></span>
-   <span data-ttu-id="88fd3-121">Коллекции с инкрементным кэшированием.</span><span class="sxs-lookup"><span data-stu-id="88fd3-121">Collections incrementally cached.</span></span> <span data-ttu-id="88fd3-122">Коллекция извлекается из базовой службы каталогов по одному объекту за раз, когда вызывается [**IEnumVARIANT:: Next**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-next) .</span><span class="sxs-lookup"><span data-stu-id="88fd3-122">The collection is retrieved from the underlying directory service one object at a time when [**IEnumVARIANT::Next**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-next) is called.</span></span> <span data-ttu-id="88fd3-123">[**IEnumVARIANT:: Reset**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-reset) вернет в начало коллекции в Cache, а **IEnumVARIANT:: Next** вернет кэшированные объекты до достижения конца кэша, после чего новые объекты будут добавлены из базового хранилища.</span><span class="sxs-lookup"><span data-stu-id="88fd3-123">[**IEnumVARIANT::Reset**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-reset) will return to the beginning of the collection in the cache and **IEnumVARIANT::Next** will return cached objects until the end of the cache is reached, at which point new objects will be added from the underlying store.</span></span> <span data-ttu-id="88fd3-124">Когда экземпляр объекта Active Directory находится в кэше, клиент не будет осведомлен о его удалении из базовой службы каталогов до тех пор, пока не попытается получить доступ к объекту с помощью параметра [**iAds::**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) [**сетинфо или iAds::.**](/windows/desktop/api/Iads/nf-iads-iads-setinfo)</span><span class="sxs-lookup"><span data-stu-id="88fd3-124">When an Active Directory object instance is in the cache the client will not become aware of its deletion from the underlying directory service until an [**IADs::GetInfo**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) or [**IADs::SetInfo**](/windows/desktop/api/Iads/nf-iads-iads-setinfo) attempts to access the object.</span></span>
-   <span data-ttu-id="88fd3-125">Коллекции не кэшированы.</span><span class="sxs-lookup"><span data-stu-id="88fd3-125">Collections not cached.</span></span> <span data-ttu-id="88fd3-126">Коллекция извлекается из базовой службы каталогов по одному объекту за раз, когда вызывается [**IEnumVARIANT:: Next**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-next) .</span><span class="sxs-lookup"><span data-stu-id="88fd3-126">The collection is retrieved from the underlying directory service one object at a time when [**IEnumVARIANT::Next**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-next) is called.</span></span> <span data-ttu-id="88fd3-127">[**IEnumVARIANT:: Reset**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-reset) вернет в начало коллекции в базовом хранилище.</span><span class="sxs-lookup"><span data-stu-id="88fd3-127">[**IEnumVARIANT::Reset**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-reset) will return to the beginning of the collection in the underlying store.</span></span> <span data-ttu-id="88fd3-128">Операции **IEnumVARIANT:: Next** и **IEnumVARIANT:: Reset** не могут получать удаленные объекты, так как объекты извлекаются по запросу из базовой службы каталогов.</span><span class="sxs-lookup"><span data-stu-id="88fd3-128">**IEnumVARIANT::Next** and **IEnumVARIANT::Reset** operations cannot retrieve deleted objects, because the objects are retrieved on-demand from the underlying directory service.</span></span> <span data-ttu-id="88fd3-129">Кэшируется только текущий объект; Если текущий объект удален, клиент не будет осведомлен о его удалении из базовой службы каталогов до тех пор, пока не попытается получить доступ к объекту с помощью методов [**iAds::**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) [**сетинфо или iAds::.**](/windows/desktop/api/Iads/nf-iads-iads-setinfo)</span><span class="sxs-lookup"><span data-stu-id="88fd3-129">Only the current object is cached; if the current object is deleted, the client will not become aware of its deletion from the underlying directory service until a [**IADs::GetInfo**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) or [**IADs::SetInfo**](/windows/desktop/api/Iads/nf-iads-iads-setinfo) attempts to access the object.</span></span>

<span data-ttu-id="88fd3-130">Независимо от модели кэширования следует помнить, что перечисление ADSI возвращает Active Directory интерфейсы службы вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="88fd3-130">Regardless of the caching model, be aware that ADSI enumeration returns Active Directory service interfaces to the caller.</span></span> <span data-ttu-id="88fd3-131">Чтобы избежать издержек при получении нового указателя на интерфейс, приложения ADSI должны кэшировать возвращаемые указатели интерфейса для объектов, которыми они предназначены.</span><span class="sxs-lookup"><span data-stu-id="88fd3-131">To avoid the overhead of obtaining a new interface pointer, ADSI applications should cache the returned interface pointers for objects that they intend to manipulate.</span></span> <span data-ttu-id="88fd3-132">Например, приложение Visual Basic, которое перечисляет контейнер и заполняет список именами, может кэшировать указатели интерфейса, связанные с именами, для последующего использования.</span><span class="sxs-lookup"><span data-stu-id="88fd3-132">For example, a Visual Basic application that enumerates a container and populates a list box with names can cache the interface pointers associated with the names for later use.</span></span> <span data-ttu-id="88fd3-133">Такой подход обеспечит большую производительность, чем заполнение списка во время перечисления и получение нового указателя интерфейса при выборе пользователем.</span><span class="sxs-lookup"><span data-stu-id="88fd3-133">This approach will provide greater performance than populating the list box during enumeration and obtaining a new interface pointer when the user makes a selection.</span></span>

## <a name="about-dispatch-ids"></a><span data-ttu-id="88fd3-134">Сведения об идентификаторах диспетчеризации</span><span class="sxs-lookup"><span data-stu-id="88fd3-134">About Dispatch IDs</span></span>

<span data-ttu-id="88fd3-135">[**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) — это интерфейс автоматизации, определенный com для контроллеров, которые не используют интерфейсы COM напрямую.</span><span class="sxs-lookup"><span data-stu-id="88fd3-135">[**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) is an Automation interface defined by COM for controllers that do not use COM interfaces directly.</span></span> <span data-ttu-id="88fd3-136">Доступ к объекту через **IDispatch** называется доступом с привязкой имени или с поздним связыванием, так как он происходит во время выполнения ("поздно") и использует строковые имена свойств и методов для разрешения ссылок ("имя").</span><span class="sxs-lookup"><span data-stu-id="88fd3-136">Accessing an object through **IDispatch** is called name-bound or late-bound access, because it occurs at run time ("late") and uses string names of properties and methods to resolve references ("name").</span></span> <span data-ttu-id="88fd3-137">Во время выполнения клиенты передают строковое имя свойства или метода, которые они хотят вызывать в метод [**IDispatch:: GetIdsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames)().</span><span class="sxs-lookup"><span data-stu-id="88fd3-137">At run time, clients pass the string name of the property or method they wish to call into the [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames)() method.</span></span> <span data-ttu-id="88fd3-138">Если свойство или метод существует в объекте, извлекается идентификатор диспетчеризации (DISPID) соответствующей функции.</span><span class="sxs-lookup"><span data-stu-id="88fd3-138">If the property or method exists on the object, the dispatch identifier (dispID) of the corresponding function is retrieved.</span></span> <span data-ttu-id="88fd3-139">Затем DISPID используется для выполнения функции с помощью [**IDispatch:: Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke)().</span><span class="sxs-lookup"><span data-stu-id="88fd3-139">The dispID is then used to execute the function through [**IDispatch::Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke)().</span></span> <span data-ttu-id="88fd3-140">При использовании **интерфейса IDispatch** свойства и методы в интерфейсах, предоставляемых одним объектом, отображаются в виде плоского списка.</span><span class="sxs-lookup"><span data-stu-id="88fd3-140">Using **IDispatch**, properties and methods on the interfaces exposed by a single object appear as a flat list.</span></span> <span data-ttu-id="88fd3-141">Поскольку доступ с ограниченным именем требует двух вызовов функций, он менее эффективен, чем непосредственное использование COM-интерфейса.</span><span class="sxs-lookup"><span data-stu-id="88fd3-141">Because name-bound access requires two function calls, it is less efficient than using a COM interface directly.</span></span> <span data-ttu-id="88fd3-142">Клиентам рекомендуется использовать COM-интерфейсы ADSI для объектов, когда необходимо учитывать производительность.</span><span class="sxs-lookup"><span data-stu-id="88fd3-142">Clients are encouraged to use the ADSI COM interfaces on the objects when performance is a consideration.</span></span> <span data-ttu-id="88fd3-143">Расширенные контроллеры автоматизации, такие как Visual Basic 4,0, могут вызывать другие COM-интерфейсы, а также **IDispatch**, если интерфейсы соответствуют ограничениям автоматизации для типов данных и передачи параметров.</span><span class="sxs-lookup"><span data-stu-id="88fd3-143">Advanced Automation controllers such as Visual Basic 4.0 can call other COM interfaces as well as **IDispatch**, if the interfaces comply with the Automation constraints for data types and parameter passing.</span></span>

<span data-ttu-id="88fd3-144">Поставщики ADSI создают идентификаторы DISPID динамически для каждого объекта Active Directory.</span><span class="sxs-lookup"><span data-stu-id="88fd3-144">ADSI providers generate dispIDs dynamically for each Active Directory object.</span></span> <span data-ttu-id="88fd3-145">Идентификаторы DISPID, полученные с помощью [**IDispatch:: GetIdsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) для заданного объекта, являются сгенерированными значениями, но не значениями, которые находятся в IDL для объекта.</span><span class="sxs-lookup"><span data-stu-id="88fd3-145">The dispIDs retrieved through [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) for a given object are the generated values, but not the values that are in the IDL for the object.</span></span> <span data-ttu-id="88fd3-146">Пользователи [**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) должны вызывать **GetIDsOfNames** для получения допустимых идентификаторов DispId во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="88fd3-146">[**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) users must call **GetIDsOfNames** to obtain valid dispIDs at run time.</span></span>

## <a name="type-information-and-type-libraries"></a><span data-ttu-id="88fd3-147">Сведения о типах и библиотеки типов</span><span class="sxs-lookup"><span data-stu-id="88fd3-147">Type Information and Type Libraries</span></span>

<span data-ttu-id="88fd3-148">Пакет SDK для ADSI предоставляет библиотеку типов Активедс. tlb, которая документирует все стандартные интерфейсы, поддерживаемые интерфейсом ADSI.</span><span class="sxs-lookup"><span data-stu-id="88fd3-148">The ADSI SDK supplies a type library, Activeds.tlb, that documents all the standard interfaces supported by ADSI.</span></span> <span data-ttu-id="88fd3-149">Поставщик должен предоставить схожую библиотеку типов для всех интерфейсов, найденных в Активедс. tlb, а также все дополнительные данные типа для интерфейсов, реализованных в компоненте поставщика.</span><span class="sxs-lookup"><span data-stu-id="88fd3-149">A provider must supply a similar type library for all interfaces found in Activeds.tlb, plus any additional type data for the interfaces implemented within the provider component.</span></span>

<span data-ttu-id="88fd3-150">Ниже приведен пример кода на IDL.</span><span class="sxs-lookup"><span data-stu-id="88fd3-150">The following is an IDL code example.</span></span>

``` syntax
[ object, uuid(IID_IADsXYZ), oleautomation, dual ]
interface IADsXYZ: IDispatch
{
// Read-only properties.
[propget]
HRESULT AReadOnlyProp ([out, retval]BSTR *pbstrAReadOnlyProp);
 
// Read/write properties.
[propget]
HRESULT AReadWriteProp ([out, retval]long *plAReadWriteProp);
[propput]
HRESULT AReadWriteProp ([in]long lAReadWriteProp);
 
// Methods.
HRESULT AMethod ([in]DATE dateInParameter,
[out, retval]BSTR *pbstrReturnValue);
};
```

## <a name="thread-safety"></a><span data-ttu-id="88fd3-151">Потокобезопасность</span><span class="sxs-lookup"><span data-stu-id="88fd3-151">Thread Safety</span></span>

<span data-ttu-id="88fd3-152">Модель COM описывает следующие три модели потоков.</span><span class="sxs-lookup"><span data-stu-id="88fd3-152">The Component Object Model (COM) describes the following three threading models.</span></span> <span data-ttu-id="88fd3-153">Приложения COM указывают, какая модель используется при инициализации библиотеки COM с помощью функций [**CoInitialize**](/windows/win32/api/objbase/nf-objbase-coinitialize) и [**CoInitializeEx**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) :</span><span class="sxs-lookup"><span data-stu-id="88fd3-153">COM applications indicate which model is in use when initializing the COM library using the [**CoInitialize**](/windows/win32/api/objbase/nf-objbase-coinitialize) and [**CoInitializeEx**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) functions:</span></span>

-   <span data-ttu-id="88fd3-154">Единый поток.</span><span class="sxs-lookup"><span data-stu-id="88fd3-154">Single threading.</span></span> <span data-ttu-id="88fd3-155">Однопотоковая модель предполагает выполнение одного потока выполнения в процессе. в дальнейшем предполагается, что для структур данных COM в процессе не требуется сериализация доступа.</span><span class="sxs-lookup"><span data-stu-id="88fd3-155">The single threaded model assumes a single thread of execution in a process, further assuming that COM data structures in a process need no access serialization.</span></span>
-   <span data-ttu-id="88fd3-156">Потоковое подразделение.</span><span class="sxs-lookup"><span data-stu-id="88fd3-156">Apartment threading.</span></span> <span data-ttu-id="88fd3-157">COM-объект связан с потоком, создавшим его.</span><span class="sxs-lookup"><span data-stu-id="88fd3-157">A COM object is associated with the thread that created it.</span></span> <span data-ttu-id="88fd3-158">Вызовы к объекту в другом потоке должны выполняться потоком, создавшим этот объект.</span><span class="sxs-lookup"><span data-stu-id="88fd3-158">Calls to an object on another thread must be executed by the thread that created that object.</span></span> <span data-ttu-id="88fd3-159">Для этого исходный поток вызывает прокси клиента, который упорядочивает вызов метода и доставляет его в функцию-заглушку сервера в целевом потоке через очередь сообщений Win32, связанную с целевым потоком.</span><span class="sxs-lookup"><span data-stu-id="88fd3-159">To accomplish this, the source thread invokes a client proxy which arranges the method call and delivers it to a server stub function in the destination thread through the Win32 message queue associated with the destination thread.</span></span>
-   <span data-ttu-id="88fd3-160">Свободная организация потоков.</span><span class="sxs-lookup"><span data-stu-id="88fd3-160">Free threading.</span></span> <span data-ttu-id="88fd3-161">Предполагается, что COM-объекты являются потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="88fd3-161">COM objects are assumed to be thread safe.</span></span> <span data-ttu-id="88fd3-162">Нескольким потокам разрешен доступ к любому объекту в процессе без сериализации.</span><span class="sxs-lookup"><span data-stu-id="88fd3-162">Multiple threads are allowed access to any object in the process with no serialization imposed.</span></span>

<span data-ttu-id="88fd3-163">ADSI не предполагает какую бы то ни было какую бы модель потоков.</span><span class="sxs-lookup"><span data-stu-id="88fd3-163">ADSI does not assume any particular threading model.</span></span> <span data-ttu-id="88fd3-164">Модули записи компонентов поставщика должны использовать модель бессрочных потоков и гарантировать согласованность их внутренних структур данных, защищая их от ненадежного потока, то есть с несогласованными обновлениями с помощью объектов синхронизации, таких как критические разделы или семафоры.</span><span class="sxs-lookup"><span data-stu-id="88fd3-164">Writers of provider components should assume the free threading model and guarantee the consistency of their internal data structures by protecting them from thread-unsafe, that is, uncoordinated, updates through the use of synchronization objects such as critical sections or semaphores.</span></span>

## <a name="object-locking"></a><span data-ttu-id="88fd3-165">Блокировка объектов</span><span class="sxs-lookup"><span data-stu-id="88fd3-165">Object Locking</span></span>

<span data-ttu-id="88fd3-166">ADSI не накладывает или не определяет схему блокировки объектов.</span><span class="sxs-lookup"><span data-stu-id="88fd3-166">ADSI does not impose or define an object-locking scheme.</span></span> <span data-ttu-id="88fd3-167">Поставщики пространств имен, поддерживающих сериализацию доступа с помощью блокировки, могут предоставлять базовую схему блокировки через расширения, зависящие от поставщика, для ADSI.</span><span class="sxs-lookup"><span data-stu-id="88fd3-167">Providers for namespaces that support access serialization using locking can expose the underlying locking scheme through provider-specific extensions to ADSI.</span></span>

## <a name="property-names-within-a-schema"></a><span data-ttu-id="88fd3-168">Имена свойств в схеме</span><span class="sxs-lookup"><span data-stu-id="88fd3-168">Property Names Within a Schema</span></span>

<span data-ttu-id="88fd3-169">ADSI представляет свойства как объекты свойств в контейнере схемы ADSI.</span><span class="sxs-lookup"><span data-stu-id="88fd3-169">ADSI represents properties as property objects within the ADSI schema container.</span></span> <span data-ttu-id="88fd3-170">Для этого необходимо, чтобы имена свойств были уникальными в пределах каждого контейнера схемы.</span><span class="sxs-lookup"><span data-stu-id="88fd3-170">This requires that property names be unique within each schema container.</span></span> <span data-ttu-id="88fd3-171">Поставщик должен убедиться в отсутствии конфликтов имен.</span><span class="sxs-lookup"><span data-stu-id="88fd3-171">The provider must ensure that there are no name collisions.</span></span>

## <a name="primary-interface"></a><span data-ttu-id="88fd3-172">Основной интерфейс</span><span class="sxs-lookup"><span data-stu-id="88fd3-172">Primary Interface</span></span>

<span data-ttu-id="88fd3-173">Если поставщик не может найти интерфейс, который должен быть возвращен в качестве основного интерфейса, возвращается **IID \_ iAds** .</span><span class="sxs-lookup"><span data-stu-id="88fd3-173">When a provider cannot identify which interface should be returned as the primary interface, **IID\_IADs** should be returned.</span></span> <span data-ttu-id="88fd3-174">Это обеспечивает доступ с ограниченным именем ко всем свойствам объекта через [**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) и методы [**iAds:: Get**](/windows/desktop/api/Iads/nf-iads-iads-get), [**iAds:: жетекс**](/windows/desktop/api/Iads/nf-iads-iads-getex), [**iads::P UT**](/windows/desktop/api/Iads/nf-iads-iads-put)и [**iAds::P утекс**](/windows/desktop/api/Iads/nf-iads-iads-putex) .</span><span class="sxs-lookup"><span data-stu-id="88fd3-174">This provides name-bound access to all properties of an object through [**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) and the [**IADs::Get**](/windows/desktop/api/Iads/nf-iads-iads-get), [**IADs::GetEx**](/windows/desktop/api/Iads/nf-iads-iads-getex), [**IADs::Put**](/windows/desktop/api/Iads/nf-iads-iads-put), and [**IADs::PutEx**](/windows/desktop/api/Iads/nf-iads-iads-putex) methods.</span></span>

 

 