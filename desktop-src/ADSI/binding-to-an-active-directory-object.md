---
title: Привязка к объекту Active Directory
description: Наиболее распространенным способом привязки к объекту Active Directory является использование функции GetObject между клиентом ADSI и поставщиком ADSI.
ms.assetid: d278ea26-2fd5-4343-8d87-ff85515325fb
ms.tgt_platform: multiple
keywords:
- Привязка к объекту Active Directory ADSI
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 59992dbc88c00be6306dec24523ec4e030d4a516
ms.sourcegitcommit: b0ebdefc3dcd5c04bede94091833aa1015a2f95c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "103891069"
---
# <a name="binding-to-an-active-directory-object"></a><span data-ttu-id="b823d-104">Привязка к объекту Active Directory</span><span class="sxs-lookup"><span data-stu-id="b823d-104">Binding to an Active Directory Object</span></span>

<span data-ttu-id="b823d-105">Наиболее распространенным способом привязки к объекту Active Directory является использование функции **GetObject** между клиентом ADSI и поставщиком ADSI.</span><span class="sxs-lookup"><span data-stu-id="b823d-105">The most common way to bind to an Active Directory object is to use the **GetObject** function between an ADSI client and an ADSI provider.</span></span> <span data-ttu-id="b823d-106">Это также самый простой способ продемонстрировать, как компонент поставщика получает запросы и службы.</span><span class="sxs-lookup"><span data-stu-id="b823d-106">This is also the easiest way to show how the provider component receives and services requests.</span></span> <span data-ttu-id="b823d-107">Как функция API ADSI [**адсжетобжект**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) , так и функция Visual Basic **GetObject** следуют тем же действиям для привязки.</span><span class="sxs-lookup"><span data-stu-id="b823d-107">Both the ADSI API function [**ADsGetObject**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) or the Visual Basic function **GetObject** follow the same steps for binding.</span></span>

<span data-ttu-id="b823d-108">В этом примере предположим, что клиент ADSI является приложением для просмотра ADSI, которое получило значение ADsPath "Sample://Seattle/Redmond/Shelly" из пользовательского интерфейса (1).</span><span class="sxs-lookup"><span data-stu-id="b823d-108">For this example, assume the ADSI client is an ADSI viewer application that has received the ADsPath "Sample://Seattle/Redmond/Shelly" from its user interface (1).</span></span> <span data-ttu-id="b823d-109">На следующем рисунке подробно описывается последовательность событий путем нумерации стрелок потока.</span><span class="sxs-lookup"><span data-stu-id="b823d-109">The following figure details the sequence of events by numbering the flow arrows.</span></span>

![подробное представление компонентов ADSI](images/dscsex.png)

<span data-ttu-id="b823d-111">На предыдущем рисунке клиент инициирует запрос указателя интерфейса на объект Active Directory, представленный параметром ADsPath "Sample://Seattle/Redmond/Shelly" из служб ADSI (2).</span><span class="sxs-lookup"><span data-stu-id="b823d-111">In the preceding figure, the client initiates the request for an interface pointer on the Active Directory object represented by the ADsPath "Sample://Seattle/Redmond/Shelly" from ADSI services (2).</span></span> <span data-ttu-id="b823d-112">Во время инициализации программное обеспечение служб заполняет таблицу установленных программных идентификаторов поставщика (ProgID) из реестра ("LDAP:", "Sample:", "WinNT:" и т. д.) и связывает их с соответствующими **идентификаторами CLSID**, которые указывают соответствующий программный модуль.</span><span class="sxs-lookup"><span data-stu-id="b823d-112">During initialization, the services software populated a table of installed provider programmatic identifiers (ProgIDs) from the registry ("LDAP:","Sample:", "WinNT:", and so on) and paired them with the matching **CLSID** s which identify the appropriate software module.</span></span>

<span data-ttu-id="b823d-113">Сервер ADSI проверяет, существует ли идентификатор ProgID, в данном случае "Sample:", в расположении ADsPath.</span><span class="sxs-lookup"><span data-stu-id="b823d-113">The ADSI server verifies that the ProgID, in this case "Sample:", exists in the ADsPath.</span></span> <span data-ttu-id="b823d-114">Затем он создает контекст привязки для оптимизации ссылок на этот объект и вызывает стандартную функцию COM [**мкпарседисплайнаме**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) для создания моникера com, который может использоваться для поиска и привязки к объекту, представляющему пользователя "Шелли".</span><span class="sxs-lookup"><span data-stu-id="b823d-114">It then creates a bind context to optimize further references to this object, and calls the standard COM function [**MkParseDisplayName**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) to create a COM moniker that can be used to find and bind to the object that represents the user "Shelly".</span></span>

<span data-ttu-id="b823d-115">В следующем разделе имена файлов в примере исходного кода компонента поставщика включаются в круглые скобки там, где это уместно.</span><span class="sxs-lookup"><span data-stu-id="b823d-115">In the following section, the file names of the example provider component source code are included in parentheses where appropriate.</span></span>

<span data-ttu-id="b823d-116">Как и в других реализациях COM-сервера, [**мкпарседисплайнаме**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) изучает идентификатор ProgID и ищет правильный **идентификатор CLSID** в реестре (3) для поиска соответствующего кода фабрики класса (кпровкф. cpp) в соответствующей реализации поставщика (4).</span><span class="sxs-lookup"><span data-stu-id="b823d-116">As in other COM server implementations, [**MkParseDisplayName**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) examines the ProgID, and looks up the proper **CLSID** in the registry (3) to find the corresponding provider-supplied class factory code (Cprovcf.cpp) in the appropriate provider implementation (4).</span></span> <span data-ttu-id="b823d-117">Этот код создает исходный объект верхнего уровня, реализующий метод [**ипарседисплайнаме::P арседисплайнаме**](/windows/win32/api/oleidl/nf-oleidl-iparsedisplayname-parsedisplayname) (кпров. cpp).</span><span class="sxs-lookup"><span data-stu-id="b823d-117">This code creates an initial top-level object that implements the [**IParseDisplayName::ParseDisplayName**](/windows/win32/api/oleidl/nf-oleidl-iparsedisplayname-parsedisplayname) method (Cprov.cpp).</span></span> <span data-ttu-id="b823d-118">Реализация поставщика **парседисплайнаме** разрешает путь в собственном пространстве имен поставщика.</span><span class="sxs-lookup"><span data-stu-id="b823d-118">The provider's implementation of **ParseDisplayName** resolves the path in the provider's own namespace.</span></span> <span data-ttu-id="b823d-119">В итоге вызывается Адсобжект и вызывается средство синтаксического анализа, предоставляемое вместе с компонентом поставщика (Parse. cpp), чтобы проверить синтаксическую правильность определения ADsPath для этого пространства имен.</span><span class="sxs-lookup"><span data-stu-id="b823d-119">This eventually calls ADsObject and invokes the parser supplied with the provider component (Parse.cpp) to verify that the ADsPath is syntactically correct for this namespace.</span></span>

<span data-ttu-id="b823d-120">**GetObject,** определенный в жетобж. cpp, определяет, является ли запрошенный объект объектом пространства имен, объектом схемы или другим типом объекта.</span><span class="sxs-lookup"><span data-stu-id="b823d-120">**GetObject**, that is defined in Getobj.cpp, then determines if the object requested is a namespace object, a schema object, or some other type of object.</span></span> <span data-ttu-id="b823d-121">Если один из первых двух элементов, то создается этот тип объекта класса схемы и извлекается соответствующий указатель интерфейса.</span><span class="sxs-lookup"><span data-stu-id="b823d-121">If either of the first two, that type of schema class object is created and the appropriate interface pointer retrieved.</span></span> <span data-ttu-id="b823d-122">В противном случае путь к каталогу примеров создается из ADsPath (например, " \\ Сиэтл \\ Redmond \\ Шелли", но в другой службе каталога это может быть " \\ OU = Сиэтл \\ OU = Redmond \\ CN = Шелли"), а управление передается сампледсопенобжект, которое открывает объект в примере хранилища данных, а также получает тип объекта (в данном случае "User") (5).</span><span class="sxs-lookup"><span data-stu-id="b823d-122">Otherwise the Sample directory path is created from the ADsPath (for example, "\\Seattle\\Redmond\\Shelly", but in a different directory service it might have had to be "\\OU=Seattle\\OU=Redmond\\CN=Shelly") and control passes to SampleDSOpenObject which opens the object in the example data storage and also retrieves its object type (in this case, "User") (5).</span></span>

<span data-ttu-id="b823d-123">После сбора данных создается новый объект (6), который представляет элемент, описываемый в параметре ADsPath, и извлекается указатель на интерфейс [**IUnknown**](/windows/win32/api/unknwn/nn-unknwn-iunknown) на этом объекте.</span><span class="sxs-lookup"><span data-stu-id="b823d-123">With the data gathered, a new object is created (6) to represent the item described by the ADsPath, and a pointer to the [**IUnknown**](/windows/win32/api/unknwn/nn-unknwn-iunknown) interface on that object is retrieved.</span></span> <span data-ttu-id="b823d-124">В этом случае создается универсальный объект Active Directory, поддерживающий методы **IUnknown** и [**iAds**](/windows/desktop/api/Iads/nn-iads-iads) (Кженобж. cpp, Core. cpp).</span><span class="sxs-lookup"><span data-stu-id="b823d-124">In this case, a generic Active Directory object is created that supports the **IUnknown** and [**IADs**](/windows/desktop/api/Iads/nn-iads-iads) methods (Cgenobj.cpp, Core.cpp).</span></span> <span data-ttu-id="b823d-125">Подсистема Ксампледсженобжект:: Аллокатеженобжект считывает данные библиотеки типов для создания правильных записей диспетчеризации для этих новых объектов, чтобы обеспечить поддержку [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch).</span><span class="sxs-lookup"><span data-stu-id="b823d-125">The CSampleDSGenObject::AllocateGenObject routine reads the type library data to create the proper dispatch entries for these new objects in order to support [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch).</span></span>

<span data-ttu-id="b823d-126">Заключение указателя этого интерфейса в моникер завершает функцию Ресолвепаснаме (Кпров. cpp) и анализирует отображаемое имя.</span><span class="sxs-lookup"><span data-stu-id="b823d-126">Wrapping this interface pointer into a moniker completes the ResolvePathName (Cprov.cpp) function and parses the display name.</span></span>

<span data-ttu-id="b823d-127">Все COM-объекты, созданные во время этого процесса, кэшируются по соображениям производительности и управляются через контекст привязки.</span><span class="sxs-lookup"><span data-stu-id="b823d-127">All the COM objects created during this process are cached for performance reasons and managed through the binding context.</span></span> <span data-ttu-id="b823d-128">Это повышает производительность для других операций с тем же объектом, который сразу же следует за привязкой моникера.</span><span class="sxs-lookup"><span data-stu-id="b823d-128">This improves performance for other operations on the same object that immediately follows the moniker binding.</span></span>

<span data-ttu-id="b823d-129">Этот правильно сформированный Active Directory объект теперь запрашивается по идентификатору интерфейса, запрошенному для начального вызова [**адсжетобжект**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) , и получает указатель на этот интерфейс (7) и передается обратно серверу ADSI клиенту (8&9).</span><span class="sxs-lookup"><span data-stu-id="b823d-129">This well-formed Active Directory object is now queried for the interface identifier requested for the initial [**ADsGetObject**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) call and a pointer to that interface is retrieved (7) and passed back through the ADSI server to the client (8&9).</span></span> <span data-ttu-id="b823d-130">После этого клиент работает непосредственно с компонентом поставщика через методы интерфейса до тех пор, пока не будет удовлетворен первоначальный запрос (10).</span><span class="sxs-lookup"><span data-stu-id="b823d-130">From then on, the client works directly with the provider component through the interface methods until the initial request is satisfied (10).</span></span>

<span data-ttu-id="b823d-131">Кроме того, запросы данных объектов от клиента обычно принимают форму запросов на получение свойств, и все они оптимизируются посредством реализации поставщика кэша свойств (Кпропс. cpp).</span><span class="sxs-lookup"><span data-stu-id="b823d-131">Furthermore, requests for object data from the client usually take the form of requests for property gets and puts, all of which are optimized through the provider implementation of a property cache (Cprops.cpp).</span></span> <span data-ttu-id="b823d-132">Интеллектуальная упаковка и распаковка данных, часто включая копирование и освобождение структур и строк, между собственными типами данных в примере операционной системы компонента поставщика и типом [**варианта**](/windows/win32/api/oaidl/ns-oaidl-variant) автоматизации, поддерживаемым интерфейсом ADSI, происходит перед загрузкой свойств в кэш (смпопер. cpp).</span><span class="sxs-lookup"><span data-stu-id="b823d-132">Intelligently packing and unpacking data, often including copying and freeing structures and strings, between the native data types on the example provider component's operating system and the Automation [**VARIANT**](/windows/win32/api/oaidl/ns-oaidl-variant) type supported by ADSI takes place before the properties are loaded into the cache (Smpoper.cpp).</span></span>

<span data-ttu-id="b823d-133">Пример компонента поставщика разработан таким образом, чтобы фактические вызовы операционной системы были логически изолированы от компонента поставщика, создав программное обеспечение, переносимое в более чем одну операционную систему (Регдсапи. cpp).</span><span class="sxs-lookup"><span data-stu-id="b823d-133">The example provider component is designed so that the actual calls to the operating system are logically isolated from the provider component, creating software portable to more than one operating system (RegDSAPI.cpp).</span></span>

 

 