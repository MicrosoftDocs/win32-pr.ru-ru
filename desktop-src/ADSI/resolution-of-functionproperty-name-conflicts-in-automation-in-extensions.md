---
title: Разрешение конфликтов имен функций и свойств в автоматизации в расширениях
description: 'В этом разделе: \ 0034; объект \ 0034; Указывает объект в целом, как клиент ADSI просматривает его. То есть ADSI и все его расширения.'
ms.assetid: 76207326-879e-408b-8004-06d940401a41
ms.tgt_platform: multiple
keywords:
- Разрешение конфликтов имен функций и свойств в автоматизации в расширениях
- расширения ADSI, разрешение конфликтов имен функций и свойств в службе автоматизации
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d9a7ac99b99ecdf0ee1b940f066d9e8166a15542
ms.sourcegitcommit: b0ebdefc3dcd5c04bede94091833aa1015a2f95c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104413720"
---
# <a name="resolution-of-functionproperty-name-conflicts-in-automation-in-extensions"></a>Разрешение конфликтов имен функций и свойств в автоматизации в расширениях

В этом разделе «Object» обозначает объект в целом, как клиент ADSI просматривает его. То есть ADSI и все его расширения.

## <a name="same-function-name-with-the-same-parameters"></a>Имя функции с одинаковыми параметрами

Если два или более сдвоенных интерфейса [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) в объекте поддерживают свойство или метод с тем же именем, например **func1**, то вызов определяется по следующим критериям. Если клиент имеет указатель на один из сдвоенных интерфейсов, поддерживающих метод с именем **func1** , а среда автоматизации поддерживает доступ vtable, **func1** вызывается напрямую через доступ к таблице vtable ADSI.

Если любое из указанных выше условий имеет значение false, то для вызова **func1** вызываются [**IDispatch:: GetIdsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) и [**IDispatch:: Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke) .

Дополнительные сведения и краткое описание того, как клиент может добавить указатель на сдвоенный интерфейс, а также описания типов сред, поддерживающих доступ к таблице vtable, см. в разделе [позднее связывание и доступ vtable в модели расширения ADSI](late-binding-vs--vtable-access-in-the-adsi-extension-model.md).

Так как все объекты расширения переправляют функции [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) обратно в агрегатор, агрегатор определяет, какой **func1** вызывается. Правила:

-   Если какой-либо интерфейс, и будет только один из них, в агрегаторе (ADSI) поддерживает функцию с именем **func1**, агрегатор вызывает собственный **func1**.
-   В противном случае агрегатор проходит через все свои расширения в порядке, указанном в реестре, и находит первое расширение, реализующее функцию с именем **func1**. Возможно, но маловероятно, что несколько сдвоенных интерфейсов [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) в этом первом расширении имеют функцию с именем **func1**. Расширение должно определять, какой **func1** всегда должен вызываться в службе автоматизации.

## <a name="same-function-name-with-different-parameters"></a>Имя функции с разными параметрами

В предыдущем разделе было рассмотрено разрешение конфликтов имен функций, то есть имена функций с одинаковыми именами функций и списком параметров, например число, тип и порядок, при возникновении в службе автоматизации. Что делать, если две функции имеют одинаковые имена, но разные параметры? Если клиент ADSI вызывает функцию с помощью [**IDispatch:: GetIdsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) без использования нескольких имен для указания параметров, модель расширения ADSI не может устранить неоднозначность функций. В соответствии со схемой разрешения, описанной выше, первое расширение в реестре, которое поддерживает эту функцию через один из своих интерфейсов, вызывает ее версию, и вызов может завершиться ошибкой или привести к неправильным результатам.

Пример:

-   Extn1 (сначала в реестре с классом CA — более высокий приоритет) поддерживает **IInterface1**.
-   Extn2 (третья в реестре с классом CA — низший приоритет) поддерживает **IInterface2**.
-   **IInterface1** поддерживает **Method1 (тип Param1, int Param2)**.
-   **IInterface2** поддерживает **Method1 (тип Param1)**.

Клиент ADSI имеет указатель интерфейса [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) на объект CA класса. Он хочет вызвать **IInterface2:: Method1**. Если клиент вызывает "Пдиспатч->GetIDsOfNames (IID \_ null, ргсзнамес, 1, My \_ LCID, ргдиспид)", просто сохранив имя функции "Method1" в *ргсзнамес \[ 0 \]*, тогда **IInterface1:: Method1** вместо нужного метода **IInterface2:: Method1** вызывается ошибка, так как число параметров отличается.

Чтобы устранить эту проблему, разработчики расширений могут добавить префиксы своих функций к собственным идентификаторам и избежать проектирования интерфейсов, использующих функции с одинаковыми именами, но разными параметрами.

Если возникает конфликт имен, клиенты ADSI могут избежать проблемы путем прямого доступа к vtable, если интерфейс является сдвоенным интерфейсом. Если прямой доступ к таблице vtable невозможен, клиенты ADSI должны вызывать [**IDispatch:: GetIdsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) с несколькими именами, указывая имена функций, а также параметры в массиве *ргсзнамес* , описанные выше.

Visual Basic 5 не вызывает функцию [**IDispatch:: GetIdsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) с несколькими именами. То есть он передает только имя функции в **GetIDsOfNames**, но не аргументы. Однако Visual Basic 5 позволяет пользователям вызывать функцию путем прямого доступа к таблице vtable вместо вызова функции **IDispatch:: GetIdsOfNames** , если интерфейс является сдвоенным интерфейсом. Если это возможно, разработчики должны использовать прямой доступ к vtable.

Дополнительные сведения об устранении конфликтов имен см. в разделе [пример разрешения конфликтов имен функций](example-for-resolving-function-name-conflicts.md).

 

 