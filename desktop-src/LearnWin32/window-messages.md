---
title: Сообщения окна (начало работы с Win32 и C++)
description: .
ms.assetid: 90c20456-44ed-4f0f-a6d3-b6c5660f0bc7
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0e7ea533a89cb0ccf7053945cd693cc6e1ef5c28
ms.sourcegitcommit: 35bb565804eaeed7ac5503595753f59d120076dd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/09/2021
ms.locfileid: "105684722"
---
# <a name="window-messages-get-started-with-win32-and-c"></a><span data-ttu-id="f6d06-103">Сообщения окна (начало работы с Win32 и C++)</span><span class="sxs-lookup"><span data-stu-id="f6d06-103">Window Messages (Get Started with Win32 and C++)</span></span>

<span data-ttu-id="f6d06-104">Приложение графического пользовательского интерфейса должно реагировать на события от пользователя и из операционной системы.</span><span class="sxs-lookup"><span data-stu-id="f6d06-104">A GUI application must respond to events from the user and from the operating system.</span></span>

- <span data-ttu-id="f6d06-105">К **событиям пользователя** относятся все способы взаимодействия с программой: щелчки мыши, клавиши, жесты с сенсорным экраном и т. д.</span><span class="sxs-lookup"><span data-stu-id="f6d06-105">**Events from the user** include all the ways that someone can interact with your program: mouse clicks, key strokes, touch-screen gestures, and so on.</span></span>
- <span data-ttu-id="f6d06-106">**События операционной системы** включают все «вне» программы, которая может повлиять на работу программы.</span><span class="sxs-lookup"><span data-stu-id="f6d06-106">**Events from the operating system** include anything "outside" of the program that can affect how the program behaves.</span></span> <span data-ttu-id="f6d06-107">Например, пользователь может подключить новое аппаратное устройство, или Windows может перейти в режим пониженного энергопотребления (спящий или спящий режим).</span><span class="sxs-lookup"><span data-stu-id="f6d06-107">For example, the user might plug in a new hardware device, or Windows might enter a lower-power state (sleep or hibernate).</span></span>

<span data-ttu-id="f6d06-108">Эти события могут возникать в любое время, пока программа выполняется, в почти в любом порядке.</span><span class="sxs-lookup"><span data-stu-id="f6d06-108">These events can occur at any time while the program is running, in almost any order.</span></span> <span data-ttu-id="f6d06-109">Как структурировать программу, поток выполнения которой нельзя прогнозировать заранее?</span><span class="sxs-lookup"><span data-stu-id="f6d06-109">How do you structure a program whose flow of execution cannot be predicted in advance?</span></span>

<span data-ttu-id="f6d06-110">Для решения этой проблемы в Windows используется модель передачи сообщений.</span><span class="sxs-lookup"><span data-stu-id="f6d06-110">To solve this problem, Windows uses a message-passing model.</span></span> <span data-ttu-id="f6d06-111">Операционная система взаимодействует с окном приложения, передавая ему сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6d06-111">The operating system communicates with your application window by passing messages to it.</span></span> <span data-ttu-id="f6d06-112">Сообщение — это просто числовой код, обозначающий определенное событие.</span><span class="sxs-lookup"><span data-stu-id="f6d06-112">A message is simply a numeric code that designates a particular event.</span></span> <span data-ttu-id="f6d06-113">Например, если пользователь нажимает левую кнопку мыши, окно получает сообщение, в котором содержится следующий код сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6d06-113">For example, if the user presses the left mouse button, the window receives a message that has the following message code.</span></span>

```C++
#define WM_LBUTTONDOWN    0x0201
```

<span data-ttu-id="f6d06-114">С некоторыми сообщениями связаны данные.</span><span class="sxs-lookup"><span data-stu-id="f6d06-114">Some messages have data associated with them.</span></span> <span data-ttu-id="f6d06-115">Например, сообщение [**WM \_ лбуттондовн**](/windows/desktop/inputdev/wm-lbuttondown) содержит координаты x и y курсора мыши.</span><span class="sxs-lookup"><span data-stu-id="f6d06-115">For example, the [**WM\_LBUTTONDOWN**](/windows/desktop/inputdev/wm-lbuttondown) message includes the x-coordinate and y-coordinate of the mouse cursor.</span></span>

<span data-ttu-id="f6d06-116">Чтобы передать сообщение в окно, операционная система вызывает процедуру окна, зарегистрированную для этого окна.</span><span class="sxs-lookup"><span data-stu-id="f6d06-116">To pass a message to a window, the operating system calls the window procedure registered for that window.</span></span> <span data-ttu-id="f6d06-117">(И теперь вы понимаете, для чего предназначена процедура окна.)</span><span class="sxs-lookup"><span data-stu-id="f6d06-117">(And now you know what the window procedure is for.)</span></span>

## <a name="the-message-loop"></a><span data-ttu-id="f6d06-118">Цикл обработки сообщений</span><span class="sxs-lookup"><span data-stu-id="f6d06-118">The Message Loop</span></span>

<span data-ttu-id="f6d06-119">Приложение получит тысячи сообщений во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6d06-119">An application will receive thousands of messages while it runs.</span></span> <span data-ttu-id="f6d06-120">(Рассмотрите, что при каждом нажатии кнопки мыши и щелчке мышью создается сообщение.) Кроме того, приложение может иметь несколько окон, каждое из которых имеет собственную процедуру окна.</span><span class="sxs-lookup"><span data-stu-id="f6d06-120">(Consider that every keystroke and mouse-button click generates a message.) Additionally, an application can have several windows, each with its own window procedure.</span></span> <span data-ttu-id="f6d06-121">Как программа получает все эти сообщения и доставляет их в правильную процедуру окна?</span><span class="sxs-lookup"><span data-stu-id="f6d06-121">How does the program receive all these messages and deliver them to the correct window procedure?</span></span> <span data-ttu-id="f6d06-122">Приложению требуется цикл для извлечения сообщений и их отправки в правильные окна.</span><span class="sxs-lookup"><span data-stu-id="f6d06-122">The application needs a loop to retrieve the messages and dispatch them to the correct windows.</span></span>

<span data-ttu-id="f6d06-123">Для каждого потока, создающего окно, операционная система создает очередь для сообщений окна.</span><span class="sxs-lookup"><span data-stu-id="f6d06-123">For each thread that creates a window, the operating system creates a queue for window messages.</span></span> <span data-ttu-id="f6d06-124">Эта очередь содержит сообщения для всех окон, созданных в этом потоке.</span><span class="sxs-lookup"><span data-stu-id="f6d06-124">This queue holds messages for all the windows that are created on that thread.</span></span> <span data-ttu-id="f6d06-125">Сама очередь скрыта от программы.</span><span class="sxs-lookup"><span data-stu-id="f6d06-125">The queue itself is hidden from your program.</span></span> <span data-ttu-id="f6d06-126">Управлять очередью напрямую нельзя.</span><span class="sxs-lookup"><span data-stu-id="f6d06-126">You cannot manipulate the queue directly.</span></span> <span data-ttu-id="f6d06-127">Тем не менее можно извлечь сообщение из очереди, вызвав функцию "функция [**onmessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) ".</span><span class="sxs-lookup"><span data-stu-id="f6d06-127">However, you can pull a message from the queue by calling the [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) function.</span></span>

```C++
MSG msg;
GetMessage(&msg, NULL, 0, 0);
```

<span data-ttu-id="f6d06-128">Эта функция удаляет первое сообщение из заголовка очереди.</span><span class="sxs-lookup"><span data-stu-id="f6d06-128">This function removes the first message from the head of the queue.</span></span> <span data-ttu-id="f6d06-129">Если очередь пуста, функция блокируется до постановки в очередь другого сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6d06-129">If the queue is empty, the function blocks until another message is queued.</span></span> <span data-ttu-id="f6d06-130">[**Тот факт, что блоки**](/windows/desktop/api/winuser/nf-winuser-getmessage) псевдо не сделают программу неотвечающей.</span><span class="sxs-lookup"><span data-stu-id="f6d06-130">The fact that [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) blocks will not make your program unresponsive.</span></span> <span data-ttu-id="f6d06-131">Если сообщений нет, программа не будет выполнять никаких действий.</span><span class="sxs-lookup"><span data-stu-id="f6d06-131">If there are no messages, there is nothing for the program to do.</span></span> <span data-ttu-id="f6d06-132">Если необходимо выполнить фоновую обработку, можно создать дополнительные потоки, которые продолжают выполняться, а **Message** ожидает другого сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6d06-132">If you have to perform background processing, you can create additional threads that continue to run while **GetMessage** waits for another message.</span></span> <span data-ttu-id="f6d06-133">(См. раздел [предотвращение узких мест в процедуре окна](writing-the-window-procedure.md).)</span><span class="sxs-lookup"><span data-stu-id="f6d06-133">(See [Avoiding Bottlenecks in Your Window Procedure](writing-the-window-procedure.md).)</span></span>

<span data-ttu-id="f6d06-134">Первым параметром для [**параметра MSG является адрес**](/windows/desktop/api/winuser/nf-winuser-getmessage) структуры [**сообщения**](/windows/win32/api/winuser/ns-winuser-msg) .</span><span class="sxs-lookup"><span data-stu-id="f6d06-134">The first parameter of [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) is the address of a [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) structure.</span></span> <span data-ttu-id="f6d06-135">Если функция выполнена, она заполняет структуру **MSG** сведениями о сообщении.</span><span class="sxs-lookup"><span data-stu-id="f6d06-135">If the function succeeds, it fills in the **MSG** structure with information about the message.</span></span> <span data-ttu-id="f6d06-136">Сюда входят целевое окно и код сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6d06-136">This includes the target window and the message code.</span></span> <span data-ttu-id="f6d06-137">Другие три параметра позволяют фильтровать сообщения, получаемые из очереди.</span><span class="sxs-lookup"><span data-stu-id="f6d06-137">The other three parameters let you filter which messages you get from the queue.</span></span> <span data-ttu-id="f6d06-138">Почти во всех случаях эти параметры будут заданы равными нулю.</span><span class="sxs-lookup"><span data-stu-id="f6d06-138">In almost all cases, you will set these parameters to zero.</span></span>

<span data-ttu-id="f6d06-139">Несмотря на [**то, что структура сообщения**](/windows/win32/api/winuser/ns-winuser-msg) содержит сведения о сообщении, вы почти никогда не будете изучать эту структуру напрямую.</span><span class="sxs-lookup"><span data-stu-id="f6d06-139">Although the [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) structure contains information about the message, you will almost never examine this structure directly.</span></span> <span data-ttu-id="f6d06-140">Вместо этого он будет передан непосредственно двум другим функциям.</span><span class="sxs-lookup"><span data-stu-id="f6d06-140">Instead, you will pass it directly to two other functions.</span></span>

```C++
TranslateMessage(&msg); 
DispatchMessage(&msg);
```

<span data-ttu-id="f6d06-141">Функция [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) связана с вводом с клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="f6d06-141">The [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) function is related to keyboard input.</span></span> <span data-ttu-id="f6d06-142">Он преобразует нажатия клавиш (Клавиша вниз, клавиша вверх) в символы.</span><span class="sxs-lookup"><span data-stu-id="f6d06-142">It translates keystrokes (key down, key up) into characters.</span></span> <span data-ttu-id="f6d06-143">Вам не обязательно быть уверенным в том, как работает эта функция. просто не забудьте вызвать ее перед [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage).</span><span class="sxs-lookup"><span data-stu-id="f6d06-143">You do not really have to know how this function works; just remember to call it before [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage).</span></span> <span data-ttu-id="f6d06-144">Если вас интересуют, ссылка на документацию MSDN предоставит вам дополнительные сведения.</span><span class="sxs-lookup"><span data-stu-id="f6d06-144">The link to the MSDN documentation will give you more information, if you are curious.</span></span>

<span data-ttu-id="f6d06-145">Функция [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) сообщает операционной системе о необходимости вызова оконной процедуры окна, которая является целью сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6d06-145">The [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) function tells the operating system to call the window procedure of the window that is the target of the message.</span></span> <span data-ttu-id="f6d06-146">Иными словами, операционная система ищет маркер окна в своей таблице окон, находит указатель на функцию, связанный с окном, и вызывает функцию.</span><span class="sxs-lookup"><span data-stu-id="f6d06-146">In other words, the operating system looks up the window handle in its table of windows, finds the function pointer associated with the window, and invokes the function.</span></span>

<span data-ttu-id="f6d06-147">Например, предположим, что пользователь нажимает левую кнопку мыши.</span><span class="sxs-lookup"><span data-stu-id="f6d06-147">For example, suppose that the user presses the left mouse button.</span></span> <span data-ttu-id="f6d06-148">Это приводит к цепочке событий:</span><span class="sxs-lookup"><span data-stu-id="f6d06-148">This causes a chain of events:</span></span>

1. <span data-ttu-id="f6d06-149">Операционная система помещает сообщение [**WM \_ лбуттондовн**](/windows/desktop/inputdev/wm-lbuttondown) в очередь сообщений.</span><span class="sxs-lookup"><span data-stu-id="f6d06-149">The operating system puts a [**WM\_LBUTTONDOWN**](/windows/desktop/inputdev/wm-lbuttondown) message on the message queue.</span></span>
2. <span data-ttu-id="f6d06-150">Ваша программа вызывает функцию WITH [**Message**](/windows/desktop/api/winuser/nf-winuser-getmessage) .</span><span class="sxs-lookup"><span data-stu-id="f6d06-150">Your program calls the [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) function.</span></span>
3. <span data-ttu-id="f6d06-151">Параметр [**onmessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) извлекает сообщение [**WM \_ лбуттондовн**](/windows/desktop/inputdev/wm-lbuttondown) из очереди и заполняет структуру [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) .</span><span class="sxs-lookup"><span data-stu-id="f6d06-151">[**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) pulls the [**WM\_LBUTTONDOWN**](/windows/desktop/inputdev/wm-lbuttondown) message from the queue and fills in the [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) structure.</span></span>
4. <span data-ttu-id="f6d06-152">Программа вызывает функции [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) и [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) .</span><span class="sxs-lookup"><span data-stu-id="f6d06-152">Your program calls the [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) and [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) functions.</span></span>
5. <span data-ttu-id="f6d06-153">Внутри [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage)операционная система вызывает процедуру окна.</span><span class="sxs-lookup"><span data-stu-id="f6d06-153">Inside [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage), the operating system calls your window procedure.</span></span>
6. <span data-ttu-id="f6d06-154">Ваша процедура окна может либо ответить на сообщение, либо пропустить ее.</span><span class="sxs-lookup"><span data-stu-id="f6d06-154">Your window procedure can either respond to the message or ignore it.</span></span>

<span data-ttu-id="f6d06-155">Когда процедура окна возвращает, возвращается обратно в [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage).</span><span class="sxs-lookup"><span data-stu-id="f6d06-155">When the window procedure returns, it returns back to [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage).</span></span> <span data-ttu-id="f6d06-156">При этом возвращается цикл обработки сообщений для следующего сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6d06-156">This returns to the message loop for the next message.</span></span> <span data-ttu-id="f6d06-157">Пока программа запущена, сообщения будут по-прежнему поступать в очередь.</span><span class="sxs-lookup"><span data-stu-id="f6d06-157">As long as your program is running, messages will continue to arrive on the queue.</span></span> <span data-ttu-id="f6d06-158">Поэтому необходимо иметь цикл, который постоянно извлекает сообщения из очереди и отправляет их.</span><span class="sxs-lookup"><span data-stu-id="f6d06-158">Therefore, you must have a loop that continually pulls messages from the queue and dispatches them.</span></span> <span data-ttu-id="f6d06-159">Вы можете представить себе цикл, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="f6d06-159">You can think of the loop as doing the following:</span></span>

```C++
// WARNING: Don't actually write your loop this way.

while (1)      
{
    GetMessage(&msg, NULL, 0,  0);
    TranslateMessage(&msg); 
    DispatchMessage(&msg);
}
```

<span data-ttu-id="f6d06-160">Как написано, этот цикл никогда бы не был завершен.</span><span class="sxs-lookup"><span data-stu-id="f6d06-160">As written, of course, this loop would never end.</span></span> <span data-ttu-id="f6d06-161">Именно в этом случае возвращается возвращаемое значение функции- [**сообщения**](/windows/desktop/api/winuser/nf-winuser-getmessage) .</span><span class="sxs-lookup"><span data-stu-id="f6d06-161">That is where the return value for the [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) function comes in.</span></span> <span data-ttu-id="f6d06-162">Как правило, функция **onmessage** возвращает ненулевое значение.</span><span class="sxs-lookup"><span data-stu-id="f6d06-162">Normally, **GetMessage** returns a nonzero value.</span></span> <span data-ttu-id="f6d06-163">Если вы хотите выйти из приложения и приостановить цикл обработки сообщений, вызовите функцию [**посткуитмессаже**](/windows/desktop/api/winuser/nf-winuser-postquitmessage) .</span><span class="sxs-lookup"><span data-stu-id="f6d06-163">When you want to exit the application and break out of the message loop, call the [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage) function.</span></span>

```C++
        PostQuitMessage(0);
```

<span data-ttu-id="f6d06-164">Функция [**посткуитмессаже**](/windows/desktop/api/winuser/nf-winuser-postquitmessage) помещает сообщение [**WM \_ Quit**](/windows/desktop/winmsg/wm-quit) в очередь сообщений.</span><span class="sxs-lookup"><span data-stu-id="f6d06-164">The [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage) function puts a [**WM\_QUIT**](/windows/desktop/winmsg/wm-quit) message on the message queue.</span></span> <span data-ttu-id="f6d06-165">**WM \_ QUIT** — это специальное сообщение: оно приводит к тому, что [**сообщение**](/windows/desktop/api/winuser/nf-winuser-getmessage) возвращает ноль, и сообщает о завершении цикла обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="f6d06-165">**WM\_QUIT** is a special message: It causes [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) to return zero, signaling the end of the message loop.</span></span> <span data-ttu-id="f6d06-166">Ниже приведен измененный цикл обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="f6d06-166">Here is the revised message loop.</span></span>

```C++
// Correct.

MSG msg = { };
while (GetMessage(&msg, NULL, 0, 0) > 0)
{
    TranslateMessage(&msg);
    DispatchMessage(&msg);
}
```

<span data-ttu-id="f6d06-167">При условии [**, что функция IsTrue возвращает**](/windows/desktop/api/winuser/nf-winuser-getmessage) ненулевое значение, выражение в цикле **while** вычисляется как true.</span><span class="sxs-lookup"><span data-stu-id="f6d06-167">As long as [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) returns a nonzero value, the expression in the **while** loop evaluates to true.</span></span> <span data-ttu-id="f6d06-168">После вызова [**посткуитмессаже**](/windows/desktop/api/winuser/nf-winuser-postquitmessage)выражение принимает значение false и программа выходит из цикла.</span><span class="sxs-lookup"><span data-stu-id="f6d06-168">After you call [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage), the expression becomes false and the program breaks out of the loop.</span></span> <span data-ttu-id="f6d06-169">(Один из интересных результатов такого поведения заключается в том, что ваша процедура окна никогда не получит сообщение [**\_ Quit WM**](/windows/desktop/winmsg/wm-quit) .</span><span class="sxs-lookup"><span data-stu-id="f6d06-169">(One interesting result of this behavior is that your window procedure never receives a [**WM\_QUIT**](/windows/desktop/winmsg/wm-quit) message.</span></span> <span data-ttu-id="f6d06-170">Поэтому для этого сообщения в процедуре окна не обязательно иметь оператор Case.)</span><span class="sxs-lookup"><span data-stu-id="f6d06-170">Therefore, you do not have to have a case statement for this message in your window procedure.)</span></span>

<span data-ttu-id="f6d06-171">Следующий очевидный вопрос заключается в том, когда следует вызывать [**посткуитмессаже**](/windows/desktop/api/winuser/nf-winuser-postquitmessage).</span><span class="sxs-lookup"><span data-stu-id="f6d06-171">The next obvious question is when to call [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage).</span></span> <span data-ttu-id="f6d06-172">Мы вернемся к этому вопросу в разделе [закрытие окна](closing-the-window.md), но сначала нам нужно написать нашу процедуру окна.</span><span class="sxs-lookup"><span data-stu-id="f6d06-172">We'll return to this question in the topic [Closing the Window](closing-the-window.md), but first we have to write our window procedure.</span></span>

## <a name="posted-messages-versus-sent-messages"></a><span data-ttu-id="f6d06-173">Отправка сообщений и отправленных сообщений</span><span class="sxs-lookup"><span data-stu-id="f6d06-173">Posted Messages versus Sent Messages</span></span>

<span data-ttu-id="f6d06-174">В предыдущем разделе говорились о сообщениях, помещаемых в очередь.</span><span class="sxs-lookup"><span data-stu-id="f6d06-174">The previous section talked about messages going onto a queue.</span></span> <span data-ttu-id="f6d06-175">Иногда операционная система вызывает процедуру окна напрямую, минуя очередь.</span><span class="sxs-lookup"><span data-stu-id="f6d06-175">Sometimes, the operating system will call a window procedure directly, bypassing the queue.</span></span>

<span data-ttu-id="f6d06-176">Терминология этого отличия может быть запутанной:</span><span class="sxs-lookup"><span data-stu-id="f6d06-176">The terminology for this distinction can be confusing:</span></span>

-   <span data-ttu-id="f6d06-177">*Отправка* сообщения означает, что сообщение помещается в очередь сообщений и отправляется через цикл обработки [**сообщений (**](/windows/desktop/api/winuser/nf-winuser-getmessage) [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage)).</span><span class="sxs-lookup"><span data-stu-id="f6d06-177">*Posting* a message means the message goes on the message queue, and is dispatched through the message loop ([**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) and [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage)).</span></span>
-   <span data-ttu-id="f6d06-178">*Отправка* сообщения означает, что сообщение пропускается, а операционная система напрямую вызывает процедуру окна.</span><span class="sxs-lookup"><span data-stu-id="f6d06-178">*Sending* a message means the message skips the queue, and the operating system calls the window procedure directly.</span></span>

<span data-ttu-id="f6d06-179">В настоящее отличие это не очень важно.</span><span class="sxs-lookup"><span data-stu-id="f6d06-179">For now, the difference is not very important.</span></span> <span data-ttu-id="f6d06-180">Оконная процедура обрабатывает все сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6d06-180">The window procedure handles all messages.</span></span> <span data-ttu-id="f6d06-181">Однако некоторые сообщения обходят очередь и пройдут непосредственно в оконную процедуру.</span><span class="sxs-lookup"><span data-stu-id="f6d06-181">However, some messages bypass the queue and go directly to your window procedure.</span></span> <span data-ttu-id="f6d06-182">Однако это может повлиять на взаимодействие приложения между Windows.</span><span class="sxs-lookup"><span data-stu-id="f6d06-182">However, it can make a difference if your application communicates between windows.</span></span> <span data-ttu-id="f6d06-183">Более подробное описание этой проблемы см. в разделе [сообщения и очереди сообщений](/windows/desktop/winmsg/about-messages-and-message-queues).</span><span class="sxs-lookup"><span data-stu-id="f6d06-183">You can find a more thorough discussion of this issue in the topic [About Messages and Message Queues](/windows/desktop/winmsg/about-messages-and-message-queues).</span></span>

## <a name="next"></a><span data-ttu-id="f6d06-184">Следующая</span><span class="sxs-lookup"><span data-stu-id="f6d06-184">Next</span></span>

[<span data-ttu-id="f6d06-185">Написание процедуры окна</span><span class="sxs-lookup"><span data-stu-id="f6d06-185">Writing the Window Procedure</span></span>](writing-the-window-procedure.md)
