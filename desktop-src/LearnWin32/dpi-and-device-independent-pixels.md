---
title: DPI и Device-Independent пикселей
ms.assetid: d282de02-62f4-4a12-a77c-f602f6db0216
description: 'Дополнительные сведения: DPI и Device-Independent пикселей'
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8e6f04e1a056611fcdfe8b59ff65b38ecec99eaf
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "103913279"
---
# <a name="dpi-and-device-independent-pixels"></a>DPI и Device-Independent пикселей

Для эффективной работы с графикой Windows необходимо понимать два связанных понятия:

-   Точек на дюйм (DPI)
-   Аппаратно-независимый пиксель (DIP).

Начнем с DPI. Для этого потребуется краткий обзор типографии. В типографии размер типа измеряется в единицах, именуемых *points*. Одна точка равна 1/72 дюйма.

<dl> 1 пт = 1/72 дюйма  
</dl>

> [!Note]  
> Это определение точки публикации на настольном компьютере. Исторически точная мера точки изменилась.

 

Например, шрифт 12-точечного шрифта помещается в строку текста 1/6 "(12/72). Очевидно, что это не означает, что каждый символ в шрифте ровно 1/6 «высокий». На самом деле некоторые символы могут быть больше, чем 1/6. Например, во многих шрифтах символ a больше, чем номинальная высота шрифта. Для правильного вывода шрифта требуется дополнительное пространство между текстом. Это пространство называется *ведущим*.

На следующем рисунке показан шрифт 72-пт. В сплошных линиях вокруг текста отображается 1 «ограничивающий прямоугольник». Пунктирная линия называется *базовой*. Большая часть символов в шрифте, оставшаяся в базовом плане. Высота шрифта включает часть, расположенную выше базовой линии ( *восхождение*), и часть, расположенную ниже базовой линии ( *спуск*). В показанном здесь шрифте восхождение составляет 56 точек, а спуск — 16 пунктов.

![Иллюстрация, на которой показан шрифт в 72 пт.](images/graphics11.png)

Однако, когда дело доходит до экрана компьютера, измерение размера текста является проблематичным, так как в пикселях используется не тот же размер. Размер пикселя зависит от двух факторов: разрешения экрана и физического размера монитора. Таким образом, физические дюймы не являются полезной мерой, так как нет фиксированной связи между физическими дюймами и пикселями. Шрифты измеряются в *логических* единицах. Шрифт в 72 пт определяется как один логический дюйм в высоту. Затем логические дюймы преобразуются в пиксели. В течение многих лет в Windows использовалось следующее преобразование: один логический дюйм равен 96 пикселов. При использовании этого коэффициента масштабирования шрифт 72-пт выводится в высоту 96 пикселей. Высота 12-точечного шрифта составляет 16 пикселей.

<dl> 12 точек = 12/72 логический дюйм = 1/6 логический дюйм = 96/6 пикселей = 16 пикселей  
</dl>

Этот коэффициент масштабирования описан как 96 точек на дюйм (DPI). Термин точки наследуется от печати, где на бумаге помещаются физические точки рукописного ввода. Для дисплеев на компьютере было бы более точным, например, 96 пикселей на логический дюйм, но в этом случае это означает, что точка DPI была задержана.

Так как фактические размеры пикселей различаются, текст, который может быть прочитан на одном мониторе, на другом мониторе могут быть слишком маленьким. Кроме того, люди имеют разные предпочтения — некоторые люди предпочитают текст больше. По этой причине Windows позволяет пользователю изменить параметр DPI. Например, если пользователь устанавливает для дисплея значение 144 DPI, то шрифт 72-пт составляет 144 пикселей в высоту. Параметры стандартного DPI: 100% (96 точек на дюйм), 125% (120 DPI) и 150% (144 DPI). Пользователь может также применить настраиваемый параметр. Начиная с Windows 7 DPI — это параметр для каждого пользователя.

## <a name="dwm-scaling"></a>Масштабирование DWM

Если программа не учитывает DPI, то следующие дефекты могут быть очевидны при высоком уровне DPI:

-   Обрезанные элементы пользовательского интерфейса.
-   Неверный макет.
-   Пикселизованным точечные рисунки и значки.
-   Неверные координаты указателя мыши, которые могут повлиять на проверку попадания, перетаскивание и т. д.

Чтобы обеспечить работу старых программ в параметрах с высоким разрешением, DWM реализует полезную резервную копию. Если программа не помечена как учитывающая DPI, DWM будет масштабировать весь пользовательский интерфейс в соответствии с параметром DPI. Например, при 144 DPI пользовательский интерфейс масштабируется по 150%, включая текст, графику, элементы управления и размеры окон. Если программа создает окно 500 × 500, окно отображается как 750 × 750 пикселей, а содержимое окна масштабируется соответствующим образом.

Такое поведение означает, что старые программы работают только в параметрах с высоким разрешением. Однако масштабирование также приводит к частично размытому внешнему виду, так как масштабирование применяется после прорисовки окна.

## <a name="dpi-aware-applications"></a>DPI-Aware приложения

Чтобы избежать масштабирования, программа может пометить себя как поддерживающую DPI. Это говорит о том, что DWM не будет выполнять автоматическое масштабирование DPI. Все новые приложения должны быть спроектированы с учетом DPI, так как осведомленность о DPI улучшает внешний вид параметров пользовательского интерфейса при высоком уровне DPI.

Программа объявляет свое разрешение с учетом DPI через манифест приложения. *Манифест* — это просто XML-файл, ОПИСЫВАЮЩИЙ библиотеку DLL или приложение. Манифест обычно внедряется в исполняемый файл, хотя он может быть предоставлен в виде отдельного файла. Манифест содержит такие сведения, как зависимости библиотек DLL, требуемый уровень привилегий и версия Windows, для которой была разработана программа.

Чтобы объявить, что программа учитывает DPI, включите в манифест следующую информацию.

``` syntax
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>true</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
</assembly>
```

Приведенный здесь список является только частичным манифестом, но компоновщик Visual Studio автоматически создает остальную часть манифеста. Чтобы включить в проект частичный манифест, выполните следующие действия в Visual Studio.

1.  В меню **проект** выберите пункт **свойство**.
2.  В левой области разверните узел **Свойства конфигурации**, разверните **инструмент манифест**, а затем щелкните **Вход и выход**.
3.  В текстовом поле **Дополнительные файлы манифеста** введите имя файла манифеста и нажмите кнопку **ОК**.

Пометив программу как учитывающую DPI, вы сообщаете DWM, что окно приложения не масштабируется. Теперь при создании окна 500 × 500 окно будет занимать 500 × 500 пикселей, независимо от значения DPI пользователя.

## <a name="gdi-and-dpi"></a>GDI и DPI

Рисование GDI измеряется в пикселях. Это означает, что если программа помечена как совместимая с DPI, и вы запрашиваете GDI для рисования прямоугольника 200 × 100, полученный прямоугольник будет состоять из 200 пикселей в ширину и 100 пикселей в высоту на экране. Однако размеры шрифтов GDI масштабируются до текущего значения DPI. Иными словами, если вы создадите шрифт 72, размер шрифта будет составлять 96 пикселей в 96 DPI, а 144 пикселей — в 144 DPI. Ниже приведен шрифт точки 72, отображаемый в 144 DPI с помощью GDI.

![Диаграмма, показывающая масштабирование шрифтов dpi в GDI.](images/graphics12.png)

Если в приложении учитывается DPI и для рисования используется GDI, масштабировать все координаты рисования в соответствии с DPI.

## <a name="direct2d-and-dpi"></a>Direct2D и DPI

Direct2D автоматически выполняет масштабирование в соответствии с параметром DPI. В Direct2D координаты измеряются в единицах, называемых аппаратно *-независимыми пикселями* (DIP). DIP определяется как 1 или 1/96 *логического* дюйма. В Direct2D все операции рисования задаются в DIP, а затем масштабируются до текущего параметра DPI.



| Масштаб | Размер DIP    |
|-------------|-------------|
| 96          | 1 пиксель     |
| 120         | 1,25 пикселей |
| 144         | 1,5 пикселей  |



 

Например, если значение DPI для пользователя равно 144 DPI, и вы запрашиваете Direct2D для прорисовки прямоугольника размером 200 × 100, прямоугольник будет состоять из 300 × 150 физических пикселей. Кроме того, DirectWrite измеряет размеры шрифтов в DIP, а не на точках. Чтобы создать шрифт размером 12 пунктов, укажите 16 DIP (12 точек = 1/6 логический дюйм = 96/6 DIP). Когда текст отображается на экране, Direct2D преобразует DIP в физические Пиксели. Преимуществом этой системы является то, что единицы измерения согласуются как для текста, так и для рисования, независимо от текущего значения DPI.

Предупреждение: координаты мыши и окна по-прежнему задаются в физических пикселях, а не DIP. Например, если обрабатывается сообщение [**WM \_ лбуттондовн**](/windows/desktop/inputdev/wm-lbuttondown) , то кнопка мыши задается в физических пикселях. Чтобы нарисовать точку в этой позиции, необходимо преобразовать координаты пикселей в DIP.

## <a name="converting-physical-pixels-to-dips"></a>Преобразование физических пикселей в DIP

Преобразование из физических пикселей в DIP использует следующую формулу.

<dl> DIP = Пиксели/(DPI/96.0)  
</dl>

Чтобы получить значение DPI, вызовите метод [**ID2D1Factory:: жетдесктопдпи**](/windows/desktop/api/d2d1/nf-d2d1-id2d1factory-getdesktopdpi) . Значение DPI возвращается в виде двух значений с плавающей запятой: одно для оси x, а другое для оси y. Теоретически эти значения могут различаться. Вычислите отдельный коэффициент масштабирования для каждой оси.


```C++
float g_DPIScaleX = 1.0f;
float g_DPIScaleY = 1.0f;

void InitializeDPIScale(ID2D1Factory *pFactory)
{
    FLOAT dpiX, dpiY;

    pFactory->GetDesktopDpi(&dpiX, &dpiY);

    g_DPIScaleX = dpiX/96.0f;
    g_DPIScaleY = dpiY/96.0f;
}

template <typename T>
float PixelsToDipsX(T x)
{
    return static_cast<float>(x) / g_DPIScaleX;
}

template <typename T>
float PixelsToDipsY(T y)
{
    return static_cast<float>(y) / g_DPIScaleY;
}
```



Ниже приведен альтернативный способ получения значения DPI, если вы не используете Direct2D:


```C++
void InitializeDPIScale(HWND hwnd)
{
    HDC hdc = GetDC(hwnd);
    g_DPIScaleX = GetDeviceCaps(hdc, LOGPIXELSX) / 96.0f;
    g_DPIScaleY = GetDeviceCaps(hdc, LOGPIXELSY) / 96.0f;
    ReleaseDC(hwnd, hdc);
}
```
> [!Note]  
> В Windows 10 версия 1903,  [**ID2D1Factory:: жетдесктопдпи**](/windows/win32/api/d2d1/nf-d2d1-id2d1factory-getdesktopdpi) является устаревшей, а рекомендация — [**DisplayInformation:: Логикалдпи**](/uwp/api/windows.graphics.display.displayinformation.logicaldpi?view=winrt-19041) для приложений Магазина Windows или [**жетдпифорвиндов**](/windows/win32/api/winuser/nf-winuser-getdpiforwindow) для классических приложений. Если вы по-прежнему хотите использовать его, отключите сообщение об ошибке компилятора, записав строку [**#pragma warning (подавлять: 4996)**](/cpp/error-messages/compiler-warnings/compiler-warning-level-3-c4996?view=vs-2019) непосредственно перед вызовом [**ID2D1Factory:: жетдесктопдпи**](/windows/win32/api/d2d1/nf-d2d1-id2d1factory-getdesktopdpi) . Хотя это не рекомендуется, по умолчанию можно задать поддержку по DPI с помощью [**сетпроцессдпиаваренессконтекст**](/windows/win32/api/winuser/nf-winuser-setprocessdpiawarenesscontext). После создания окна (HWND) в процессе изменение режима поддержки DPI больше не поддерживается. Если вы устанавливаете режим поддержки по умолчанию для обработки точек на дюйм как программно, необходимо вызвать соответствующий API перед созданием дескрипторов HWND. Дополнительные сведения см. [в разделе Настройка отслеживания количества точек на дюйм по умолчанию для процесса](../hidpi/setting-the-default-dpi-awareness-for-a-process.md).

## <a name="resizing-the-render-target"></a>Изменение размера целевого объекта прорисовки

Если размер окна изменяется, необходимо изменить размер целевого объекта рендеринга для соответствия. В большинстве случаев также потребуется обновить макет и перекрасить окно. Эти действия показаны в следующем коде.


```C++
void MainWindow::Resize()
{
    if (pRenderTarget != NULL)
    {
        RECT rc;
        GetClientRect(m_hwnd, &rc);

        D2D1_SIZE_U size = D2D1::SizeU(rc.right, rc.bottom);

        pRenderTarget->Resize(size);
        CalculateLayout();
        InvalidateRect(m_hwnd, NULL, FALSE);
    }
}
```



Функция [**жетклиентрект**](/windows/desktop/api/winuser/nf-winuser-getclientrect) получает новый размер клиентской области в физических пикселях (не DIP). Метод [**ID2D1HwndRenderTarget:: resize**](../direct2d/id2d1hwndrendertarget-resize.md) обновляет размер целевого объекта рендеринга, также заданный в пикселях. Функция [**инвалидатерект**](/windows/desktop/api/winuser/nf-winuser-invalidaterect) принудительно выполняет перерисовку, добавляя всю клиентскую область в область обновления окна. (См. раздел [Рисование окна](painting-the-window.md)в модуле 1.)

По мере увеличения или уменьшения размера окна, как правило, необходимо повторно вычислить расположение рисуемых объектов. Например, в программе Circle необходимо обновить радиус и центральную точку:


```C++
void MainWindow::CalculateLayout()
{
    if (pRenderTarget != NULL)
    {
        D2D1_SIZE_F size = pRenderTarget->GetSize();
        const float x = size.width / 2;
        const float y = size.height / 2;
        const float radius = min(x, y);
        ellipse = D2D1::Ellipse(D2D1::Point2F(x, y), radius, radius);
    }
}
```



Метод [**ID2D1RenderTarget:: resize**](/windows/desktop/api/d2d1/nf-d2d1-id2d1rendertarget-getsize) возвращает размер целевого объекта отрисовки в DIP (не в пикселях), который является подходящим блоком для вычисления макета. Существует тесно связанный метод [**ID2D1RenderTarget:: жетпикселсизе**](/windows/desktop/api/d2d1/nf-d2d1-id2d1rendertarget-getpixelsize), который возвращает размер в физических пикселях. Для целевого объекта прорисовки **HWND** это значение соответствует размеру, возвращенному [**жетклиентрект**](/windows/desktop/api/winuser/nf-winuser-getclientrect). Но помните, что рисование выполняется в DIP, а не в пикселях.

## <a name="next"></a>Следующая

[Использование цвета в Direct2D](using-color-in-direct2d.md)

 

 
