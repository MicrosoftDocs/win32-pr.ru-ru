---
title: Рисование окна
description: Вы создали окно. Теперь нужно отобразить что-то в нем. В терминологии Windows это называется рисованием окна. Чтобы смешивать метафоры, окно — это пустой холст, ожидающий его заполнения.
ms.assetid: db97a4c9-7592-42d1-a5de-9c468169eefc
ms.topic: article
ms.date: 08/16/2019
ms.openlocfilehash: f0f9d5c2759ea1735e370eb258743364980daee8
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2020
ms.locfileid: "104553083"
---
# <a name="painting-the-window"></a>Рисование окна

Вы создали окно. Теперь нужно отобразить что-то в нем. В терминологии Windows это называется рисованием окна. Чтобы смешивать метафоры, окно — это пустой холст, ожидающий его заполнения.

Иногда программа запустит Рисование для обновления внешнего вида окна. В других случаях операционная система сообщит вам, что необходимо перекрасить часть окна. В этом случае операционная система отправляет окну сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) . Часть окна, которая должна быть окрашена, называется *областью обновления*.

При первом отображении окна вся клиентская область окна должна быть окрашена. Поэтому при отображении окна всегда будет отображаться по крайней мере одно сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) .

![Иллюстрация, показывающая область обновления окна](images/painting01.png)

Вы несете ответственность за рисование клиентской области. Окружающий фрейм, включая заголовок окна, автоматически зарисовывается операционной системой. После завершения заполнения клиентской области очищается регион обновления, который сообщает операционной системе, что ей не нужно отсылать другое сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) , пока что не изменится.

Теперь предположим, что пользователь перемещает другое окно, чтобы оно скрывало часть окна. Когда скрытая часть снова становится видимой, эта часть добавляется в область обновления, и окно получает другое сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) .

![Иллюстрация изменения региона обновления при перекрытии двух окон](images/painting02.png)

Регион обновления также изменяется, если пользователь растягивает окно. На следующей схеме пользователь растягивает окно вправо. Новая развернутая область в правой части окна добавляется в область обновления:

![Иллюстрация изменения области обновления при изменении размера окна](images/painting03.png)

В нашем первом примере программы подпрограмма рисования очень проста. Он просто заполняет всю клиентскую область сплошным цветом. Тем не менее, этот пример достаточно для демонстрации некоторых важных концепций.

```C++
switch (uMsg)
{
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        // All painting occurs here, between BeginPaint and EndPaint.

        FillRect(hdc, &ps.rcPaint, (HBRUSH) (COLOR_WINDOW+1));

        EndPaint(hwnd, &ps);
    }
    return 0;
}
```

Запустите операцию рисования, вызвав функцию [**бегинпаинт**](/windows/desktop/api/winuser/nf-winuser-beginpaint) . Эта функция заполняет структуру [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) сведениями о запросе на перерисовку. Текущий регион обновления указывается в элементе **члене rcpaint структуры** элемента **PAINTSTRUCT**. Этот регион обновления определяется относительно клиентской области:

![Иллюстрация, показывающая происхождение клиентской области](images/painting04.png)

В коде рисования есть два основных варианта:

- Заполните всю клиентскую область независимо от размера области обновления. Все, что находится за пределами области обновления, обрезается. То есть операционная система пропускает ее.
- Оптимизируйте, рисуя только часть окна внутри области обновления.

Если вы всегда рисуете всю клиентскую область, код будет проще. Однако при наличии сложной логики рисования может быть более эффективным пропускать области за пределами области обновления.

Следующая строка кода заполняет область обновления одним цветом, используя определенный системой цвет фона окна (**\_ окно цвета**). Фактический цвет, указанный **в \_ окне цвета** , зависит от текущей цветовой схемы пользователя.

```C++
FillRect(hdc, &ps.rcPaint, (HBRUSH) (COLOR_WINDOW+1));
```

Сведения о [**филлрект**](/windows/desktop/api/winuser/nf-winuser-fillrect) не важны для этого примера, но второй параметр дает координаты прямоугольника для заполнения. В этом случае мы передаем весь регион обновления (член **члене rcpaint структуры** объекта [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct)). В первом сообщении [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) вся клиентская область должна быть окрашена, поэтому **члене rcpaint структуры** будет содержать всю клиентскую область. В последующих сообщениях **WM \_ Paint** **члене rcpaint структуры** может содержать прямоугольник меньшего размера.

Функция [**филлрект**](/windows/desktop/api/winuser/nf-winuser-fillrect) является частью интерфейс графических устройств (GDI), которая имеет встроенную графику Windows в течение очень долгого времени. В Windows 7 Корпорация Майкрософт представила новый графический механизм с именем Direct2D, который поддерживает высокопроизводительные графические операции, такие как аппаратное ускорение. Direct2D также доступен для Windows Vista через [обновление платформы для Windows Vista](../win7ip/platform-update-for-windows-vista-overview.md) и для windows Server 2008 с помощью обновления платформы для windows Server 2008. (GDI по-прежнему полностью поддерживается.)

Завершив рисование, вызовите функцию [**ендпаинт**](/windows/desktop/api/winuser/nf-winuser-endpaint) . Эта функция очищает регион обновления, который сообщает Windows, что окно завершило свою прорисовку.

## <a name="next"></a>Следующая

[Закрытие окна](closing-the-window.md)