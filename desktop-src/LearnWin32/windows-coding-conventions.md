---
title: Windows Соглашения о написании кода
description: если вы не знакомы с Windows программированием, это можно сделать при первом просмотре программы Windows.
ms.assetid: 466a66db-7681-4fce-9672-07849cd1b096
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b78c24f38f9f2f410c044637ca3aa59d4baa39e9b671b3485c5b85899b69c2fb
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118387399"
---
# <a name="windows-coding-conventions"></a>Windows Соглашения о написании кода

если вы не знакомы с Windows программированием, это можно сделать при первом просмотре программы Windows. Код заполняется нестранными определениями типов, такими как **DWORD \_ ptr** и **лпрект**, а переменные имеют такие имена, как *HWND* и *пвсз* (называемые венгерской нотацией). стоит потратить немного времени на изучение некоторых Windows соглашений о написании кода.

подавляющее большинство интерфейсов api Windows состоят из функций или интерфейсов модели COM. в качестве классов C++ предоставлено очень мало Windows интерфейсов api. (важным исключением является GDI+, один из api-интерфейсов двухмерной графики.)

## <a name="typedefs"></a>Определения типов

заголовки Windows содержат множество типов typedef. Многие из них определены в файле заголовка Виндеф. h. Ниже приведены некоторые из них, которые часто встречаются.

### <a name="integer-types"></a>Целочисленные типы



| Тип данных     | Размер    | Входил?  |
|---------------|---------|----------|
| **BYTE**      | 8 бит  | Без знака |
| **DWORD**     | 32 бита | Без знака |
| **INT32**     | 32 бита | Со знаком   |
| **INT64**     | 64 бита | Со знаком   |
| **LONG**      | 32 бита | Со знаком   |
| **лонглонг**  | 64 бита | Со знаком   |
| **UINT32**    | 32 бита | Без знака |
| **UINT64**    | 64 бита | Без знака |
| **ULONG**     | 32 бита | Без знака |
| **улонглонг** | 64 бита | Без знака |
| **WORD**      | 16 бит | Без знака |



 

Как видите, в этих определениях типов имеется определенный объем избыточности. часть этого перекрывается просто из-за истории api-интерфейсов Windows. Перечисленные типы имеют фиксированный размер, а размеры одинаковы в 32-и 64-приложениях. Например, тип **DWORD** всегда 32 бит в ширину.

### <a name="boolean-type"></a>Логический тип

**Bool** — это typedef для целочисленного значения, используемого в логическом контексте. Файл заголовка Виндеф. h также определяет два значения для использования с **bool**.


```C++
#define FALSE    0 
#define TRUE     1
```



Несмотря на это определение **true**, большинство функций, возвращающих тип **bool** , могут возвращать любое ненулевое значение, обозначающее логическую истинность. Поэтому всегда следует писать следующее:


```C++
// Right way.
BOOL result = SomeFunctionThatReturnsBoolean();
if (result) 
{ 
    ...
}
```



и не так:


```C++
// Wrong!
if (result == TRUE) 
{
    ... 
}
```



Помните, что **bool** является целочисленным типом и не является взаимозаменяемым с типом **bool** C++.

### <a name="pointer-types"></a>Типы указателей

Windows определяет множество типов данных, имеющих форму *указателя на X*. Они обычно имеют префикс *P-* или *LP-* в имени. Например, **лпрект** является указателем на [**Rect**](/previous-versions//dd162897(v=vs.85)), где **Rect** — это структура, описывающая прямоугольник. Следующие объявления переменных эквивалентны.


```C++
RECT*  rect;  // Pointer to a RECT structure.
LPRECT rect;  // The same
PRECT  rect;  // Also the same.
```



Исторически, *P* означает "указатель", а *LP* — "длинный указатель". длинные указатели (также называемые *дальнеимися указателями*) являются наследие из 16-разрядных Windows, когда они были необходимы для адресации диапазонов памяти за пределами текущего сегмента. Префикс *LP* был сохранен, чтобы упростить перенос 16-разрядного кода в 32-разрядный Windows. На сегодняшний день нет различий — указатель является указателем.

### <a name="pointer-precision-types"></a>Типы точности указателей

Следующие типы данных всегда имеют размер указателя, то есть 32 бит в 32-разрядных приложениях и 64 бит на уровне в 64-разрядных приложениях. Размер определяется во время компиляции. если 32-разрядное приложение выполняется на 64-разрядной Windows, эти типы данных по-прежнему имеют ширину 4 байта. (64-разрядное приложение не может выполняться на 32-бит Windows, поэтому обратная ситуация не возникает.)

-   **DWORD \_ ptr**
-   **INT \_ ptr**
-   **LONG \_ ptr**
-   **ULONG- \_ ptr**
-   **UINT \_ ptr**

Эти типы используются в ситуациях, когда целочисленное значение может быть приведено к указателю. Они также используются для определения переменных для арифметических операций с указателями и для определения счетчиков циклов, которые просматривают весь диапазон байтов в буферах памяти. В общем случае они появляются в местах, где существующее 32-разрядное значение было расширено до 64 бит на 64-разрядной Windows.

## <a name="hungarian-notation"></a>Венгерская нотация

*Венгерская нотация* — это практика добавления префиксов к именам переменных для предоставления дополнительных сведений о переменной. (Инвентаризация в нотации, Чарльз Симони, была венгерской, поэтому ее имя).

В исходной форме нотация Венгерская информация предоставляет *семантическую* информацию о переменной, которая сообщает вам о предполагаемом использовании. Например, *я* обозначает индекс, *CB* означает размер в байтах ("количество байт"), а значения строк и столбцов для значений *RW* и *Col* . Эти префиксы предназначены для того, чтобы избежать случайного использования переменной в неправильном контексте. Например, если вы видели выражение `rwPosition +  cbTable` , вы узнаете, что к размеру добавляется номер строки, что почти наверняка является ошибкой в коде.

Более распространенная форма венгерской нотации использует префиксы для предоставления сведений о *типе* , например *DW* для **DWORD** и *w* для **Word**.

При поиске в Интернете по «венгерской нотации» вы найдете множество мнений о том, хорошо ли Венгерская нотация. Некоторые программисты имеют сильная отличие от венгерской нотации. Другие считают это полезным. Независимо от многих примеров кода на MSDN используется Венгерская нотация, но вам не нужно запоминать префиксы для понимания кода.

## <a name="next"></a>Следующая

[Работа со строками](working-with-strings.md)

 

 