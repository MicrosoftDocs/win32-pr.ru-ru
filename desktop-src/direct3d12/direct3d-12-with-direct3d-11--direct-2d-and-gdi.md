---
title: Взаимодействие Direct3D 12
description: D3D12 можно использовать для написания компонентных приложений.
ms.assetid: 51F7E715-82B6-48D8-A06A-CBBEDF6968F5
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3b5fcfe2adf756c12f034031675d0c3ac5571b44
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104549036"
---
# <a name="direct3d-12-interop"></a><span data-ttu-id="5752a-103">Взаимодействие Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="5752a-103">Direct3D 12 interop</span></span>

<span data-ttu-id="5752a-104">D3D12 можно использовать для написания компонентных приложений.</span><span class="sxs-lookup"><span data-stu-id="5752a-104">D3D12 can be used to write componentized applications.</span></span>

-   [<span data-ttu-id="5752a-105">Общие сведения о взаимодействии</span><span class="sxs-lookup"><span data-stu-id="5752a-105">Interop overview</span></span>](#interop-overview)
-   [<span data-ttu-id="5752a-106">Причины использования взаимодействия</span><span class="sxs-lookup"><span data-stu-id="5752a-106">Reasons for using interop</span></span>](#reasons-for-using-interop)
    -   [<span data-ttu-id="5752a-107">Совместное использование списка команд</span><span class="sxs-lookup"><span data-stu-id="5752a-107">Sharing a command list</span></span>](#sharing-a-command-list)
    -   [<span data-ttu-id="5752a-108">Совместное использование очереди команд</span><span class="sxs-lookup"><span data-stu-id="5752a-108">Sharing a command queue</span></span>](#sharing-a-command-queue)
    -   [<span data-ttu-id="5752a-109">Совместное использование примитивов синхронизации</span><span class="sxs-lookup"><span data-stu-id="5752a-109">Sharing sync primitives</span></span>](#sharing-sync-primitives)
    -   [<span data-ttu-id="5752a-110">Совместное использование ресурсов</span><span class="sxs-lookup"><span data-stu-id="5752a-110">Sharing resources</span></span>](#sharing-resources)
    -   [<span data-ttu-id="5752a-111">Выбор модели взаимодействия</span><span class="sxs-lookup"><span data-stu-id="5752a-111">Choosing an interop model</span></span>](#choosing-an-interop-model)
-   [<span data-ttu-id="5752a-112">Интерфейсы API взаимодействия</span><span class="sxs-lookup"><span data-stu-id="5752a-112">Interop APIs</span></span>](#interop-apis)
-   [<span data-ttu-id="5752a-113">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="5752a-113">Related topics</span></span>](#related-topics)

## <a name="interop-overview"></a><span data-ttu-id="5752a-114">Общие сведения о взаимодействии</span><span class="sxs-lookup"><span data-stu-id="5752a-114">Interop overview</span></span>

<span data-ttu-id="5752a-115">D3D12 может быть очень мощным и разрешать приложениям писать графические коды с эффективностью, подобной консоли, но не всякий раз, когда нужно переносить колесико и писать все подсистемы отрисовки с нуля.</span><span class="sxs-lookup"><span data-stu-id="5752a-115">D3D12 can be very powerful, and allow applications to write graphics code with console-like efficiency, but not every application needs to reinvent the wheel and write the entirety of their rendering engine from scratch.</span></span> <span data-ttu-id="5752a-116">В некоторых случаях другой компонент или библиотека уже сделали это лучше, или в других случаях производительность части кода не столь важна, как ее правильность и удобочитаемость.</span><span class="sxs-lookup"><span data-stu-id="5752a-116">In some cases, another component or library has already done it better, or in other cases, the performance of a portion of code is not as critical as its correctness and readability.</span></span>

<span data-ttu-id="5752a-117">В этом разделе рассматриваются следующие методы взаимодействия:</span><span class="sxs-lookup"><span data-stu-id="5752a-117">This section covers the following interop techniques:</span></span>

-   <span data-ttu-id="5752a-118">D3D12 и D3D12 на одном устройстве</span><span class="sxs-lookup"><span data-stu-id="5752a-118">D3D12 and D3D12, on the same device</span></span>
-   <span data-ttu-id="5752a-119">D3D12 и D3D12 на разных устройствах</span><span class="sxs-lookup"><span data-stu-id="5752a-119">D3D12 and D3D12, on different devices</span></span>
-   <span data-ttu-id="5752a-120">D3D12 и любое сочетание D3D11, D3D10 или D2D на одном устройстве</span><span class="sxs-lookup"><span data-stu-id="5752a-120">D3D12 and any combination of D3D11, D3D10, or D2D, on the same device</span></span>
-   <span data-ttu-id="5752a-121">D3D12 и любое сочетание D3D11, D3D10 или D2D на разных устройствах</span><span class="sxs-lookup"><span data-stu-id="5752a-121">D3D12 and any combination of D3D11, D3D10, or D2D, on different devices</span></span>
-   <span data-ttu-id="5752a-122">D3D12 и GDI, D3D12 и D3D11 и GDI</span><span class="sxs-lookup"><span data-stu-id="5752a-122">D3D12 and GDI, or D3D12 and D3D11 and GDI</span></span>

## <a name="reasons-for-using-interop"></a><span data-ttu-id="5752a-123">Причины использования взаимодействия</span><span class="sxs-lookup"><span data-stu-id="5752a-123">Reasons for using interop</span></span>

<span data-ttu-id="5752a-124">Существует несколько причин, по которым приложению требуется D3D12 взаимодействие с другими API.</span><span class="sxs-lookup"><span data-stu-id="5752a-124">There are several reasons an application would want D3D12 interop with other APIs.</span></span> <span data-ttu-id="5752a-125">Некоторые примеры.</span><span class="sxs-lookup"><span data-stu-id="5752a-125">Some examples:</span></span>

-   <span data-ttu-id="5752a-126">Добавочное перенос: требуется перенести целое приложение с D3D10 или D3D11 на D3D12, в то время как оно работает на промежуточных этапах процесса переноса (для включения тестирования и отладки).</span><span class="sxs-lookup"><span data-stu-id="5752a-126">Incremental porting: wanting to port an entire application from D3D10 or D3D11 to D3D12, while having it functional at intermediate stages of the porting process (to enable testing and debugging).</span></span>
-   <span data-ttu-id="5752a-127">Код в виде черного прямоугольника: требуется оставить определенную часть приложения как есть, а затем перенести остальную часть кода.</span><span class="sxs-lookup"><span data-stu-id="5752a-127">Black box code: wanting to leave a particular portion of an application as-is while porting the rest of the code.</span></span> <span data-ttu-id="5752a-128">Например, может отсутствовать необходимость в переносе элементов пользовательского интерфейса игры.</span><span class="sxs-lookup"><span data-stu-id="5752a-128">For example, there might be no need to port UI elements of a game.</span></span>
-   <span data-ttu-id="5752a-129">Неизменяемые компоненты. необходимо использовать компоненты, не принадлежащие приложению, которые не записываются в целевую D3D12.</span><span class="sxs-lookup"><span data-stu-id="5752a-129">Unchangeable components: needing to use components which are not owned by the application, which are not written to target D3D12.</span></span>
-   <span data-ttu-id="5752a-130">Новый компонент: не требуется переносить все приложение, но требуется использовать новый компонент, написанный с помощью D3D12.</span><span class="sxs-lookup"><span data-stu-id="5752a-130">A new component: not wanting to port the entire application, but wanting to use a new component which is written using D3D12.</span></span>

<span data-ttu-id="5752a-131">Существует четыре основных метода взаимодействия в D3D12:</span><span class="sxs-lookup"><span data-stu-id="5752a-131">There are four main techniques for interop in D3D12:</span></span>

-   <span data-ttu-id="5752a-132">Приложение может предоставить компоненту список открытых команд, который записывает некоторые дополнительные команды отрисовки в уже привязанный целевой объект рендеринга.</span><span class="sxs-lookup"><span data-stu-id="5752a-132">An app can choose to provide an open command list to a component, which records some additional rendering commands to an already-bound render target.</span></span> <span data-ttu-id="5752a-133">Это эквивалентно предоставлению подготовленного контекста устройства другому компоненту в D3D11 и отличному для таких вещей, как добавление пользовательского интерфейса или текста в уже привязанный задний буфер.</span><span class="sxs-lookup"><span data-stu-id="5752a-133">This is equivalent to providing a prepared device context to another component in D3D11, and is great for things like adding UI/text to an already bound back buffer.</span></span>
-   <span data-ttu-id="5752a-134">Приложение может указать очередь команд для компонента, а также требуемый целевой ресурс.</span><span class="sxs-lookup"><span data-stu-id="5752a-134">An app can choose to provide a command queue to a component, along with a desired destination resource.</span></span> <span data-ttu-id="5752a-135">Это эквивалентно использованию API [**клеарстате**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-clearstate) или [**девицеконтекстстате**](/windows/desktop/api/d3d11_1/nn-d3d11_1-id3ddevicecontextstate) в D3D11 для предоставления чистого контекста устройства другому компоненту.</span><span class="sxs-lookup"><span data-stu-id="5752a-135">This is equivalent to using [**ClearState**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-clearstate) or [**DeviceContextState**](/windows/desktop/api/d3d11_1/nn-d3d11_1-id3ddevicecontextstate) APIs in D3D11 to provide a clean device context to another component.</span></span> <span data-ttu-id="5752a-136">Вот как работают такие компоненты, как D2D.</span><span class="sxs-lookup"><span data-stu-id="5752a-136">This is how components like D2D operate.</span></span>
-   <span data-ttu-id="5752a-137">Компонент может отказаться от модели, где она создает список команд, потенциально параллельно, что приложение несет ответственность за отправку в более позднее время.</span><span class="sxs-lookup"><span data-stu-id="5752a-137">A component may opt for a model where it produces a command list, potentially in parallel, which the app is responsible for submission at a later time.</span></span> <span data-ttu-id="5752a-138">По крайней мере один ресурс должен быть предоставлен через границы компонентов.</span><span class="sxs-lookup"><span data-stu-id="5752a-138">At least one resource must be provided across component boundaries.</span></span> <span data-ttu-id="5752a-139">Этот же метод доступен в D3D11 с использованием отложенных контекстов, хотя производительность в D3D12 является более предпочтительной.</span><span class="sxs-lookup"><span data-stu-id="5752a-139">This same technique is available in D3D11 using deferred contexts, though the performance in D3D12 is more desirable.</span></span>
-   <span data-ttu-id="5752a-140">Каждый компонент имеет собственные очереди и (или) устройства, а приложению и компонентам требуется совместное использование ресурсов и сведений о синхронизации на границах компонентов.</span><span class="sxs-lookup"><span data-stu-id="5752a-140">Each component has its own queue(s) and/or device(s), and the app and components need to share resources and synchronization information across component boundaries.</span></span> <span data-ttu-id="5752a-141">Это похоже на устаревший `ISurfaceQueue` и более современный [**идксгикэйедмутекс**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex).</span><span class="sxs-lookup"><span data-stu-id="5752a-141">This is similar to the legacy `ISurfaceQueue`, and the more modern [**IDXGIKeyedMutex**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex).</span></span>

<span data-ttu-id="5752a-142">Разница между этими сценариями заключается в том, что именно является общим для границ компонентов.</span><span class="sxs-lookup"><span data-stu-id="5752a-142">The differences between these scenarios is what exactly is shared between the component boundaries.</span></span> <span data-ttu-id="5752a-143">Предполагается, что устройство является общим, но, поскольку оно по сути не имеет состояния, оно не имеет отношения к действительности.</span><span class="sxs-lookup"><span data-stu-id="5752a-143">The device is assumed to be shared, but since it is basically stateless, it is not really relevant.</span></span> <span data-ttu-id="5752a-144">Ключевыми объектами являются список команд, очередь команд, объекты синхронизации и ресурсы.</span><span class="sxs-lookup"><span data-stu-id="5752a-144">The key objects are the command list, the command queue, the sync objects, and the resources.</span></span> <span data-ttu-id="5752a-145">Каждый из них имеет свои сложности при совместном использовании.</span><span class="sxs-lookup"><span data-stu-id="5752a-145">Each of these have their own complications when sharing them.</span></span>

### <a name="sharing-a-command-list"></a><span data-ttu-id="5752a-146">Совместное использование списка команд</span><span class="sxs-lookup"><span data-stu-id="5752a-146">Sharing a command list</span></span>

<span data-ttu-id="5752a-147">Простейший метод взаимодействия требует предоставления общего доступа только к списку команд с частью подсистемы.</span><span class="sxs-lookup"><span data-stu-id="5752a-147">The simplest method of interop requires sharing only a command list with a portion of the engine.</span></span> <span data-ttu-id="5752a-148">После завершения операций отрисовки владелец списка команд перейдет к вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="5752a-148">Once the rendering operations have completed, the command list ownership goes back to the caller.</span></span> <span data-ttu-id="5752a-149">Владение списком команд можно отслеживать в стеке.</span><span class="sxs-lookup"><span data-stu-id="5752a-149">The ownership of the command list can be traced through the stack.</span></span> <span data-ttu-id="5752a-150">Так как списки команд являются отдельными потоками, приложение не может выполнить что-либо уникальное или инновационное с помощью этого метода.</span><span class="sxs-lookup"><span data-stu-id="5752a-150">Since command lists are single threaded, there’s no way for an app to do something unique or innovative using this technique.</span></span>

### <a name="sharing-a-command-queue"></a><span data-ttu-id="5752a-151">Совместное использование очереди команд</span><span class="sxs-lookup"><span data-stu-id="5752a-151">Sharing a command queue</span></span>

<span data-ttu-id="5752a-152">Возможно, самым распространенным способом для нескольких компонентов, совместно использующих устройство в одном процессе.</span><span class="sxs-lookup"><span data-stu-id="5752a-152">Probably the most common technique for multiple components sharing a device in the same process.</span></span>

<span data-ttu-id="5752a-153">Если очередь команд является единицей совместного использования, необходимо вызвать компонент, чтобы убедиться, что все необработанные списки команд должны быть немедленно отправлены в очередь команд (и все очереди внутренних команд должны быть синхронизированы).</span><span class="sxs-lookup"><span data-stu-id="5752a-153">When the command queue is the unit of sharing, there needs to be a call to the component to let it know that all outstanding command lists need to be submitted to the command queue immediately (and any internal command queues need to be synchronized).</span></span> <span data-ttu-id="5752a-154">Это эквивалентно API-интерфейсу [**очистки**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-flush) D3D11, и это единственный способ, с помощью которого приложение может отправлять собственные списки команд или примитивы синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5752a-154">This is equivalent to the D3D11 [**Flush**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-flush) API, and is the only way that the application can submit its own command lists or sync primitives.</span></span>

### <a name="sharing-sync-primitives"></a><span data-ttu-id="5752a-155">Совместное использование примитивов синхронизации</span><span class="sxs-lookup"><span data-stu-id="5752a-155">Sharing sync primitives</span></span>

<span data-ttu-id="5752a-156">Ожидаемый шаблон для компонента, который работает на собственных устройствах и/или очередях команд, — принять [**ID3D12Fence**](/windows/desktop/api/d3d12/nn-d3d12-id3d12fence) или общий дескриптор и пару UInt64 после начала работы, которая будет ожидать, а затем второй ID3D12Fence или общий дескриптор, а также пару UInt64, которая будет сообщать о завершении всей работы.</span><span class="sxs-lookup"><span data-stu-id="5752a-156">The expected pattern for a component which operates on its own devices and/or command queues will be to accept an [**ID3D12Fence**](/windows/desktop/api/d3d12/nn-d3d12-id3d12fence) or shared handle, and UINT64 pair upon beginning its work, which it will wait on, and then a second ID3D12Fence or shared handle, and UINT64 pair which it will signal when all work is complete.</span></span> <span data-ttu-id="5752a-157">Этот шаблон соответствует текущей реализации схемы синхронизации модели [**идксгикэйедмутекс**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex) и DWM/DXGI.</span><span class="sxs-lookup"><span data-stu-id="5752a-157">This pattern matches the current implementation of both [**IDXGIKeyedMutex**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex) and the DWM/DXGI flip model synchronization design.</span></span>

### <a name="sharing-resources"></a><span data-ttu-id="5752a-158">Совместное использование ресурсов</span><span class="sxs-lookup"><span data-stu-id="5752a-158">Sharing resources</span></span>

<span data-ttu-id="5752a-159">Гораздо сложнее написать приложение D3D12, использующее несколько компонентов, — как работать с ресурсами, которые совместно используются в границах компонентов.</span><span class="sxs-lookup"><span data-stu-id="5752a-159">By far the most complicated part of writing a D3D12 app which leverages multiple components is how to deal with the resources which are shared across component boundaries.</span></span> <span data-ttu-id="5752a-160">Это в основном обусловлено концепцией состояний ресурсов.</span><span class="sxs-lookup"><span data-stu-id="5752a-160">This is mostly due to the concept of resource states.</span></span> <span data-ttu-id="5752a-161">Хотя некоторые аспекты проектирования состояния ресурсов предназначены для работы с синхронизацией внутри списка команд, другие могут оказывать влияние между списками команд, влияя на макет ресурсов и допустимыми наборами операций или характеристиками производительности доступа к данным ресурсов.</span><span class="sxs-lookup"><span data-stu-id="5752a-161">While some aspects of the resource state design are meant to deal with intra-command-list synchronization, others do have impact between command lists, affecting resource layout and either valid sets of operations or performance characteristics of accessing the resource data.</span></span>

<span data-ttu-id="5752a-162">Существует два шаблона работы с этой сложностью, которые, в сущности, подразумевают контракт между компонентами.</span><span class="sxs-lookup"><span data-stu-id="5752a-162">There are two patterns of dealing with this complication, both of which involve essentially a contract between components.</span></span>

-   <span data-ttu-id="5752a-163">Контракт может быть определен разработчиком компонента и документирован.</span><span class="sxs-lookup"><span data-stu-id="5752a-163">The contract can be defined by the component developer and documented.</span></span> <span data-ttu-id="5752a-164">Это может быть так же просто, как «ресурс должен быть в состоянии по умолчанию при запуске работы, и будет возвращен в состояние по умолчанию по завершении работы» или может иметь более сложные правила, позволяющие предоставить общий доступ к буферу глубины без принудительного разрешения промежуточной глубины.</span><span class="sxs-lookup"><span data-stu-id="5752a-164">This could be as simple as “the resource must be in the default state when work is started, and will be put back in the default state when work is done” or could have more complicated rules to allow things like sharing a depth buffer without forcing intermediate depth resolves.</span></span>
-   <span data-ttu-id="5752a-165">Контракт может быть определен приложением во время выполнения, когда ресурс совместно используется в границах компонентов.</span><span class="sxs-lookup"><span data-stu-id="5752a-165">The contract can be defined by the application at runtime, at the time when the resource is shared across component boundaries.</span></span> <span data-ttu-id="5752a-166">Он состоит из одних и тех же двух частей информации: состояние, в котором будет находиться ресурс, когда компонент начинает использовать его, и состояние, в котором компонент должен оставить его в момент завершения.</span><span class="sxs-lookup"><span data-stu-id="5752a-166">It consists of the same two pieces of information – the state the resource will be in when the component starts using it, and the state the component should leave it in when it finishes.</span></span>

### <a name="choosing-an-interop-model"></a><span data-ttu-id="5752a-167">Выбор модели взаимодействия</span><span class="sxs-lookup"><span data-stu-id="5752a-167">Choosing an interop model</span></span>

<span data-ttu-id="5752a-168">Для большинства D3D12 приложений совместное использование очереди команд, вероятно, является идеальной моделью.</span><span class="sxs-lookup"><span data-stu-id="5752a-168">For most D3D12 applications, sharing a command queue is probably the ideal model.</span></span> <span data-ttu-id="5752a-169">Она позволяет полностью владеть созданием и отправкой работы без дополнительной нагрузки на память из избыточных очередей и без снижения производительности при работе с примитивами синхронизации GPU.</span><span class="sxs-lookup"><span data-stu-id="5752a-169">It allows complete ownership of work creation and submission, without the additional memory overhead from having redundant queues, and without the perf impact of dealing with the GPU sync primitives.</span></span>

<span data-ttu-id="5752a-170">Общий доступ к примитивам синхронизации требуется, когда компоненты должны работать с различными свойствами очереди, например с типом или приоритетом, или после того, как общий доступ должен охватывать границы процесса.</span><span class="sxs-lookup"><span data-stu-id="5752a-170">Sharing sync primitives is required once the components need to deal with different queue properties, such as type or priority, or once the sharing needs to span process boundaries.</span></span>

<span data-ttu-id="5752a-171">Совместное использование или создание списков команд не широко используется внешними компонентами сторонних разработчиков, но они могут широко использоваться в компонентах, которые являются внутренними для игрового ядра.</span><span class="sxs-lookup"><span data-stu-id="5752a-171">Sharing or producing command lists are not widely used externally by third party components, but might be widely used in components which are internal to a game engine.</span></span>

## <a name="interop-apis"></a><span data-ttu-id="5752a-172">Интерфейсы API взаимодействия</span><span class="sxs-lookup"><span data-stu-id="5752a-172">Interop APIs</span></span>

<span data-ttu-id="5752a-173">В разделе [Direct3D 11 on 12](./direct3d-11-on-12.md) описывается использование большей части области API, связанной с видами взаимодействия, описанными в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="5752a-173">The [Direct3D 11 on 12](./direct3d-11-on-12.md) topic walks you through the usage of much of the API surface related to the kinds of interoperation described in this topic.</span></span>

<span data-ttu-id="5752a-174">См. также метод [ID3D12Device:: креатешаредхандле](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle) , который можно использовать для совместного использования поверхностей между API графических интерфейсов Windows.</span><span class="sxs-lookup"><span data-stu-id="5752a-174">Also see the [ID3D12Device::CreateSharedHandle](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle) method, which you can use to share surfaces between Windows graphics APIs.</span></span>

## <a name="related-topics"></a><span data-ttu-id="5752a-175">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="5752a-175">Related topics</span></span>

* [<span data-ttu-id="5752a-176">Основные сведения о Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="5752a-176">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
* [<span data-ttu-id="5752a-177">Работа с Direct3D 11, Direct3D 10 и Direct2D</span><span class="sxs-lookup"><span data-stu-id="5752a-177">Working with Direct3D 11, Direct3D 10 and Direct2D</span></span>](direct3d-12-interop.md)
* [<span data-ttu-id="5752a-178">Direct3D 11 на 12</span><span class="sxs-lookup"><span data-stu-id="5752a-178">Direct3D 11 on 12</span></span>](./direct3d-11-on-12.md)