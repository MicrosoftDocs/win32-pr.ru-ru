---
title: Взаимодействие Direct3D 12
description: D3D12 можно использовать для написания компонентных приложений.
ms.assetid: 51F7E715-82B6-48D8-A06A-CBBEDF6968F5
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3b5fcfe2adf756c12f034031675d0c3ac5571b44
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104549036"
---
# <a name="direct3d-12-interop"></a>Взаимодействие Direct3D 12

D3D12 можно использовать для написания компонентных приложений.

-   [Общие сведения о взаимодействии](#interop-overview)
-   [Причины использования взаимодействия](#reasons-for-using-interop)
    -   [Совместное использование списка команд](#sharing-a-command-list)
    -   [Совместное использование очереди команд](#sharing-a-command-queue)
    -   [Совместное использование примитивов синхронизации](#sharing-sync-primitives)
    -   [Совместное использование ресурсов](#sharing-resources)
    -   [Выбор модели взаимодействия](#choosing-an-interop-model)
-   [Интерфейсы API взаимодействия](#interop-apis)
-   [Связанные темы](#related-topics)

## <a name="interop-overview"></a>Общие сведения о взаимодействии

D3D12 может быть очень мощным и разрешать приложениям писать графические коды с эффективностью, подобной консоли, но не всякий раз, когда нужно переносить колесико и писать все подсистемы отрисовки с нуля. В некоторых случаях другой компонент или библиотека уже сделали это лучше, или в других случаях производительность части кода не столь важна, как ее правильность и удобочитаемость.

В этом разделе рассматриваются следующие методы взаимодействия:

-   D3D12 и D3D12 на одном устройстве
-   D3D12 и D3D12 на разных устройствах
-   D3D12 и любое сочетание D3D11, D3D10 или D2D на одном устройстве
-   D3D12 и любое сочетание D3D11, D3D10 или D2D на разных устройствах
-   D3D12 и GDI, D3D12 и D3D11 и GDI

## <a name="reasons-for-using-interop"></a>Причины использования взаимодействия

Существует несколько причин, по которым приложению требуется D3D12 взаимодействие с другими API. Некоторые примеры.

-   Добавочное перенос: требуется перенести целое приложение с D3D10 или D3D11 на D3D12, в то время как оно работает на промежуточных этапах процесса переноса (для включения тестирования и отладки).
-   Код в виде черного прямоугольника: требуется оставить определенную часть приложения как есть, а затем перенести остальную часть кода. Например, может отсутствовать необходимость в переносе элементов пользовательского интерфейса игры.
-   Неизменяемые компоненты. необходимо использовать компоненты, не принадлежащие приложению, которые не записываются в целевую D3D12.
-   Новый компонент: не требуется переносить все приложение, но требуется использовать новый компонент, написанный с помощью D3D12.

Существует четыре основных метода взаимодействия в D3D12:

-   Приложение может предоставить компоненту список открытых команд, который записывает некоторые дополнительные команды отрисовки в уже привязанный целевой объект рендеринга. Это эквивалентно предоставлению подготовленного контекста устройства другому компоненту в D3D11 и отличному для таких вещей, как добавление пользовательского интерфейса или текста в уже привязанный задний буфер.
-   Приложение может указать очередь команд для компонента, а также требуемый целевой ресурс. Это эквивалентно использованию API [**клеарстате**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-clearstate) или [**девицеконтекстстате**](/windows/desktop/api/d3d11_1/nn-d3d11_1-id3ddevicecontextstate) в D3D11 для предоставления чистого контекста устройства другому компоненту. Вот как работают такие компоненты, как D2D.
-   Компонент может отказаться от модели, где она создает список команд, потенциально параллельно, что приложение несет ответственность за отправку в более позднее время. По крайней мере один ресурс должен быть предоставлен через границы компонентов. Этот же метод доступен в D3D11 с использованием отложенных контекстов, хотя производительность в D3D12 является более предпочтительной.
-   Каждый компонент имеет собственные очереди и (или) устройства, а приложению и компонентам требуется совместное использование ресурсов и сведений о синхронизации на границах компонентов. Это похоже на устаревший `ISurfaceQueue` и более современный [**идксгикэйедмутекс**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex).

Разница между этими сценариями заключается в том, что именно является общим для границ компонентов. Предполагается, что устройство является общим, но, поскольку оно по сути не имеет состояния, оно не имеет отношения к действительности. Ключевыми объектами являются список команд, очередь команд, объекты синхронизации и ресурсы. Каждый из них имеет свои сложности при совместном использовании.

### <a name="sharing-a-command-list"></a>Совместное использование списка команд

Простейший метод взаимодействия требует предоставления общего доступа только к списку команд с частью подсистемы. После завершения операций отрисовки владелец списка команд перейдет к вызывающему объекту. Владение списком команд можно отслеживать в стеке. Так как списки команд являются отдельными потоками, приложение не может выполнить что-либо уникальное или инновационное с помощью этого метода.

### <a name="sharing-a-command-queue"></a>Совместное использование очереди команд

Возможно, самым распространенным способом для нескольких компонентов, совместно использующих устройство в одном процессе.

Если очередь команд является единицей совместного использования, необходимо вызвать компонент, чтобы убедиться, что все необработанные списки команд должны быть немедленно отправлены в очередь команд (и все очереди внутренних команд должны быть синхронизированы). Это эквивалентно API-интерфейсу [**очистки**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-flush) D3D11, и это единственный способ, с помощью которого приложение может отправлять собственные списки команд или примитивы синхронизации.

### <a name="sharing-sync-primitives"></a>Совместное использование примитивов синхронизации

Ожидаемый шаблон для компонента, который работает на собственных устройствах и/или очередях команд, — принять [**ID3D12Fence**](/windows/desktop/api/d3d12/nn-d3d12-id3d12fence) или общий дескриптор и пару UInt64 после начала работы, которая будет ожидать, а затем второй ID3D12Fence или общий дескриптор, а также пару UInt64, которая будет сообщать о завершении всей работы. Этот шаблон соответствует текущей реализации схемы синхронизации модели [**идксгикэйедмутекс**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex) и DWM/DXGI.

### <a name="sharing-resources"></a>Совместное использование ресурсов

Гораздо сложнее написать приложение D3D12, использующее несколько компонентов, — как работать с ресурсами, которые совместно используются в границах компонентов. Это в основном обусловлено концепцией состояний ресурсов. Хотя некоторые аспекты проектирования состояния ресурсов предназначены для работы с синхронизацией внутри списка команд, другие могут оказывать влияние между списками команд, влияя на макет ресурсов и допустимыми наборами операций или характеристиками производительности доступа к данным ресурсов.

Существует два шаблона работы с этой сложностью, которые, в сущности, подразумевают контракт между компонентами.

-   Контракт может быть определен разработчиком компонента и документирован. Это может быть так же просто, как «ресурс должен быть в состоянии по умолчанию при запуске работы, и будет возвращен в состояние по умолчанию по завершении работы» или может иметь более сложные правила, позволяющие предоставить общий доступ к буферу глубины без принудительного разрешения промежуточной глубины.
-   Контракт может быть определен приложением во время выполнения, когда ресурс совместно используется в границах компонентов. Он состоит из одних и тех же двух частей информации: состояние, в котором будет находиться ресурс, когда компонент начинает использовать его, и состояние, в котором компонент должен оставить его в момент завершения.

### <a name="choosing-an-interop-model"></a>Выбор модели взаимодействия

Для большинства D3D12 приложений совместное использование очереди команд, вероятно, является идеальной моделью. Она позволяет полностью владеть созданием и отправкой работы без дополнительной нагрузки на память из избыточных очередей и без снижения производительности при работе с примитивами синхронизации GPU.

Общий доступ к примитивам синхронизации требуется, когда компоненты должны работать с различными свойствами очереди, например с типом или приоритетом, или после того, как общий доступ должен охватывать границы процесса.

Совместное использование или создание списков команд не широко используется внешними компонентами сторонних разработчиков, но они могут широко использоваться в компонентах, которые являются внутренними для игрового ядра.

## <a name="interop-apis"></a>Интерфейсы API взаимодействия

В разделе [Direct3D 11 on 12](./direct3d-11-on-12.md) описывается использование большей части области API, связанной с видами взаимодействия, описанными в этом разделе.

См. также метод [ID3D12Device:: креатешаредхандле](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle) , который можно использовать для совместного использования поверхностей между API графических интерфейсов Windows.

## <a name="related-topics"></a>Связанные темы

* [Основные сведения о Direct3D 12](directx-12-getting-started.md)
* [Работа с Direct3D 11, Direct3D 10 и Direct2D](direct3d-12-interop.md)
* [Direct3D 11 на 12](./direct3d-11-on-12.md)