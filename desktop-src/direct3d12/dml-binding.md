---
title: Привязывание в DirectML
description: В Директмл привязка относится к присоединению ресурсов к конвейеру для использования GPU во время инициализации и выполнения операторов машинного обучения.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: a04bf0bcc63fff810604e3db72fe507cc10040f5
ms.sourcegitcommit: db89157e3be911fdce2e543e99faa31fb2403bc8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/18/2020
ms.locfileid: "104548974"
---
# <a name="binding-in-directml"></a><span data-ttu-id="5c2f1-103">Привязывание в DirectML</span><span class="sxs-lookup"><span data-stu-id="5c2f1-103">Binding in DirectML</span></span>

<span data-ttu-id="5c2f1-104">В Директмл *Привязка* относится к присоединению ресурсов к конвейеру для использования GPU во время инициализации и выполнения операторов машинного обучения.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-104">In DirectML, *binding* refers to the attachment of resources to the pipeline for the GPU to use during the initialization and execution of your machine learning operators.</span></span> <span data-ttu-id="5c2f1-105">Эти ресурсы могут быть входными и выходными десятками, например, а также временными или постоянными ресурсами, которые требуются оператору.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-105">These resources can be input and output tensors, for example, as well as any temporary or persistent resources that the operator needs.</span></span>

<span data-ttu-id="5c2f1-106">В этом разделе рассматриваются концептуальные и процедурные сведения о привязке.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-106">This topic addresses the conceptual and procedural details of binding.</span></span> <span data-ttu-id="5c2f1-107">Рекомендуется также полностью прочитать документацию по вызываемым API-интерфейсам, включая параметры и примечания.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-107">We recommend that you also fully read the documentation for the APIs that you call, including parameters and Remarks.</span></span>

## <a name="important-ideas-in-binding"></a><span data-ttu-id="5c2f1-108">Важные идеи в привязке</span><span class="sxs-lookup"><span data-stu-id="5c2f1-108">Important ideas in binding</span></span>

<span data-ttu-id="5c2f1-109">Приведенный ниже список шагов содержит подробное описание задач, связанных с привязкой.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-109">The list of steps below contain a high-level description of binding-related tasks.</span></span> <span data-ttu-id="5c2f1-110">Эти шаги необходимо выполнять каждый раз при выполнении диспетчеризации [, который можно](/windows/desktop/api/directml/nn-directml-idmldispatchable)отправить, &mdash; либо инициализатором оператора, либо скомпилированным оператором.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-110">You need to follow these steps each time you execute a [dispatchable](/windows/desktop/api/directml/nn-directml-idmldispatchable)&mdash;a dispatchable is either an operator initializer or a compiled operator.</span></span> <span data-ttu-id="5c2f1-111">Эти шаги представляют важные идеи, структуры и методы, задействованные в привязке Директмл.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-111">These steps introduce the important ideas, structures, and methods involved in DirectML binding.</span></span>

<span data-ttu-id="5c2f1-112">В последующих разделах этого раздела более подробно описаны эти задачи привязки, а также приведены примеры фрагментов кода, взятых из примера кода [приложения с минимальным директмлм](dml-min-app.md) .</span><span class="sxs-lookup"><span data-stu-id="5c2f1-112">Subsequent sections in this topic dig deeper and explain these binding tasks in more detail, with illustrative code snippets taken from the [minimal DirectML application](dml-min-app.md) code example.</span></span>

- <span data-ttu-id="5c2f1-113">Вызовите [**идмлдиспатчабле:: жетбиндингпропертиес**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) для диспетчеризации, чтобы определить, сколько дескрипторов требуется, а также каковы временные и постоянные потребности в ресурсах.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-113">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) on the dispatchable to determine how many descriptors it needs, and also its temporary/persistent resource needs.</span></span>
- <span data-ttu-id="5c2f1-114">Создайте кучу дескрипторов Direct3D 12 достаточно большой для дескрипторов и привяжите ее к конвейеру.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-114">Create a Direct3D 12 descriptor heap large enough for the descriptors, and bind it to the pipeline.</span></span>
- <span data-ttu-id="5c2f1-115">Вызовите метод [**идмлдевице:: креатебиндингтабле**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) , чтобы создать таблицу привязки директмл для представления ресурсов, привязанных к конвейеру.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-115">Call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create a DirectML binding table to represent the resources bound to the pipeline.</span></span> <span data-ttu-id="5c2f1-116">Используйте структуру [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) для описания таблицы привязки, включая подмножество дескрипторов, на которые она указывает в куче.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-116">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the subset of the descriptors that it points to in the descriptor heap.</span></span>
- <span data-ttu-id="5c2f1-117">Создавайте временные и постоянные ресурсы в виде буферных ресурсов Direct3D 12, опишите их с помощью структур [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) и [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) и добавляйте их в таблицу привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-117">Create temporary/persistent resources as Direct3D 12 buffer resources, describe them with [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) and [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structures, and add them to the binding table.</span></span>
- <span data-ttu-id="5c2f1-118">Если диспетчеризации является скомпилированным оператором, создайте буфер элементов тензорные в качестве ресурса буфера Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-118">If the dispatchable is a compiled operator, then create a buffer of tensor elements as a Direct3D 12 buffer resource.</span></span> <span data-ttu-id="5c2f1-119">Заполните или отправьте его, опишите с помощью структур **DML_BUFFER_BINDING** и **DML_BINDING_DESC** и добавьте его в таблицу привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-119">Populate/upload it, describe it with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and add it to the binding table.</span></span>
- <span data-ttu-id="5c2f1-120">Передайте таблицу привязки в качестве параметра при вызове [**идмлкоммандрекордер:: рекорддиспатч**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-120">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

## <a name="retrieve-the-binding-properties-of-a-dispatchable"></a><span data-ttu-id="5c2f1-121">Получение свойств привязки для диспетчеризации</span><span class="sxs-lookup"><span data-stu-id="5c2f1-121">Retrieve the binding properties of a dispatchable</span></span>

<span data-ttu-id="5c2f1-122">Структура [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) описывает потребности привязки для диспетчеризации (инициализатор оператора или скомпилированного оператора).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-122">The [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) structure describes the binding needs of a dispatchable (operator initializer or compiled operator).</span></span> <span data-ttu-id="5c2f1-123">Эти свойства, связанные с привязкой, включают число дескрипторов, которые следует привязать к диспетчеризации, а также размер в байтах любого временного или постоянного ресурса, который ему необходим.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-123">These binding-related properties include the number of descriptors that you should bind to the dispatchable, as well as the size in bytes of any temporary and/or persistent resource that it needs.</span></span>

> [!NOTE]
> <span data-ttu-id="5c2f1-124">Даже для нескольких операторов одного типа не следует делать предположения о том, что они имеют одинаковые требования к привязке.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-124">Even for multiple operators of the same type, don't make assumptions about them having the same binding requirements.</span></span> <span data-ttu-id="5c2f1-125">Запросите свойства привязки для каждого создаваемого инициализатора и оператора.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-125">Query the binding properties for every initializer and operator that you create.</span></span>

<span data-ttu-id="5c2f1-126">Вызовите метод [**идмлдиспатчабле:: жетбиндингпропертиес**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) , чтобы получить **DML_BINDING_PROPERTIES**.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-126">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) to retrieve a **DML_BINDING_PROPERTIES**.</span></span>

```cppwinrt
winrt::com_ptr<::IDMLCompiledOperator> dmlCompiledOperator;
// Code to create and compile a DirectML operator goes here.

DML_BINDING_PROPERTIES executeDmlBindingProperties{
    dmlCompiledOperator->GetBindingProperties()
};

winrt::com_ptr<::IDMLOperatorInitializer> dmlOperatorInitializer;
// Code to create a DirectML operator initializer goes here.

DML_BINDING_PROPERTIES initializeDmlBindingProperties{
    dmlOperatorInitializer->GetBindingProperties()
};

UINT descriptorCount = ...
```

<span data-ttu-id="5c2f1-127">`descriptorCount`Получаемое здесь значение определяет (минимальный) размер кучи дескрипторов и таблицы привязки, создаваемой в следующих двух шагах.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-127">The `descriptorCount` value that you retrieve here determines the (minimum) size of the descriptor heap and of the binding table that you create in the next two steps.</span></span>

<span data-ttu-id="5c2f1-128">**DML_BINDING_PROPERTIES** также содержит `TemporaryResourceSize` элемент, который является минимальным размером в байтах временного ресурса, который должен быть привязан к таблице привязки для этого подготовленного объекта.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-128">**DML_BINDING_PROPERTIES** also contains a `TemporaryResourceSize` member, which is the minimum size in bytes of the temporary resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="5c2f1-129">Нулевое значение означает, что временный ресурс не требуется.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-129">A value of zero means that a temporary resource is not required.</span></span>

<span data-ttu-id="5c2f1-130">И `PersistentResourceSize` элемент, который является минимальным размером в байтах постоянного ресурса, который должен быть привязан к таблице привязки для этого подготовленного объекта.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-130">And a `PersistentResourceSize` member, which is the minimum size in bytes of the persistent resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="5c2f1-131">Нулевое значение означает, что постоянный ресурс не требуется.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-131">A value of zero means that a persistent resource is not required.</span></span> <span data-ttu-id="5c2f1-132">Постоянный ресурс, если он необходим, должен быть указан во время инициализации скомпилированного оператора (где он привязан как результат инициализатора оператора), а также во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-132">A persistent resource, if one is needed, must be supplied during initialization of a compiled operator (where it is bound as an output of the operator initializer) as well as during execution.</span></span> <span data-ttu-id="5c2f1-133">Дополнительные сведения об этом приведены далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-133">There's more about this later in this topic.</span></span> <span data-ttu-id="5c2f1-134">Только скомпилированные операторы имеют постоянные ресурсы — инициализаторы операторов всегда возвращают значение 0 для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-134">Only compiled operators have persistent resources—operator initializers always return a value of 0 for this member.</span></span>

<span data-ttu-id="5c2f1-135">При вызове **идмлдиспатчабле:: жетбиндингпропертиес** в инициализаторе оператора как до, так и после вызова [**Идмлоператоринитиализер:: Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), два набора возвращаемых свойств привязки не гарантировано идентичны.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-135">If you call **IDMLDispatchable::GetBindingProperties** on an operator initializer both before and after a call to [**IDMLOperatorInitializer::Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), then the two sets of binding properties retrieved are not guaranteed to be identical.</span></span>

## <a name="describe-create-and-bind-a-descriptor-heap"></a><span data-ttu-id="5c2f1-136">Описание, создание и привязка кучи дескрипторов</span><span class="sxs-lookup"><span data-stu-id="5c2f1-136">Describe, create, and bind a descriptor heap</span></span>

<span data-ttu-id="5c2f1-137">В терминах дескрипторов ответственность начинается и заканчивается в куче дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-137">In terms of descriptors, your responsibility begins and ends with the descriptor heap itself.</span></span> <span data-ttu-id="5c2f1-138">Директмл сам по себе создает дескрипторы в пределах предоставляемой кучи и управляет ими.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-138">DirectML itself takes care of creating and managing the descriptors inside of the heap that you provide.</span></span>

<span data-ttu-id="5c2f1-139">Поэтому используйте структуру [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) , чтобы описать кучу, достаточно большую для числа дескрипторов, которые нужны для диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-139">So, use a [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) structure to describe a heap large enough for the number of descriptors that the dispatchable needs.</span></span> <span data-ttu-id="5c2f1-140">Затем создайте его с помощью [**ID3D12Device:: креатедескрипторхеап**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-140">Then create it with [**ID3D12Device::CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span></span> <span data-ttu-id="5c2f1-141">И, наконец, вызовите [**ID3D12GraphicsCommandList:: сетдескрипторхеапс**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) , чтобы привязать кучу дескрипторов к конвейеру.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-141">And, lastly, call [**ID3D12GraphicsCommandList::SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) to bind your descriptor heap to the pipeline.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12DescriptorHeap> d3D12DescriptorHeap;

D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDescription{};
descriptorHeapDescription.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
descriptorHeapDescription.NumDescriptors = descriptorCount;
descriptorHeapDescription.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

winrt::check_hresult(
    d3D12Device->CreateDescriptorHeap(
        &descriptorHeapDescription,
        _uuidof(d3D12DescriptorHeap),
        d3D12DescriptorHeap.put_void()
    )
);

std::array<ID3D12DescriptorHeap*, 1> d3D12DescriptorHeaps{ d3D12DescriptorHeap.get() };
d3D12GraphicsCommandList->SetDescriptorHeaps(
    static_cast<UINT>(d3D12DescriptorHeaps.size()),
    d3D12DescriptorHeaps.data()
);
```

## <a name="describe-and-create-a-binding-table"></a><span data-ttu-id="5c2f1-142">Описание и создание таблицы привязки</span><span class="sxs-lookup"><span data-stu-id="5c2f1-142">Describe and create a binding table</span></span>

<span data-ttu-id="5c2f1-143">Таблица привязки Директмл представляет ресурсы, привязанные к конвейеру для использования для диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-143">A DirectML binding table represents the resources that you bind to the pipeline for a dispatchable to use.</span></span> <span data-ttu-id="5c2f1-144">Эти ресурсы могут быть входными и выходными десятками (или другими параметрами) для оператора или могут быть различными постоянными и временными ресурсами, с которыми работает диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-144">Those resources could be input and output tensors (or other parameters) for an operator, or they could be various persistent and temporary resources that a dispatchable works with.</span></span>

<span data-ttu-id="5c2f1-145">Используйте структуру [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) для описания таблицы привязки, включая диспетчеризации, для которой таблица привязки будет представлять привязки, и диапазон дескрипторов (из только что созданной кучи дескрипторов), на которые должна ссылаться таблица привязки (и в которую директмл может записывать дескрипторы).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-145">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the dispatchable for which the binding table will represent the bindings, and the range of descriptors (from the descriptor heap that you just created) that you wish the binding table to refer to (and into which DirectML may write descriptors).</span></span> <span data-ttu-id="5c2f1-146">`descriptorCount`Значение (одно из свойств привязки, полученных на первом шаге) указывает, какой минимальный размер (в дескрипторах) таблицы привязки, необходимой для подготовленного объекта.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-146">The `descriptorCount` value (one of the binding properties that we retrieved in the first step) tells us what minimum size is, in descriptors, of the binding table required for the dispatchable object.</span></span> <span data-ttu-id="5c2f1-147">Здесь мы используем это значение, чтобы указать максимальное число дескрипторов, которые Директмл разрешается записывать в нашу кучу, начиная с начала и от предоставленных дескрипторов ЦП и GPU.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-147">Here, we use that value to indicate the maximum number of descriptors that DirectML is permitted to write into our heap, from the start of both the supplied CPU and GPU descriptor handles.</span></span>

<span data-ttu-id="5c2f1-148">Затем вызовите [**идмлдевице:: креатебиндингтабле**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) , чтобы создать таблицу привязки директмл.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-148">Then call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create the DirectML binding table.</span></span> <span data-ttu-id="5c2f1-149">В последующих шагах после создания дополнительных ресурсов для диспетчеризации мы добавим эти ресурсы в таблицу привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-149">In later steps, after we've created further resources for the dispatchable, we'll add those resources to the binding table.</span></span>

<span data-ttu-id="5c2f1-150">Вместо передачи **DML_BINDING_TABLE_DESC** этому вызову можно передать `nullptr` , указав пустую таблицу привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-150">Instead of passing a **DML_BINDING_TABLE_DESC** to this call, you can pass `nullptr`, indicating an empty binding table.</span></span>

```cppwinrt
DML_BINDING_TABLE_DESC dmlBindingTableDesc{};
dmlBindingTableDesc.Dispatchable = dmlOperatorInitializer.get();
dmlBindingTableDesc.CPUDescriptorHandle = d3D12DescriptorHeap->GetCPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.GPUDescriptorHandle = d3D12DescriptorHeap->GetGPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.SizeInDescriptors = descriptorCount;

winrt::com_ptr<::IDMLBindingTable> dmlBindingTable;
winrt::check_hresult(
    dmlDevice->CreateBindingTable(
        &dmlBindingTableDesc,
        __uuidof(dmlBindingTable),
        dmlBindingTable.put_void()
    )
);
```

<span data-ttu-id="5c2f1-151">Порядок, в котором Директмл записывает дескрипторы в кучу, не определен, поэтому приложение должно не перезаписывать дескрипторы, инкапсулированные таблицей привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-151">The order in which DirectML writes descriptors into the heap is unspecified, so your application must take care not to overwrite the descriptors wrapped by the binding table.</span></span> <span data-ttu-id="5c2f1-152">Предоставленные дескрипторы ЦП и GPU могут поступать из разных куч, однако ответственность за то, чтобы весь диапазон дескрипторов, на который ссылается дескриптор дескриптора ЦП, копируется в диапазон, на который ссылается дескриптор GPU, перед выполнением с помощью этой таблицы привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-152">The supplied CPU and GPU descriptor handles may come from different heaps, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span> <span data-ttu-id="5c2f1-153">Куча дескрипторов, из которой предоставляются дескрипторы, должна иметь тип **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-153">The descriptor heap from which the handles are supplied must have type **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span></span> <span data-ttu-id="5c2f1-154">Кроме того, куча, на которую ссылается, `GPUDescriptorHandle` должна представлять собой кучу дескрипторов, видимую в шейдере.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-154">Additionally, the heap referred to by the `GPUDescriptorHandle` must be a shader-visible descriptor heap.</span></span>

<span data-ttu-id="5c2f1-155">Можно сбросить таблицу привязки, чтобы удалить все добавленные в нее ресурсы, в то же время изменив любое свойство, заданное на начальном **DML_BINDING_TABLE_DESC** (чтобы создать оболочку для нового диапазона дескрипторов или повторно использовать его для другой диспетчеризации).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-155">You can reset a binding table to remove any resources that you've added to it, while at the same time changing any property that you set on its initial **DML_BINDING_TABLE_DESC** (to wrap a new range of descriptors, or to re-use it for a different dispatchable).</span></span> <span data-ttu-id="5c2f1-156">Просто внесите изменения в структуру Description и вызовите [**идмлбиндингтабле:: Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-156">Just make the changes to the description structure, and call [**IDMLBindingTable::Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span></span>

```cppwinrt
dmlBindingTableDesc.Dispatchable = pIDMLCompiledOperator.get();

winrt::check_hresult(
    pIDMLBindingTable->Reset(
        &dmlBindingTableDesc
    )
);
```

## <a name="describe-and-bind-any-temporarypersistent-resources"></a><span data-ttu-id="5c2f1-157">Опишите и привяжите временные или постоянные ресурсы</span><span class="sxs-lookup"><span data-stu-id="5c2f1-157">Describe and bind any temporary/persistent resources</span></span>

<span data-ttu-id="5c2f1-158">Структура **DML_BINDING_PROPERTIES** , заполняемая при [извлечении свойств привязки](#retrieve-the-binding-properties-of-a-dispatchable) для диспетчеризации, содержит размер в байтах всех временных и (или) постоянных ресурсов, которые должны быть подготовлены к отправке.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-158">The **DML_BINDING_PROPERTIES** structure that we populated when we [retrieved the binding properties](#retrieve-the-binding-properties-of-a-dispatchable) of our dispatchable contains the size in bytes of any temporary and/or persistent resource that the dispatchable needs.</span></span> <span data-ttu-id="5c2f1-159">Если один из этих размеров не равен нулю, создайте буферный ресурс Direct3D 12 и добавьте его в таблицу привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-159">If either of these sizes is non-zero, then create a Direct3D 12 buffer resource and add it to the binding table.</span></span>

<span data-ttu-id="5c2f1-160">В приведенном ниже примере кода мы создаем временный ресурс ( `temporaryResourceSize` Размер в байтах) для диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-160">In the code example below, we create a temporary resource (`temporaryResourceSize` bytes in size) for the dispatchable.</span></span> <span data-ttu-id="5c2f1-161">Мы описываем, как привязать ресурс, а затем добавим эту привязку к таблице привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-161">We describe how we wish to bind the resource, and then we add that binding to the binding table.</span></span>

<span data-ttu-id="5c2f1-162">Поскольку мы привязываете один буферный ресурс, мы описываем привязку к структуре [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) .</span><span class="sxs-lookup"><span data-stu-id="5c2f1-162">Since we're binding a single buffer resource, we describe our binding with a [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) structure.</span></span> <span data-ttu-id="5c2f1-163">В этой структуре мы указываем буферный ресурс Direct3D 12 (ресурс должен иметь измерение [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)), а также смещение и размер в буфере.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-163">In that structure, we specify the Direct3D 12 buffer resource (the resource must have dimension [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)), as well as an offset-and-size into the buffer.</span></span> <span data-ttu-id="5c2f1-164">Также можно описать привязку для массива буферов (а не для одного буфера), и для этой цели существует структура [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) .</span><span class="sxs-lookup"><span data-stu-id="5c2f1-164">It's also possible to describe a binding for an array of buffers (rather than for a single buffer), and the [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) structure exists for that purpose.</span></span>

<span data-ttu-id="5c2f1-165">Для абстракции различий между буферной привязкой и привязкой массива буфера используется структура  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) .</span><span class="sxs-lookup"><span data-stu-id="5c2f1-165">To abstract away the distinction between a buffer binding and a buffer array binding, we use the  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structure.</span></span> <span data-ttu-id="5c2f1-166">Можно задать `Type` для члена **DML_BINDING_DESC** значение [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) или **DML_BINDING_TYPE_BUFFER_ARRAY**.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-166">You can set the `Type` member of the **DML_BINDING_DESC** to either [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) or **DML_BINDING_TYPE_BUFFER_ARRAY**.</span></span> <span data-ttu-id="5c2f1-167">Затем можно установить `Desc` элемент, указывающий либо на **DML_BUFFER_BINDING** , либо на **DML_BUFFER_ARRAY_BINDING** в зависимости от `Type` .</span><span class="sxs-lookup"><span data-stu-id="5c2f1-167">And you can then set the `Desc` member to point to either a **DML_BUFFER_BINDING** or to a **DML_BUFFER_ARRAY_BINDING**, depending on `Type`.</span></span>

<span data-ttu-id="5c2f1-168">В этом примере мы работаем с временным ресурсом, поэтому мы добавим его в таблицу привязки с помощью вызова [**идмлбиндингтабле:: биндтемпорариресаурце**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-168">We're dealing with the temporary resource in this example, so we add it to the binding table with a call to [**IDMLBindingTable::BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span></span>

```cppwinrt
D3D12_HEAP_PROPERTIES defaultHeapProperties{ CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT) };
winrt::com_ptr<::ID3D12Resource> temporaryBuffer;

D3D12_RESOURCE_DESC temporaryBufferDesc{ CD3DX12_RESOURCE_DESC::Buffer(temporaryResourceSize) };
winrt::check_hresult(
    d3D12Device->CreateCommittedResource(
        &defaultHeapProperties,
        D3D12_HEAP_FLAG_NONE,
        &temporaryBufferDesc,
        D3D12_RESOURCE_STATE_COMMON,
        nullptr,
        __uuidof(temporaryBuffer),
        temporaryBuffer.put_void()
    )
);

DML_BUFFER_BINDING bufferBinding{ temporaryBuffer.get(), 0, temporaryResourceSize };
DML_BINDING_DESC bindingDesc{ DML_BINDING_TYPE_BUFFER, &bufferBinding };
dmlBindingTable->BindTemporaryResource(&bindingDesc);
```

<span data-ttu-id="5c2f1-169">Временный ресурс (если он необходим) — это вспомогательная память, которая используется внутренним образом во время выполнения оператора, поэтому вам не нужно беспокоиться о его содержимом.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-169">A temporary resource (if one is needed) is scratch memory that's used internally during the execution of the operator, so you don't need to be concerned with its contents.</span></span> <span data-ttu-id="5c2f1-170">Кроме того, не нужно размещайте его после вызова [**идмлкоммандрекордер:: рекорддиспатч**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) на GPU.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-170">Nor do you need to keep it around after your call to [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) has completed on the GPU.</span></span> <span data-ttu-id="5c2f1-171">Это означает, что приложение может освободить или перезаписать временный ресурс в между отправками скомпилированного оператора.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-171">This means that your application may release or overwrite the temporary resource in between dispatches of the compiled operator.</span></span> <span data-ttu-id="5c2f1-172">Предоставленный диапазон буфера должен быть привязан как временный ресурс, чтобы его начальное смещение совпадало с [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-172">The supplied buffer range to be bound as the temporary resource must have its start offset aligned to [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="5c2f1-173">Тип кучи, лежащий в основе буфера, должен быть **D3D12_HEAP_TYPE_DEFAULT**.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-173">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

<span data-ttu-id="5c2f1-174">Если отправляемый отчет сообщает ненулевой размер для более длительного постоянного ресурса, то процедура немного отличается.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-174">If the dispatchable reports a non-zero size for its more long-lived persistent resource, though, then the procedure is a little different.</span></span> <span data-ttu-id="5c2f1-175">Необходимо создать буфер и описать привязку, следуя той же схеме, что показано выше.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-175">You should create a buffer and describe a binding following the same pattern as shown above.</span></span> <span data-ttu-id="5c2f1-176">Но добавьте его в таблицу привязки инициализатора оператора с помощью вызова [**идмлбиндингтабле:: биндаутпутс**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), так как это задание инициализатора оператора для инициализации постоянного ресурса.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-176">But add it to your operator initializer's binding table with a call to [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), because it's the operator initializer's job to initialize the persistent resource.</span></span> <span data-ttu-id="5c2f1-177">Затем добавьте его в таблицу привязки скомпилированного оператора с помощью вызова [**идмлбиндингтабле:: биндперсистентресаурце**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-177">Then add it to your compiled operator's binding table with a call to [**IDMLBindingTable::BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span></span> <span data-ttu-id="5c2f1-178">См. пример кода [приложения с минимальным директмл](dml-min-app.md) , чтобы увидеть этот рабочий процесс в действии.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-178">See the [minimal DirectML application](dml-min-app.md) code example to see this workflow in action.</span></span> <span data-ttu-id="5c2f1-179">Содержимое и время существования постоянного ресурса должны сохраняться при условии, что скомпилированный оператор выполняет.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-179">The persistent resource's contents and lifetime must persist as long as the compiled operator does.</span></span> <span data-ttu-id="5c2f1-180">То есть если оператору требуется постоянный ресурс, приложение должно предоставить его во время инициализации, а затем указать его для всех последующих выполнений оператора, не изменяя его содержимое.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-180">That is, if an operator requires a persistent resource, then your application must supply it during initialization and subsequently also supply it to all future executes of the operator without modifying its contents.</span></span> <span data-ttu-id="5c2f1-181">Постоянный ресурс обычно используется Директмл для хранения таблиц подстановки или других долгосрочных данных, которые вычисляются во время инициализации оператора и повторно используются при последующих выполнениях этого оператора.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-181">The persistent resource is typically used by DirectML to store lookup tables or other long-lived data that is computed during initialization of an operator and reused on future executions of that operator.</span></span> <span data-ttu-id="5c2f1-182">Заданный буферный диапазон, который должен быть привязан как постоянный буфер, должно быть согласованным со смещением начала до [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-182">The supplied buffer range to be bound as the persistent buffer must have its start offset aligned to [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="5c2f1-183">Тип кучи, лежащий в основе буфера, должен быть **D3D12_HEAP_TYPE_DEFAULT**.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-183">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

## <a name="describe-and-bind-any-tensors"></a><span data-ttu-id="5c2f1-184">Описание и привязка любых десятков</span><span class="sxs-lookup"><span data-stu-id="5c2f1-184">Describe and bind any tensors</span></span>

<span data-ttu-id="5c2f1-185">Если вы работаете с скомпилированным оператором (а не с инициализатором оператора), необходимо привязать входные и выходные ресурсы (для десятков и других параметров) к таблице привязки оператора.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-185">If you're dealing with a compiled operator (rather than with an operator initializer), then you need to bind input and output resources (for tensors and other parameters) to the operator's binding table.</span></span> <span data-ttu-id="5c2f1-186">Количество привязок должно точно соответствовать числу входных данных оператора, включая дополнительные десятки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-186">The number of bindings must exactly match the number of inputs of the operator, including optional tensors.</span></span> <span data-ttu-id="5c2f1-187">Некоторые десятки входных и выходных данных и другие параметры, которые принимает оператор, описаны в разделе этого оператора (например, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-187">The particular input and output tensors and other parameters that an operator takes are documented in the topic for that operator (for example, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span></span>

<span data-ttu-id="5c2f1-188">Ресурс тензорные — это буфер, содержащий отдельные значения элементов тензорные.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-188">A tensor resource is a buffer that contains the individual element values of the tensor.</span></span> <span data-ttu-id="5c2f1-189">Вы передаете и считываете такой буфер в GPU с помощью регулярных методик Direct3D 12 ([Загрузка ресурсов](/windows/desktop/direct3d12/uploading-resources) и [считывание данных через буфер](/windows/desktop/direct3d12/readback-data-using-heaps)).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-189">You upload and read back such a buffer to/from the GPU using the regular Direct3D 12 techniques ([Upload resources](/windows/desktop/direct3d12/uploading-resources) and [Read back data via a buffer](/windows/desktop/direct3d12/readback-data-using-heaps)).</span></span> <span data-ttu-id="5c2f1-190">См. пример кода [приложения с минимальными директмлми](dml-min-app.md) , чтобы увидеть эти приемы в действии.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-190">See the [minimal DirectML application](dml-min-app.md) code example to see these techniques in action.</span></span>

<span data-ttu-id="5c2f1-191">Наконец, опишите входные и выходные привязки ресурсов с структурами **DML_BUFFER_BINDING** и **DML_BINDING_DESC** , а затем добавьте их в таблицу привязки скомпилированного оператора с вызовами [**Идмлбиндингтабле:: Биндинпутс**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) и [**идмлбиндингтабле:: биндаутпутс**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-191">Lastly, describe your input and output resource bindings with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and then add them to the compiled operator's binding table with calls to [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span> <span data-ttu-id="5c2f1-192">При вызове метода \**идмлбиндингтабле:: BIND \** _ директмл записывает один или несколько дескрипторов в диапазон дескрипторов ЦП.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-192">When you call an \**IDMLBindingTable::Bind\** _ method, DirectML writes one or more descriptors into the range of CPU descriptors.</span></span>

```cppwinrt
DML_BUFFER_BINDING inputBufferBinding{ inputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC inputBindingDesc{ DML_BINDING_TYPE_BUFFER, &inputBufferBinding };
dmlBindingTable->BindInputs(1, &inputBindingDesc);

DML_BUFFER_BINDING outputBufferBinding{ outputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC outputBindingDesc{ DML_BINDING_TYPE_BUFFER, &outputBufferBinding };
dmlBindingTable->BindOutputs(1, &outputBindingDesc);
```

<span data-ttu-id="5c2f1-193">Одним из этапов создания оператора директмл (см. [_ *идмлдевице:: креатеоператор* \*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) является объявление одной или нескольких структур [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) для описания буферов данных тензорные, которые оператор принимает и возвращает.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-193">One of the steps in creating a DirectML operator (see [_ *IDMLDevice::CreateOperator*\*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) is to declare one or more [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) structures to describe the tensor data buffers that the operator takes and returns.</span></span> <span data-ttu-id="5c2f1-194">А также тип и размер буфера тензорные можно дополнительно указать флаг [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) .</span><span class="sxs-lookup"><span data-stu-id="5c2f1-194">As well as the tensor buffer's type and size, you can optionally specify the [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) flag.</span></span>

<span data-ttu-id="5c2f1-195">**DML_TENSOR_FLAG_OWNED_BY_DML** указывает, что данные тензорные должны принадлежать и управляются директмл.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-195">**DML_TENSOR_FLAG_OWNED_BY_DML** indicates that the tensor data should be owned and managed by DirectML.</span></span> <span data-ttu-id="5c2f1-196">Директмл создает копию данных тензорные во время инициализации оператора и сохраняет их в постоянном ресурсе.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-196">DirectML makes a copy of the tensor data during initialization of the operator, and stores it in the persistent resource.</span></span> <span data-ttu-id="5c2f1-197">Это позволяет Директмл выполнять переформатирование данных тензорные в другие, более эффективные формы.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-197">This allows DirectML to perform reformatting of the tensor data into other, more efficient forms.</span></span> <span data-ttu-id="5c2f1-198">Установка этого флага может повысить производительность, но обычно она полезна только для десятков, данные которых не меняются в течение времени существования оператора (например, весовых десятков).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-198">Setting this flag may increase performance, but it's typically only useful for tensors whose data doesn't change for the lifetime of the operator (for example, weight tensors).</span></span> <span data-ttu-id="5c2f1-199">И флаг можно использовать только для входных десятков.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-199">And the flag may only be used on input tensors.</span></span> <span data-ttu-id="5c2f1-200">Если флаг установлен для конкретного описания тензорные, то соответствующий тензорные должен быть привязан к таблице привязки во время инициализации оператора, а не во время выполнения (что приведет к ошибке).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-200">When the flag is set on a particular tensor description, the corresponding tensor must be bound to the binding table during operator initialization, and not during execution (which will result in an error).</span></span> <span data-ttu-id="5c2f1-201">Это отличается от поведения по умолчанию (поведение без флага DML_TENSOR_FLAG_OWNED_BY_DML), где тензорные должен быть привязан во время выполнения, а не во время инициализации.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-201">That's the opposite of the default behavior (the behavior without the DML_TENSOR_FLAG_OWNED_BY_DML flag), where the tensor is expected to be bound during execution, and not during initialization.</span></span> <span data-ttu-id="5c2f1-202">При вводе данных тензорные в инициализатор оператора можно привязать отправку, а не кучу по УМОЛЧАНИю, так как Директмл создает копию данных.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-202">When you supply the tensor data to an operator initializer, it's legal to bind an UPLOAD rather than a DEFAULT heap, because DirectML makes a copy of the data.</span></span> <span data-ttu-id="5c2f1-203">Во всех остальных случаях все ресурсы, привязанные к Директмл, должны быть ресурсами кучи по УМОЛЧАНИю.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-203">In all other cases, all resources bound to DirectML must be DEFAULT heap resources.</span></span>

<span data-ttu-id="5c2f1-204">Дополнительные сведения см. в разделе [**идмлбиндингтабле:: биндинпутс**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**Идмлбиндингтабле:: биндаутпутс**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-204">For more info, see [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span>

## <a name="execute-the-dispatchable"></a><span data-ttu-id="5c2f1-205">Выполнение диспетчеризации</span><span class="sxs-lookup"><span data-stu-id="5c2f1-205">Execute the dispatchable</span></span>

<span data-ttu-id="5c2f1-206">Передайте таблицу привязки в качестве параметра при вызове [**идмлкоммандрекордер:: рекорддиспатч**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-206">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

<span data-ttu-id="5c2f1-207">При использовании таблицы привязки во время вызова **идмлкоммандрекордер:: рекорддиспатч** директмл привязывает соответствующие дескрипторы GPU к конвейеру.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-207">When you use the binding table during a call to **IDMLCommandRecorder::RecordDispatch**, DirectML binds the corresponding GPU descriptors to the pipeline.</span></span> <span data-ttu-id="5c2f1-208">Дескрипторы ЦП и GPU не обязательно должны указывать на одни и те же записи в куче дескрипторов, однако это позволяет приложению гарантировать, что весь диапазон дескрипторов, на который ссылается дескриптор дескриптора ЦП, копируется в диапазон, на который ссылается дескриптор GPU, перед выполнением с помощью этой таблицы привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-208">The CPU and GPU descriptor handles aren't required to point to the same entries in a descriptor heap, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12GraphicsCommandList> d3D12GraphicsCommandList;
// Code to create a Direct3D 12 command list goes here.

winrt::com_ptr<::IDMLCommandRecorder> dmlCommandRecorder;
// Code to create a DirectML command recorder goes here.

dmlCommandRecorder->RecordDispatch(
    d3D12GraphicsCommandList.get(),
    dmlOperatorInitializer.get(),
    dmlBindingTable.get()
);
```

<span data-ttu-id="5c2f1-209">Наконец, закройте список команд Direct3D 12 и отправьте его для выполнения так же, как любой другой список команд.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-209">Finally, close your Direct3D 12 command list, and submit it for execution as you would any other command list.</span></span>

<span data-ttu-id="5c2f1-210">Перед выполнением **рекорддиспатч** на GPU необходимо перевести все привязанные ресурсы в состояние **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** или в состояние неявного продвижения на **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, например **D3D12_RESOURCE_STATE_COMMON**.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-210">Prior to execution of **RecordDispatch** on the GPU, you must transition all bound resources to the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state, or to a state implicitly promotable to **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, such as **D3D12_RESOURCE_STATE_COMMON**.</span></span> <span data-ttu-id="5c2f1-211">После завершения этого вызова ресурсы остаются в состоянии **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** .</span><span class="sxs-lookup"><span data-stu-id="5c2f1-211">After this call completes, the resources remain in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state.</span></span> <span data-ttu-id="5c2f1-212">Единственным исключением из этого является привязка куч для отправки, связанная при выполнении инициализатора операторов, а для одного или нескольких десятков установлен флаг **DML_TENSOR_FLAG_OWNED_BY_DML** .</span><span class="sxs-lookup"><span data-stu-id="5c2f1-212">The only exception to this is for upload heaps bound when executing an operator initializer and while one or more tensors has the **DML_TENSOR_FLAG_OWNED_BY_DML** flag set.</span></span> <span data-ttu-id="5c2f1-213">В этом случае любые кучи передачи, привязанные для входных данных, должны находиться в состоянии **D3D12_RESOURCE_STATE_GENERIC_READ** и остаться в этом состоянии, как это требуется для всех куч передачи.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-213">In that case, any upload heaps bound for input must be in the **D3D12_RESOURCE_STATE_GENERIC_READ** state and will remain in that state, as required by all upload heaps.</span></span> <span data-ttu-id="5c2f1-214">Если **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** не был задан при компиляции оператора, то все привязки должны быть установлены в таблице привязки перед вызовом **рекорддиспатч** , в противном случае поведение не определено.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-214">If **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** was not set when compiling the operator, then all bindings must be set on the binding table before **RecordDispatch** is called, otherwise the behavior is undefined.</span></span> <span data-ttu-id="5c2f1-215">В противном случае, если оператор поддерживает [позднее связывание](#optionally-specify-late-bound-operator-bindings), привязка ресурсов может быть отложена до тех пор, пока список команд Direct3D 12 не будет отправлен в очередь команд для выполнения.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-215">Otherwise, if an operator supports [late binding](#optionally-specify-late-bound-operator-bindings), then binding of resources may be deferred until the Direct3D 12 command list is submitted to the command queue for execution.</span></span>

<span data-ttu-id="5c2f1-216">**Рекорддиспатч** действует логически так же, как вызов [**ID3D12GraphicsCommandList::D Patch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-216">**RecordDispatch** acts logically like a call to [**ID3D12GraphicsCommandList::Dispatch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span></span> <span data-ttu-id="5c2f1-217">Таким образом, барьеры неупорядоченного представления доступа (UAV) необходимы для обеспечения правильного упорядочения при наличии зависимостей данных между диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-217">As such, unordered access view (UAV) barriers are necessary to ensure correct ordering if there are data dependencies between dispatches.</span></span> <span data-ttu-id="5c2f1-218">Этот метод не вставляет UAV барьеры на входные и выходные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-218">This method does not insert UAV barriers on input nor output resources.</span></span> <span data-ttu-id="5c2f1-219">Приложение должно обеспечить выполнение правильных UAV барьеров на входных данных, если их содержимое зависит от вышестоящей диспетчеризации, а также от всех выходов, если имеются нисходящие диспетчеризации, зависящие от этих выходов.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-219">Your application must ensure that the correct UAV barriers are performed on any inputs if their contents depend on an upstream dispatch, and on any outputs if there are downstream dispatches that depend on those outputs.</span></span>

## <a name="lifetime-and-synchronization-of-descriptors-and-binding-table"></a><span data-ttu-id="5c2f1-220">Время существования и синхронизация дескрипторов и таблицы привязки</span><span class="sxs-lookup"><span data-stu-id="5c2f1-220">Lifetime and synchronization of descriptors and binding table</span></span>

<span data-ttu-id="5c2f1-221">Хорошей моделью привязки в Директмл является то, что в фоновом режиме сама таблица привязки Директмл создает дескрипторы неупорядоченного представления доступа (UAV) в пределах предоставляемой кучи дескрипторов и управляет ими.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-221">A good mental model of binding in DirectML is that behind the scenes the DirectML binding table itself is creating and managing unordered access view (UAV) descriptors inside the descriptor heap that you provide.</span></span> <span data-ttu-id="5c2f1-222">Таким образом, все обычные правила Direct3D 12 применяются к синхронизации доступа к этой куче и ее дескрипторам.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-222">So, all of the usual Direct3D 12 rules apply around synchronizing access to that heap and to its descriptors.</span></span> <span data-ttu-id="5c2f1-223">Это приложение отвечает за правильную синхронизацию между работой ЦП и GPU, использующей таблицу привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-223">It's your application's responsibility to perform correct synchronization between the CPU and GPU work that uses a binding table.</span></span>

<span data-ttu-id="5c2f1-224">Таблица привязки не может перезаписать дескриптор во время использования дескриптора (например, в предыдущем кадре).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-224">A binding table can't overwrite a descriptor while the descriptor is in use (by a prior frame, for example).</span></span> <span data-ttu-id="5c2f1-225">Таким образом, если вы хотите повторно использовать уже ограниченную кучу дескрипторов (например, вызвав BIND \* снова в связанной таблице привязки или перезаписав кучу дескрипторов вручную), следует подождать, пока диспетчер, использующий кучу дескрипторов, завершит выполнение на GPU.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-225">So, if you want to reuse an already-bound descriptor heap (for example, by calling Bind\* again on a binding table that points to it, or by overwriting the descriptor heap manually), then you should wait for the dispatchable that's currently using the descriptor heap to finish executing on the GPU.</span></span> <span data-ttu-id="5c2f1-226">В таблице привязки не поддерживается строгая ссылка на кучу дескрипторов, в которую он записывается, поэтому вы не должны выпустить резервную кучу дескрипторов, пока вся работа, использующая эту таблицу привязки, не завершит выполнение на GPU.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-226">A binding table doesn't maintain a strong reference on the descriptor heap that it writes into, so you mustn't release the backing shader-visible descriptor heap until all work using that binding table has completed execution on the GPU.</span></span>

<span data-ttu-id="5c2f1-227">С другой стороны, в то время как в таблице привязки указывается и управляется куча дескрипторов, таблица сама по себе не *содержит* такой памяти.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-227">On the other hand, while a binding table does specify and manage a descriptor heap, the table doesn't itself *contain* any of that memory.</span></span> <span data-ttu-id="5c2f1-228">Таким образом, вы можете освободить или сбросить таблицу привязки в любое время после вызова [**идмлкоммандрекордер:: рекорддиспатч**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) (вам не нужно ждать завершения этого вызова на GPU, если базовые дескрипторы остаются действительными).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-228">So, you may release or reset a binding table any time after you've called [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) with it (you don't need to wait for that call to complete on the GPU, so long as the underlying descriptors remain valid).</span></span>

<span data-ttu-id="5c2f1-229">В таблице привязки не сохраняются строгие ссылки на ресурсы, привязанные к ним &mdash; . приложение должно гарантировать, что ресурсы не будут удалены, пока они все еще используются графическим процессором.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-229">The binding table doesn't keep strong references on any resources bound using it&mdash;your application must ensure that resources are not deleted while still in use by the GPU.</span></span> <span data-ttu-id="5c2f1-230">Кроме того, таблица привязки не является потокобезопасной, так как &mdash; приложение не должно вызывать методы в таблице привязки одновременно из разных потоков без синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-230">Also, a binding table isn't thread safe&mdash;your application must not call methods on a binding table simultaneously from different threads without synchronization.</span></span>

<span data-ttu-id="5c2f1-231">И учтите, что в любом случае повторная привязка необходима только при изменении привязанных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-231">And consider that in any case rebinding is necessary only when you change which resources are bound.</span></span> <span data-ttu-id="5c2f1-232">Если не требуется изменять привязанные ресурсы, то можно выполнить привязку один раз при запуске и передать одну и ту же таблицу привязки каждый раз при вызове **рекорддиспатч**.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-232">If you don't need to change the bound resources, then you can bind once at startup, and pass the same binding table each time you call **RecordDispatch**.</span></span>

<span data-ttu-id="5c2f1-233">Для вывода рабочих нагрузок машинного обучения и подготовки к просмотру достаточно убедиться, что таблицы привязки каждого кадра указывают на диапазоны кучи дескрипторов, которые еще не используются в GPU.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-233">For interleaving machine learning and rendering workloads, just ensure that each frame's binding tables points to ranges of the descriptor heap that are not already in use on the GPU.</span></span>

## <a name="optionally-specify-late-bound-operator-bindings"></a><span data-ttu-id="5c2f1-234">При необходимости укажите привязки операторов с поздним связыванием</span><span class="sxs-lookup"><span data-stu-id="5c2f1-234">Optionally specify late-bound operator bindings</span></span>

<span data-ttu-id="5c2f1-235">Если вы работаете с скомпилированным оператором (а не с инициализатором оператора), то у вас есть возможность указать позднее связывание для оператора.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-235">If you're dealing with a compiled operator (rather than with an operator initializer), then you have the option to specify late binding for the operator.</span></span> <span data-ttu-id="5c2f1-236">Без позднего связывания перед записью оператора в список команд необходимо установить все привязки в таблице привязки.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-236">Without late binding, you must set all bindings on the binding table before you record an operator into a command list.</span></span> <span data-ttu-id="5c2f1-237">С помощью позднего связывания можно задать (или изменить) привязки для операторов, которые уже записаны в список команд до отправки в очередь команд.</span><span class="sxs-lookup"><span data-stu-id="5c2f1-237">With late binding, you can set (or change) bindings on operators that you've already recorded into a command list, before it has been submitted to the command queue.</span></span>

<span data-ttu-id="5c2f1-238">Чтобы указать позднее связывание, вызовите [**идмлдевице:: компилеоператор**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) с `flags` аргументом [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span><span class="sxs-lookup"><span data-stu-id="5c2f1-238">To specify late binding, call [**IDMLDevice::CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) with a `flags` argument of [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span></span>