---
title: Местонахождение
description: Объект считается резидентным, когда он доступен для GPU.
ms.assetid: 956F80D7-EEC8-4D88-B251-EE325614F31E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6b842ce5b3e89c3877f50036e747a90f14104bce
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104549002"
---
# <a name="residency"></a><span data-ttu-id="19e40-103">Местонахождение</span><span class="sxs-lookup"><span data-stu-id="19e40-103">Residency</span></span>

<span data-ttu-id="19e40-104">Объект считается *резидентным* , когда он доступен для GPU.</span><span class="sxs-lookup"><span data-stu-id="19e40-104">An object is considered to be *resident* when it is accessible by the GPU.</span></span>

-   [<span data-ttu-id="19e40-105">Бюджет местонахождение</span><span class="sxs-lookup"><span data-stu-id="19e40-105">Residency budget</span></span>](#residency-budget)
-   [<span data-ttu-id="19e40-106">Ресурсы кучи</span><span class="sxs-lookup"><span data-stu-id="19e40-106">Heap resources</span></span>](#heap-resources)
-   [<span data-ttu-id="19e40-107">Приоритеты местонахождение</span><span class="sxs-lookup"><span data-stu-id="19e40-107">Residency priorities</span></span>](#residency-priorities)
    -   [<span data-ttu-id="19e40-108">Алгоритм приоритета по умолчанию</span><span class="sxs-lookup"><span data-stu-id="19e40-108">Default priority algorithm</span></span>](#default-priority-algorithm)
-   [<span data-ttu-id="19e40-109">Программирование управления местонахождение</span><span class="sxs-lookup"><span data-stu-id="19e40-109">Programming residency management</span></span>](#programming-residency-management)
-   [<span data-ttu-id="19e40-110">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="19e40-110">Related topics</span></span>](#related-topics)

## <a name="residency-budget"></a><span data-ttu-id="19e40-111">Бюджет местонахождение</span><span class="sxs-lookup"><span data-stu-id="19e40-111">Residency budget</span></span>

<span data-ttu-id="19e40-112">GPU пока не поддерживает сбои страниц, поэтому приложения должны зафиксировать данные в физической памяти, пока GPU сможет получить к ним доступ.</span><span class="sxs-lookup"><span data-stu-id="19e40-112">GPUs do not yet support page-faulting, so applications must commit data into physical memory while the GPU could access it.</span></span> <span data-ttu-id="19e40-113">Этот процесс известен как «делая что-то резидентным» и должен выполняться как для физической системной памяти, так и для физической отдельной видеопамяти.</span><span class="sxs-lookup"><span data-stu-id="19e40-113">This process is known as “making something resident”, and must be done for both physical system memory and physical discrete video memory.</span></span> <span data-ttu-id="19e40-114">В D3D12 большинство объектов API инкапсулируют некоторый объем доступной памяти GPU.</span><span class="sxs-lookup"><span data-stu-id="19e40-114">In D3D12, most API objects encapsulate some amount of GPU-accessible memory.</span></span> <span data-ttu-id="19e40-115">Эта память, доступная GPU, становится резидентной во время создания объекта API и удалена при уничтожении объекта API.</span><span class="sxs-lookup"><span data-stu-id="19e40-115">That GPU-accessible memory is made resident during the creation of the API object, and evicted on API object destruction.</span></span>

<span data-ttu-id="19e40-116">Объем физической памяти, доступной для процесса, называется бюджетом видеопамяти.</span><span class="sxs-lookup"><span data-stu-id="19e40-116">The amount of physical memory available for the process is known as the video memory budget.</span></span> <span data-ttu-id="19e40-117">Бюджет может заметно изменяться в фоновом режиме и выходом из спящего режима; и при переключении пользователя на другое приложение оно будет заметно меняться.</span><span class="sxs-lookup"><span data-stu-id="19e40-117">The budget can fluctuate noticeably as background processes wake-up and sleep; and fluctuate dramatically when the user switches away to another application.</span></span> <span data-ttu-id="19e40-118">Приложение может получать уведомления при изменении бюджета и опрашивать как текущий, так и потребляемый в данный момент объем памяти.</span><span class="sxs-lookup"><span data-stu-id="19e40-118">The application can be notified when the budget changes and poll both the current budget and the currently consumed amount of memory.</span></span> <span data-ttu-id="19e40-119">Если приложение не остается в пределах своего бюджета, процесс будет периодически заморожен, чтобы другие приложения выполнялись и (или) API-интерфейсы создания возвращали ошибку.</span><span class="sxs-lookup"><span data-stu-id="19e40-119">If an application doesn’t stay within its budget, the process will be intermittently frozen to allow other applications to run and/or the creation APIs will return failure.</span></span> <span data-ttu-id="19e40-120">Интерфейс [**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3) предоставляет методы, относящиеся к этой функции, в частности [**куеривидеомеморинфо**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo) и [**регистервидеомеморибуджетчанженотификатионевент**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent).</span><span class="sxs-lookup"><span data-stu-id="19e40-120">The [**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3) interface provides the methods pertaining to this functionality, in particular [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo) and [**RegisterVideoMemoryBudgetChangeNotificationEvent**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent).</span></span>

<span data-ttu-id="19e40-121">Приложениям рекомендуется использовать резервирование для обозначения объема памяти, который они не могут проделать.</span><span class="sxs-lookup"><span data-stu-id="19e40-121">Applications are encouraged to use a reservation to denote the amount of memory they cannot go without.</span></span> <span data-ttu-id="19e40-122">В идеале для такого резервирования подходит значение "низкая" графика, заданное пользователем, или что-то еще меньше.</span><span class="sxs-lookup"><span data-stu-id="19e40-122">Ideally, the user-specified “low” graphics settings, or something even lower, is the right value for such a reservation.</span></span> <span data-ttu-id="19e40-123">Настройка резервирования никогда не придает приложению более высокий бюджет по сравнению с обычным получением.</span><span class="sxs-lookup"><span data-stu-id="19e40-123">Setting a reservation won’t ever give an application a higher budget than it would normally receive.</span></span> <span data-ttu-id="19e40-124">Вместо этого сведения о резервировании помогают ядру ОС быстро уменьшить влияние больших случаев нехватки памяти.</span><span class="sxs-lookup"><span data-stu-id="19e40-124">Instead, the reservation information helps the OS kernel quickly minimize the impact of large memory pressure situations.</span></span> <span data-ttu-id="19e40-125">Даже резервирование не гарантирует доступность приложения, если приложение не является приложением переднего плана.</span><span class="sxs-lookup"><span data-stu-id="19e40-125">Even the reservation is not guaranteed to be available to the application when the application isn’t the foreground application.</span></span>

## <a name="heap-resources"></a><span data-ttu-id="19e40-126">Ресурсы кучи</span><span class="sxs-lookup"><span data-stu-id="19e40-126">Heap resources</span></span>

<span data-ttu-id="19e40-127">Несмотря на то, что многие объекты API инкапсулируют память, доступную для GPU, кучи, & ресурсы, должны быть наиболее значимыми способами потребления и управления физической памятью приложениями.</span><span class="sxs-lookup"><span data-stu-id="19e40-127">While many API objects encapsulate some GPU-accessible memory, heaps & resources are expected to be the most significant way applications consume and manage physical memory.</span></span> <span data-ttu-id="19e40-128">Куча — это единица самого низкого уровня для управления физической памятью, поэтому лучше иметь некоторые знания с их свойствами местонахождение.</span><span class="sxs-lookup"><span data-stu-id="19e40-128">A heap is the lowest level unit to manage physical memory, so it’s good to have some familiarity with their residency properties.</span></span>

-   <span data-ttu-id="19e40-129">Кучи нельзя сделать частично резидентным, но в зарезервированных ресурсах Существуют обходные пути.</span><span class="sxs-lookup"><span data-stu-id="19e40-129">Heaps cannot be made partially resident, but workarounds exists with reserved resources.</span></span>
-   <span data-ttu-id="19e40-130">Кучи должны быть включены в бюджет как часть определенного пула.</span><span class="sxs-lookup"><span data-stu-id="19e40-130">Heaps should be budgeted as part of a particular pool.</span></span> <span data-ttu-id="19e40-131">Адаптеры памяти имеют один пул, тогда как дискретные адаптеры имеют два пула.</span><span class="sxs-lookup"><span data-stu-id="19e40-131">UMA adapters have one pool, while discrete adapters have two pools.</span></span> <span data-ttu-id="19e40-132">Несмотря на то, что ядро может переносить некоторые кучи на дискретные адаптеры из видеопамяти в системную память, это делает это только крайне крайнее самое последнее средство.</span><span class="sxs-lookup"><span data-stu-id="19e40-132">While it is true that kernel can shift some heaps on discrete adapters from video memory to system memory, it does so only as an extreme last resort.</span></span> <span data-ttu-id="19e40-133">Приложения не должны полагаться на поведение ядра сверх бюджета и должны сосредоточиться на хорошем управлении бюджетом.</span><span class="sxs-lookup"><span data-stu-id="19e40-133">Applications should not rely on the over-budget behavior of the kernel, and should focus on good budget management instead.</span></span>
-   <span data-ttu-id="19e40-134">Кучи могут быть исключены из местонахождение, что позволяет разносить их содержимое на диск.</span><span class="sxs-lookup"><span data-stu-id="19e40-134">Heaps can be evicted from residency, which allows their content to be paged out to disk.</span></span> <span data-ttu-id="19e40-135">Но уничтожение куч является более надежным методом для высвобождения местонахождение на всех архитектурах адаптеров.</span><span class="sxs-lookup"><span data-stu-id="19e40-135">But, destruction of heaps is a more reliable technique to free up residency across all adapter architectures.</span></span> <span data-ttu-id="19e40-136">В адаптерах, где поле *семаксгпувиртуаладдрессбитсперпроцесс* [**функции D3D12 с \_ \_ \_ \_ виртуальным \_ адресом \_ GPU**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support) приближается к размеру бюджета, [**исключение**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict) не гарантирует надежное освобождение местонахождение.</span><span class="sxs-lookup"><span data-stu-id="19e40-136">On adapters where *theMaxGPUVirtualAddressBitsPerProcess* field of [**D3D12\_FEATURE\_DATA\_GPU\_VIRTUAL\_ADDRESS\_SUPPORT**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support) is near the budget size, [**Evict**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict) won’t reliably reclaim residency.</span></span>
-   <span data-ttu-id="19e40-137">Создание кучи может выполняться очень часто; но он оптимизирован для фоновой обработки потока.</span><span class="sxs-lookup"><span data-stu-id="19e40-137">Heap creation can be slow; but it is optimized for background thread processing.</span></span> <span data-ttu-id="19e40-138">Рекомендуется создавать кучи в фоновых потоках, чтобы избежать сбоев потока отрисовки.</span><span class="sxs-lookup"><span data-stu-id="19e40-138">It’s recommended to create heaps on background threads to avoid glitching the render thread.</span></span> <span data-ttu-id="19e40-139">В D3D12 несколько потоков могут безопасно вызывать вызовы Create подпрограмм параллельно.</span><span class="sxs-lookup"><span data-stu-id="19e40-139">In D3D12, multiple threads may safely call create routines concurrently.</span></span>

<span data-ttu-id="19e40-140">D3D12 предоставляет большую гибкость и ортогональность в своей модели ресурсов, чтобы обеспечить дополнительные возможности для приложений.</span><span class="sxs-lookup"><span data-stu-id="19e40-140">D3D12 introduces more flexibility and orthogonality into its resource model in order to enable more options for applications.</span></span> <span data-ttu-id="19e40-141">В D3D12 есть три высокоуровневые типа ресурсов: зафиксированные, размещенные и зарезервированные.</span><span class="sxs-lookup"><span data-stu-id="19e40-141">There are three high-level types of resources in D3D12: committed, placed, and reserved.</span></span>

-   <span data-ttu-id="19e40-142">Зафиксированные ресурсы одновременно создают как ресурс, так и кучу.</span><span class="sxs-lookup"><span data-stu-id="19e40-142">Committed resources create both a resource and a heap at the same time.</span></span> <span data-ttu-id="19e40-143">Куча является неявной и недоступен напрямую.</span><span class="sxs-lookup"><span data-stu-id="19e40-143">The heap is implicit and cannot be accessed directly.</span></span> <span data-ttu-id="19e40-144">Размер кучи подходит для размещения всего ресурса в куче.</span><span class="sxs-lookup"><span data-stu-id="19e40-144">The heap is appropriately sized to locate the entire resource within the heap.</span></span>
-   <span data-ttu-id="19e40-145">Размещенные ресурсы позволяют размещать ресурс с ненулевым смещением в куче.</span><span class="sxs-lookup"><span data-stu-id="19e40-145">Placed resources allow the placement of a resource at a non-zero offset within a heap.</span></span> <span data-ttu-id="19e40-146">Смещения обычно должны быть выравны 64 КБ; но некоторые исключения существуют в обоих направлениях.</span><span class="sxs-lookup"><span data-stu-id="19e40-146">Offsets must typically be aligned to 64KB; but some exceptions exist in both directions.</span></span> <span data-ttu-id="19e40-147">Для ресурсов MSAA требуется выравнивание в 4-ем смещении и выравнивание по горизонтали для мелких текстур.</span><span class="sxs-lookup"><span data-stu-id="19e40-147">MSAA resources require 4MB offset alignment, and 4KB offset alignment is available for small textures.</span></span> <span data-ttu-id="19e40-148">Размещенные ресурсы не могут быть перемещены или повторно сопоставлены с другой кучей напрямую; но они обеспечивают простое перемещение данных ресурсов между кучами.</span><span class="sxs-lookup"><span data-stu-id="19e40-148">Placed resources cannot be relocated or remapped to another heap directly; but they enable simple relocation of the resource data between heaps.</span></span> <span data-ttu-id="19e40-149">После создания нового размещенного ресурса в другой куче и копирования данных ресурсов для нового расположения данных ресурса потребуется использовать новые дескрипторы ресурсов.</span><span class="sxs-lookup"><span data-stu-id="19e40-149">After creating a new placed resource in a different heap and copying the resource data, new resource descriptors will have to be used for the new resource data location.</span></span>
-   <span data-ttu-id="19e40-150">Зарезервированные ресурсы доступны только в том случае, если адаптер поддерживает мозаичный уровень ресурсов 1 или более.</span><span class="sxs-lookup"><span data-stu-id="19e40-150">Reserved resources are only available when the adapter supports tiled resources tier 1 or greater.</span></span> <span data-ttu-id="19e40-151">Если они доступны, они предлагают наиболее широкие доступные методы управления местонахождение. но не все адаптеры сейчас поддерживают их.</span><span class="sxs-lookup"><span data-stu-id="19e40-151">When available, they offer the most advanced residency management techniques available; but not all adapters currently support them.</span></span> <span data-ttu-id="19e40-152">Они позволяют повторно сопоставить ресурс, не требуя повторного создания дескрипторов ресурсов, частичного MIP уровня местонахождение, сценариев разреженных текстур и т. д. Не все типы ресурсов поддерживаются даже в том случае, если доступны зарезервированные ресурсы, поэтому полностью общий местонахождение Manager на основе страниц пока неосуществим.</span><span class="sxs-lookup"><span data-stu-id="19e40-152">They enable remapping a resource without requiring regeneration of resource descriptors, partial mip level residency, and sparse texture scenarios, etc. Not all resources types are supported even when reserved resources are available, so a fully general page-based residency manager isn’t yet feasible.</span></span>

## <a name="residency-priorities"></a><span data-ttu-id="19e40-153">Приоритеты местонахождение</span><span class="sxs-lookup"><span data-stu-id="19e40-153">Residency priorities</span></span>

<span data-ttu-id="19e40-154">Обновление Windows 10 Creators Update позволяет разработчикам влиять на то, какие кучи и ресурсы будут предпочтительнее оставаться резидентными, когда для нехватки памяти требуется понизить уровень некоторых его ресурсов.</span><span class="sxs-lookup"><span data-stu-id="19e40-154">The Windows 10 Creators Update enables developers to influence which heaps and resources will be prefered to stay resident when memory pressure requires that some of its resources be demoted.</span></span> <span data-ttu-id="19e40-155">Это помогает разработчикам создавать более эффективные приложения, используя знания о том, что среда выполнения не может вычислять данные об использовании API.</span><span class="sxs-lookup"><span data-stu-id="19e40-155">This helps developers create better performing applications by leveraging knowlege that the runtime can't infer from API usage.</span></span> <span data-ttu-id="19e40-156">Ожидалось, что разработчики станут более удобными и способны определять приоритеты при переходе с использования зафиксированных ресурсов на зарезервированным и мозаичные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="19e40-156">Its expected that developers will become more comfortable and capable specifying priorities as they transition from using commited resources to resereved and tiled resources.</span></span>

<span data-ttu-id="19e40-157">Применение этих приоритетов должно быть проще, чем управление двумя динамическими бюджетами памяти, их понижение и продвижение ресурсов вручную беттвин их, так как приложения уже могут это сделать.</span><span class="sxs-lookup"><span data-stu-id="19e40-157">Applying these priorities must be easier than manageing two dynamic memory budgets, manually demoting and promoting resources bettween them, since applications can already do that.</span></span> <span data-ttu-id="19e40-158">Таким образом, структура API приоритета местонахождение размещается с учетом разумных приоритетов по умолчанию, назначаемых каждой куче или ресурсу по мере его создания.</span><span class="sxs-lookup"><span data-stu-id="19e40-158">Therefore, the design of the residency priority API is coursely-grained with reasonable default priorities assigned to each heap or resource as its created.</span></span> <span data-ttu-id="19e40-159">Дополнительные сведения см. в разделе [**ID3D12Device1:: сетресиденциприорити**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) и перечисление [**\_ \_ приоритетов D3D12 местонахождение**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) .</span><span class="sxs-lookup"><span data-stu-id="19e40-159">For more information, see [**ID3D12Device1::SetResidencyPriority**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) and the [**D3D12\_RESIDENCY\_PRIORITY**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) enumeration.</span></span>

<span data-ttu-id="19e40-160">При использовании приоритетов разработчики должны быть:</span><span class="sxs-lookup"><span data-stu-id="19e40-160">With priorities, developers are expected to either:</span></span>

-   <span data-ttu-id="19e40-161">Повысьте приоритет нескольких исключительных куч, чтобы лучше уменьшить влияние на производительность этих куч на более ранних или более часто, чем понизить их естественные шаблоны доступа.</span><span class="sxs-lookup"><span data-stu-id="19e40-161">Raise the priority of a few exceptional heaps to better mitigate the experienced performance impact of these heaps being demoted sooner or more frequently than their natural access patterns would demand.</span></span> <span data-ttu-id="19e40-162">Этот подход предполагается использовать в приложениях, переданных из графических интерфейсов API, таких как Direct3D 11 или OpenGL, которые значительно отличаются от модели управления ресурсами, чем Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="19e40-162">This approach is expected to be leveraged by applications ported from graphics APIs such as Direct3D 11 or OpenGL, who's resource management model is significantly different than that of Direct3D 12.</span></span>
-   <span data-ttu-id="19e40-163">Переопределяйте почти все приоритеты кучи с помощью собственной схемы сегментации приложения, фиксированной на основе знаний частоты доступа или динамической работы программиста. Фиксированная схема проще в управлении, чем на динамическую, но может быть менее эффективной и требует от программиста вмешательство по мере изменения использования шаблонов в процессе разработки.</span><span class="sxs-lookup"><span data-stu-id="19e40-163">Override nearly all heap priorities with the application's own bucketization scheme, either fixed, based on the programmer's knowlege of access frequency, or dynamic; a fixed scheme is simpler to manage than a dynamic one, but can be less effective and require programmer intevention as use patterns change over the course of development.</span></span> <span data-ttu-id="19e40-164">Этот подход предполагается использовать в приложениях, созданных с помощью управления ресурсами в стиле Direct3D 12, например тех, которые используют библиотеку местонахождение (особенно динамические схемы).</span><span class="sxs-lookup"><span data-stu-id="19e40-164">This approach is expected to be leveraged by applications that are built with Direct3D 12-style resource management in mind, such as those that use the residency library (especially dynamic schemes).</span></span>

### <a name="default-priority-algorithm"></a><span data-ttu-id="19e40-165">Алгоритм приоритета по умолчанию</span><span class="sxs-lookup"><span data-stu-id="19e40-165">Default priority algorithm</span></span>

<span data-ttu-id="19e40-166">Приложение не может задавать полезные приоритеты для любой кучи, которой он пытается управлять, без предварительного ундерстанинг алгоритма приоритета по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="19e40-166">An application can't specify useful priorities for any heap it attempts to manage without first understaning the default priority algorithm.</span></span> <span data-ttu-id="19e40-167">Это обусловлено тем, что значение назначения определенного приоритета для кучи является производным от его относительного приоритета для других куч с приоритетом, которые конкурируют за ту же память.</span><span class="sxs-lookup"><span data-stu-id="19e40-167">This is because the value of assigning a particular priority to a heap is derived from its relative priority to other prioritized heaps that compete for the same memory.</span></span>

<span data-ttu-id="19e40-168">Стратегия, выбранная для создания приоритетов по умолчанию, состоит в том, чтобы классифицировать кучи в два сегмента, отпользуясь (с более высоким приоритетом) кучами, которые предположительно часто записываются GPU на кучи, которые не являются.</span><span class="sxs-lookup"><span data-stu-id="19e40-168">The strategy chosen for generating default priorities is to categorize heaps into two buckets, favoring (giving higher priority to) heaps that are assumed to be written frequently by the GPU over heaps that aren't.</span></span>

<span data-ttu-id="19e40-169">Контейнер с высоким приоритетом содержит кучи и ресурсы, созданные с помощью флагов, которые определяют их как целевые объекты отрисовки, буферы трафаретов глубины или неупорядоченные представления доступа (Уавс).</span><span class="sxs-lookup"><span data-stu-id="19e40-169">The high-priority bucket contains heaps and resources that are created with flags that identify them as render targets, depth-stencil buffers, or Unordered Access Views (UAVs).</span></span> <span data-ttu-id="19e40-170">Им присваиваются значения приоритета в диапазоне, начиная с **D3D12 \_ местонахождение \_ Priority \_**. для дальнейшего определения приоритета между этими кучами и ресурсами наименьшие 16 бит приоритета устанавливаются в размер кучи или ресурса, деленный на 10 МБ (с насыщением до 0xFFFF для очень больших куч).</span><span class="sxs-lookup"><span data-stu-id="19e40-170">These are assigned priority values in the range starting at **D3D12\_RESIDENCY\_PRIORITY\_HIGH**; to further prioritize among these heaps and resources, the lowest 16-bits of the priority are set to the size of the heap or resource divided by 10MB (saturating to 0xFFFF for extremely large heaps).</span></span> <span data-ttu-id="19e40-171">Это дополнительное определение приоритета увеличивает кучу и ресурсы.</span><span class="sxs-lookup"><span data-stu-id="19e40-171">This additional prioritization favors larger heaps and resources.</span></span>

<span data-ttu-id="19e40-172">Контейнер с низким приоритетом содержит все другие кучи и ресурсы, которым назначено значение приоритета **D3D12 \_ местонахождение \_ Priority \_ Обычная**.</span><span class="sxs-lookup"><span data-stu-id="19e40-172">The low-priority bucket contains all other heaps and resources, which are assigned a priority value of **D3D12\_RESIDENCY\_PRIORITY\_NORMAL**.</span></span> <span data-ttu-id="19e40-173">Дальнейшее определение приоритетов между этими кучами и ресурсами не выполняется.</span><span class="sxs-lookup"><span data-stu-id="19e40-173">No further prioritization among these heaps and resources is attempted.</span></span>

## <a name="programming-residency-management"></a><span data-ttu-id="19e40-174">Программирование управления местонахождение</span><span class="sxs-lookup"><span data-stu-id="19e40-174">Programming residency management</span></span>

<span data-ttu-id="19e40-175">Простые приложения могут получить, просто создав выделенные ресурсы, пока не наблюдаются сбои памяти.</span><span class="sxs-lookup"><span data-stu-id="19e40-175">Simple applications may be able to get by merely creating committed resources until experiencing out-of-memory failures.</span></span> <span data-ttu-id="19e40-176">При сбое приложение может уничтожить другие зафиксированные ресурсы или объекты API, чтобы обеспечить успешное создание ресурсов.</span><span class="sxs-lookup"><span data-stu-id="19e40-176">Upon failure, the application can destroy other committed resources or API objects to enable further resource creations to succeed.</span></span> <span data-ttu-id="19e40-177">Однако даже простые приложения настоятельно рекомендуют отслеживать отрицательные изменения бюджета и уничтожать неиспользуемые объекты API примерно один раз в кадре.</span><span class="sxs-lookup"><span data-stu-id="19e40-177">But, even simple applications are strongly recommended to watch for negative budget changes and destroy unused API objects roughly once a frame.</span></span>

<span data-ttu-id="19e40-178">Сложность структуры управления местонахождение будет возобновлена при попытке оптимизировать архитектуру адаптеров или внедрять приоритеты местонахождение.</span><span class="sxs-lookup"><span data-stu-id="19e40-178">The complexity of a residency management design will go up when trying to optimize for adapter architectures or incorporating residency priorities.</span></span> <span data-ttu-id="19e40-179">Дискретными бюджетирование и управление двумя пулами дискретной памяти будут более сложными, чем управление только одним, и назначение фиксированных приоритетов в масштабе может стать недоступным при развитии использования шаблонов.</span><span class="sxs-lookup"><span data-stu-id="19e40-179">Discretely budgeting and managing two pools of discrete memory will be more complex than managing only one, and assigning fixed priorities on a wide scale can become a maintainance burden if use patterns evolve.</span></span> <span data-ttu-id="19e40-180">Избыточное перенаправление текстур в системную память увеличивает сложность, так как неверный ресурс в системной памяти может значительно повлиять на частоту кадров.</span><span class="sxs-lookup"><span data-stu-id="19e40-180">Overflowing textures into system memory adds more complexity, as the wrong resource in system-memory can severely impact frame rate.</span></span> <span data-ttu-id="19e40-181">И не существует простых функциональных возможностей, позволяющих определить ресурсы, которые могут либо выиграть от более высокой пропускной способности GPU, либо допускать более низкую пропускную способность GPU.</span><span class="sxs-lookup"><span data-stu-id="19e40-181">And, there is no simple functionality to help identify the resources that would either benefit from higher GPU bandwidth or tolerate lower GPU bandwidth.</span></span>

<span data-ttu-id="19e40-182">Даже более сложные конструкции запрашивают функции текущего адаптера.</span><span class="sxs-lookup"><span data-stu-id="19e40-182">Even more complicated designs will query for the features of the current adapter.</span></span> <span data-ttu-id="19e40-183">Эта информация доступна в [**D3D12, \_ \_ \_ \_ \_ \_ Поддержка виртуальных адресов графического процессора Data GPU**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support), [**\_ \_ \_ архитектура данных компонентов D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture), [**\_ \_ \_ уровень мозаичных ресурсов D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier)и [**\_ \_ \_ уровень кучи ресурсов D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier).</span><span class="sxs-lookup"><span data-stu-id="19e40-183">This information is available in [**D3D12\_FEATURE\_DATA\_GPU\_VIRTUAL\_ADDRESS\_SUPPORT**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support), [**D3D12\_FEATURE\_DATA\_ARCHITECTURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture), [**D3D12\_TILED\_RESOURCES\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier), and [**D3D12\_RESOURCE\_HEAP\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier).</span></span>

<span data-ttu-id="19e40-184">Несколько частей приложения, скорее всего, будут использовать разные методы.</span><span class="sxs-lookup"><span data-stu-id="19e40-184">Multiple parts of an application will likely wind up using different techniques.</span></span> <span data-ttu-id="19e40-185">Например, некоторые крупные текстуры и редко используемые пути кода могут использовать зафиксированные ресурсы, в то время как многие текстуры могут быть назначены свойством потоковой передачи и использовать общий метод размещения ресурсов.</span><span class="sxs-lookup"><span data-stu-id="19e40-185">For example, some large textures and rarely exercised code paths may use committed resources, while many textures may be designated with a streaming property and use a general placed-resource technique.</span></span>

## <a name="related-topics"></a><span data-ttu-id="19e40-186">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="19e40-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="19e40-187">**ID3D12Heap**</span><span class="sxs-lookup"><span data-stu-id="19e40-187">**ID3D12Heap**</span></span>](/windows/desktop/api/d3d12/nn-d3d12-id3d12heap)
</dt> <dt>

[<span data-ttu-id="19e40-188">Управление памятью</span><span class="sxs-lookup"><span data-stu-id="19e40-188">Memory Management</span></span>](memory-management.md)
</dt> </dl>

 

 