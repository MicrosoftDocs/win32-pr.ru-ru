---
title: Различия в модели привязки от Direct3D 11
description: Одним из основных решений по проектированию привязок DirectX12 является отделение ее от других задач управления. Это помещает некоторые требования к приложению для управления определенными потенциальными причинами опасности.
ms.assetid: 3EE7E9AE-203D-40D4-9F12-4313ED179035
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a625bd1b79766990658feba9bf18ddf7f46c3788ca20aea1de0b4ab80ae0a71f
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119632529"
---
# <a name="differences-in-the-binding-model-from-direct3d-11"></a>Различия в модели привязки от Direct3D 11

Одним из основных решений по проектированию привязок DirectX12 является отделение ее от других задач управления. Это помещает некоторые требования к приложению для управления определенными потенциальными причинами опасности.

Основное преимущество модели привязки D3D12 заключается в том, что она позволяет приложениям часто изменять привязки текстур без затрат на производительность ЦП. Другими преимуществами является то, что шейдеры имеют доступ к очень большому количеству ресурсов, шейдеру не нужно заранее знать, сколько ресурсов будет привязано, и что можно использовать унифицированную модель привязки ресурсов независимо от оборудования или потока содержимого приложений.

Для повышения производительности в модели привязки не требуется, чтобы система следит за тем, какие привязки приложение запросило использовать GPU, и существует чистая интеграция между привязками и списками команд с несколькими потоками.

В следующих разделах перечислены некоторые изменения в модели привязки ресурсов с момента D3D11.

-   [Управление местонахождение памяти, отделенное от привязки](#memory-residency-management-separated-from-binding)
-   [Управление жизненным циклом объектов, отделенное от привязки](#object-lifetime-management-separated-from-binding)
-   [Отслеживание состояния ресурсов драйвера, отделенное от привязки](#driver-resource-state-tracking-separated-from-binding)
-   [Синхронизация сопоставленной памяти GPU ЦП, отделенной от привязки](#cpu-gpu-mapped-memory-synchronization-separated-from-binding)
-   [Связанные темы](#related-topics)

## <a name="memory-residency-management-separated-from-binding"></a>Управление местонахождение памяти, отделенное от привязки

Приложения имеют явный контроль над тем, какие поверхности они должны быть доступны для непосредственного использования GPU (называемого «резидентным»). И наоборот, они могут применить другие состояния к ресурсам, например явно сделать их нерезидентными или позволить операционной системе выбирать определенные классы приложений, требующих минимального объема памяти. Важно отметить, что Управление приложением того, что является резидентным, полностью отделяется от того, как оно предоставляет доступ к ресурсам для шейдеров.

Отделение управления местонахождение от механизма предоставления шейдерам доступа к ресурсам снижает затраты на систему и оборудование для отрисовки, поскольку ОС не обязательно постоянно проверять состояние локальной привязки, чтобы узнать, что делать в резидентном режиме. Более того, шейдеру больше не нужно знать, какие точные поверхности могут ссылаться на них, если весь набор потенциально доступных ресурсов был заранее создан в резиденте.

## <a name="object-lifetime-management-separated-from-binding"></a>Управление жизненным циклом объектов, отделенное от привязки

В отличие от предыдущих API, система больше не отслеживает привязки ресурсов в конвейере. Это позволяет системе поддерживать ресурсы активности, выпущенные приложением, так как на них по-прежнему ссылаются невыполненные работы GPU.

Прежде чем освободить любой ресурс, например текстуру, необходимо убедиться, что GPU завершил создание ссылок на него. Это означает, что прежде чем приложение сможет безопасно освободить ресурс, графический процессор должен завершить выполнение списка команд, ссылающегося на ресурс.

## <a name="driver-resource-state-tracking-separated-from-binding"></a>Отслеживание состояния ресурсов драйвера, отделенное от привязки

Система больше не проверяет привязки ресурсов, чтобы понять, когда произошел переход ресурсов, требующий дополнительного использования драйвера или GPU. Распространенным примером многих GPU и драйверов является необходимость узнать, когда поверхность используется в качестве целевого представления отрисовки (РТВ) для шейдера представление ресурсов (SRV). Сами приложения теперь должны выделять, когда какие-либо переходы по ресурсам, которые может отслеживать система, происходят через выделенные API.

## <a name="cpu-gpu-mapped-memory-synchronization-separated-from-binding"></a>Синхронизация сопоставленной памяти GPU ЦП, отделенной от привязки

Система больше не проверяет привязки ресурсов, чтобы понять, нужно ли отложить обработку, поскольку она зависит от ресурса, который был сопоставлен для доступа к ЦП, но еще не сопоставлен. Теперь у приложений есть ответственность за синхронизацию доступа к памяти ЦП и GPU. Для этого система предоставляет механизмы, позволяющие приложению запрашивать спящий режим потока ЦП до завершения работы. Опрос также может быть выполнен, но может быть менее эффективным.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Привязка ресурсов](resource-binding.md)
</dt> </dl>

 

 




