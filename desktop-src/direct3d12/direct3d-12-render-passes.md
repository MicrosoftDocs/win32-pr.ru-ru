---
title: Проходы рендеринга Direct3D 12
description: Функция передачи прорисовки позволяет повысить эффективность работы графического процессора за счет уменьшения трафика памяти в память и из нее. Это позволяет приложению лучше выявляет требования к подготовке к просмотру ресурсов и зависимости данных.
ms.localizationpriority: high
ms.topic: article
ms.date: 11/15/2018
ms.openlocfilehash: f776729f17ac0017d713c6f37bc71de7302a7c08
ms.sourcegitcommit: 780d4b1601c45658ef0b799b80d13f45a53d808d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/26/2020
ms.locfileid: "104548923"
---
# <a name="direct3d-12-render-passes"></a><span data-ttu-id="1d4c7-103">Проходы рендеринга Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="1d4c7-103">Direct3D 12 render passes</span></span>

<span data-ttu-id="1d4c7-104">Функция подготовки к просмотру является новой для Windows 10, версия 1809 (10,0; Сборка 17763) и содержит концепцию прохода визуализации Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-104">The render passes feature is new for Windows 10, version 1809 (10.0; Build 17763), and it introduces the concept of a Direct3D 12 render pass.</span></span> <span data-ttu-id="1d4c7-105">Проход визуализации состоит из подмножества команд, записанных в список команд.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-105">A render pass consists of a subset of the commands that you record into a command list.</span></span>

<span data-ttu-id="1d4c7-106">Чтобы объявить, где начинается и заканчивается каждый проход рендеринга, вы вкладывает команды, относящиеся к этому проходу, внутри вызовов [**ID3D12GraphicsCommandList4:: бегинрендерпасс**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass) и [**ендрендерпасс**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-endrenderpass).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-106">To declare where each render pass begins and ends, you nest the commands belonging to that pass inside calls to [**ID3D12GraphicsCommandList4::BeginRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass) and [**EndRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-endrenderpass).</span></span> <span data-ttu-id="1d4c7-107">Следовательно, любой список команд содержит ноль, один или несколько проходов рендеринга.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-107">Consequently, any command list contains zero, one, or more render passes.</span></span>

## <a name="scenarios"></a><span data-ttu-id="1d4c7-108">Сценарии</span><span class="sxs-lookup"><span data-stu-id="1d4c7-108">Scenarios</span></span>

<span data-ttu-id="1d4c7-109">Проходы рендеринга могут повысить производительность модуля подготовки отчетов, если он основан на Tile-Based отложенной отрисовки (ТБДР), помимо других методов.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-109">Render passes can improve the performance of your renderer if it's based on Tile-Based Deferred Rendering (TBDR), among other techniques.</span></span> <span data-ttu-id="1d4c7-110">В частности, этот метод позволяет модулю подготовки отчетов повысить эффективность работы GPU за счет уменьшения трафика памяти в и из памяти, позволяя приложению лучше обнаруживать требования к подготовке к просмотру ресурсов и зависимости данных.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-110">More specifically, the technique helps your renderer to improve GPU efficiency by reducing memory traffic to/from off-chip memory by enabling your application to better identify resource rendering ordering requirements and data dependencies.</span></span>

<span data-ttu-id="1d4c7-111">Отображаемый драйвер, написанный явным образом для использования функции прорисовки, дает лучшие результаты.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-111">A display driver written expressly to leverage the render passes feature gives the best results.</span></span> <span data-ttu-id="1d4c7-112">Но подготовка к просмотру интерфейсов API может выполняться даже на уже существующих драйверах (хотя, не обязательно с повышением производительности).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-112">But render passes APIs can run even on pre-existing drivers (although, not necessarily with performance improvements).</span></span>

<span data-ttu-id="1d4c7-113">Это сценарии, в которых проходы рендеринга предназначены для предоставления значения.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-113">These are the scenarios in which render passes is designed to provide value.</span></span>

### <a name="allow-your-application-to-avoid-unnecessary-loadsstores-of-resources-fromto-main-memory-on-a-tile-based-deferred-rendering-tbdr-architecture"></a><span data-ttu-id="1d4c7-114">Разрешите приложению избежать ненужных нагрузок или хранилищ ресурсов в основной памяти на Tile-Based архитектуре отложенной отрисовки (ТБДР)</span><span class="sxs-lookup"><span data-stu-id="1d4c7-114">Allow your application to avoid unnecessary loads/stores of resources from/to main memory on a Tile-Based Deferred Rendering (TBDR) architecture</span></span>

<span data-ttu-id="1d4c7-115">Одно из значений этапов отрисовки — это то, что оно предоставляет централизованное расположение зависимостей данных приложения для набора операций отрисовки.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-115">One of the value propositions of render passes is that it provides you with a central location to indicate your application's data dependencies for a set of rendering operations.</span></span> <span data-ttu-id="1d4c7-116">Эти зависимости данных позволяют драйверу экрана проверять эти данные в течение времени привязки или барьера, а также выдавать инструкции, которые уменьшают загрузку ресурсов и сохраняет их в основной памяти.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-116">These data dependencies allow the display driver to inspect this data at bind/barrier time, and to issue instructions that minimize resource loads/stores from/to main memory.</span></span>

### <a name="allow-your-tbdr-architecture-to-opportunistically-persistent-resources-in-on-chip-cache-across-render-passes-even-in-separate-command-lists"></a><span data-ttu-id="1d4c7-117">Разрешите вашей архитектуре ТБДР рационально постоянные ресурсы в кэше в микросхеме для проходов отрисовки (даже в отдельных списках команд).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-117">Allow your TBDR architecture to opportunistically persistent resources in on-chip cache across render passes (even in separate Command Lists)</span></span>

> [!NOTE]
> <span data-ttu-id="1d4c7-118">В частности, этот сценарий ограничивается ситуациями, когда вы пишете в одни и те же целевые объекты отрисовки в нескольких списках команд.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-118">Specifically, this scenario is limited to the cases where you're writing to the same render target(s) across multiple command lists.</span></span>

<span data-ttu-id="1d4c7-119">Общий шаблон отрисовки предназначен для того, чтобы приложение отображалось в одни и те же целевые объекты отрисовки для нескольких списков команд последовательно, даже несмотря на то, что команды отрисовки создаются параллельно.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-119">A common rendering pattern is for your application to render to the same render target(s) across multiple command lists serially, even though the rendering commands are generated in parallel.</span></span> <span data-ttu-id="1d4c7-120">Использование проходов рендеринга в этом сценарии позволяет объединять эти передачи таким образом (так как приложение знает, что оно будет возобновлять отрисовку в списке команд сразу же), что драйвер экрана может избежать сброса в основную память в границах списка команд.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-120">Your use of render passes in this scenario allows these passes to be combined in such a way (since the application knows that it will resume rendering on the immediate succeeding command list) that the display driver can avoid a flush to main memory on command list boundaries.</span></span>

## <a name="your-applications-responsibilities"></a><span data-ttu-id="1d4c7-121">Обязанности приложения</span><span class="sxs-lookup"><span data-stu-id="1d4c7-121">Your application's responsibilities</span></span>

<span data-ttu-id="1d4c7-122">Даже при использовании функции «прорисовка», ни среда выполнения Direct3D 12, ни видеодрайвер не принимают на себя ответственность за вывод возможностей по переупорядочиванию и предотвращению загрузки и хранения.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-122">Even with the render passes feature, neither the Direct3D 12 runtime nor the display driver take on the responsibility of deducing opportunities to re-order/avoid loads and stores.</span></span> <span data-ttu-id="1d4c7-123">Чтобы правильно использовать функцию передачи прорисовки, приложение имеет эти обязанности.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-123">To correctly leverage the render passes feature, your application has these responsibilities.</span></span>

- <span data-ttu-id="1d4c7-124">Правильно выявление зависимостей данных и упорядочения для своих операций.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-124">Properly identify data/ordering dependencies for its operations.</span></span>
- <span data-ttu-id="1d4c7-125">Упорядочивайте свои отклонения таким образом, чтобы свести к сведению сокращение количества записей на диск (поэтому, сократите использование флагов **_PRESERVE** ).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-125">Order its submissions in a way that minimizes flushes (so, minimize your use of **_PRESERVE** flags).</span></span>
- <span data-ttu-id="1d4c7-126">Правильно используйте барьеры ресурсов и следите за состоянием ресурсов.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-126">Correctly make use of resource barriers, and track resource state.</span></span>
- <span data-ttu-id="1d4c7-127">Избегайте ненужных копий и сбросов.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-127">Avoid unneeded copies/clears.</span></span> <span data-ttu-id="1d4c7-128">Чтобы определить их, можно использовать автоматические предупреждения о производительности из [средства PIX on Windows](https://devblogs.microsoft.com/pix/).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-128">To help identify these, you can make use of the automated performance warnings from the [PIX on Windows tool](https://devblogs.microsoft.com/pix/).</span></span>

## <a name="using-the-render-pass-feature"></a><span data-ttu-id="1d4c7-129">Использование функции «подготовка к просмотру»</span><span class="sxs-lookup"><span data-stu-id="1d4c7-129">Using the render pass feature</span></span>

### <a name="what-is-a-render-pass"></a><span data-ttu-id="1d4c7-130">Что такое *проход прорисовки*?</span><span class="sxs-lookup"><span data-stu-id="1d4c7-130">What is a *render pass*?</span></span>

<span data-ttu-id="1d4c7-131">Проход визуализации определяется этими элементами.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-131">A render pass is defined by these elements.</span></span>

- <span data-ttu-id="1d4c7-132">Набор выходных привязок, фиксированных на протяжении этапа подготовки к просмотру.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-132">A set of output bindings that are fixed for the duration of the render pass.</span></span> <span data-ttu-id="1d4c7-133">Эти привязки относятся к одному или нескольким представлениям целевого объекта отрисовки (RTVs) и (или) к представлению трафарета глубины.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-133">These bindings are to one or more render target views (RTVs), and/or to a depth stencil view (DSV).</span></span>
- <span data-ttu-id="1d4c7-134">Список операций GPU, предназначенных для набора выходных привязок.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-134">A list of GPU operations that target that set of output bindings.</span></span>
- <span data-ttu-id="1d4c7-135">Метаданные, описывающие зависимости нагрузки и хранения для всех выходных привязок, предназначенных для прохода визуализации.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-135">Metadata that describes the load/store dependencies for all output bindings targeted by the render pass.</span></span>

### <a name="declare-your-output-bindings"></a><span data-ttu-id="1d4c7-136">Объявление выходных привязок</span><span class="sxs-lookup"><span data-stu-id="1d4c7-136">Declare your output bindings</span></span>

<span data-ttu-id="1d4c7-137">В начале этапа рендеринга вы объявляете привязки для целевых объектов отрисовки и (или) в буфер глубины или шаблона.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-137">At the start of a render pass, you declare bindings to your render target(s) and/or to your depth/stencil buffer.</span></span> <span data-ttu-id="1d4c7-138">Привязка к целевым объекту отрисовки необязательна, и она необязательна для привязки к буферу глубины или шаблона.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-138">It's optional to bind to render target(s), and it's optional to bind to a depth/stencil buffer.</span></span> <span data-ttu-id="1d4c7-139">Однако необходимо выполнить привязку по крайней мере к одному из двух, а в приведенном ниже примере кода выполнить привязку к обоим.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-139">But you must bind to at least one of the two, and in the code example below we bind to both.</span></span>

<span data-ttu-id="1d4c7-140">Эти привязки объявляются в вызове [**ID3D12GraphicsCommandList4:: бегинрендерпасс**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-140">You declare these bindings in a call to [**ID3D12GraphicsCommandList4::BeginRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass).</span></span>

```cppwinrt
void render_passes(::ID3D12GraphicsCommandList4 * pIGCL4,
    D3D12_CPU_DESCRIPTOR_HANDLE const& rtvCPUDescriptorHandle,
    D3D12_CPU_DESCRIPTOR_HANDLE const& dsvCPUDescriptorHandle)
{
    const float clearColor4[]{ 0.f, 0.f, 0.f, 0.f };
    CD3DX12_CLEAR_VALUE clearValue{ DXGI_FORMAT_R32G32B32_FLOAT, clearColor4 };

    D3D12_RENDER_PASS_BEGINNING_ACCESS renderPassBeginningAccessClear{ D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_CLEAR, { clearValue } };
    D3D12_RENDER_PASS_ENDING_ACCESS renderPassEndingAccessPreserve{ D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE, {} };
    D3D12_RENDER_PASS_RENDER_TARGET_DESC renderPassRenderTargetDesc{ rtvCPUDescriptorHandle, renderPassBeginningAccessClear, renderPassEndingAccessPreserve };

    D3D12_RENDER_PASS_BEGINNING_ACCESS renderPassBeginningAccessNoAccess{ D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_NO_ACCESS, {} };
    D3D12_RENDER_PASS_ENDING_ACCESS renderPassEndingAccessNoAccess{ D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_NO_ACCESS, {} };
    D3D12_RENDER_PASS_DEPTH_STENCIL_DESC renderPassDepthStencilDesc{ dsvCPUDescriptorHandle, renderPassBeginningAccessNoAccess, renderPassBeginningAccessNoAccess, renderPassEndingAccessNoAccess, renderPassEndingAccessNoAccess };

    pIGCL4->BeginRenderPass(1, &renderPassRenderTargetDesc, &renderPassDepthStencilDesc, D3D12_RENDER_PASS_FLAG_NONE);
    // Record command list.
    pIGCL4->EndRenderPass();
    // Begin/End further render passes and then execute the command list(s).
}
```

<span data-ttu-id="1d4c7-141">Первое поле структуры [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) задается дескриптору дескриптора ЦП, соответствующему одному или нескольким представлениям целевого объекта отрисовки (RTVs).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-141">You set the first field of the [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) structure to the CPU descriptor handle corresponding to one or more render target views (RTVs).</span></span> <span data-ttu-id="1d4c7-142">Аналогично [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) содержит дескриптор ДЕСКРИПТОРа ЦП, соответствующий представлению трафарета глубины (DSV).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-142">Similarly, [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) contains the CPU descriptor handle corresponding to a depth stencil view (DSV).</span></span> <span data-ttu-id="1d4c7-143">Дескрипторы дескрипторов ЦП являются теми же, которые в противном случае передавались в [**ID3D12GraphicsCommandList:: омсетрендертаржетс**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-143">Those CPU descriptor handles are the same ones that you would otherwise pass to [**ID3D12GraphicsCommandList::OMSetRenderTargets**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets).</span></span> <span data-ttu-id="1d4c7-144">И, как и в случае с **омсетрендертаржетс**, ДЕСКРИПТОРы ЦП *привязываются* из соответствующих куч (дескрипторов ЦП) во время вызова **бегинрендерпасс**.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-144">And, just as with **OMSetRenderTargets**, the CPU descriptors are *snapped* from their respective (CPU descriptor) heaps at the time of the call to **BeginRenderPass**.</span></span>

<span data-ttu-id="1d4c7-145">RTVs и DSV не наследуются в ходе подготовки к просмотру.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-145">The RTVs and DSV are not inherited in to the render pass.</span></span> <span data-ttu-id="1d4c7-146">Вместо этого они должны быть установлены.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-146">Rather, they must be set.</span></span> <span data-ttu-id="1d4c7-147">Кроме того, RTVs и DSV, объявленные в **бегинрендерпасс** , распространяются в список команд.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-147">Nor are the RTVs and DSV declared in **BeginRenderPass** propagated out to the command list.</span></span> <span data-ttu-id="1d4c7-148">Вместо этого они находятся в неопределенном состоянии после этапа подготовки к просмотру.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-148">Rather, they are in an undefined state following the render pass.</span></span>

### <a name="render-passes-and-workloads"></a><span data-ttu-id="1d4c7-149">Этапы отрисовки и рабочие нагрузки</span><span class="sxs-lookup"><span data-stu-id="1d4c7-149">Render passes and workloads</span></span>

<span data-ttu-id="1d4c7-150">Нельзя вложить проходы рендеринга, и вы не сможете выполнить проход рендеринга в нескольких списках команд (они должны начинаться и заканчиваться при записи в один список команд).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-150">You can't nest render passes, and you can't have a render pass straddle more than one command list (they must begin and end while recording into a single command list).</span></span> <span data-ttu-id="1d4c7-151">Оптимизация, предназначенная для реализации эффективного многопоточного создания проходов рендеринга, обсуждается в разделе [ Подготовка флагов передачи](#render-pass-flags)ниже.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-151">Optimizations designed to enable efficient multi-threaded generation of render passes are discussed in the section [ render pass Flags](#render-pass-flags), below.</span></span>

<span data-ttu-id="1d4c7-152">Запись, которую вы выполняете в ходе передачи, не является *допустимой* для чтения до последующего прохода отрисовки.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-152">A write that you do from within a render pass isn't *valid* for you to read from until a subsequent render pass.</span></span> <span data-ttu-id="1d4c7-153">Это исключает некоторые типы барьеров в рамках прохода рендеринга &mdash; , например, барьер от **RENDER_TARGET** до **SHADER_RESOURCE** на целевом объекте отрисовки, привязанном в текущий момент.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-153">That precludes some types of barriers from within the render pass&mdash;for example, barriering from **RENDER_TARGET** to **SHADER_RESOURCE** on the currently-bound render target.</span></span> <span data-ttu-id="1d4c7-154">Дополнительные сведения см. в разделе [этапы подготовки к просмотру и барьеры ресурсов](#render-passes-and-resource-barriers)ниже.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-154">For more info, see the section [Render passes and resource barriers](#render-passes-and-resource-barriers), below.</span></span>

<span data-ttu-id="1d4c7-155">Единственным исключением в ограничении записи и чтения, которое было упомянуто выше, является неявное считывание, которое выполняется в процессе тестирования глубины и наложения целевого объекта визуализации.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-155">The one exception to the write-read constraint just mentioned involves the implicit reads that occur as part of depth-testing and render target blending.</span></span>
<span data-ttu-id="1d4c7-156">Таким образом, эти API запрещены в рамках прохода отрисовки (основная среда выполнения удаляет список команд, если они вызываются во время записи).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-156">So, these APIs are disallowed within a render pass (the core runtime removes the command list if any of them are called during recording).</span></span>

- [<span data-ttu-id="1d4c7-157">**ID3D12GraphicsCommandList1:: Атомиккопибуфферуинт**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-157">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint)
- [<span data-ttu-id="1d4c7-158">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-158">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64)
- [<span data-ttu-id="1d4c7-159">**ID3D12GraphicsCommandList4:: Бегинрендерпасс**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-159">**ID3D12GraphicsCommandList4::BeginRenderPass**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass)
- [<span data-ttu-id="1d4c7-160">**ID3D12GraphicsCommandList:: КлеардепсстенЦилвиев**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-160">**ID3D12GraphicsCommandList::ClearDepthStencilView**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-cleardepthstencilview)
- [<span data-ttu-id="1d4c7-161">**ID3D12GraphicsCommandList:: Клеаррендертаржетвиев**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-161">**ID3D12GraphicsCommandList::ClearRenderTargetView**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearrendertargetview)
- [<span data-ttu-id="1d4c7-162">**ID3D12GraphicsCommandList:: Клеарстате**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-162">**ID3D12GraphicsCommandList::ClearState**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearstate)
- [<span data-ttu-id="1d4c7-163">**ID3D12GraphicsCommandList:: Клеарунордередакцессвиевфлоат**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-163">**ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewfloat)
- [<span data-ttu-id="1d4c7-164">**ID3D12GraphicsCommandList:: Клеарунордередакцессвиевуинт**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-164">**ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewuint)
- [<span data-ttu-id="1d4c7-165">**ID3D12GraphicsCommandList:: Копибуфферрегион**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-165">**ID3D12GraphicsCommandList::CopyBufferRegion**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copybufferregion)
- [<span data-ttu-id="1d4c7-166">**ID3D12GraphicsCommandList:: Копиресаурце**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-166">**ID3D12GraphicsCommandList::CopyResource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copyresource)
- [<span data-ttu-id="1d4c7-167">**ID3D12GraphicsCommandList:: Копитекстуререгион**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-167">**ID3D12GraphicsCommandList::CopyTextureRegion**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion)
- [<span data-ttu-id="1d4c7-168">**ID3D12GraphicsCommandList:: Копитилес**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-168">**ID3D12GraphicsCommandList::CopyTiles**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytiles)
- [<span data-ttu-id="1d4c7-169">**ID3D12GraphicsCommandList::D Искардресаурце**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-169">**ID3D12GraphicsCommandList::DiscardResource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-discardresource)
- [<span data-ttu-id="1d4c7-170">**ID3D12GraphicsCommandList::D Patch**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-170">**ID3D12GraphicsCommandList::Dispatch**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch)
- [<span data-ttu-id="1d4c7-171">**ID3D12GraphicsCommandList:: Омсетрендертаржетс**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-171">**ID3D12GraphicsCommandList::OMSetRenderTargets**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets)
- [<span data-ttu-id="1d4c7-172">**ID3D12GraphicsCommandList:: Ресолвекуеридата**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-172">**ID3D12GraphicsCommandList::ResolveQueryData**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvequerydata)
- [<span data-ttu-id="1d4c7-173">**ID3D12GraphicsCommandList:: Ресолвесубресаурце**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-173">**ID3D12GraphicsCommandList::ResolveSubresource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvesubresource)
- [<span data-ttu-id="1d4c7-174">**ID3D12GraphicsCommandList1:: Ресолвесубресаурцерегион**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-174">**ID3D12GraphicsCommandList1::ResolveSubresourceRegion**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion)
- [<span data-ttu-id="1d4c7-175">**ID3D12GraphicsCommandList3:: Сетпротектедресаурцесессион**</span><span class="sxs-lookup"><span data-stu-id="1d4c7-175">**ID3D12GraphicsCommandList3::SetProtectedResourceSession**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist3-setprotectedresourcesession)

### <a name="render-passes-and-resource-barriers"></a><span data-ttu-id="1d4c7-176">Этапы рендеринга и барьеры ресурсов</span><span class="sxs-lookup"><span data-stu-id="1d4c7-176">Render passes and resource barriers</span></span>

<span data-ttu-id="1d4c7-177">Вы не можете читать или использовать запись, которая произошла в рамках одного этапа рендеринга.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-177">You may not read from, or consume, a write that occurred within the same render pass.</span></span> <span data-ttu-id="1d4c7-178">Некоторые барьеры не соответствуют этому ограничению, например от **D3D12_RESOURCE_STATE_RENDER_TARGET** до **\* _SHADER_RESOURCE** на целевом объекте отрисовки в данный момент (и уровень отладки приведет к ошибке).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-178">Certain barriers don't conform to this constraint, for example from **D3D12_RESOURCE_STATE_RENDER_TARGET** to **\*_SHADER_RESOURCE** on the currently-bound render target (and the debug layer will error to that effect).</span></span> <span data-ttu-id="1d4c7-179">Но такое же барьер на целевом объекте прорисовки, записанном *вне* текущего прохода отрисовки, является согласованным, так как операции записи будут завершаться до начала текущего прохода отрисовки.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-179">But, that same barrier on a render target that was written *outside* the current render pass is conformant, because the writes will complete ahead of the current render pass starting.</span></span>
<span data-ttu-id="1d4c7-180">Вам может быть полезно знать о некоторых оптимизациях, которые могут быть внесены драйвером экрана в этом отношении.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-180">You might benefit from knowing about certain optimizations that a display driver can make in this regard.</span></span> <span data-ttu-id="1d4c7-181">При наличии согласованной рабочей нагрузки драйвер экрана может перемещать любые барьеры, обнаруженные в процессе подготовки к просмотру, в начало прохода рендеринга.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-181">Given a conformant workload, a display driver might move any barriers encountered in your render pass to the beginning of the render pass.</span></span> <span data-ttu-id="1d4c7-182">Там они могут быть объединены (и не влияют на операции заполнения или группирования).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-182">There, they can be coalesced (and not interfere with any tiling/binning operations).</span></span> <span data-ttu-id="1d4c7-183">Это допустимая оптимизация, при которой все операции записи были завершены до начала текущего прохода рендеринга.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-183">This is a valid optimization provided that all of your writes have finished before the current render pass starts.</span></span>

<span data-ttu-id="1d4c7-184">Ниже приведен пример более полного примера оптимизации драйверов, в котором предполагается, что у вас есть механизм визуализации, имеющий архитектуру привязки ресурсов до Direct3D 12, &mdash; выполняющую барьеры по *запросу в* зависимости от того, как привязаны ресурсы.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-184">Here's a more complete driver-optimization example, which assumes that you have a rendering engine that has a pre-Direct3D 12-style resource-binding design&mdash;doing barriers *on demand* based on how resources are bound.</span></span> <span data-ttu-id="1d4c7-185">При записи в представление неупорядоченного доступа (UAV) к концу кадра (для использования в следующем фрейме) обработчик может оставить ресурс в состоянии **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** в конце кадра.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-185">When writing into an unordered access view (UAV) toward the end of a frame (to be consumed in the following frame), the engine might happen to leave the resource in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state at the conclusion of the frame.</span></span> <span data-ttu-id="1d4c7-186">В следующем фрейме, когда обработчик привязывает ресурс как представление ресурсов шейдера (SRV), он обнаружит, что ресурс находится в неправильном состоянии, и он выдаст барьер от **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** до **D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE**.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-186">In the frame that follows, when the engine goes to bind the resource as a shader resource view (SRV), it will find that the resource is not in the correct state, and it will issue a barrier from **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** to **D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE**.</span></span> <span data-ttu-id="1d4c7-187">Если это барьер находится на этапе подготовки к просмотру, то драйвер экрана выключается в том случае, если все операции записи уже выполнялись *за пределами* текущего прохода отрисовки, и соответственно (и при этом происходит оптимизация). видеодрайвер может *переместить* барьер вплоть до начала этапа подготовки к просмотру.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-187">If that barrier occurs within the render pass, then the display driver is justified in assuming that all writes have already occurred *outside* of this current render pass, and consequently (and here's where the optimization comes in) the display driver might *move* the barrier up to the start of the render pass.</span></span> <span data-ttu-id="1d4c7-188">Опять же, это допустимо, пока код соответствует ограничению «запись-чтение», описанному в этом разделе и последнем.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-188">Again, this is valid, as long as your code is conforming to the write-read constraint described in this section and the last.</span></span>


<span data-ttu-id="1d4c7-189">Это примеры согласованных барьеров.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-189">These are examples of conformant barriers.</span></span>
- <span data-ttu-id="1d4c7-190">**D3D12_RESOURCE_STATE_UNORDERED_ACCESS** **D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT**.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-190">**D3D12_RESOURCE_STATE_UNORDERED_ACCESS** to **D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT**.</span></span>
- <span data-ttu-id="1d4c7-191">**D3D12_RESOURCE_STATE_COPY_DEST** **\* _SHADER_RESOURCE**.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-191">**D3D12_RESOURCE_STATE_COPY_DEST** to **\*_SHADER_RESOURCE**.</span></span>

<span data-ttu-id="1d4c7-192">И это примеры несогласованных препятствий.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-192">And these are examples of non-conformant barriers.</span></span>

- <span data-ttu-id="1d4c7-193">**D3D12_RESOURCE_STATE_RENDER_TARGET** в любое состояние чтения в RTVs/DSV, привязанном к текущему объекту.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-193">**D3D12_RESOURCE_STATE_RENDER_TARGET** to any read state on currently-bound RTVs/DSVs.</span></span>
- <span data-ttu-id="1d4c7-194">**D3D12_RESOURCE_STATE_DEPTH_WRITE** в любое состояние чтения в RTVs/DSV, привязанном к текущему объекту.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-194">**D3D12_RESOURCE_STATE_DEPTH_WRITE** to any read state on currently-bound RTVs/DSVs.</span></span>
- <span data-ttu-id="1d4c7-195">Любой барьер для псевдонимов.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-195">Any aliasing barrier.</span></span>
- <span data-ttu-id="1d4c7-196">Неупорядоченные барьеры представления доступа (UAV).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-196">Unordered access view (UAV) barriers.</span></span> 

### <a name="resource-access-declaration"></a><span data-ttu-id="1d4c7-197">Объявление доступа к ресурсам</span><span class="sxs-lookup"><span data-stu-id="1d4c7-197">Resource access declaration</span></span>

<span data-ttu-id="1d4c7-198">Во время **бегинрендерпасс** , а также объявление всех ресурсов, которые обслуживаются в качестве RTVs и (или) представления источника данных в рамках этого прохода, необходимо также указать их начальные и конечные характеристики *доступа* .</span><span class="sxs-lookup"><span data-stu-id="1d4c7-198">At **BeginRenderPass** time, as well as declaring all resources that are serving as RTVs and/or DSV within that pass, you must also specify their beginning and ending *access* characteristics.</span></span> <span data-ttu-id="1d4c7-199">Как можно увидеть в примере кода в разделе [объявление выходных привязок](#declare-your-output-bindings) выше, это можно сделать с помощью структур [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) и [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) .</span><span class="sxs-lookup"><span data-stu-id="1d4c7-199">As you can see in the code example in the [Declare your output bindings](#declare-your-output-bindings) section above, you do this with the [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) and [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) structures.</span></span>

<span data-ttu-id="1d4c7-200">Дополнительные сведения см. в разделе структуры [**D3D12_RENDER_PASS_BEGINNING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_beginning_access) и [**D3D12_RENDER_PASS_ENDING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_ending_access) , а также перечисления [**D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_beginning_access_type) и [**D3D12_RENDER_PASS_ENDING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_ending_access_type) .</span><span class="sxs-lookup"><span data-stu-id="1d4c7-200">For more details, see the [**D3D12_RENDER_PASS_BEGINNING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_beginning_access) and [**D3D12_RENDER_PASS_ENDING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_ending_access) structures, and the [**D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_beginning_access_type) and [**D3D12_RENDER_PASS_ENDING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_ending_access_type) enumerations.</span></span>

### <a name="render-pass-flags"></a><span data-ttu-id="1d4c7-201">Отрисовывает флаги Pass</span><span class="sxs-lookup"><span data-stu-id="1d4c7-201">Render pass flags</span></span>

<span data-ttu-id="1d4c7-202">Последний параметр, переданный в **бегинрендерпасс** , является флагом этапа подготовки к просмотру (значение из перечисления [**D3D12_RENDER_PASS_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_flags) ).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-202">The last parameter passed to **BeginRenderPass** is a render pass flag (a value from the [**D3D12_RENDER_PASS_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_flags) enumeration).</span></span>

```cppwinrt
enum D3D12_RENDER_PASS_FLAGS
{
    D3D12_RENDER_PASS_FLAG_NONE = 0,
    D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES = 0x1,
    D3D12_RENDER_PASS_FLAG_SUSPENDING_PASS = 0x2,
    D3D12_RENDER_PASS_FLAG_RESUMING_PASS = 0x4
};
```

#### <a name="uav-writes-within-a-render-pass"></a><span data-ttu-id="1d4c7-203">UAV записи в рамках прохода прорисовки</span><span class="sxs-lookup"><span data-stu-id="1d4c7-203">UAV writes within a render pass</span></span>

<span data-ttu-id="1d4c7-204">Операции записи неупорядоченного представления доступа (UAV) разрешены в рамках этапа подготовки к просмотру, но необходимо указать, что вы будете выдавать UAV записи в рамках прохода визуализации, указав **D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES**, чтобы драйвер дисплея мог отказаться от мозаичного заполнения при необходимости.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-204">Unordered access view (UAV) writes are permitted within a render pass, but you must specifically indicate that you'll be issuing UAV writes within the render pass by specifying **D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES**, so that the display driver can opt out of tiling if necessary.</span></span>

<span data-ttu-id="1d4c7-205">UAVные обращения должны следовать описанному выше ограничению Write-Read (операции записи в ходе подготовки к просмотру недопустимы для чтения до последующего прохода отрисовки).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-205">UAV accesses must follow the write-read constraint described above (writes in a render pass are not valid to read until a subsequent render pass).</span></span> <span data-ttu-id="1d4c7-206">UAV барьеры не разрешены в рамках прохода рендеринга.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-206">UAV barriers are not permitted within a render pass.</span></span>

<span data-ttu-id="1d4c7-207">Привязки UAV (с помощью корневых таблиц или корневых дескрипторов) наследуются в проходы прорисовки и распространяются из проходов прорисовки.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-207">UAV bindings (via root tables or root descriptors) are inherited into render passes, and are propagated out of render passes.</span></span>

#### <a name="suspending-passes-and-resuming-passes"></a><span data-ttu-id="1d4c7-208">Приостановка — передача и возобновление — пройденные</span><span class="sxs-lookup"><span data-stu-id="1d4c7-208">Suspending-passes, and resuming-passes</span></span>

<span data-ttu-id="1d4c7-209">Можно указать весь проход отрисовки как приостановку и/или возобновление-проход.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-209">You can indicate an entire render pass as being a suspending-pass and/or a resuming-pass.</span></span> <span data-ttu-id="1d4c7-210">Приостановка-последующего связывания должно иметь идентичные представления и флаги доступа между проходами, и могут не иметь каких-либо промежуточных операций GPU (например, прорисовка, отправка, Отмена, очистка, копирование, сопоставление элементов обновления, немедленный режим записи, запросы, разрешения запросов) между приостановкой этапа подготовки к просмотру и возобновлением прохода визуализации.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-210">A suspending-followed-by-a-resuming pair must have identical views/access flags between the passes, and may not have any intervening GPU operations (for example, draws, dispatches, discards, clears, copies, update-tile-mappings, write-buffer-immediates, queries, query resolves) between the suspending render pass and the resuming render pass.</span></span>

<span data-ttu-id="1d4c7-211">Предполагаемый вариант использования — многопоточный рендеринг, где, например, четыре списка команд (каждый с собственными проходами рендеринга) могут ориентироваться на одни и те же целевые объекты рендеринга.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-211">The intended use case is multi-threaded rendering, where say four command lists (each with their own render passes) can target the same render targets.</span></span> <span data-ttu-id="1d4c7-212">Когда проходы прорисовки приостановлены или возобновляются в списках команд, списки команд должны выполняться в том же вызове [**ID3D12CommandQueue:: ексекутекоммандлистс**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-212">When render passes are suspended/resumed across command lists, the command lists must be executed in the same call to [**ID3D12CommandQueue::ExecuteCommandLists**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists).</span></span>

<span data-ttu-id="1d4c7-213">Проход рендеринга может возобновляться и приостанавливаться.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-213">A render pass can be both resuming and suspending.</span></span> <span data-ttu-id="1d4c7-214">В многопоточном примере, в котором указаны списки команд 2 и 3, будут возобновлены с 1 до 2 соответственно.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-214">In the multi-threaded example just given, command lists 2 and 3 would be resuming from 1 and 2, respectively.</span></span> <span data-ttu-id="1d4c7-215">И в то же время 2 и 3 приостанавливаются к 3 и 4 соответственно.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-215">And at the same time 2 and 3 would be suspending to 3 and 4, respectively.</span></span>

## <a name="query-for-render-passes-feature-support"></a><span data-ttu-id="1d4c7-216">Запрос на поддержку функций функции подготовки к просмотру</span><span class="sxs-lookup"><span data-stu-id="1d4c7-216">Query for render passes feature support</span></span>

<span data-ttu-id="1d4c7-217">Можно вызвать [**ID3D12Device:: чеккфеатуресуппорт**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) , чтобы запросить экстент, в котором драйвер устройства и/или оборудование эффективно поддерживают проходы отрисовки.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-217">You can call [**ID3D12Device::CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) to query the extent to which a device driver and/or the hardware efficiently supports render passes.</span></span>

```cppwinrt
D3D12_RENDER_PASS_TIER get_render_passes_tier(::ID3D12Device * pIDevice)
{
    D3D12_FEATURE_DATA_D3D12_OPTIONS5 featureSupport{};
    winrt::check_hresult(
        pIDevice->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS5, &featureSupport, sizeof(featureSupport))
    );
    return featureSupport.RenderPassesTier;
}
...
    D3D12_RENDER_PASS_TIER renderPassesTier{ get_render_passes_tier(pIDevice) };
```

<span data-ttu-id="1d4c7-218">Из-за логики сопоставления среды выполнения функция Render передает значение Always.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-218">Because of the runtime's mapping logic, render passes always function.</span></span> <span data-ttu-id="1d4c7-219">Но в зависимости от поддержки функций они не всегда предоставляют преимущество.</span><span class="sxs-lookup"><span data-stu-id="1d4c7-219">But, depending on feature support, they won't always provide a benefit.</span></span> <span data-ttu-id="1d4c7-220">Вы можете использовать код, похожий на приведенный выше пример кода, чтобы определить, стоит ли время выполнять команды в процессе подготовки к просмотру, и когда она определенно не является преимуществом (т. е. когда среда выполнения просто сопоставляется с существующей поверхностью API).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-220">You can use code similar to the code example above to determine whether/when it is worth your while to issue commands as render passes, and when it is definitely not a benefit (that is, when the runtime is just mapping to the existing API surface).</span></span> <span data-ttu-id="1d4c7-221">Выполнение этой проверки особенно важно, если вы используете [D3D11On12](/windows/desktop/direct3d12/direct3d-11-on-12)).</span><span class="sxs-lookup"><span data-stu-id="1d4c7-221">Performing this check is particularly important if you're using [D3D11On12](/windows/desktop/direct3d12/direct3d-11-on-12)).</span></span>

<span data-ttu-id="1d4c7-222">Описание трех уровней поддержки см. в разделе Перечисление [**D3D12_RENDER_PASS_TIER**](/windows/win32/api/d3d12/ne-d3d12-d3d12_render_pass_tier) .</span><span class="sxs-lookup"><span data-stu-id="1d4c7-222">For a description of the three tiers of support, see the [**D3D12_RENDER_PASS_TIER**](/windows/win32/api/d3d12/ne-d3d12-d3d12_render_pass_tier) enumeration.</span></span>
