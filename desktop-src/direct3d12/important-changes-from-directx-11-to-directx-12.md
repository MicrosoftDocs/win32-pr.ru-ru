---
title: Важные изменения с Direct3D 11 до Direct3D 12
description: Direct3D 12 представляет значительный уход с модели программирования Direct3D 11. Direct3D 12 позволяет приложениям ближе к оборудованию, чем когда-либо ранее.
ms.assetid: CE5066C9-7EA6-437D-9EB0-AACFB6CFAD9E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5be891d71d6c1f3a12d8d5aac3ec46785207ed31
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548938"
---
# <a name="important-changes-from-direct3d-11-to-direct3d-12"></a><span data-ttu-id="13928-104">Важные изменения с Direct3D 11 до Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="13928-104">Important Changes from Direct3D 11 to Direct3D 12</span></span>

<span data-ttu-id="13928-105">Direct3D 12 представляет значительный уход с модели программирования Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="13928-105">Direct3D 12 represents a significant departure from the Direct3D 11 programming model.</span></span> <span data-ttu-id="13928-106">Direct3D 12 позволяет приложениям ближе к оборудованию, чем когда-либо ранее.</span><span class="sxs-lookup"><span data-stu-id="13928-106">Direct3D 12 lets apps get closer to hardware than ever before.</span></span> <span data-ttu-id="13928-107">Чем ближе к оборудованию, Direct3D 12 быстрее и эффективнее.</span><span class="sxs-lookup"><span data-stu-id="13928-107">By being closer to hardware, Direct3D 12 is faster and more efficient.</span></span> <span data-ttu-id="13928-108">Но при этом при использовании Direct3D 12 Вы несете ответственность за выполнение большего числа задач, чем при использовании Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="13928-108">But, the trade-off of your app having increased speed and efficiency with Direct3D 12 is that you are responsible for more tasks than you were with Direct3D 11.</span></span>

-   [<span data-ttu-id="13928-109">Явная синхронизация</span><span class="sxs-lookup"><span data-stu-id="13928-109">Explicit Synchronization</span></span>](#explicit-synchronization)
-   [<span data-ttu-id="13928-110">Управление местонахождение физической памяти</span><span class="sxs-lookup"><span data-stu-id="13928-110">Physical Memory Residency Management</span></span>](#physical-memory-residency-management)
-   [<span data-ttu-id="13928-111">Объекты состояния конвейера</span><span class="sxs-lookup"><span data-stu-id="13928-111">Pipeline state objects</span></span>](#pipeline-state-objects)
-   [<span data-ttu-id="13928-112">Списки команд и пакеты</span><span class="sxs-lookup"><span data-stu-id="13928-112">Command lists and bundles</span></span>](#command-lists-and-bundles)
-   [<span data-ttu-id="13928-113">Кучи дескрипторов и таблицы</span><span class="sxs-lookup"><span data-stu-id="13928-113">Descriptor heaps and tables</span></span>](#descriptor-heaps-and-tables)
-   [<span data-ttu-id="13928-114">Перенос с Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="13928-114">Porting from Direct3D 11</span></span>](#porting-from-direct3d-11)
-   [<span data-ttu-id="13928-115">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="13928-115">Related topics</span></span>](#related-topics)

<span data-ttu-id="13928-116">Direct3D 12 является возвратом к программированию низкого уровня; Он обеспечивает более полный контроль над графическими элементами игр и приложений, представляя следующие новые функции: объекты для представления общего состояния конвейера, списки команд и пакеты для отправки работы, а также кучи дескрипторов и таблицы для доступа к ресурсам.</span><span class="sxs-lookup"><span data-stu-id="13928-116">Direct3D 12 is a return to low-level programming; it gives you more control over the graphical elements of your games and apps by introducing these new features: objects to represent the overall state of the pipeline, command lists and bundles for work submission, and descriptor heaps and tables for resource access.</span></span>

<span data-ttu-id="13928-117">Производительность и эффективность приложения увеличились с помощью Direct3D 12, но вы несете ответственность за выполнение большего числа задач, чем при использовании Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="13928-117">Your app has increased speed and efficiency with Direct3D 12, but you are responsible for more tasks than you were with Direct3D 11.</span></span>

## <a name="explicit-synchronization"></a><span data-ttu-id="13928-118">Явная синхронизация</span><span class="sxs-lookup"><span data-stu-id="13928-118">Explicit Synchronization</span></span>

-   <span data-ttu-id="13928-119">В Direct3D 12 синхронизация GPU теперь является явной обязанностью приложения и больше не выполняется неявным образом средой выполнения, как в Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="13928-119">In Direct3D 12, CPU-GPU synchronization is now the explicit responsibility of the app and is no longer implicitly performed by the runtime, as it is in Direct3D 11.</span></span> <span data-ttu-id="13928-120">Это также означает, что автоматическая проверка на наличие угроз конвейера не выполняется Direct3D 12, поэтому это несет ответственность за приложения.</span><span class="sxs-lookup"><span data-stu-id="13928-120">This fact also means that no automatic checking for pipeline hazards is performed by Direct3D 12, so again this is the apps responsibility.</span></span>
-   <span data-ttu-id="13928-121">В Direct3D 12 приложения отвечают за обновление конвейерных данных.</span><span class="sxs-lookup"><span data-stu-id="13928-121">In Direct3D 12, apps are responsible for pipelining data updates.</span></span> <span data-ttu-id="13928-122">То есть шаблон "Map/Lock-DISCARD" в Direct3D 11 необходимо выполнять вручную в Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="13928-122">That is, the "Map/Lock-DISCARD" pattern in Direct3D 11 must be performed manually in Direct3D 12.</span></span> <span data-ttu-id="13928-123">В Direct3D 11, если графический процессор по-прежнему использует буфер при вызове [**ссылку ID3D11DeviceContext:: Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) с [**D3D11ной \_ \_ записью \_ в Map**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), среда выполнения возвращает указатель на новый регион памяти вместо старых данных буфера.</span><span class="sxs-lookup"><span data-stu-id="13928-123">In Direct3D 11, if the GPU is still using the buffer when you call [**ID3D11DeviceContext::Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) with [**D3D11\_MAP\_WRITE\_DISCARD**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), the runtime returns a pointer to a new region of memory instead of the old buffer data.</span></span> <span data-ttu-id="13928-124">Это позволяет GPU продолжать использовать старые данные, пока приложение помещает данные в новый буфер.</span><span class="sxs-lookup"><span data-stu-id="13928-124">This allows the GPU to continue using the old data while the app places data in the new buffer.</span></span> <span data-ttu-id="13928-125">В приложении не требуется дополнительное управление памятью; Старый буфер повторно используется или уничтожается автоматически после завершения работы графического процессора.</span><span class="sxs-lookup"><span data-stu-id="13928-125">No additional memory management is required in the app; the old buffer is reused or destroyed automatically when the GPU is finished with it.</span></span>
-   <span data-ttu-id="13928-126">В Direct3D 12 все динамические обновления (включая буферы констант, динамические буферы вершин, динамические текстуры и т. д.) явным образом управляются приложением.</span><span class="sxs-lookup"><span data-stu-id="13928-126">In Direct3D 12, all dynamic updates (including constant buffers, dynamic vertex buffers, dynamic textures, and so on) are explicitly controlled by the app.</span></span> <span data-ttu-id="13928-127">Эти динамические обновления включают в себя все необходимые временные границы GPU или буферизацию.</span><span class="sxs-lookup"><span data-stu-id="13928-127">These dynamic updates include any required GPU fences or buffering.</span></span> <span data-ttu-id="13928-128">Приложение несет ответственность за хранение доступной памяти, пока она больше не нужна.</span><span class="sxs-lookup"><span data-stu-id="13928-128">The app is responsible for keeping the memory available until it is no longer needed.</span></span>
-   <span data-ttu-id="13928-129">Direct3D 12 использует подсчет ссылок в стиле COM только для времени существования интерфейсов (с использованием модели слабых ссылок Direct3D, привязанной к времени существования устройства).</span><span class="sxs-lookup"><span data-stu-id="13928-129">Direct3D 12 uses COM-style reference counting only for the lifetimes of interfaces (by using the weak reference model of Direct3D tied to the lifetime of the device).</span></span> <span data-ttu-id="13928-130">Все время существования памяти и описания ресурсов — это единственная ответственность за то, что приложение должно поддерживаться в течение нужного времени и не подсчитывается по ссылке.</span><span class="sxs-lookup"><span data-stu-id="13928-130">All resource and description memory lifetimes are the sole responsibly of the app to maintain for the proper duration, and are not reference counted.</span></span> <span data-ttu-id="13928-131">В Direct3D 11 для управления жизненным циклом зависимостей интерфейса также используется подсчет ссылок.</span><span class="sxs-lookup"><span data-stu-id="13928-131">Direct3D 11 uses reference counting to manage the lifetimes of interface dependencies as well.</span></span>

## <a name="physical-memory-residency-management"></a><span data-ttu-id="13928-132">Управление местонахождение физической памяти</span><span class="sxs-lookup"><span data-stu-id="13928-132">Physical Memory Residency Management</span></span>

<span data-ttu-id="13928-133">Приложение Direct3D 12 должно предотвращать состояния гонки между несколькими очередями, несколькими адаптерами и потоками ЦП.</span><span class="sxs-lookup"><span data-stu-id="13928-133">A Direct3D 12 application must prevent race-conditions between multiple queues, multiple adapters, and the CPU threads.</span></span> <span data-ttu-id="13928-134">D3D12 больше не синхронизирует ЦП и GPU, а также не поддерживает удобные механизмы переименования ресурсов и создания нескольких буферов.</span><span class="sxs-lookup"><span data-stu-id="13928-134">D3D12 no longer synchronizes the CPU and GPU, nor supports convenient mechanisms for resource renaming or multi-buffering.</span></span> <span data-ttu-id="13928-135">Границы должны использоваться во избежание нескольких единиц обработки из-за нехватки памяти, прежде чем другой модуль обработки завершит его использование.</span><span class="sxs-lookup"><span data-stu-id="13928-135">Fences must be used to avoid multiple processing units from over-writing memory before another processing unit finishes using it.</span></span>

<span data-ttu-id="13928-136">Приложение Direct3D 12 должно обеспечить, чтобы данные находились в памяти во время считывания GPU.</span><span class="sxs-lookup"><span data-stu-id="13928-136">The Direct3D 12 application must ensure data is resident in memory while the GPU reads it.</span></span> <span data-ttu-id="13928-137">Память, используемая каждым объектом, становится резидентной во время создания объекта.</span><span class="sxs-lookup"><span data-stu-id="13928-137">Memory used by each object is made resident during the creation of the object.</span></span> <span data-ttu-id="13928-138">Приложения, вызывающие эти методы, должны использовать ограждения, чтобы убедиться, что GPU не обращается к удаленным объектам.</span><span class="sxs-lookup"><span data-stu-id="13928-138">Applications which call these methods must use fences to ensure the GPU doesn't access objects which have been evicted.</span></span>

<span data-ttu-id="13928-139">Барьеры ресурсов — это еще один тип синхронизации, используемый для синхронизации изменений ресурсов и подресурсов на очень детализированном уровне.</span><span class="sxs-lookup"><span data-stu-id="13928-139">Resource barriers are another type of synchronization needed, used to synchronize resource and subresource transitions at a very granular level.</span></span>

<span data-ttu-id="13928-140">См. сведения об [управлении памятью в Direct3D 12](memory-management.md).</span><span class="sxs-lookup"><span data-stu-id="13928-140">Refer to [Memory Management in Direct3D 12](memory-management.md).</span></span>

## <a name="pipeline-state-objects"></a><span data-ttu-id="13928-141">Объекты состояния конвейера</span><span class="sxs-lookup"><span data-stu-id="13928-141">Pipeline state objects</span></span>

<span data-ttu-id="13928-142">Direct3D 11 позволяет управлять состоянием конвейера с помощью большого набора независимых объектов.</span><span class="sxs-lookup"><span data-stu-id="13928-142">Direct3D 11 allows pipeline state manipulation through a large set of independent objects.</span></span> <span data-ttu-id="13928-143">Например, состояние входного ассемблера, состояние шейдера пикселей, состояние средства прорисовки и состояние слияния вывода могут быть изменены независимо друг от друга.</span><span class="sxs-lookup"><span data-stu-id="13928-143">For example, input assembler state, pixel shader state, rasterizer state, and output merger state can all be independently modified.</span></span> <span data-ttu-id="13928-144">Такая схема обеспечивает удобное и относительно высокоуровневое представление графического конвейера, но не использует возможности современного оборудования, в основном потому, что различные состояния часто являются взаимозависимыми.</span><span class="sxs-lookup"><span data-stu-id="13928-144">This design provides a convenient and relatively high-level representation of the graphics pipeline, but it doesn’t utilize the capabilities of modern hardware, primarily because the various states are often interdependent.</span></span> <span data-ttu-id="13928-145">Например, многие GPU объединяют пиксельный шейдер и выходное состояние слияния в одно аппаратное представление.</span><span class="sxs-lookup"><span data-stu-id="13928-145">For example, many GPUs combine pixel shader and output merger state into a single hardware representation.</span></span> <span data-ttu-id="13928-146">Но поскольку API Direct3D 11 позволяет устанавливать эти этапы конвейера отдельно, драйвер экрана не может разрешить проблемы состояния конвейера до тех пор, пока состояние не будет завершено, что не превышает время рисования.</span><span class="sxs-lookup"><span data-stu-id="13928-146">But because the Direct3D 11 API allows these pipeline stages to be set separately, the display driver can't resolve issues of pipeline state until the state is finalized, which isn’t until draw time.</span></span> <span data-ttu-id="13928-147">Эта схема задерживает настройку состояния оборудования, что означает дополнительные издержки и меньшее число вызовов Draw на кадр.</span><span class="sxs-lookup"><span data-stu-id="13928-147">This scheme delays hardware state setup, which means extra overhead and fewer maximum draw calls per frame.</span></span>

<span data-ttu-id="13928-148">Direct3D 12 решает эту схему, объединяя большую часть состояния конвейера с неизменяемыми объектами состояния конвейера (псос), которые завершаются после создания.</span><span class="sxs-lookup"><span data-stu-id="13928-148">Direct3D 12 addresses this scheme by unifying much of the pipeline state into immutable pipeline state objects (PSOs), which are finalized upon creation.</span></span> <span data-ttu-id="13928-149">После этого оборудование и драйверы могут немедленно преобразовать PSO в любую аппаратную собственную инструкцию и состояние, необходимые для выполнения работы GPU.</span><span class="sxs-lookup"><span data-stu-id="13928-149">Hardware and drivers can then immediately convert the PSO into whatever hardware native instructions and state are required to execute GPU work.</span></span> <span data-ttu-id="13928-150">Вы по-прежнему можете динамически изменять используемые PSO, но для этого оборудование должно скопировать минимальный объем предварительно вычисленного состояния непосредственно в регистры оборудования, а не считать состояние оборудования на лету.</span><span class="sxs-lookup"><span data-stu-id="13928-150">You can still dynamically change which PSO is in use, but to do so, the hardware only needs to copy the minimal amount of pre-computed state directly to the hardware registers, rather than computing the hardware state on the fly.</span></span> <span data-ttu-id="13928-151">С помощью псос накладные расходы на вызываемые объекты значительно сокращаются, и для каждого кадра может выполняться множество вызовов Draw.</span><span class="sxs-lookup"><span data-stu-id="13928-151">By using PSOs, draw call overhead is reduced significantly, and many more draw calls can occur per frame.</span></span> <span data-ttu-id="13928-152">Дополнительные сведения о псос см. [в разделе Управление состоянием графического конвейера в Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="13928-152">For more information about PSOs, see [Managing graphics pipeline state in Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span></span>

## <a name="command-lists-and-bundles"></a><span data-ttu-id="13928-153">Списки команд и пакеты</span><span class="sxs-lookup"><span data-stu-id="13928-153">Command lists and bundles</span></span>

<span data-ttu-id="13928-154">В Direct3D 11 все операции отправки выполняются через [непосредственный контекст](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), представляющий один поток команд, которые переходят на GPU.</span><span class="sxs-lookup"><span data-stu-id="13928-154">In Direct3D 11, all work submission is done via the [immediate context](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), which represents a single stream of commands that go to the GPU.</span></span> <span data-ttu-id="13928-155">Для обеспечения многопоточного масштабирования игры также имеют доступ к [отложенным контекстам](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) .</span><span class="sxs-lookup"><span data-stu-id="13928-155">To achieve multithreaded scaling, games also have [deferred contexts](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) available to them.</span></span> <span data-ttu-id="13928-156">Отложенные контексты в Direct3D 11 не соответствуют идеальному оборудованию, поэтому в них можно выполнять сравнительно мало работы.</span><span class="sxs-lookup"><span data-stu-id="13928-156">Deferred contexts in Direct3D 11 don't map perfectly to hardware, so relatively little work can be done in them.</span></span>

<span data-ttu-id="13928-157">В Direct3D 12 появилась новая модель для отправки работ на основе списков команд, содержащих все сведения, необходимые для выполнения определенной рабочей нагрузки на GPU.</span><span class="sxs-lookup"><span data-stu-id="13928-157">Direct3D 12 introduces a new model for work submission based on command lists that contain the entirety of information needed to execute a particular workload on the GPU.</span></span> <span data-ttu-id="13928-158">Каждый новый список команд содержит такие сведения, как PSO для использования, необходимые ресурсы текстуры и буфера, а также аргументы для всех вызовов рисования.</span><span class="sxs-lookup"><span data-stu-id="13928-158">Each new command list contains information such as which PSO to use, what texture and buffer resources are needed, and the arguments to all draw calls.</span></span> <span data-ttu-id="13928-159">Поскольку каждый список команд является автономным и не наследует состояние, драйвер может предварительно вычислить все необходимые команды GPU в режиме готовности к началу и беспроблемному потоку.</span><span class="sxs-lookup"><span data-stu-id="13928-159">Because each command list is self-contained and inherits no state, the driver can pre-compute all necessary GPU commands up-front and in a free-threaded manner.</span></span> <span data-ttu-id="13928-160">Единственным последовательным процессом является окончательное отправление списков команд GPU с помощью очереди команд.</span><span class="sxs-lookup"><span data-stu-id="13928-160">The only serial process necessary is the final submission of command lists to the GPU via the command queue.</span></span>

<span data-ttu-id="13928-161">Помимо списков команд, Direct3D 12 также вводит еще один уровень работы предварительное вычисление: *пакеты*.</span><span class="sxs-lookup"><span data-stu-id="13928-161">In addition to command lists, Direct3D 12 also introduces a second level of work pre-computation: *bundles*.</span></span> <span data-ttu-id="13928-162">В отличие от списков команд, которые являются полностью автономными и обычно создаются, отправляются один раз и отбрасываются, пакеты предоставляют форму наследования состояния, допускающую повторное использование.</span><span class="sxs-lookup"><span data-stu-id="13928-162">Unlike command lists, which are completely self-contained and are typically constructed, submitted once, and discarded, bundles provide a form of state inheritance that permits reuse.</span></span> <span data-ttu-id="13928-163">Например, если в игре требуется нарисовать две модели символов с разными текстурами, одним из подходов является запись списка команд с двумя наборами идентичных вызовов рисования.</span><span class="sxs-lookup"><span data-stu-id="13928-163">For example, if a game wants to draw two character models with different textures, one approach is to record a command list with two sets of identical draw calls.</span></span> <span data-ttu-id="13928-164">Но другим подходом является «запись» одного пакета, который рисует одну модель символов, затем «воспроизводить» пакет дважды в списке команд, используя разные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="13928-164">But another approach is to "record" one bundle that draws a single character model, then "play back" the bundle twice on the command list using different resources.</span></span> <span data-ttu-id="13928-165">В последнем случае драйверу экрана требуется лишь один раз вычислить соответствующие инструкции, а создание списка команд фактически сводится к двум недорогихм вызовам функций.</span><span class="sxs-lookup"><span data-stu-id="13928-165">In the latter case, the display driver only has to compute the appropriate instructions once, and creating the command list essentially amounts to two low-cost function calls.</span></span>

<span data-ttu-id="13928-166">Дополнительные сведения о списках команд и пакетов см. в разделе [Отправка рабочих данных в Direct3D 12](command-queues-and-command-lists.md).</span><span class="sxs-lookup"><span data-stu-id="13928-166">For more information about command lists and bundles, see [Work Submission in Direct3D 12](command-queues-and-command-lists.md).</span></span>

## <a name="descriptor-heaps-and-tables"></a><span data-ttu-id="13928-167">Кучи дескрипторов и таблицы</span><span class="sxs-lookup"><span data-stu-id="13928-167">Descriptor heaps and tables</span></span>

<span data-ttu-id="13928-168">Привязка ресурсов в Direct3D 11 очень абстрактна и удобна, но оставляет многие современные аппаратные возможности недостаточными.</span><span class="sxs-lookup"><span data-stu-id="13928-168">Resource binding in Direct3D 11 is highly abstracted and convenient, but leaves many modern hardware capabilities underutilized.</span></span> <span data-ttu-id="13928-169">В Direct3D 11 игры создают объекты *представления* ресурсов, а затем привязывают эти представления к нескольким *слотам* на различных стадиях шейдера в конвейере.</span><span class="sxs-lookup"><span data-stu-id="13928-169">In Direct3D 11, games create *view* objects of resources, then bind those views to several *slots* at various shader stages in the pipeline.</span></span> <span data-ttu-id="13928-170">Шейдеры, в свою очередь, считывают данные из этих явных слотов привязки, которые фиксируются во время рисования.</span><span class="sxs-lookup"><span data-stu-id="13928-170">Shaders, in turn, read data from those explicit bind slots, which are fixed at draw time.</span></span> <span data-ttu-id="13928-171">Эта модель означает, что каждый раз, когда игра будет рисовать с использованием различных ресурсов, она должна повторно привязать различные представления к разным слотам и снова вызвать Draw.</span><span class="sxs-lookup"><span data-stu-id="13928-171">This model means that whenever a game will draw using different resources, it must re-bind different views to different slots, and call draw again.</span></span> <span data-ttu-id="13928-172">Этот вариант также представляет издержки, которые можно устранить, полностью используя современные аппаратные возможности.</span><span class="sxs-lookup"><span data-stu-id="13928-172">This case also represents overhead that can be eliminated by fully utilizing modern hardware capabilities.</span></span>

<span data-ttu-id="13928-173">Direct3D 12 изменяет модель привязки в соответствии с современным оборудованием и значительно повышает производительность.</span><span class="sxs-lookup"><span data-stu-id="13928-173">Direct3D 12 changes the binding model to match modern hardware and significantly improves performance.</span></span> <span data-ttu-id="13928-174">Вместо использования автономных представлений ресурсов и явного сопоставления с слотами Direct3D 12 предоставляет кучу дескрипторов, в которой игры создают различные представления ресурсов.</span><span class="sxs-lookup"><span data-stu-id="13928-174">Instead of requiring standalone resource views and explicit mapping to slots, Direct3D 12 provides a descriptor heap into which games create their various resource views.</span></span> <span data-ttu-id="13928-175">Эта схема предоставляет механизм GPU для непосредственного создания аппаратно-машинного описания ресурса (дескриптора) в оперативной памяти.</span><span class="sxs-lookup"><span data-stu-id="13928-175">This scheme provides a mechanism for the GPU to directly write the hardware-native resource description (descriptor) to memory up-front.</span></span> <span data-ttu-id="13928-176">Чтобы объявить, какие ресурсы должны использоваться конвейером для конкретного вызова Draw, игры указывают одну или несколько таблиц дескрипторов, представляющих поддиапазоны полной кучи дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="13928-176">To declare which resources are to be used by the pipeline for a particular draw call, games specify one or more descriptor tables that represent sub-ranges of the full descriptor heap.</span></span> <span data-ttu-id="13928-177">Так как куча дескрипторов уже заполнена соответствующими данными дескрипторов конкретного оборудования, изменение таблиц дескрипторов является чрезвычайно экономичной операцией.</span><span class="sxs-lookup"><span data-stu-id="13928-177">As the descriptor heap has already been populated with the appropriate hardware-specific descriptor data, changing descriptor tables is an extremely low-cost operation.</span></span>

<span data-ttu-id="13928-178">В дополнение к повышению производительности, обеспечиваемой кучами и таблицами дескрипторов, Direct3D 12 также позволяет динамически индексировать ресурсы в шейдерах, что обеспечивает беспрецедентную гибкость и разблокировку новых методов отрисовки.</span><span class="sxs-lookup"><span data-stu-id="13928-178">In addition to the improved performance offered by descriptor heaps and tables, Direct3D 12 also allows resources to be dynamically indexed in shaders, which provides unprecedented flexibility and unlocks new rendering techniques.</span></span> <span data-ttu-id="13928-179">В качестве примера современные обработчики отложенной отрисовки обычно задают в промежуточный g-buffer идентификатор материала или объекта некоторого типа.</span><span class="sxs-lookup"><span data-stu-id="13928-179">As an example, modern deferred rendering engines typically encode a material or object identifier of some kind to the intermediate g-buffer.</span></span> <span data-ttu-id="13928-180">В Direct3D 11 эти механизмы должны быть осторожными, чтобы не использовать слишком много материалов, так как в одном g-буфере может значительно замедлиться выполнение окончательного прохода визуализации.</span><span class="sxs-lookup"><span data-stu-id="13928-180">In Direct3D 11, these engines must be careful to avoid using too many materials, as including too many in one g-buffer can significantly slow down the final render pass.</span></span> <span data-ttu-id="13928-181">С динамически индексируемыми ресурсами можно окончательно завершить сцену с тысячами материалов так же быстро, как и с десятью единицами.</span><span class="sxs-lookup"><span data-stu-id="13928-181">With dynamically indexable resources, a scene with a thousand materials can be finalized just as quickly as one with only ten.</span></span>

<span data-ttu-id="13928-182">Дополнительные сведения о кучах дескрипторов и таблицах см. в разделе [Привязка ресурсов](resource-binding.md)и [различия в модели привязки от Direct3D 11](binding-model.md).</span><span class="sxs-lookup"><span data-stu-id="13928-182">For more information about descriptor heaps and tables, see [Resource Binding](resource-binding.md), and [Differences in the Binding Model from Direct3D 11](binding-model.md).</span></span>

## <a name="porting-from-direct3d-11"></a><span data-ttu-id="13928-183">Перенос с Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="13928-183">Porting from Direct3D 11</span></span>

<span data-ttu-id="13928-184">Перенос из Direct3D 11 является вовлеченным процессом, описанным в разделе [Перенос с Direct3D 11 на Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="13928-184">Porting from Direct3D 11 is an involved process, described in [Porting from Direct3D 11 to Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span></span> <span data-ttu-id="13928-185">Также ознакомьтесь с диапазоном вариантов [работы с Direct3D 11, Direct3D 10 и Direct2D](direct3d-12-interop.md).</span><span class="sxs-lookup"><span data-stu-id="13928-185">Also refer to the range of options in [Working with Direct3D 11, Direct3D 10 and Direct2D](direct3d-12-interop.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="13928-186">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="13928-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="13928-187">Основные сведения о Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="13928-187">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
</dt> </dl>

 

 