---
title: Общие сведения о кучах дескрипторов
description: Кучи дескрипторов содержат множество типов объектов, которые не являются частью объекта состояния конвейера (PSO), например представления ресурсов шейдера (СРВС), неупорядоченные представления доступа (Уавс), представления постоянного буфера (КБВС) и пробы.
ms.assetid: 14561E77-44E0-4A58-8456-F40D59ECA175
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a8bf720ebb71d016457fa4383a8d33aa62e2eee4
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104003"
---
# <a name="descriptor-heaps-overview"></a><span data-ttu-id="57187-103">Общие сведения о кучах дескрипторов</span><span class="sxs-lookup"><span data-stu-id="57187-103">Descriptor Heaps Overview</span></span>

<span data-ttu-id="57187-104">Кучи дескрипторов содержат множество типов объектов, которые не являются частью объекта состояния конвейера (PSO), например представления ресурсов шейдера (СРВС), неупорядоченные представления доступа (Уавс), представления постоянного буфера (КБВС) и пробы.</span><span class="sxs-lookup"><span data-stu-id="57187-104">Descriptor heaps contain many object types that are not part of a Pipeline State Object (PSO), such as Shader Resource Views (SRVs), Unordered Access Views (UAVs), Constant Buffer Views (CBVs), and Samplers.</span></span>

-   [<span data-ttu-id="57187-105">Назначение куч дескрипторов</span><span class="sxs-lookup"><span data-stu-id="57187-105">The Purpose of Descriptor Heaps</span></span>](#the-purpose-of-descriptor-heaps)
-   [<span data-ttu-id="57187-106">Синхронизация</span><span class="sxs-lookup"><span data-stu-id="57187-106">Synchronization</span></span>](#synchronization)
-   [<span data-ttu-id="57187-107">Привязка</span><span class="sxs-lookup"><span data-stu-id="57187-107">Binding</span></span>](#binding)
-   [<span data-ttu-id="57187-108">Переключение куч</span><span class="sxs-lookup"><span data-stu-id="57187-108">Switching heaps</span></span>](#switching-heaps)
-   [<span data-ttu-id="57187-109">Пакеты</span><span class="sxs-lookup"><span data-stu-id="57187-109">Bundles</span></span>](#bundles)
-   [<span data-ttu-id="57187-110">Управление</span><span class="sxs-lookup"><span data-stu-id="57187-110">Management</span></span>](#management)
-   [<span data-ttu-id="57187-111">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="57187-111">Related topics</span></span>](#related-topics)

## <a name="the-purpose-of-descriptor-heaps"></a><span data-ttu-id="57187-112">Назначение куч дескрипторов</span><span class="sxs-lookup"><span data-stu-id="57187-112">The Purpose of Descriptor Heaps</span></span>

<span data-ttu-id="57187-113">Основной целью кучи дескриптора является охватывающая часть памяти, необходимая для хранения спецификаций дескрипторов типов объектов, на которые ссылается шейдер, для как можно большего размера окна отрисовки (в идеале это весь кадр отрисовки или более).</span><span class="sxs-lookup"><span data-stu-id="57187-113">The primary purpose of a descriptor heap is to encompass the bulk of memory allocation required for storing the descriptor specifications of object types that shaders reference for as large of a window of rendering as possible (ideally an entire frame of rendering or more).</span></span> <span data-ttu-id="57187-114">Если приложение переключается на те текстуры, которые конвейер видит быстро, из API, то в куче дескрипторов должно быть место для определения таблиц дескрипторов в режиме реального времени для каждого необходимого набора состояний.</span><span class="sxs-lookup"><span data-stu-id="57187-114">If an application is switching which textures the pipeline sees rapidly from the API, there has to be space in the descriptor heap to define descriptor tables on the fly for every set of state needed.</span></span> <span data-ttu-id="57187-115">Приложение может повторно использовать определения, если ресурсы снова используются в другом объекте, например, или просто назначать пространство кучи последовательно при переключении различных типов объектов.</span><span class="sxs-lookup"><span data-stu-id="57187-115">The application can choose to reuse definitions if the resources are used again in another object, for example, or just assign the heap space sequentially as it switches various object types.</span></span>

<span data-ttu-id="57187-116">Кучи дескрипторов также позволяют отдельным программным компонентам управлять хранилищем дескрипторов отдельно друг от друга.</span><span class="sxs-lookup"><span data-stu-id="57187-116">Descriptor heaps also allow individual software components to manage descriptor storage separately from each other.</span></span>

<span data-ttu-id="57187-117">Все кучи видимы для ЦП.</span><span class="sxs-lookup"><span data-stu-id="57187-117">All heaps are visible to the CPU.</span></span> <span data-ttu-id="57187-118">Приложение также может запрашивать свойства доступа к ЦП, которые должна иметь куча дескриптора (если таковая имеется) — запись в сочетании, запись обратно и т. д.</span><span class="sxs-lookup"><span data-stu-id="57187-118">The application can also request which CPU access properties a descriptor heap should have (if any) – write combined, write back, and so on.</span></span> <span data-ttu-id="57187-119">Приложения могут создавать столько куч дескриптора, сколько нужно, с тем, какие свойства требуются.</span><span class="sxs-lookup"><span data-stu-id="57187-119">Apps can create as many descriptor heaps as desired with whatever properties are desired.</span></span> <span data-ttu-id="57187-120">Приложения всегда имеют возможность создавать кучи дескрипторов, предназначенные исключительно для промежуточных целей, которые не ограничены размером, и копировать в кучи дескрипторов, которые используются для отрисовки по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="57187-120">Apps always have the option to create descriptor heaps that are purely for staging purposes that are unconstrained in size, and copying to descriptor heaps that are used for rendering as necessary.</span></span>

<span data-ttu-id="57187-121">Существуют некоторые ограничения, которые могут попасть в одну кучу дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="57187-121">There are some restrictions in what can go in the same descriptor heap.</span></span> <span data-ttu-id="57187-122">Записи CBV, UAV и SRV могут находиться в одной куче дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="57187-122">CBV, UAV and SRV entries can be in the same descriptor heap.</span></span> <span data-ttu-id="57187-123">Однако записи образцов не могут совместно использовать кучу с записями CBV, UAV или SRV.</span><span class="sxs-lookup"><span data-stu-id="57187-123">However, Samplers entries cannot share a heap with CBV, UAV or SRV entries.</span></span> <span data-ttu-id="57187-124">Как правило, существует два набора куч дескрипторов: один для общих ресурсов, а второй для образцов.</span><span class="sxs-lookup"><span data-stu-id="57187-124">Typically, there are two sets of descriptor heaps, one for the common resources and the second for Samplers.</span></span>

<span data-ttu-id="57187-125">Использование куч дескриптора в Direct3D 12 отражает большинство аппаратных средств GPU, что заключается в том, чтобы либо использовать дескрипторы в режиме реального времени только в кучах дескрипторов, либо просто уменьшить число битов адресации, если используются эти кучи.</span><span class="sxs-lookup"><span data-stu-id="57187-125">The use of descriptor heaps by Direct3D 12 mirrors what most GPU hardware does, which is to either require descriptors live only in descriptor heaps, or simply that fewer addressing bits are needed if these heaps are used.</span></span> <span data-ttu-id="57187-126">Direct3D 12 требует использования куч дескриптора, поэтому нет возможности размещать дескрипторы в любом месте памяти.</span><span class="sxs-lookup"><span data-stu-id="57187-126">Direct3D 12 does require the use of descriptor heaps, there is no option to put descriptors anywhere in memory.</span></span>

<span data-ttu-id="57187-127">Кучи дескрипторов могут быть изменены только ПРОЦЕССОРом, поэтому графический процессор не может изменить кучу дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="57187-127">Descriptor heaps can only be edited immediately by the CPU, there is no option to edit a descriptor heap by the GPU.</span></span>

## <a name="synchronization"></a><span data-ttu-id="57187-128">Синхронизация</span><span class="sxs-lookup"><span data-stu-id="57187-128">Synchronization</span></span>

<span data-ttu-id="57187-129">Содержимое кучи дескрипторов можно изменить до, во время и после записи списков команд, ссылающихся на нее.</span><span class="sxs-lookup"><span data-stu-id="57187-129">Descriptor heap contents can be changed before, during and after recording command lists that reference it.</span></span> <span data-ttu-id="57187-130">Однако дескрипторы нельзя изменить, пока список команд, отправленный для выполнения, может ссылаться на это расположение, так как это может вызвать состояние гонки.</span><span class="sxs-lookup"><span data-stu-id="57187-130">However, descriptors cannot be changed while a command list submitted for execution might reference that location, as this could invoke a race condition.</span></span>

## <a name="binding"></a><span data-ttu-id="57187-131">Привязка</span><span class="sxs-lookup"><span data-stu-id="57187-131">Binding</span></span>

<span data-ttu-id="57187-132">Хотя бы одна объединенная куча CBV/SRV/UAV и одна куча выборки могут быть привязаны в любой момент времени.</span><span class="sxs-lookup"><span data-stu-id="57187-132">At most one CBV/SRV/UAV combined heap and one Sampler heap can be bound at any one time.</span></span> <span data-ttu-id="57187-133">Эти кучи являются общими для конвейеров графики и вычислений (описанных в их псос).</span><span class="sxs-lookup"><span data-stu-id="57187-133">These heaps are shared between both the graphics and compute pipelines (described in their PSOs).</span></span>

## <a name="switching-heaps"></a><span data-ttu-id="57187-134">Переключение куч</span><span class="sxs-lookup"><span data-stu-id="57187-134">Switching heaps</span></span>

<span data-ttu-id="57187-135">Приложение может переключать кучи в одном списке команд или в разных, используя API [**сетдескрипторхеапс**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) и [**Reset**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset) .</span><span class="sxs-lookup"><span data-stu-id="57187-135">It is acceptable for an application to switch heaps within the same command list or in different ones using the [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) and [**Reset**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset) APIs.</span></span> <span data-ttu-id="57187-136">На некоторых устройствах это может быть дорогостоящей операцией, требующей остановки GPU для сброса всей работы, которая зависит от кучи дескрипторов, привязанных в данный момент.</span><span class="sxs-lookup"><span data-stu-id="57187-136">On some hardware, this can be an expensive operation, requiring a GPU stall to flush all work that depends on the currently bound descriptor heap.</span></span> <span data-ttu-id="57187-137">В результате, если необходимо изменить кучу дескрипторов, приложения должны попытаться сделать это, когда Рабочая нагрузка GPU становится относительно светлой, что может привести к ограничению изменений в начале списка команд.</span><span class="sxs-lookup"><span data-stu-id="57187-137">As a result, if descriptor heaps must be changed, applications should try to do so when the GPU workload is relatively light, perhaps limiting changes to the start of a command list.</span></span>

## <a name="bundles"></a><span data-ttu-id="57187-138">Пакеты</span><span class="sxs-lookup"><span data-stu-id="57187-138">Bundles</span></span>

<span data-ttu-id="57187-139">В пакетах может быть только один вызов метода [**сетдескрипторхеапс**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) , а набор куч дескриптора должен точно совпадать со списком команд, вызывающим пакет.</span><span class="sxs-lookup"><span data-stu-id="57187-139">With bundles there can only be one call to the [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) method, and the descriptor heaps set must match exactly those of the command list calling the bundle.</span></span> <span data-ttu-id="57187-140">Если пакет не изменяет таблицы дескрипторов, не нужно задавать кучу дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="57187-140">If the bundle does not change descriptor tables, it does not need to set the descriptor heaps.</span></span>

<span data-ttu-id="57187-141">Список вызовов API, которые нельзя использовать с пакетами, см. в разделе [Создание и запись списков команд и пакетов](recording-command-lists-and-bundles.md).</span><span class="sxs-lookup"><span data-stu-id="57187-141">For a list of API calls that cannot be used with bundles, refer to [Creating and Recording Command Lists and Bundles](recording-command-lists-and-bundles.md).</span></span>

## <a name="management"></a><span data-ttu-id="57187-142">Управление</span><span class="sxs-lookup"><span data-stu-id="57187-142">Management</span></span>

<span data-ttu-id="57187-143">Для отображения всех объектов в сцене требуется много дескрипторов, и существуют некоторые стратегии управления, которые могут быть выполнены.</span><span class="sxs-lookup"><span data-stu-id="57187-143">To render all of the objects in a scene, many descriptors will be needed, and there are some different management strategies that can be followed.</span></span>

<span data-ttu-id="57187-144">Основная стратегия заключается в том, чтобы заполнить свежую область кучи дескрипторов всеми требованиями для следующего вызова Draw.</span><span class="sxs-lookup"><span data-stu-id="57187-144">The most basic strategy would be to fill in a fresh area of the descriptor heap with all of the requirements for the next draw call.</span></span> <span data-ttu-id="57187-145">Таким образом, непосредственно перед выполнением вызова Draw в списке команд указатель таблицы дескриптора будет установлен в начало новой заполненной таблицы.</span><span class="sxs-lookup"><span data-stu-id="57187-145">So, just before issuing the draw call on the command list, a descriptor table pointer would be set to the start of the freshly populated table.</span></span> <span data-ttu-id="57187-146">Перемещается, что нет необходимости записывать, где какой-либо конкретный дескриптор находится в куче.</span><span class="sxs-lookup"><span data-stu-id="57187-146">The upside is that there is no need to record where any particular descriptor is in the heap.</span></span>

<span data-ttu-id="57187-147">Недостаток этой стратегии заключается в том, что в куче дескрипторов может быть много повторов, особенно при отрисовке очень похожей сцены, и пространство кучи дескрипторов будет быстро использоваться.</span><span class="sxs-lookup"><span data-stu-id="57187-147">The downside to this strategy is that there could be a lot of repetition of descriptors in the descriptor heap, especially when a very similar scene is being rendered, and that descriptor heap space is going to be used up quickly.</span></span> <span data-ttu-id="57187-148">Отдельные кучи дескрипторов для тех, которые визуализируются на GPU и записываются ЦП, возможно, придется избежать конфликта.</span><span class="sxs-lookup"><span data-stu-id="57187-148">Separate descriptor heaps for those being rendered on the GPU and for those being recorded by the CPU, would probably be necessary to avoid conflict.</span></span> <span data-ttu-id="57187-149">Можно также использовать систему подраспределения.</span><span class="sxs-lookup"><span data-stu-id="57187-149">Alternatively a sub-allocation system could be used.</span></span>

<span data-ttu-id="57187-150">Кроме того, базовая система может быть дополнительно оптимизирована путем аккуратного использования перекрывающихся таблиц дескрипторов из одного вызова Draw к следующему, чтобы были добавлены только новые дескрипторы.</span><span class="sxs-lookup"><span data-stu-id="57187-150">Also, the basic system could be further optimized by careful use of overlapping descriptor tables from one draw call to the next, so that only the new descriptors required are added.</span></span>

<span data-ttu-id="57187-151">Более эффективная стратегия, чем базовая, может быть предварительно заполнена кучами дескрипторов с помощью дескрипторов, необходимых для объектов (или материалов), которые являются частью сцены.</span><span class="sxs-lookup"><span data-stu-id="57187-151">A more efficient strategy than the basic one would be to pre-fill descriptor heaps with descriptors required for the objects (or materials) that are known to be part of the scene.</span></span> <span data-ttu-id="57187-152">Идея в том, что необходимо только задать таблицу дескрипторов во время рисования, так как куча дескрипторов заполняется заранее.</span><span class="sxs-lookup"><span data-stu-id="57187-152">The idea here is that it is only necessary to set the descriptor table at draw time, as the descriptor heap is populated ahead of time.</span></span>

<span data-ttu-id="57187-153">Разновидность предварительной стратегии заключается в интерпретации кучи дескрипторов как одного огромного массива, содержащего все необходимые дескрипторы в фиксированных известных расположениях.</span><span class="sxs-lookup"><span data-stu-id="57187-153">A variation of the pre-filling strategy is to treat the descriptor heap as one huge array, containing all the required descriptors in fixed known locations.</span></span> <span data-ttu-id="57187-154">Затем вызов Draw должен получить набор констант, которые являются индексами в массиве, где должны использоваться дескрипторы.</span><span class="sxs-lookup"><span data-stu-id="57187-154">Then the draw call needs only to receive a set of constants which are the indices into the array of where the descriptors are that need to be used.</span></span>

<span data-ttu-id="57187-155">Дальнейшая оптимизация заключается в том, чтобы гарантировать, что корневые константы и корневые дескрипторы содержат наиболее часто меняющиеся, а не размещайте константы в куче дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="57187-155">A further optimization is to ensure root constants and root descriptors contain those that change most frequently, rather than place constants in the descriptor heap.</span></span> <span data-ttu-id="57187-156">Для большинства аппаратных средств это эффективный способ обработки констант.</span><span class="sxs-lookup"><span data-stu-id="57187-156">For most hardware this is an efficient way of handling constants.</span></span>

<span data-ttu-id="57187-157">На практике графический механизм может использовать другую стратегию в различных ситуациях, а также объединять элементы каждой стратегии в соответствии с определенными требованиями к отрисовке.</span><span class="sxs-lookup"><span data-stu-id="57187-157">In practice a graphics engine might use a different strategy in different situations, and combine elements of each strategy to suit the particular drawing requirements.</span></span>

## <a name="related-topics"></a><span data-ttu-id="57187-158">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="57187-158">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="57187-159">Кучи дескрипторов</span><span class="sxs-lookup"><span data-stu-id="57187-159">Descriptor Heaps</span></span>](descriptor-heaps.md)
</dt> </dl>

 

 




