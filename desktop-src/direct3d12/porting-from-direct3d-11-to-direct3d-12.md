---
title: Перенос из Direct3D 11 в Direct3D 12
description: В этом разделе приводятся некоторые рекомендации по переносу из пользовательского графического подсистемы Direct3D 11 в Direct3D 12.
ms.assetid: 9EB4AC6B-AFDD-4673-8EB3-54272C151784
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f8ccf4a0bd10032d94ecaf4a88cc442f3a7ad516
ms.sourcegitcommit: 0dec0044816af3f2b2e6403659e1cf11138c90cd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/13/2021
ms.locfileid: "121812559"
---
# <a name="porting-from-direct3d-11-to-direct3d-12"></a>Перенос из Direct3D 11 в Direct3D 12

В этом разделе приводятся некоторые рекомендации по переносу из пользовательского графического подсистемы Direct3D 11 в Direct3D 12.

-   [Создание устройства](#device-creation)
-   [Зафиксированные ресурсы](#committed-resources)
-   [Зарезервированные ресурсы](#reserved-resources)
-   [Идет отправка данных](#uploading-data)
-   [Шейдеры и объекты шейдеров](#shaders-and-shader-objects)
-   [Отправка работы в GPU](#submitting-work-to-the-gpu)
-   [Синхронизация ЦП и GPU](#cpugpu-synchronization)
-   [Привязка ресурсов](#resource-binding)
-   [Состояние ресурса](#resource-state)
-   [Цепочек переключений](#swapchains)
-   [Фиксированная визуализация функции](#fixed-function-rendering)
-   [Вероятность и завершение](#odds-and-ends)
-   [Связанные темы](#related-topics)

## <a name="device-creation"></a>Создание устройства

Как Direct3D 11, так и Direct3D 12 используют одинаковый шаблон создания устройств. Существующие драйверы Direct3D 12 **D3D_FEATURE_LEVEL_11_0** и более поздних версий, поэтому можно игнорировать старые уровни компонентов и связанные с ними ограничения.

Также помните, что при использовании Direct3D 12 необходимо явно перечислить сведения об устройстве с помощью интерфейсов DXGI. В Direct3D 11 вы можете *создать цепочку* на устройстве DXGI с устройства Direct3D, и это не поддерживается для Direct3D 12.

Создание программного устройства деформации на Direct3D 12 выполняется путем предоставления явного адаптера, полученного из **IDXGIFactory4:: енумварпадаптер**. Устройство деформации для Direct3D 12 доступно только в системах с включенным дополнительным компонентом " **графические средства** ".

> [!NOTE]
> Эквивалента **D3D11CreateDeviceAndSwapChain** не существует. Даже при использовании Direct3D 11 мы не рекомендуем использовать эту функцию, так как зачастую лучше создать устройство и имеющуюся цепочку буферов отдельные шаги.

## <a name="committed-resources"></a>Зафиксированные ресурсы

Объекты, созданные со следующими интерфейсами в Direct3D 11, переводят на то, что называется "выделенными ресурсами" в Direct3D 12. Зафиксированный ресурс — это ресурс, с которым связаны как виртуальное адресное пространство, так и физические страницы. это концепция модели памяти Microsoft Windows Device Driver 2 (WDD2), на которой основан Direct3D 12.

Ресурсы Direct3D 11:

-   [**ID3D11Resource**](/windows/win32/api/d3d11/nn-d3d11-id3d11resource)
-   [**ID3D11Buffer**](/windows/win32/api/d3d11/nn-d3d11-id3d11buffer) и [ **ID3D11Device:: CreateBuffer**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createbuffer)
-   [**ID3D11Texture1D**](/windows/win32/api/d3d11/nn-d3d11-id3d11texture1d) и [ **ID3D11Device: CreateTexture1D**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createtexture1d)
-   [**ID3D11Texture2D**](/windows/win32/api/d3d11/nn-d3d11-id3d11texture2d) и [ **ID3D11Device:: CreateTexture2D**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createtexture2d)
-   [**ID3D11Texture3D**](/windows/win32/api/d3d11/nn-d3d11-id3d11texture3d) и [ **ID3D11Device:: CreateTexture3D**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createtexture3d)

В Direct3D 12 все они представлены [**ID3D12Resource**](/windows/win32/api/d3d12/nn-d3d12-id3d12resource) и [**ID3D12Device:: креатекоммиттедресаурце**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource).

## <a name="reserved-resources"></a>Зарезервированные ресурсы

Зарезервированные ресурсы — это ресурсы, где выделено только виртуальное адресное пространство, физическая память не выделяется до тех пор, пока не будет вызван вызов [**ID3D12Device:: CreateHeap**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createheap). По сути, это та же концепция, что и мозаичные ресурсы в Direct3D 11.

Флаги ([**D3D11 \_ ресурса \_ \_**](/windows/win32/api/d3d11/ne-d3d11-d3d11_resource_misc_flag)), используемые в Direct3D 11 для настройки мозаичных ресурсов, а затем сопоставляют их с физической памятью.

-   D3D11 \_ ресурсов \_ для \_ перемозаики
-   \_ \_ \_ Пул ПЛИТок ресурсов \_ D3D11

## <a name="uploading-data"></a>Идет отправка данных

В Direct3D 11 имеется одна временная шкала (вызовы, следующие за последовательностью, например данные, инициализированные [**\_ \_ данными подресурсов D3D11**](/windows/win32/api/d3d11/ns-d3d11-d3d11_subresource_data), выполняется вызов [**ссылку ID3D11DeviceContext:: упдатесубресаурце**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-updatesubresource), а затем вызывается [**ссылку ID3D11DeviceContext:: Map**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-map)). Число копий, созданных для данных, не очевидно для разработчика Direct3D 11.

В Direct3D 12 есть две временные шкалы: временная шкала GPU (настраивается вызовами [**копитекстуререгион**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion)и [**копибуфферрегион**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copybufferregion) из памяти сопоставляемые) и временная шкала ЦП (определяется вызовами [**Map**](/windows/win32/api/d3d12/nf-d3d12-id3d12resource-map)). Вспомогательные функции предоставляются (в файле d3dx12. h) с именем [**Updatesubresources**](updatesubresources1.md) , которые используют общую временную шкалу. Существует несколько разновидностей этой вспомогательной функции, которая использует [**ID3D12Device:: GetCopyableFootprints**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcopyablefootprints), другой использует механизм выделения кучи и другой, использующий механизм выделения стека. Эти вспомогательные функции копируют ресурсы в GPU и ЦП через промежуточную промежуточную область памяти.

Как правило, GPU и ЦП имеют собственную копию ресурса, привязанную к собственной временной шкале. Подход общей временной шкалы аналогично поддерживает две копии.

## <a name="shaders-and-shader-objects"></a>Шейдеры и объекты шейдеров

В Direct3D 11 существует множество способов создания шейдеров и объектов состояния, а также установки состояния этих объектов с помощью методов создания [**ID3D11Device**](/windows/win32/api/d3d11/nn-d3d11-id3d11device) и методов [**ссылку ID3D11DeviceContext**](/windows/win32/api/d3d11/nn-d3d11-id3d11devicecontext) Set. Обычно для этих методов выполняется большое количество вызовов, которые затем объединяются драйвером для установки правильного состояния конвейера.

В Direct3D 12 этот параметр состояния конвейера был объединен в один объект ([**креатекомпутепипелинестате**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcomputepipelinestate) для ядра вычислений и [**креатеграфикспипелинестате**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-creategraphicspipelinestate) для подсистемы графики), который затем прикрепляется к списку команд перед вызовом Draw с вызовом [**сетпипелинестате**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setpipelinestate).

Эти вызовы заменяют все отдельные вызовы для задания шейдеров, макета ввода, состояния смешения, состояния средства прорисовки, состояния трафарета глубины и т. д. в Direct3D 11

- Методы устройства 11: ``CreateInputLayout`` , ``CreateXShader`` , ``CreateDepthStencilState`` , андд ``CreateRasterizerState`` .
- Методы контекста устройства 11:  ``IASetInputLayout`` , ``xxSetShader`` , ``OMSetBlendState`` , ``OMSetDepthStencilState`` и ``RSSetState`` .

Хотя Direct3D 12 может поддерживать старые скомпилированные BLOB-объекты шейдера, шейдеры следует создавать с помощью модели шейдеров 5,1 с интерфейсами API FXC/D3DCompile или с использованием модели шейдеров 6 с помощью компилятора ДКСИЛ ДКСК. Необходимо проверить поддержку Shader Model 6 с помощью [**чеккфеатуресуппорт**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) и **D3D12_FEATURE_SHADER_MODEL**.

## <a name="submitting-work-to-the-gpu"></a>Отправка работы в GPU

в Direct3D 11 Существует небольшой контроль над тем, как отправляются данные о работе, он в основном обрабатывается драйвером, хотя некоторые элементы управления поддерживаются вызовами [**ссылку ID3D11DeviceContext:: Flush**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-flush) и [**IDXGISwapChain1::P resent1**](/windows/win32/api/dxgi1_2/nf-dxgi1_2-idxgiswapchain1-present1) .

В случае передачи работы Direct3D 12 это приложение очень явно и управляется приложением. Основной конструкцией для отправки работы является [**ID3D12GraphicsCommandList**](/windows/win32/api/d3d12/nn-d3d12-id3d12graphicscommandlist), который используется для записи всех команд приложений (и весьма похож на концепцию отложенного контекста ID3D11). Резервное хранилище для списка команд предоставляется [**ID3D12CommandAllocator**](/windows/win32/api/d3d12/nn-d3d12-id3d12commandallocator), что позволяет приложению управлять использованием памяти в списке команд, фактически предоставляя память, которую драйвер Direct3D 12 будет использовать для хранения списка команд.

Наконец, [**ID3D12CommandQueue**](/windows/win32/api/d3d12/nn-d3d12-id3d12commandqueue) является очередью первых поправок, которая сохраняет правильный порядок списков команд для отправки в GPU. Следующий список команд из очереди будет отправлен драйвером только после того, как один из списков команд завершил выполнение на GPU.

В Direct3D 11 нет явной концепции очереди команд. В стандартной установке Direct3D 12 текущий список команд **D3D12_COMMAND_LIST_TYPE_DIRECT** для текущего кадра можно считать аналогом мгновенного контекста Direct3D 11. Это предоставляет многие из тех же функций.


| D3D11DeviceContext                  | Список ID3D12GraphicsCommand     |
|-------------------------------------|--------------------------------|
| ClearDepthStencilView               | ClearDepthStencilView          |
| ClearRenderTargetView               | ClearRenderTargetView          |
| Клеарунордередакцесс *               | Клеарунордередакцесс *          |
| Draw, Дравинстанцед                 | DrawInstanced                  |
| Дравиндексед, Дравиндексединстанцед   | DrawIndexedInstanced           |
| Dispatch                            | Dispatch                       |
| Иасетинпутлайаут, Кскссетшадер и т. д. | SetPipelineState               |
| омсетблендстате                     | OMSetBlendFactor               |
| омсетдепсстенЦилстате              | OMSetStencilRef                |
| OMSetRenderTargets                  | OMSetRenderTargets             |
| RSSetViewports                      | RSSetViewports                 |
| RSSetScissorRects                   | RSSetScissorRects              |
| IASetPrimitiveTopology              | IASetPrimitiveTopology         |
| IASetVertexBuffers                  | IASetVertexBuffers             |
| IASetIndexBuffer                    | IASetIndexBuffer               |
| ResolveSubresource                  | ResolveSubresource             |
| кописубресаурцерегион               | CopyBufferRegion               |
| упдатесубресаурце                   | CopyTextureRegion              |
| CopyResource                        | CopyResource                   |

> [!NOTE]
> Список команд, созданный с помощью **D3D12_COMMAND_LIST_TYPE_BUNDLE** , аналогичный в отложенный контекст. Direct3D 12 также поддерживает абиилти для доступа к некоторым функциям *непосредственных контекстов* , одновременно выполняющих отрисовку с помощью **D3D12_COMMAND_LIST_TYPE_COPY** и **D3D12_COMMAND_LIST_TYPE_COMPUTE** типов списков команд.

## <a name="cpugpu-synchronization"></a>Синхронизация ЦП и GPU

В Direct3D 11 синхронизация ЦП и GPU выполнялась в значительной степени автоматически, и не требуется, чтобы приложение поддерживало состояние физической памяти.

в Direct3D 12 приложение должно явным образом управлять двумя временными шкалами (ЦП и GPU). Для этого необходимо, чтобы сведения поддерживались приложением, какие ресурсы требуются для GPU и сколько времени. Это также означает, что приложение несет ответственность за то, чтобы содержимое ресурсов (например, зафиксированные ресурсы, кучи, распределителя команд) не изменялось до тех пор, пока GPU не завершит их использование.

Основным объектом для синхронизации временных шкал является объект [**ID3D12Fence**](/windows/win32/api/d3d12/nn-d3d12-id3d12fence) . Работа ограждений довольно проста, они позволяют графическому процессору сообщать о завершении задачи. Как GPU, так и ЦП могут одновременно и ожидать ограждения.

Обычно подход заключается в том, что при отправке списка команд для выполнения сигнал ограждения передается GPU по завершении (после завершения чтения данных), что позволяет ПРОЦЕССОРу повторно использовать или уничтожать ресурсы.

В Direct3D 11 [**ссылку ID3D11DeviceContext:: Map**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-map) флаг D3D11, \_ который \_ \_ отбрасывает запись, фактически обрабатывает каждый ресурс как неограниченный объем памяти, в которую приложение может выполнять запись (процесс, называемый переименованием). В Direct3D 12 процесс выполняется явным образом: необходимо выделить дополнительную память, а для синхронизации операций следует использовать ограждения. Кольцевые буферы (состоящие из больших буферов) могут быть хорошим методом для этого, см. сценарий кольцевого буфера в разделе [Управление ресурсами на основе ограждений](fence-based-resource-management.md).

![Использование кольцевого буфера](images/ring-buffer-1.png)

## <a name="resource-binding"></a>Привязка ресурсов

Представления в Direct3D 11 (представления ресурсов шейдера, представления целевых объектов прорисовки и т. д.) в значительной мере заменены в Direct3D 12 понятием дескриптора. Методы создания по-прежнему существуют в Direct3D 12 (например, [**креатешадерресаурцевиев**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createshaderresourceview) и [**креатерендертаржетвиев**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrendertargetview)), которые вызываются после создания кучи дескрипторов, для записи данных в кучу. Привязка в Direct3D 12 теперь обрабатывается дескрипторами дескрипторов, описанными в корневой сигнатуре, и отправляется с помощью методов [**сетграфиксрутдескриптортабле**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable) или [**сеткомпутерутдескриптортабле**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable) .

Сведения об корневых сигнатурах сопоставлений между номером корневого слота подписи и таблицами дескрипторов, где таблица дескрипторов может содержать ссылки на ресурсы, доступные для шейдеров вершин, шейдеров пикселей и других шейдеров, таких как константные буферы, представления ресурсов шейдеров и пробы. Эта гибкость позволяет отключать пространство регистра HLSL из пространства привязки API в Direct3D 12, в отличие от Direct3D 11, где между ними есть одно сопоставление.

Одним из последствий этой системы является то, что приложение отвечает за переименование таблиц дескрипторов, что позволяет разработчикам понять стоимость производительности при изменении даже одного дескриптора на вызов Draw.

Новая функция Direct3D 12 заключается в том, что приложение может контролировать, какие дескрипторы являются общими для каждого этапа шейдера. В таких ресурсах Direct3D 11, как Уавс, совместно используются всеми этапами шейдера. Включение отключения дескрипторов для определенных стадий шейдера позволяет отключать регистры, используемые дескрипторами, которые были отключены, и использовать их в дескрипторах, которые включены для определенного этапа шейдера.

В следующей таблице показан пример корневой подписи.



| Корневой слот параметров | Запись таблицы дескрипторов         |
|---------------------|--------------------------------|
| 0                   | Диапазон дескрипторов VS — B13     |
| 1                   | Диапазон дескрипторов VS T0-T127    |
| 2                   | Диапазон дескрипторов VS S0-S16     |
| 3                   | Диапазон дескрипторов PS — B0-B13     |
| ...                 |                                |
| 14                  | Диапазон дескрипторов DS S0-16      |
| 15                  | Диапазон общих дескрипторов U0-u63 |



 

## <a name="resource-state"></a>Состояние ресурса

В Direct3D 11 состояние ресурсов не поддерживается приложением, а драйвером.

В Direct3D 12 обслуживание состояния ресурсов превращается в приложение, чтобы обеспечить полный параллелизм при записи списков команд: приложение должно обрабатывать временные шкалы записи для списков команд (которые могут выполняться параллельно) и временные шкалы выполнения, которые должны быть последовательными.

Переход состояния ресурса обрабатывается методом [**ресаурцебарриер**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier) . В основном приложение должно уведомлять драйвер об изменении использования ресурсов. Например, если ресурс используется в качестве целевого объекта рендеринга, а затем он будет использоваться в качестве входных данных для шейдера вершин при следующем вызове Draw, это может потребовать кратковременной остановки в операции GPU для завершения операции целевого объекта прорисовки перед обработкой шейдера вершин.

Эта система обеспечивает детальную синхронизацию (остановки GPU) графического конвейера, а также сброс кэша и, возможно, некоторые изменения макета памяти (например, представление целевого объекта прорисовки для распаковки представления набора элементов глубины).

Это называется барьером перехода. Существуют и другие виды барьеров. в Direct3D 11 [**ID3D11DeviceContext2:: тиледресаурцебарриер**](/windows/win32/api/d3d11_2/nf-d3d11_2-id3d11devicecontext2-tiledresourcebarrier) включил ту же физическую память, что и два разных мозаичных ресурса. В Direct3D 12 это называется "барьером псевдонима". Барьеры псевдонимов можно использовать как для мозаичных, так и для размещенных ресурсов в Direct3D 12. Кроме того, UAV барьер. В Direct3D 11 все операции диспетчеризации и прорисовки UAV должны быть сериализованы, хотя эти операции могут конвейерировать или работать параллельно. Для Direct3D 12 это ограничение удаляется путем добавления UAV барьера. UAV барьер гарантирует, что операции UAV являются последовательными, поэтому, если вторая операция требует первого завершения, вторая будет вынуждена ждать добавления барьера. Операция по умолчанию для Уавс — это просто то, что операции будут выполняться как можно быстрее.

Очевидно, что при параллельной работе Рабочая нагрузка повышает производительность.

## <a name="swapchains"></a>Цепочек переключений

Цепочка подкачки DXGI является основанием для цепочек подкачки в Direct3D 11 и 12. Существует несколько незначительных отличий, в Direct3D 11 три типа цепочки буферов перемещаются последовательно, отменяются и переворачиваются \_ последовательно. Для Direct3D 12 существует только два типа: переворот \_ последовательных и зеркальных \_ отклонения. Как отмечалось выше, необходимо явно создать имеющуюся цепочку буферов через **IDXGIFactory4** или более поздней версии и использовать тот же интерфейс для любого перечисления адаптера.

В Direct3D 11 имеется автоматический поворот обратного буфера: для заднего буфера 0 требуется только одно представление целевого объекта прорисовки. В режиме вращения буфера Direct3D 12 для каждого заднего буфера должно быть представление целевого объекта отрисовки. Используйте метод [**IDXGISwapChain3:: жеткуррентбаккбуффериндекс**](/windows/win32/api/dxgi1_4/nf-dxgi1_4-idxgiswapchain3-getcurrentbackbufferindex) , чтобы выбрать, в какой из них следует выполнить отрисовку. Еще раз такая дополнительная гибкость позволяет повысить параллелизм.

> [!NOTE]
> Хотя существует множество способов настройки приложения, обычно приложения имеют по одному **ID3D12CommandAllocator** на буфер цепочки подкачки. Это позволяет приложению перейти к созданию набора команд для следующего кадра, пока GPU визуализирует предыдущий.

## <a name="fixed-function-rendering"></a>Фиксированная визуализация функции

В Direct3D 11 существовало несколько методов, которые упрощают различные операции высшего уровня, такие как [**женератемипс**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-generatemips) (создание полных цепочек MIP) и [**дравауто**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-drawauto) (использование потокового вывода в качестве входных данных шейдера без дополнительных входов из приложения). Эти методы недоступны в Direct3D 12. приложению необходимо выполнить эти операции, создав шейдеры для их выполнения.

## <a name="odds-and-ends"></a>Вероятность и завершение

В следующей таблице показано несколько функций, которые похожи на Direct3D 11 и 12, но не идентичны.



| Direct3D 11                                                                            | Direct3D 12                                                                                                                                                                                                                                                                                                                                                                                                                              |
|----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [**ID3D11Query**](/windows/win32/api/d3d11/nn-d3d11-id3d11query)                                              | [**ID3D12QueryHeap**](/windows/win32/api/d3d12/nn-d3d12-id3d12queryheap) позволяет объединять запросы в группу, уменьшая затраты.                                                                                                                                                                                                                                                                                                                                     |
| [**ID3D11Predicate**](/windows/win32/api/d3d11/nn-d3d11-id3d11predicate)                                      | Затенения теперь включается, если данные находятся в полностью прозрачном буфере. Объект Direct3D 11 [**ID3D11Predicate**](/windows/win32/api/d3d11/nn-d3d11-id3d11predicate) заменяется [**ID3D12Resource:: Map**](/windows/win32/api/d3d12/nf-d3d12-id3d12resource-map), который должен следовать за вызовом [**РЕСОЛВЕКУЕРИДАТА**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvequerydata) и операцией синхронизации GPU с использованием ограждения для ожидания готовности данных. См. [затенения](predication.md). |
| Скрытый счетчик UAV/SO                                                                  | Приложение отвечает за выделение и Управление счетчиками SO/UAV. Ознакомьтесь со счетчиками [потокового вывода](stream-output-counters.md) и [счетчиками UAV](uav-counters.md).                                                                                                                                                                                                                                                             |
| Динамический Минлод ресурсов (уровень детализации миниум)                                       | Он был перемещен в статический Минлод дескриптора SRV.                                                                                                                                                                                                                                                                                                                                                                                 |
| Нарисовать \* косвенные/[**диспатчиндирект**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-dispatchindirect) | Непрямые методы рисования объединяются в один метод [**ексекутеиндирект**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-executeindirect) .                                                                                                                                                                                                                                                                                                        |
| Форматы ДепсстенЦил чередуются                                                   | Форматы ДепсстенЦил — плоские. Например, формат 24 бит глубины, 8 бит набора элементов будет храниться в формате 24/8/24/8... и т. д. в Direct3D 11, но как 24/24/24... за которым следует 8/8/8... в Direct3D 12. Обратите внимание, что каждая плоскость является собственным подресурсом в D3D12 (см. [подресурсы](subresources.md)).                                                                                                                    |
| [**ресизетилепул**](/windows/win32/api/d3d11_2/nf-d3d11_2-id3d11devicecontext2-resizetilepool)                   | Зарезервированные ресурсы могут быть сопоставлены с несколькими кучами. Когда пул плиток будет увеличился в D3D11, вместо этого можно выделить дополнительную кучу в D3D12.                                                                                                                                                                                                                                                                               |



 

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Дополнительные обучающие видеоматериалы по DirectX: руководство по переносу с DirectX 11 на DirectX 12](https://www.youtube.com/watch?v=BV64mdOCgZo)
</dt> <dt>

[Основные сведения о Direct3D 12](directx-12-getting-started.md)
</dt> <dt>

[Работа с Direct3D 11, Direct3D 10 и Direct2D](direct3d-12-interop.md)
</dt> </dl>
