---
title: Присвоение псевдонимов памяти и наследование данных
description: Размещенный и зарезервированный ресурс может быть псевдонимом физической памяти в куче. Размещенные ресурсы обеспечивают дополнительные сценарии наследования данных, чем зарезервированные ресурсы, если в куче установлен общий флаг или если ресурсы с псевдонимами имеют полностью определенные макеты памяти.
ms.assetid: 53C5804B-0F81-41AF-83D2-A96DCDFDC94A
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cace5b5997e2a460406ae72abb247224886f3926
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104416"
---
# <a name="memory-aliasing-and-data-inheritance"></a><span data-ttu-id="fbb3c-104">Присвоение псевдонимов памяти и наследование данных</span><span class="sxs-lookup"><span data-stu-id="fbb3c-104">Memory Aliasing and Data Inheritance</span></span>

<span data-ttu-id="fbb3c-105">Размещенный и зарезервированный ресурс может быть псевдонимом физической памяти в куче.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-105">Placed and reserved resource may alias physical memory within a heap.</span></span> <span data-ttu-id="fbb3c-106">Размещенные ресурсы обеспечивают дополнительные сценарии наследования данных, чем зарезервированные ресурсы, если в куче установлен общий флаг или если ресурсы с псевдонимами имеют полностью определенные макеты памяти.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-106">Placed resources enable more data inheritance scenarios than reserved resources when the heap has the shared flag set or when the aliased resources have fully defined memory layouts.</span></span>

-   [<span data-ttu-id="fbb3c-107">Псевдонимы</span><span class="sxs-lookup"><span data-stu-id="fbb3c-107">Aliasing</span></span>](#memory-aliasing-and-data-inheritance)
-   [<span data-ttu-id="fbb3c-108">Наследование данных</span><span class="sxs-lookup"><span data-stu-id="fbb3c-108">Data Inheritance</span></span>](#data-inheritance)
-   [<span data-ttu-id="fbb3c-109">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="fbb3c-109">Related topics</span></span>](#related-topics)

## <a name="aliasing"></a><span data-ttu-id="fbb3c-110">Псевдонимы</span><span class="sxs-lookup"><span data-stu-id="fbb3c-110">Aliasing</span></span>

<span data-ttu-id="fbb3c-111">Для использования двух ресурсов, использующих общую физическую память, необходимо выдать барьер псевдонимов, даже если наследование данных нежелательно.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-111">An aliasing barrier must be issued between the usage of two resources that share the same physical memory, even if data inheritance is not desired.</span></span> <span data-ttu-id="fbb3c-112">Простые модели использования должны отметьте, по крайней мере, целевой ресурс, вовлеченный в такую операцию.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-112">Simple usage models must denote, at least, the destination resource involved in such an operation.</span></span> <span data-ttu-id="fbb3c-113">Дополнительные сведения и модели расширенного использования см. в разделе [**креатеплацедресаурце**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createplacedresource) .</span><span class="sxs-lookup"><span data-stu-id="fbb3c-113">See [**CreatePlacedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createplacedresource) for more details and advanced usage models.</span></span>

<span data-ttu-id="fbb3c-114">После доступа к ресурсу все ресурсы, которые совместно используют физическую память с этим ресурсом, становятся недействительными, пока не будет разрешено наследование данных.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-114">After a resource is accessed, any resources which share physical memory with that resource become invalidated, unless data inheritance is allowed to occur.</span></span> <span data-ttu-id="fbb3c-115">Чтение недействительных ресурсов приводит к неопределенному содержимому ресурса.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-115">Reads of invalidated resources result in undefined resource contents.</span></span> <span data-ttu-id="fbb3c-116">Операции записи в недействительные ресурсы также приводят к неопределенному содержимому ресурса, если не выполняются два условия:</span><span class="sxs-lookup"><span data-stu-id="fbb3c-116">Writes to invalidated resources also result in undefined resource contents, unless two conditions occur:</span></span>

-   <span data-ttu-id="fbb3c-117">Ресурс не имеет \_ флаг ресурса D3D12 \_ \_ Разрешить \_ \_ целевой объект прорисовки или \_ флаг ресурса D3D12 \_ \_ Разрешить \_ \_ набор элементов глубины.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-117">The resource does not have either the D3D12\_RESOURCE\_FLAG\_ALLOW\_RENDER\_TARGET or D3D12\_RESOURCE\_FLAG\_ALLOW\_DEPTH\_STENCIL.</span></span>
-   <span data-ttu-id="fbb3c-118">Запись является операцией копирования или очистки во всем подресурсе или плитке.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-118">The write is a copy or clear operation to an entire subresource or tile.</span></span> <span data-ttu-id="fbb3c-119">Инициализация плиток доступна только для ресурсов с плиткой "64 КБ" \_ \_ неопределенные плитки \_ свиззле и 64 КБ \_ \_ стандартного \_ свиззле.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-119">Tile-initialization is only available for resources with 64KB\_TILE\_UNDEFINED\_SWIZZLE and 64KB\_TILE\_STANDARD\_SWIZZLE.</span></span>

<span data-ttu-id="fbb3c-120">Перекрывающиеся проверки ограничены более низкими уровнями детализации, когда макеты предоставляют сведения о расположении шаг текселя данных и о том, когда ресурсы находятся в определенных состояниях барьера переходов.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-120">Overlapping invalidations are scoped to smaller granularities, when layouts provide information on the location on the location of texel data and when resources are in certain transition barrier states.</span></span> <span data-ttu-id="fbb3c-121">Но недействительность не может быть меньше детализации выравнивания ресурсов.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-121">But, invalidations cannot go any smaller than resource alignment granularities.</span></span>

<span data-ttu-id="fbb3c-122">Степень детализации выравнивания буфера составляет 64 КБ, и приоритет имеет более высокий уровень детализации выравнивания.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-122">A buffer alignment granularity is 64KB, and larger alignment granularity takes precedence.</span></span> <span data-ttu-id="fbb3c-123">Это важно при рассмотрении 4-кратных текстур, так как несколько таких текстур могут находиться в области 64 КБ без перекрытия друг друга.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-123">This is important when considering 4KB textures, as multiple 4KB textures can reside in a 64KB region without overlapping each other.</span></span> <span data-ttu-id="fbb3c-124">Однако псевдонимы буфера для одного и того же региона 64 КБ нельзя использовать в сочетании с этими недопустимыми текстурами.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-124">But, a buffer aliasing the same 64KB region cannot be used in conjunction with any of those 4KB textures.</span></span> <span data-ttu-id="fbb3c-125">Приложение не может надежно защитить доступ к буферу от пересекающихся текстур размером 4 КБ, так как GPU разрешается свиззле 4 КБ данных текстуры в области 64 КБ в неопределенном шаблоне.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-125">The application cannot reliably keep the access to the buffer from intersecting the 4KB textures, as GPUs are allowed to swizzle 4KB texture data within the 64KB region in an undefined pattern.</span></span>

<span data-ttu-id="fbb3c-126">элемент 64 КБ \_ \_ неопределенный элемент \_ свиззле, \_ свиззле "Стандартный плитка" в 64 КБ \_ \_ , а также \_ Основные макеты текстур строк сообщают приложению, что перекрывающиеся гранулярности выравнивания стали недействительными.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-126">64KB\_TILE\_UNDEFINED\_SWIZZLE, 64KB\_TILE\_STANDARD\_SWIZZLE, and ROW\_MAJOR texture layouts inform the application which overlapping alignment granularities have become invalid.</span></span> <span data-ttu-id="fbb3c-127">Например, приложение может создать двумерный массив текстуры целевого объекта отрисовки с двумя срезами массива, одним уровнем MIP и \_ плиткой 64 КБ \_ undefine \_ свиззле Layout.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-127">For example: An application can create a 2D render target texture array with 2 array slices, a single mip level, and the 64KB\_TILE\_UNDEFINED\_SWIZZLE layout.</span></span> <span data-ttu-id="fbb3c-128">Предположим, что приложение понимает, что каждый срез массива занимает 100 64 КБ.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-128">Assume the application understands each array slice occupies 100 64KB tiles.</span></span> <span data-ttu-id="fbb3c-129">Приложение может отказаться от с помощью среза массива 0 и повторно использовать эту память для буфера ~ 6 МБ, текстуры ~ 6 МБ с неопределенным макетом и т. д. В дальнейшем Предположим, что приложение больше не требует первого элемента среза массива 1.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-129">The application can forgo using array slice 0, and re-use that memory for either a ~6MB buffer, a ~6MB texture with undefined layout, etc. Going further, assume the application no longer required the first tile of array slice 1.</span></span> <span data-ttu-id="fbb3c-130">После этого приложение может также располагаться в 64-буфере до тех пор, пока отрисовка еще не потребует первого элемента среза массива 1.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-130">Then, the application could also locate a 64KB buffer there until rendering would again require the first tile of array slice 1.</span></span> <span data-ttu-id="fbb3c-131">Чтобы повторно использовать первую плитку с массивом текстур, приложению потребуется выполнить полную очистку или копирование.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-131">The application would have to do a full tile clear or copy in order to re-use the first tile with the texture array again.</span></span>

<span data-ttu-id="fbb3c-132">Однако даже текстуры с определенными макетами по-прежнему имеют проблемные ситуации.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-132">However, even textures with defined layouts still have problematic cases.</span></span> <span data-ttu-id="fbb3c-133">Размеры ресурсов текстуры могут значительно отличаться от того, что может вычислить приложение, так как некоторые архитектуры адаптеров выделяют дополнительную память для текстур, чтобы уменьшить эффективность работы в ходе распространенных сценариев визуализации.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-133">Texture resource sizes can significantly differ from what the application can calculate itself, because some adapter architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios.</span></span> <span data-ttu-id="fbb3c-134">Любые недействительности в этой дополнительной области памяти приводят к тому, что весь ресурс становится недействительным.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-134">Any invalidations into that extra memory region cause the entire resource to become invalidated.</span></span> <span data-ttu-id="fbb3c-135">Дополнительные сведения см. в разделе [**жетресаурцеаллокатионинфо**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-getresourceallocationinfo) .</span><span class="sxs-lookup"><span data-stu-id="fbb3c-135">See [**GetResourceAllocationInfo**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-getresourceallocationinfo) for more details.</span></span>

## <a name="data-inheritance"></a><span data-ttu-id="fbb3c-136">Наследование данных</span><span class="sxs-lookup"><span data-stu-id="fbb3c-136">Data Inheritance</span></span>

<span data-ttu-id="fbb3c-137">Размещенные ресурсы обеспечивают наибольшее наследование данных для текстур, даже с неопределенными макетами памяти.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-137">Placed resources enable the most data inheritance for textures, even with undefined memory layouts.</span></span> <span data-ttu-id="fbb3c-138">Приложения могут имитировать возможности наследования данных, предоставляемые общими фиксируемыми ресурсами, путем обнаружения двух текстур с одинаковыми свойствами ресурса с одинаковым смещением в общей куче.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-138">Applications can mimic the data inheritance capabilities that shared committed resources enable by locating two textures with identical resource properties at the same offset in a shared heap.</span></span> <span data-ttu-id="fbb3c-139">Полное описание ресурса должно быть идентичным, включая оптимизированное значение и тип метода создания ресурсов (помещенные или зарезервированные).</span><span class="sxs-lookup"><span data-stu-id="fbb3c-139">The entire resource description must be identical, including the optimized clear value and type of resource creation method (placed or reserved).</span></span> <span data-ttu-id="fbb3c-140">Но у обоих ресурсов могут быть разные состояния начального барьера перехода.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-140">But, both resources may have had different initial transition barrier states.</span></span>

<span data-ttu-id="fbb3c-141">Зарезервированные ресурсы позволяют использовать наследование данных на плитке; Однако для состояний барьера переключения ресурсов обычно существуют ограничения.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-141">Reserved resources enable per-tile data inheritance; but restrictions commonly exist for resource transition barrier states.</span></span>

<span data-ttu-id="fbb3c-142">Для наследования данных оба ресурса должны находиться в совместимом состоянии барьера переключения ресурсов:</span><span class="sxs-lookup"><span data-stu-id="fbb3c-142">To inherit data, both resources must be in a compatible resource transition barrier state:</span></span>

-   <span data-ttu-id="fbb3c-143">Для буферов, одновременных текстур доступа и текстур перекрестных адаптеров состояние смены ресурсов не имеет значения, а все состояния являются "совместимыми".</span><span class="sxs-lookup"><span data-stu-id="fbb3c-143">For buffers, simultaneous access textures, and cross-adapter textures, the resource transition state is not important and all states are “compatible”.</span></span>
-   <span data-ttu-id="fbb3c-144">Для зарезервированных текстур без предыдущих свойств или другого наследования данных на плитке до 64 КБ \_ \_ неопределенное значение \_ свиззле или 64 КБ \_ \_ \_ . состояние барьера перехода ресурсов, включая плитку, должно быть в общем состоянии.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-144">For reserved textures without the previous properties or other per-tile data inheritance through 64KB\_TILE\_UNDEFINED\_SWIZZLE or 64KB\_TILE\_STANDARD\_SWIZZLE, the resource transition barrier state including the tile must be in the common state.</span></span>
-   <span data-ttu-id="fbb3c-145">Для всех остальных текстур, в которых описания ресурсов точно соответствуют друг другу, состояние барьера переключения ресурсов для каждой соответствующей пары подресурсов должно:</span><span class="sxs-lookup"><span data-stu-id="fbb3c-145">For all other textures, where the resource descriptions match exactly, the resource transition barrier state for each corresponding pair of subresources must:</span></span>
    -   <span data-ttu-id="fbb3c-146">Быть в общем состоянии.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-146">Be in the common state.</span></span>
    -   <span data-ttu-id="fbb3c-147">Должно быть равно, если в этих состояниях есть один и тот же флаг записи GPU.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-147">Be equal when the state has the same GPU-write flag in them.</span></span>

<span data-ttu-id="fbb3c-148">Если GPU поддерживает стандартные свиззле, то буферы и стандартные текстуры свиззле могут быть псевдонимами для одной и той же памяти и наследовать данные между ними.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-148">When the GPU supports standard swizzle, buffers and standard swizzle textures may be aliased to the same memory and inherit data between them.</span></span> <span data-ttu-id="fbb3c-149">Приложение может манипулировать пикселей текстуры из буферного представления, поскольку стандартный шаблон свиззле описывает, как пикселей текстуры размещается в памяти.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-149">The application can manipulate texels from the buffer representation, because the standard swizzle pattern describes how texels are laid out in memory.</span></span> <span data-ttu-id="fbb3c-150">Шаблон свиззле, видимый для ЦП, эквивалентен шаблону свиззле, видимому в буферах.</span><span class="sxs-lookup"><span data-stu-id="fbb3c-150">The CPU-visible swizzle pattern is equivalent to the GPU-visible swizzle pattern seen in buffers.</span></span>

## <a name="related-topics"></a><span data-ttu-id="fbb3c-151">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="fbb3c-151">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="fbb3c-152">Подраспределение в кучах</span><span class="sxs-lookup"><span data-stu-id="fbb3c-152">Suballocation Within Heaps</span></span>](suballocation-within-heaps.md)
</dt> </dl>

 

 




