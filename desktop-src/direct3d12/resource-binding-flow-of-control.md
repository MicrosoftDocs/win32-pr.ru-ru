---
title: Общие сведения о привязке ресурсов
description: Ключом к привязке ресурсов в DirectX 12 являются понятия дескриптора, таблиц дескрипторов, куч дескрипторов и корневой подписи.
ms.assetid: 92E100CA-822D-46B1-BD37-FF57C3FB703D
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2bc7e78255c123777716eddb43d9443e19113b34
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104178"
---
# <a name="resource-binding-overview"></a><span data-ttu-id="713d8-103">Общие сведения о привязке ресурсов</span><span class="sxs-lookup"><span data-stu-id="713d8-103">Resource Binding Overview</span></span>

<span data-ttu-id="713d8-104">Ключом к привязке ресурсов в DirectX 12 являются понятия *дескриптора*, *таблиц дескрипторов*, *куч дескрипторов* и *корневой подписи*.</span><span class="sxs-lookup"><span data-stu-id="713d8-104">The key to resource binding in DirectX 12 are the concepts of a *descriptor*, *descriptor tables*, *descriptor heaps*, and a *root signature*.</span></span>

-   [<span data-ttu-id="713d8-105">Ресурсы и графический конвейер</span><span class="sxs-lookup"><span data-stu-id="713d8-105">Resources and the Graphics Pipeline</span></span>](#resources-and-the-graphics-pipeline)
-   [<span data-ttu-id="713d8-106">Типы ресурсов и представления</span><span class="sxs-lookup"><span data-stu-id="713d8-106">Resource types and views</span></span>](#resource-types-and-views)
-   [<span data-ttu-id="713d8-107">Поток привязки ресурсов элемента управления</span><span class="sxs-lookup"><span data-stu-id="713d8-107">Resource Binding Flow of Control</span></span>](#resource-binding-overview)
-   [<span data-ttu-id="713d8-108">Выделено</span><span class="sxs-lookup"><span data-stu-id="713d8-108">Suballocation</span></span>](#suballocation)
-   [<span data-ttu-id="713d8-109">Освобождение ресурсов</span><span class="sxs-lookup"><span data-stu-id="713d8-109">Freeing Resources</span></span>](#freeing-resources)
-   [<span data-ttu-id="713d8-110">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="713d8-110">Related topics</span></span>](#related-topics)

## <a name="resources-and-the-graphics-pipeline"></a><span data-ttu-id="713d8-111">Ресурсы и графический конвейер</span><span class="sxs-lookup"><span data-stu-id="713d8-111">Resources and the Graphics Pipeline</span></span>

<span data-ttu-id="713d8-112">Ресурсы шейдера (например, текстуры, константные таблицы, изображения, буферы и т. д.) не привязываются непосредственно к конвейеру шейдера; Вместо этого они ссылаются с помощью *дескриптора*.</span><span class="sxs-lookup"><span data-stu-id="713d8-112">Shader resources (such as textures, constant tables, images, buffers and so on) are not bound directly to the shader pipeline; instead, they are referenced through a *descriptor*.</span></span> <span data-ttu-id="713d8-113">Дескриптор — это небольшой объект, содержащий сведения об одном ресурсе.</span><span class="sxs-lookup"><span data-stu-id="713d8-113">A descriptor is a small object that contains information about one resource.</span></span>

<span data-ttu-id="713d8-114">Дескрипторы группируются вместе для формирования *таблиц дескрипторов*.</span><span class="sxs-lookup"><span data-stu-id="713d8-114">Descriptors are grouped together to form *descriptor tables*.</span></span> <span data-ttu-id="713d8-115">Каждая таблица дескрипторов хранит сведения об одном диапазоне типов ресурсов.</span><span class="sxs-lookup"><span data-stu-id="713d8-115">Each descriptor table stores information about one range of types of resource.</span></span> <span data-ttu-id="713d8-116">Существует много различных типов ресурсов.</span><span class="sxs-lookup"><span data-stu-id="713d8-116">There are many different types of resources.</span></span> <span data-ttu-id="713d8-117">Ниже перечислены наиболее распространенные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="713d8-117">The most common resources are:</span></span>

-   <span data-ttu-id="713d8-118">Представления буфера констант (КБВС)</span><span class="sxs-lookup"><span data-stu-id="713d8-118">Constant buffer views (CBVs)</span></span>
-   <span data-ttu-id="713d8-119">Неупорядоченные представления доступа (Уавс)</span><span class="sxs-lookup"><span data-stu-id="713d8-119">Unordered access views (UAVs)</span></span>
-   <span data-ttu-id="713d8-120">Представления ресурсов шейдера (СРВС)</span><span class="sxs-lookup"><span data-stu-id="713d8-120">Shader resource views (SRVs)</span></span>
-   <span data-ttu-id="713d8-121">Образцы.</span><span class="sxs-lookup"><span data-stu-id="713d8-121">Samplers</span></span>

<span data-ttu-id="713d8-122">Дескрипторы SRV, UAV и КБВС могут быть объединены в одну и ту же таблицу дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="713d8-122">SRV, UAV, and CBVs descriptors can be combined into the same descriptor table.</span></span>

<span data-ttu-id="713d8-123">Конвейеры графики и вычислений получают доступ к ресурсам, ссылаясь на таблицы дескрипторов по индексу.</span><span class="sxs-lookup"><span data-stu-id="713d8-123">The graphics and compute pipelines gain access to resources by referencing into descriptor tables by index.</span></span>

<span data-ttu-id="713d8-124">Таблицы дескрипторов хранятся в *куче дескрипторов*.</span><span class="sxs-lookup"><span data-stu-id="713d8-124">Descriptor tables are stored in a *descriptor heap*.</span></span> <span data-ttu-id="713d8-125">В идеале кучи дескрипторов будут содержать все дескрипторы (в таблицах дескрипторов) для одного или нескольких кадров для подготовки к просмотру.</span><span class="sxs-lookup"><span data-stu-id="713d8-125">Descriptor heaps will ideally contain all the descriptors (in descriptor tables) for one or more frames to be rendered.</span></span> <span data-ttu-id="713d8-126">Все ресурсы будут храниться в кучах пользовательского режима.</span><span class="sxs-lookup"><span data-stu-id="713d8-126">All the resources will be stored in user mode heaps.</span></span>

<span data-ttu-id="713d8-127">Еще одна концепция состоит из *корневой сигнатуры*.</span><span class="sxs-lookup"><span data-stu-id="713d8-127">Another concept is that of a *root signature*.</span></span> <span data-ttu-id="713d8-128">Корневая подпись — это соглашение о привязке, определяемое приложением, которое используется шейдером для определения местоположения ресурсов, к которым им требуется доступ.</span><span class="sxs-lookup"><span data-stu-id="713d8-128">The root signature is a binding convention, defined by the application, that is used by shaders to locate the resources that they need access to.</span></span> <span data-ttu-id="713d8-129">Корневая подпись может хранить:</span><span class="sxs-lookup"><span data-stu-id="713d8-129">The root signature can store:</span></span>

-   <span data-ttu-id="713d8-130">Индексы для таблиц дескрипторов в куче дескрипторов, где макет таблицы дескрипторов был предварительно определен.</span><span class="sxs-lookup"><span data-stu-id="713d8-130">Indexes to descriptor tables in a descriptor heap, where the layout of the descriptor table has been pre-defined.</span></span>
-   <span data-ttu-id="713d8-131">Константы, так что приложения могут привязывать определяемые пользователем константы (называемые *корневыми константами*) непосредственно к шейдерам без необходимости проходить через дескрипторы и таблицы.</span><span class="sxs-lookup"><span data-stu-id="713d8-131">Constants, so apps can bind user-defined constants (known as *root constants*) directly to shaders without having to go through descriptors and descriptor tables.</span></span>
-   <span data-ttu-id="713d8-132">Очень небольшое число дескрипторов непосредственно внутри корневой сигнатуры, например представление константного буфера (CBV), которое изменяется на рисование, тем самым сохраняя приложение от необходимости размещения этих дескрипторов в куче дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="713d8-132">A very small number of descriptors directly inside the root signature, such as a constant buffer view (CBV) that changes per draw, thereby saving the application from needing to put those descriptors in a descriptor heap.</span></span>

<span data-ttu-id="713d8-133">Иными словами, корневая подпись обеспечивает оптимизацию производительности, подходящую для небольших объемов данных, которые изменяются на рисование.</span><span class="sxs-lookup"><span data-stu-id="713d8-133">In other words, the root signature provides performance optimizations suitable for small amounts of data that change per draw.</span></span>

<span data-ttu-id="713d8-134">Конструкция Direct3D 12 для привязки разделяет его от других задач, таких как управление памятью, управление жизненным циклом объектов, отслеживание состояния и синхронизация памяти (см. раздел [различия в модели привязки от Direct3D 11](binding-model.md)).</span><span class="sxs-lookup"><span data-stu-id="713d8-134">The Direct3D 12 design for binding separates it from other tasks, such as memory management, object lifetime management, state tracking, and memory synchronization (refer to [Differences in the Binding Model from Direct3D 11](binding-model.md)).</span></span> <span data-ttu-id="713d8-135">Привязка Direct3D 12 разработана с низкой нагрузкой и оптимизирована для вызовов API, которые выполняются наиболее часто.</span><span class="sxs-lookup"><span data-stu-id="713d8-135">Direct3D 12 binding is designed to be low overhead and optimized for the API calls that are made most frequently.</span></span> <span data-ttu-id="713d8-136">Она также масштабируется от низкого до высокопроизводительного оборудования и масштабируется с более высокого (более линейного конвейера Direct3D 11) до более новых (более параллельных) подходов к программированию графических модулей.</span><span class="sxs-lookup"><span data-stu-id="713d8-136">It is also scalable across low end to high end hardware, and scalable from older (the more linear Direct3D 11 pipeline) to the newer (more parallel) approaches to graphics engine programming.</span></span>

## <a name="resource-types-and-views"></a><span data-ttu-id="713d8-137">Типы ресурсов и представления</span><span class="sxs-lookup"><span data-stu-id="713d8-137">Resource types and views</span></span>

<span data-ttu-id="713d8-138">Типы ресурсов совпадают с Direct3D 11, а именно:</span><span class="sxs-lookup"><span data-stu-id="713d8-138">Resource types are the same as Direct3D 11, namely:</span></span>

-   <span data-ttu-id="713d8-139">Texture1D и Texture1DArray</span><span class="sxs-lookup"><span data-stu-id="713d8-139">Texture1D, and Texture1DArray</span></span>
-   <span data-ttu-id="713d8-140">Texture2D, Texture2DArray, Texture2DMS, Texture2DMSArray</span><span class="sxs-lookup"><span data-stu-id="713d8-140">Texture2D, and Texture2DArray, Texture2DMS, Texture2DMSArray</span></span>
-   <span data-ttu-id="713d8-141">Texture3D</span><span class="sxs-lookup"><span data-stu-id="713d8-141">Texture3D</span></span>
-   <span data-ttu-id="713d8-142">Буферы (типизированные, структурированные и необработанные)</span><span class="sxs-lookup"><span data-stu-id="713d8-142">Buffers (typed, structured and raw)</span></span>

<span data-ttu-id="713d8-143">Представления ресурсов похожи, но немного отличаются от представлений в Direct3D 11, вершин и буферов индексов.</span><span class="sxs-lookup"><span data-stu-id="713d8-143">Resource views are similar but slightly different from Direct3D 11, vertex and index buffer views have been added.</span></span>

-   <span data-ttu-id="713d8-144">Представление буфер констант (CBV)</span><span class="sxs-lookup"><span data-stu-id="713d8-144">Constant buffer view (CBV)</span></span>
-   <span data-ttu-id="713d8-145">Представление неупорядоченного доступа (UAV)</span><span class="sxs-lookup"><span data-stu-id="713d8-145">Unordered access view (UAV)</span></span>
-   <span data-ttu-id="713d8-146">Представление ресурсов шейдера (SRV)</span><span class="sxs-lookup"><span data-stu-id="713d8-146">Shader resource view (SRV)</span></span>
-   <span data-ttu-id="713d8-147">Образцы.</span><span class="sxs-lookup"><span data-stu-id="713d8-147">Samplers</span></span>
-   <span data-ttu-id="713d8-148">Представление целевого объекта прорисовки (РТВ)</span><span class="sxs-lookup"><span data-stu-id="713d8-148">Render Target View (RTV)</span></span>
-   <span data-ttu-id="713d8-149">Представление трафарета глубины (DSV)</span><span class="sxs-lookup"><span data-stu-id="713d8-149">Depth Stencil View (DSV)</span></span>
-   <span data-ttu-id="713d8-150">Представление буфера индекса (ИБВ)</span><span class="sxs-lookup"><span data-stu-id="713d8-150">Index Buffer View (IBV)</span></span>
-   <span data-ttu-id="713d8-151">Представление буфера вершин (ВБВ)</span><span class="sxs-lookup"><span data-stu-id="713d8-151">Vertex Buffer View (VBV)</span></span>
-   <span data-ttu-id="713d8-152">Представление потока вывода (сов)</span><span class="sxs-lookup"><span data-stu-id="713d8-152">Stream Output View (SOV)</span></span>

<span data-ttu-id="713d8-153">Только первые четыре из этих представлений на самом деле видимы для шейдеров, см. [видимые кучи дескрипторов шейдеров](shader-visible-descriptor-heaps.md) и [видимые кучи дескрипторов без шейдера](non-shader-visible-descriptor-heaps.md).</span><span class="sxs-lookup"><span data-stu-id="713d8-153">Only the first four of these views are actually visible to shaders, refer to [Shader Visible Descriptor Heaps](shader-visible-descriptor-heaps.md) and [Non Shader Visible Descriptor Heaps](non-shader-visible-descriptor-heaps.md).</span></span>

## <a name="resource-binding-flow-of-control"></a><span data-ttu-id="713d8-154">Поток привязки ресурсов элемента управления</span><span class="sxs-lookup"><span data-stu-id="713d8-154">Resource Binding Flow of Control</span></span>

<span data-ttu-id="713d8-155">Основное внимание уделяется только корневым сигнатурам, корневым дескрипторам, корневым константам, таблицам дескрипторов и кучам дескрипторов. поток логики отрисовки для приложения должен выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="713d8-155">Focusing just on root signatures, root descriptors, root constants, descriptor tables, and descriptor heaps, the flow of rendering logic for an app should be similar to the following:</span></span>

-   <span data-ttu-id="713d8-156">Создайте один или несколько объектов корневой подписи — по одному для каждой конфигурации привязки, которая требуется приложению.</span><span class="sxs-lookup"><span data-stu-id="713d8-156">Create one or more root signature objects – one for every different binding configuration an application needs.</span></span>
-   <span data-ttu-id="713d8-157">Создайте шейдеры и состояние конвейера с помощью объектов корневой сигнатуры, с которыми они будут использоваться.</span><span class="sxs-lookup"><span data-stu-id="713d8-157">Create shaders and pipeline state with the root signature objects they will be used with.</span></span>
-   <span data-ttu-id="713d8-158">Создайте одну (или, если необходимо, больше) кучу дескрипторов, которая будет содержать все описания UAV и CBV для каждого кадра отрисовки.</span><span class="sxs-lookup"><span data-stu-id="713d8-158">Create one (or, if necessary, more) descriptor heaps that will contain all the SRV, UAV, and CBV descriptors for each frame of rendering.</span></span>
-   <span data-ttu-id="713d8-159">Инициализируйте кучи дескрипторов с помощью дескрипторов, где это возможно для наборов дескрипторов, которые будут повторно использоваться во многих кадрах.</span><span class="sxs-lookup"><span data-stu-id="713d8-159">Initialize the descriptor heap(s) with descriptors where possible for sets of descriptors that will be reused across many frames.</span></span>
-   <span data-ttu-id="713d8-160">Для каждого отображаемого кадра:</span><span class="sxs-lookup"><span data-stu-id="713d8-160">For each frame to be rendered:</span></span>
    -   <span data-ttu-id="713d8-161">Для каждого списка команд:</span><span class="sxs-lookup"><span data-stu-id="713d8-161">For each command list:</span></span>
        -   <span data-ttu-id="713d8-162">Задайте текущую корневую подпись для использования (и при необходимости измените ее при подготовке к просмотру, что является редко необходимым).</span><span class="sxs-lookup"><span data-stu-id="713d8-162">Set the current root signature to use (and change if needed during rendering – which is rarely required).</span></span>
        -   <span data-ttu-id="713d8-163">Обновите некоторые константы корневой сигнатуры и (или) дескрипторы корневой подписи для нового представления (например, проекции мира или представления).</span><span class="sxs-lookup"><span data-stu-id="713d8-163">Update some root signature’s constants and/or root signature descriptors for the new view (such as world/view projections).</span></span>
        -   <span data-ttu-id="713d8-164">Для каждого рисуемого элемента:</span><span class="sxs-lookup"><span data-stu-id="713d8-164">For each item to draw:</span></span>
            -   <span data-ttu-id="713d8-165">Определите новые дескрипторы в кучах дескрипторов, необходимые для отрисовки каждого объекта.</span><span class="sxs-lookup"><span data-stu-id="713d8-165">Define any new descriptors in descriptor heaps as needed for per-object rendering.</span></span> <span data-ttu-id="713d8-166">Для кучи дескрипторов, видимых шейдером, приложение должно использовать пространство кучи дескрипторов, на которое еще не ссылается визуализация, которая может быть в полете, например, линейное выделение пространства через кучу дескрипторов во время подготовки к просмотру.</span><span class="sxs-lookup"><span data-stu-id="713d8-166">For shader-visible descriptor heaps, the app must make sure to use descriptor heap space that isn’t already being referenced by rendering that could be in flight – for example, linearly allocating space through the descriptor heap during rendering.</span></span>
            -   <span data-ttu-id="713d8-167">Обновите корневую подпись с помощью указателей на требуемые регионы куч дескриптора.</span><span class="sxs-lookup"><span data-stu-id="713d8-167">Update the root signature with pointers to the required regions of the descriptor heaps.</span></span> <span data-ttu-id="713d8-168">Например, одна таблица дескрипторов может указывать на некоторые статические (неизменяемые) дескрипторы, инициализированные ранее, а другая таблица дескрипторов может указывать на некоторые динамические дескрипторы, настроенные для текущей отрисовки.</span><span class="sxs-lookup"><span data-stu-id="713d8-168">For example, one descriptor table might point to some static (unchanging) descriptors initialized earlier, while another descriptor table might point to some dynamic descriptors configured for the current rendering.</span></span>
            -   <span data-ttu-id="713d8-169">Обновите некоторые константы корневой подписи и (или) дескрипторы корневой подписи для отрисовки на уровне элементов.</span><span class="sxs-lookup"><span data-stu-id="713d8-169">Update some root signature’s constants and/or root signature descriptors for per-item rendering.</span></span>
            -   <span data-ttu-id="713d8-170">Задать для элемента состояние конвейера (только при необходимости изменения), совместимое с корневой подписью, привязанной к текущему объекту.</span><span class="sxs-lookup"><span data-stu-id="713d8-170">Set the pipeline state for the item to draw (only if change needed), compatible with the currently bound root signature.</span></span>
            -   <span data-ttu-id="713d8-171">Draw</span><span class="sxs-lookup"><span data-stu-id="713d8-171">Draw</span></span>
        -   <span data-ttu-id="713d8-172">Повторить (следующий элемент)</span><span class="sxs-lookup"><span data-stu-id="713d8-172">Repeat (next item)</span></span>
    -   <span data-ttu-id="713d8-173">Повтор (следующий список команд)</span><span class="sxs-lookup"><span data-stu-id="713d8-173">Repeat (next command list)</span></span>
    -   <span data-ttu-id="713d8-174">Только после завершения работы GPU с любой памятью, которая больше не будет использоваться, ее можно освободить.</span><span class="sxs-lookup"><span data-stu-id="713d8-174">Strictly when the GPU has finished with any memory that will no longer be used, it can be released.</span></span> <span data-ttu-id="713d8-175">Ссылки дескрипторов на него не нужно удалять, если не отправляется дополнительная визуализация, использующая эти дескрипторы.</span><span class="sxs-lookup"><span data-stu-id="713d8-175">Descriptors' references to it do not need to be deleted if additional rendering that uses those descriptors is not submitted.</span></span> <span data-ttu-id="713d8-176">Таким образом, последующая отрисовка может указывать на другие области в кучах дескрипторов, или устаревшие дескрипторы могут быть перезаписаны допустимыми дескрипторами для повторного использования пространства кучи дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="713d8-176">So, subsequent rendering can point to other areas in descriptor heaps, or stale descriptors can be overwritten with valid descriptors to reuse the descriptor heap space.</span></span>
-   <span data-ttu-id="713d8-177">Повторить (следующий кадр)</span><span class="sxs-lookup"><span data-stu-id="713d8-177">Repeat (next frame)</span></span>

<span data-ttu-id="713d8-178">Обратите внимание, что другие типы дескрипторов, представления целевого объекта отрисовки (RTVs), представления трафарета глубины (DSV), представления буферов вершин (Ибвс), представления буфера вершины (Вбвс) и представления объектов шейдера (сов) управляются по-разному.</span><span class="sxs-lookup"><span data-stu-id="713d8-178">Note that other descriptor types, render target views (RTVs), depth stencil views (DSV), index buffer views (IBVs), vertex buffer views (VBVs), and shader object views (SOV), are managed differently.</span></span> <span data-ttu-id="713d8-179">Драйвер обрабатывает управление версиями набора дескрипторов, привязанных к каждому элементу Draw во время записи списка команд (аналогично тому, как задаются сведения об оборудовании и драйвере версии привязки корневой сигнатуры).</span><span class="sxs-lookup"><span data-stu-id="713d8-179">The driver handles the versioning of the set of descriptors bound for each draw during recording of the command list (similar to how the root signature bindings are versioned by the hardware/driver).</span></span> <span data-ttu-id="713d8-180">Это отличается от содержимого куч-видимых дескрипторов шейдера, для которых приложение должно вручную выделить кучу, так как она ссылается на разные дескрипторы рисования.</span><span class="sxs-lookup"><span data-stu-id="713d8-180">This is different from the contents of shader-visible descriptor heaps, for which the application must manually allocate through the heap as it references different descriptors between draws.</span></span> <span data-ttu-id="713d8-181">Управление версиями содержимого кучи, которое является видимым шейдером, оставлено приложению, так как оно позволяет приложениям выполнять такие действия, как повторное использование дескрипторов, которые не изменяются или используют большие статические наборы дескрипторов, и использовать индексацию шейдера (например, по ИДЕНТИФИКАТОРу материала) для выбора дескрипторов из кучи дескрипторов или использовать сочетания методов для различных наборов дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="713d8-181">Versioning of heap content that is shader-visible is left to the application because it allows applications to do things like reuse descriptors that don’t change, or use large static sets of descriptors and use shader indexing (such as by material ID) to select descriptors to use from the descriptor heap, or use combinations of techniques for different sets of descriptors.</span></span> <span data-ttu-id="713d8-182">Оборудование не оборудовано для поддержки такого типа гибкости для других типов дескрипторов (РТВ, DSV, ИБВ, ВБВ, сов).</span><span class="sxs-lookup"><span data-stu-id="713d8-182">The hardware isn’t equipped to handle this type of flexibility for the other descriptor types (RTV, DSV, IBV, VBV, SOV).</span></span>

## <a name="suballocation"></a><span data-ttu-id="713d8-183">Выделено</span><span class="sxs-lookup"><span data-stu-id="713d8-183">Suballocation</span></span>

<span data-ttu-id="713d8-184">В Direct3D 12 приложение имеет низкий уровень контроля над управлением памятью.</span><span class="sxs-lookup"><span data-stu-id="713d8-184">In Direct3D 12, the app has low-level control over memory management.</span></span> <span data-ttu-id="713d8-185">В более ранних версиях Direct3D, включая Direct3D 11, выделено одно выделение для каждого ресурса.</span><span class="sxs-lookup"><span data-stu-id="713d8-185">In earlier versions of Direct3D, including Direct3D 11, there would be one allocation per resource.</span></span> <span data-ttu-id="713d8-186">В Direct3D 12 приложение может использовать API для выделения большого блока памяти, чем требуется для одного объекта.</span><span class="sxs-lookup"><span data-stu-id="713d8-186">In Direct3D 12, the app can use the API to allocate a large block of memory, larger than any single object would need.</span></span> <span data-ttu-id="713d8-187">После этого приложение может создавать дескрипторы, указывающие на разделы этого большого блока памяти.</span><span class="sxs-lookup"><span data-stu-id="713d8-187">After this is done, the app can create descriptors to point to sections of that large memory block.</span></span> <span data-ttu-id="713d8-188">Этот процесс решает, что следует разместить, где (меньшие блоки внутри большого блока) называется *подраспределением*.</span><span class="sxs-lookup"><span data-stu-id="713d8-188">This process of deciding what to put where (smaller blocks inside the large block) is known as *suballocation*.</span></span> <span data-ttu-id="713d8-189">Включение этого приложения может привести к повышению эффективности использования вычислений и памяти.</span><span class="sxs-lookup"><span data-stu-id="713d8-189">Enabling the app to do this can yield gains in efficient use of computation and memory.</span></span> <span data-ttu-id="713d8-190">Например, переименование ресурсов отрисовывается как устаревшее.</span><span class="sxs-lookup"><span data-stu-id="713d8-190">For example, resource renaming is rendered obsolete.</span></span> <span data-ttu-id="713d8-191">Вместо этого приложения могут использовать ограждения, чтобы определить, когда используется определенный ресурс, и когда он не является ограждением при выполнении списка команд, где список команд требует использования этого конкретного ресурса.</span><span class="sxs-lookup"><span data-stu-id="713d8-191">In place of this, apps can use fences to determine when a particular resource is being used and when it's not by fencing on command list executions where the command list requires the use of that particular resource.</span></span>

## <a name="freeing-resources"></a><span data-ttu-id="713d8-192">Освобождение ресурсов</span><span class="sxs-lookup"><span data-stu-id="713d8-192">Freeing Resources</span></span>

<span data-ttu-id="713d8-193">Прежде чем можно будет освободить память, которая была привязана к конвейеру, необходимо завершить графический процессор.</span><span class="sxs-lookup"><span data-stu-id="713d8-193">Before any memory that has been bound to the pipeline can be freed, the GPU must be finished with it.</span></span>

<span data-ttu-id="713d8-194">Ожидание отрисовки кадров, вероятно, является грубым способом убедиться в том, что GPU завершен.</span><span class="sxs-lookup"><span data-stu-id="713d8-194">Waiting for frame rendering is probably the coarsest way to be certain that the GPU has finished.</span></span> <span data-ttu-id="713d8-195">В более тонком Гране можно снова использовать ограждения — когда команда записывается в список команд, для которого необходимо отследить завершение, вставьте ограждение сразу после нее.</span><span class="sxs-lookup"><span data-stu-id="713d8-195">At a finer grain, you can again use fences—when a command is recorded into a command list that you want to track the completion of, insert a fence immediately after it.</span></span> <span data-ttu-id="713d8-196">Затем можно выполнять различные операции синхронизации с ограждением.</span><span class="sxs-lookup"><span data-stu-id="713d8-196">Then, you can do various synchronization operations with the fence.</span></span> <span data-ttu-id="713d8-197">Вы отправляете новую работу (списки команд), которая ожидает до тех пор, пока заданная ограждение не перейдет к GPU, что указывает на то, что все до его завершения, или вы можете запросить возникновение события ЦП при передаче ограждения (которое приложение может ожидать в спящем потоке).</span><span class="sxs-lookup"><span data-stu-id="713d8-197">You submit new work (command lists) that waits until a specified fence has passed on the GPU, which indicates that everything before it is complete, or you can request that a CPU event be raised when the fence has passed (which the app can be waiting on with a sleeping thread).</span></span> <span data-ttu-id="713d8-198">В Direct3D 11 это было `EnqueueSetEvent` ().</span><span class="sxs-lookup"><span data-stu-id="713d8-198">In Direct3D 11, this was `EnqueueSetEvent`().</span></span>

## <a name="related-topics"></a><span data-ttu-id="713d8-199">Связанные темы</span><span class="sxs-lookup"><span data-stu-id="713d8-199">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="713d8-200">Привязка ресурсов</span><span class="sxs-lookup"><span data-stu-id="713d8-200">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




