---
description: В этом разделе описывается использование рабочих очередей в Microsoft Media Foundation.
ms.assetid: 6be05df7-e8ff-4110-8f73-a62eb31fd414
title: Использование рабочих очередей
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d7bb41b830742ca871d44cadac9bd26a9967aa1
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104263482"
---
# <a name="using-work-queues"></a><span data-ttu-id="0de14-103">Использование рабочих очередей</span><span class="sxs-lookup"><span data-stu-id="0de14-103">Using Work Queues</span></span>

<span data-ttu-id="0de14-104">В этом разделе описывается использование рабочих очередей в Microsoft Media Foundation.</span><span class="sxs-lookup"><span data-stu-id="0de14-104">This topic describes how to use work queues in Microsoft Media Foundation.</span></span>

-   [<span data-ttu-id="0de14-105">Использование рабочих очередей</span><span class="sxs-lookup"><span data-stu-id="0de14-105">Using Work Queues</span></span>](#using-work-queues)
-   [<span data-ttu-id="0de14-106">Завершение работы рабочих очередей</span><span class="sxs-lookup"><span data-stu-id="0de14-106">Shutting Down Work Queues</span></span>](#shutting-down-work-queues)
-   [<span data-ttu-id="0de14-107">Использование запланированных рабочих элементов</span><span class="sxs-lookup"><span data-stu-id="0de14-107">Using Scheduled Work Items</span></span>](#using-scheduled-work-items)
-   [<span data-ttu-id="0de14-108">Использование периодических обратных вызовов</span><span class="sxs-lookup"><span data-stu-id="0de14-108">Using Periodic Callbacks</span></span>](#using-periodic-callbacks)
-   [<span data-ttu-id="0de14-109">См. также</span><span class="sxs-lookup"><span data-stu-id="0de14-109">Related topics</span></span>](#related-topics)

## <a name="using-work-queues"></a><span data-ttu-id="0de14-110">Использование рабочих очередей</span><span class="sxs-lookup"><span data-stu-id="0de14-110">Using Work Queues</span></span>

<span data-ttu-id="0de14-111">Рабочая очередь — это эффективный способ выполнения асинхронных операций в другом потоке.</span><span class="sxs-lookup"><span data-stu-id="0de14-111">A work queue is an efficient way to perform asynchronous operations on another thread.</span></span> <span data-ttu-id="0de14-112">По сути, вы размещаете рабочие элементы в очереди, а очередь содержит поток, который извлекает каждый элемент из очереди и отправляет его.</span><span class="sxs-lookup"><span data-stu-id="0de14-112">Conceptually, you put work items in the queue, and the queue has a thread that pulls each item from the queue and dispatches it.</span></span> <span data-ttu-id="0de14-113">Рабочие элементы реализуются как обратные вызовы с помощью интерфейса [**имфасинккаллбакк**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) .</span><span class="sxs-lookup"><span data-stu-id="0de14-113">Work items are implemented as callbacks by using the [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) interface.</span></span>

<span data-ttu-id="0de14-114">Media Foundation создает несколько стандартных рабочих очередей, называемых *рабочими очередями платформы*.</span><span class="sxs-lookup"><span data-stu-id="0de14-114">Media Foundation creates several standard work queues, called *platform work queues*.</span></span> <span data-ttu-id="0de14-115">Приложения также могут создавать собственные рабочие очереди, называемые *частными рабочими очередями*.</span><span class="sxs-lookup"><span data-stu-id="0de14-115">Applications can also create their own work queues, called *private work queues*.</span></span> <span data-ttu-id="0de14-116">Список рабочих очередей платформы см. в разделе [идентификаторы рабочей очереди](work-queue-identifiers.md).</span><span class="sxs-lookup"><span data-stu-id="0de14-116">For a list of the platform work queues, see [Work Queue Identifiers](work-queue-identifiers.md).</span></span> <span data-ttu-id="0de14-117">Чтобы создать частную рабочую очередь, вызовите [**мфаллокатеворккуеуе**](/windows/desktop/api/mfapi/nf-mfapi-mfallocateworkqueue).</span><span class="sxs-lookup"><span data-stu-id="0de14-117">To create a private work queue, call [**MFAllocateWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfallocateworkqueue).</span></span> <span data-ttu-id="0de14-118">Эта функция возвращает идентификатор для новой рабочей очереди.</span><span class="sxs-lookup"><span data-stu-id="0de14-118">This function returns an identifier for the new work queue.</span></span> <span data-ttu-id="0de14-119">Чтобы поместить элемент в очередь, вызовите [**мфпутворкитем**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) или [**мфпутворкитемекс**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitemex).</span><span class="sxs-lookup"><span data-stu-id="0de14-119">To put an item in the queue, call [**MFPutWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) or [**MFPutWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitemex).</span></span> <span data-ttu-id="0de14-120">В обоих случаях необходимо указать интерфейс обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="0de14-120">In both cases, you must specify a callback interface.</span></span>

-   <span data-ttu-id="0de14-121">[**Мфпутворкитем**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) принимает указатель на интерфейс [**имфасинккаллбакк**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) , а также необязательный объект состояния, который реализует **IUnknown**.</span><span class="sxs-lookup"><span data-stu-id="0de14-121">[**MFPutWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) takes a pointer to the [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) interface, plus an optional state object that implements **IUnknown**.</span></span> <span data-ttu-id="0de14-122">Это те же параметры, которые используются в асинхронных методах, как описано в разделе [методы асинхронного обратного вызова](asynchronous-callback-methods.md).</span><span class="sxs-lookup"><span data-stu-id="0de14-122">These are the same parameters used in asynchronous methods, as described in the topic [Asynchronous Callback Methods](asynchronous-callback-methods.md).</span></span> <span data-ttu-id="0de14-123">На внутреннем уровне эта функция создает объект асинхронного результата, который передается в метод [**Invoke**](/windows/desktop/api/mfobjects/nf-mfobjects-imfasynccallback-invoke) метода обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="0de14-123">Internally, this function creates an asynchronous result object, which is passed to the callback's [**Invoke**](/windows/desktop/api/mfobjects/nf-mfobjects-imfasynccallback-invoke) method.</span></span>
-   <span data-ttu-id="0de14-124">[**Мфпутворкитемекс**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitemex) принимает указатель на интерфейс [**имфасинкресулт**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) .</span><span class="sxs-lookup"><span data-stu-id="0de14-124">[**MFPutWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitemex) takes a pointer to the [**IMFAsyncResult**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) interface.</span></span> <span data-ttu-id="0de14-125">Этот интерфейс представляет объект асинхронного результата.</span><span class="sxs-lookup"><span data-stu-id="0de14-125">This interface represents an asynchronous result object.</span></span> <span data-ttu-id="0de14-126">Создайте этот объект, вызвав [**мфкреатеасинкресулт**](/windows/desktop/api/mfapi/nf-mfapi-mfcreateasyncresult) и указав интерфейс обратного вызова и, при необходимости, объект состояния.</span><span class="sxs-lookup"><span data-stu-id="0de14-126">Create this object by calling [**MFCreateAsyncResult**](/windows/desktop/api/mfapi/nf-mfapi-mfcreateasyncresult) and specifying your callback interface and, optionally, a state object.</span></span>

<span data-ttu-id="0de14-127">В обоих случаях поток рабочей очереди вызывает метод [**имфасинккаллбакк:: Invoke**](/windows/desktop/api/mfobjects/nf-mfobjects-imfasynccallback-invoke) .</span><span class="sxs-lookup"><span data-stu-id="0de14-127">In both cases, the work queue thread calls your [**IMFAsyncCallback::Invoke**](/windows/desktop/api/mfobjects/nf-mfobjects-imfasynccallback-invoke) method.</span></span> <span data-ttu-id="0de14-128">Используйте метод **Invoke** для выполнения рабочего элемента.</span><span class="sxs-lookup"><span data-stu-id="0de14-128">Use the **Invoke** method to perform the work item.</span></span>

<span data-ttu-id="0de14-129">Если несколько потоков или компонентов совместно используют одну и ту же рабочую очередь, можно вызвать [**мфлоккворккуеуе**](/windows/desktop/api/mfapi/nf-mfapi-mflockworkqueue) , чтобы заблокировать рабочую очередь, что не позволит платформе освободить ее.</span><span class="sxs-lookup"><span data-stu-id="0de14-129">If more than one thread or component shares the same work queue, you can call [**MFLockWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mflockworkqueue) to lock the work queue, which prevents the platform from releasing it.</span></span> <span data-ttu-id="0de14-130">Для каждого вызова [**мфаллокатеворккуеуе**](/windows/desktop/api/mfapi/nf-mfapi-mfallocateworkqueue) или **Мфлоккворккуеуе** необходимо вызвать [**мфунлоккворккуеуе**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockworkqueue) один раз, чтобы освободить рабочую очередь.</span><span class="sxs-lookup"><span data-stu-id="0de14-130">For each call to [**MFAllocateWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfallocateworkqueue) or **MFLockWorkQueue**, you must call [**MFUnlockWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockworkqueue) once to release the work queue.</span></span> <span data-ttu-id="0de14-131">Например, если создать новую рабочую очередь и затем заблокировать ее один раз, необходимо вызвать **мфунлоккворккуеуе** дважды, один раз для вызова **мфаллокатеворккуеуе** и один раз для вызова **мфлоккворккуеуе**.</span><span class="sxs-lookup"><span data-stu-id="0de14-131">For example, if you create a new work queue and then lock it once, you must call **MFUnlockWorkQueue** twice, once for the call to **MFAllocateWorkQueue** and once for the call to **MFLockWorkQueue**.</span></span>

<span data-ttu-id="0de14-132">В следующем коде показано, как создать новую рабочую очередь, поместить рабочий элемент в очередь и освободить рабочую очередь.</span><span class="sxs-lookup"><span data-stu-id="0de14-132">The following code shows how to create a new work queue, put a work item in the queue, and release the work queue.</span></span>

<span data-ttu-id="0de14-133">Дополнительные сведения о рабочих очередях в Windows 8 см. в разделе [улучшения рабочей очереди и потоков](media-foundation-work-queue-and-threading-improvements.md) .</span><span class="sxs-lookup"><span data-stu-id="0de14-133">See [Work Queue and Threading Improvements](media-foundation-work-queue-and-threading-improvements.md) for additional information on work queues in Windows 8.</span></span>


```C++
DWORD idWorkQueue = 0;
HRESULT hr = S_OK;

// Create a new work queue.
hr = MFAllocateWorkQueue(&idWorkQueue);

// Put an item on the queue.
if (SUCCEEDED(hr))
{
    hr = MFPutWorkItem(idWorkQueue, pCallback, NULL);
}

// Wait for the callback to be invoked.
if (SUCCEEDED(hr))
{
    WaitForSingleObject(hEvent, INFINITE);
}

// Release the work queue.
if (SUCCEEDED(hr))
{
    hr = MFUnlockWorkQueue(idWorkQueue);
}
```



<span data-ttu-id="0de14-134">В этом примере предполагается, что *пкаллбакк* является указателем на интерфейс [**имфасинккаллбакк**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) приложения.</span><span class="sxs-lookup"><span data-stu-id="0de14-134">This example assumes that *pCallback* is a pointer to the application's [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) interface.</span></span> <span data-ttu-id="0de14-135">Также предполагается, что обратный вызов задает обработчик событий *Хевент* .</span><span class="sxs-lookup"><span data-stu-id="0de14-135">It also assumes that the callback sets the *hEvent* event handle.</span></span> <span data-ttu-id="0de14-136">Перед вызовом [**мфунлоккворккуеуе**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockworkqueue)код ожидает установки этого события.</span><span class="sxs-lookup"><span data-stu-id="0de14-136">The code waits for this event to be set before calling [**MFUnlockWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockworkqueue).</span></span>

<span data-ttu-id="0de14-137">Потоки рабочей очереди всегда создаются в процессе вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="0de14-137">Work queue threads are always created in the caller's process.</span></span> <span data-ttu-id="0de14-138">В каждой рабочей очереди обратные вызовы сериализуются.</span><span class="sxs-lookup"><span data-stu-id="0de14-138">Within each work queue, the callbacks are serialized.</span></span> <span data-ttu-id="0de14-139">Если вы вызываете [**мфпутворкитем**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) дважды с той же рабочей очередью, второй обратный вызов не вызывается до тех пор, пока не вернется первый обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="0de14-139">If you call [**MFPutWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) twice with the same work queue, the second callback is not invoked until the first callback has returned.</span></span>

## <a name="shutting-down-work-queues"></a><span data-ttu-id="0de14-140">Завершение работы рабочих очередей</span><span class="sxs-lookup"><span data-stu-id="0de14-140">Shutting Down Work Queues</span></span>

<span data-ttu-id="0de14-141">Перед вызовом [**мфшутдовн**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown)Освободите все ресурсы, используемые потоками рабочих очередей.</span><span class="sxs-lookup"><span data-stu-id="0de14-141">Before calling [**MFShutdown**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown), release any resources that are being used by work queue threads.</span></span> <span data-ttu-id="0de14-142">Чтобы синхронизировать этот процесс, можно заблокировать Media Foundationную платформу, которая не позволяет функции **мфшутдовн** закрывать потоки рабочих очередей.</span><span class="sxs-lookup"><span data-stu-id="0de14-142">To synchronize this process, you can lock the Media Foundation platform, which prevents the **MFShutdown** function from closing any work queue threads.</span></span> <span data-ttu-id="0de14-143">Если **мфшутдовн** вызывается, когда платформа заблокирована, **мфшутдовн** ожидает несколько сотен миллисекунд, чтобы платформа была разблокирована.</span><span class="sxs-lookup"><span data-stu-id="0de14-143">If **MFShutdown** is called while the platform is locked, **MFShutdown** waits a few hundred milliseconds for the platform to be unlocked.</span></span> <span data-ttu-id="0de14-144">Если он не разблокирован в течение этого времени, **мфшутдовн** закрывает потоки рабочей очереди.</span><span class="sxs-lookup"><span data-stu-id="0de14-144">If it is not unlocked within that time, **MFShutdown** closes the work queue threads.</span></span>

<span data-ttu-id="0de14-145">Реализация [**имфасинкресулт**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) по умолчанию автоматически блокирует Media Foundationную платформу при создании результирующего объекта.</span><span class="sxs-lookup"><span data-stu-id="0de14-145">The default implementation of [**IMFAsyncResult**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) automatically locks the Media Foundation platform when the result object is created.</span></span> <span data-ttu-id="0de14-146">Освобождение интерфейса разблокирует платформу.</span><span class="sxs-lookup"><span data-stu-id="0de14-146">Releasing the interface unlocks the platform.</span></span> <span data-ttu-id="0de14-147">Поэтому вам почти никогда не придется блокировать платформу напрямую.</span><span class="sxs-lookup"><span data-stu-id="0de14-147">Therefore, you will almost never need to lock the platform directly.</span></span> <span data-ttu-id="0de14-148">Но при написании собственной пользовательской реализации **имфасинкресулт** следует вручную заблокировать и разблокировать платформу.</span><span class="sxs-lookup"><span data-stu-id="0de14-148">But if you write your own custom implementation of **IMFAsyncResult**, then you should manually lock and unlock the platform.</span></span> <span data-ttu-id="0de14-149">Чтобы заблокировать платформу, вызовите [**мфлоккплатформ**](/windows/desktop/api/mfapi/nf-mfapi-mflockplatform).</span><span class="sxs-lookup"><span data-stu-id="0de14-149">To lock the platform, call [**MFLockPlatform**](/windows/desktop/api/mfapi/nf-mfapi-mflockplatform).</span></span> <span data-ttu-id="0de14-150">Чтобы разблокировать платформу, вызовите [**мфунлоккплатформ**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockplatform).</span><span class="sxs-lookup"><span data-stu-id="0de14-150">To unlock the platform, call [**MFUnlockPlatform**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockplatform).</span></span> <span data-ttu-id="0de14-151">Пример см. в разделе [пользовательские асинхронные объекты Result](custom-asynchronous-result-objects.md).</span><span class="sxs-lookup"><span data-stu-id="0de14-151">For an example, see [Custom Asynchronous Result Objects](custom-asynchronous-result-objects.md).</span></span>

<span data-ttu-id="0de14-152">После вызова [**мфшутдовн**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown)необходимо убедиться, что платформа разблокирована в течение 5-секундного периода ожидания.</span><span class="sxs-lookup"><span data-stu-id="0de14-152">After you call [**MFShutdown**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown), you need to ensure that the platform is unlocked within the 5-second time-out period.</span></span> <span data-ttu-id="0de14-153">Для этого выпустите все [**имфасинкресулт**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) указатели и вызовите [**мфунлоккплатформ**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockplatform) , если вы заблокировали платформу вручную.</span><span class="sxs-lookup"><span data-stu-id="0de14-153">Do this by releasing all [**IMFAsyncResult**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) pointers, and by calling [**MFUnlockPlatform**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockplatform) if you locked the platform manually.</span></span> <span data-ttu-id="0de14-154">Убедитесь, что освобождаются все ресурсы, используемые потоками рабочих очередей, или ваше приложение может привести к утечке памяти.</span><span class="sxs-lookup"><span data-stu-id="0de14-154">Make sure to release any resources that are being used by work queue threads, or your application might leak memory.</span></span>

<span data-ttu-id="0de14-155">Как правило, если приложение завершает работу и освобождает каждый объект Media Foundation перед вызовом [**мфшутдовн**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown), нет необходимости беспокоиться о блокировке.</span><span class="sxs-lookup"><span data-stu-id="0de14-155">Typically, if your application shuts down and releases every Media Foundation object before calling [**MFShutdown**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown), you do not have to worry about locking.</span></span> <span data-ttu-id="0de14-156">Механизм блокировки просто позволяет потокам рабочей очереди корректно завершать работу после вызова **мфшутдовн**.</span><span class="sxs-lookup"><span data-stu-id="0de14-156">The locking mechanism simply allows work queue threads to exit gracefully after you call **MFShutdown**.</span></span>

## <a name="using-scheduled-work-items"></a><span data-ttu-id="0de14-157">Использование запланированных рабочих элементов</span><span class="sxs-lookup"><span data-stu-id="0de14-157">Using Scheduled Work Items</span></span>

<span data-ttu-id="0de14-158">Вы можете запланировать выполнение обратного вызова по истечении заданного периода времени, вызвав [**мфсчедулеворкитем**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitem) или [**мфсчедулеворкитемекс**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitemex).</span><span class="sxs-lookup"><span data-stu-id="0de14-158">You can schedule a callback to occur after a set period of time by calling [**MFScheduleWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitem) or [**MFScheduleWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitemex).</span></span>

-   <span data-ttu-id="0de14-159">[**Мфсчедулеворкитем**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitem) принимает указатель на обратный вызов, необязательный объект состояния и интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="0de14-159">[**MFScheduleWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitem) takes a pointer to your callback, an optional state object, and a time-out interval.</span></span>
-   <span data-ttu-id="0de14-160">[**Мфсчедулеворкитемекс**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitemex) принимает указатель на объект асинхронного результата и значение времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="0de14-160">[**MFScheduleWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitemex) takes a pointer to an asynchronous result object and a time-out value.</span></span>

<span data-ttu-id="0de14-161">Укажите время ожидания как отрицательное значение в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="0de14-161">Specify the time-out as a negative value in milliseconds.</span></span> <span data-ttu-id="0de14-162">Например, чтобы запланировать вызов обратного вызова в течение 5 секунд, используйте значение − 5000.</span><span class="sxs-lookup"><span data-stu-id="0de14-162">For example, to schedule a callback to be invoked in 5 seconds, use the value −5000.</span></span> <span data-ttu-id="0de14-163">Обе функции возвращают **значение \_ ключа мфворкитем** , которое можно использовать для отмены обратного вызова, передавая его в функцию [**мфканцелворкитем**](/windows/desktop/api/mfapi/nf-mfapi-mfcancelworkitem) .</span><span class="sxs-lookup"><span data-stu-id="0de14-163">Both functions return an **MFWORKITEM\_KEY** value, which you can use to cancel the callback by passing it to the [**MFCancelWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfcancelworkitem) function.</span></span>

<span data-ttu-id="0de14-164">Запланированные рабочие элементы всегда используют \_ очередь ответного вызова мфасинк для \_ \_ платформы таймера.</span><span class="sxs-lookup"><span data-stu-id="0de14-164">Scheduled work items always use the MFASYNC\_CALLBACK\_QUEUE\_TIMER platform work queue.</span></span>

## <a name="using-periodic-callbacks"></a><span data-ttu-id="0de14-165">Использование периодических обратных вызовов</span><span class="sxs-lookup"><span data-stu-id="0de14-165">Using Periodic Callbacks</span></span>

<span data-ttu-id="0de14-166">Функция [**мфаддпериодиккаллбакк**](/windows/desktop/api/mfapi/nf-mfapi-mfaddperiodiccallback) планирует периодически вызывать обратный вызов до тех пор, пока вы его не отмените.</span><span class="sxs-lookup"><span data-stu-id="0de14-166">The [**MFAddPeriodicCallback**](/windows/desktop/api/mfapi/nf-mfapi-mfaddperiodiccallback) function schedules a callback to be invoked periodically until you cancel it.</span></span> <span data-ttu-id="0de14-167">Интервал обратного вызова является фиксированным; приложения не могут изменить его.</span><span class="sxs-lookup"><span data-stu-id="0de14-167">The callback interval is fixed; applications cannot change it.</span></span> <span data-ttu-id="0de14-168">Чтобы узнать точный интервал, вызовите [**мфжеттимерпериодиЦити**](/windows/desktop/api/mfapi/nf-mfapi-mfgettimerperiodicity).</span><span class="sxs-lookup"><span data-stu-id="0de14-168">To find out the exact interval, call [**MFGetTimerPeriodicity**](/windows/desktop/api/mfapi/nf-mfapi-mfgettimerperiodicity).</span></span> <span data-ttu-id="0de14-169">Интервал равен 10 миллисекундам, поэтому эта функция предназначена для ситуаций, когда требуется частое «значение Tick», например реализация часов представления.</span><span class="sxs-lookup"><span data-stu-id="0de14-169">The interval is on the order of 10 milliseconds, so this function is meant for situations where you need a frequent "tick," such as implementing a presentation clock.</span></span> <span data-ttu-id="0de14-170">Если необходимо запланировать выполнение операции реже, используйте запланированный рабочий элемент, как описано выше.</span><span class="sxs-lookup"><span data-stu-id="0de14-170">If you want to schedule an operation to occur less frequently, use a scheduled work item, as described previously.</span></span>

<span data-ttu-id="0de14-171">В отличие от других обратных вызовов, описанных в этом разделе, периодический обратный вызов не использует интерфейс [**имфасинккаллбакк**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) .</span><span class="sxs-lookup"><span data-stu-id="0de14-171">Unlike the other callbacks described in this topic, the periodic callback does not use the [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) interface.</span></span> <span data-ttu-id="0de14-172">Вместо этого используется указатель на функцию.</span><span class="sxs-lookup"><span data-stu-id="0de14-172">Instead, it uses a function pointer.</span></span> <span data-ttu-id="0de14-173">Дополнительные сведения см. в разделе [**обратный вызов мфпериодиккаллбакк**](/windows/win32/api/mfapi/nc-mfapi-mfperiodiccallback).</span><span class="sxs-lookup"><span data-stu-id="0de14-173">For more information, see [**MFPERIODICCALLBACK Callback**](/windows/win32/api/mfapi/nc-mfapi-mfperiodiccallback).</span></span>

<span data-ttu-id="0de14-174">Чтобы отменить периодический обратный вызов, вызовите [**мфремовепериодиккаллбакк**](/windows/desktop/api/mfapi/nf-mfapi-mfremoveperiodiccallback).</span><span class="sxs-lookup"><span data-stu-id="0de14-174">To cancel the periodic callback, call [**MFRemovePeriodicCallback**](/windows/desktop/api/mfapi/nf-mfapi-mfremoveperiodiccallback).</span></span>

<span data-ttu-id="0de14-175">Периодические обратные вызовы используют \_ \_ \_ рабочую очередь платформы таймера очереди ответного вызова мфасинк.</span><span class="sxs-lookup"><span data-stu-id="0de14-175">Periodic callbacks use the MFASYNC\_CALLBACK\_QUEUE\_TIMER platform work queue.</span></span>

## <a name="related-topics"></a><span data-ttu-id="0de14-176">См. также</span><span class="sxs-lookup"><span data-stu-id="0de14-176">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="0de14-177">Рабочие очереди</span><span class="sxs-lookup"><span data-stu-id="0de14-177">Work Queues</span></span>](work-queues.md)
</dt> <dt>

[<span data-ttu-id="0de14-178">**мфасинкресулт**</span><span class="sxs-lookup"><span data-stu-id="0de14-178">**MFASYNCRESULT**</span></span>](/windows/win32/api/mfapi/ns-mfapi-mfasyncresult)
</dt> <dt>

[<span data-ttu-id="0de14-179">Усовершенствования рабочей очереди и потоков</span><span class="sxs-lookup"><span data-stu-id="0de14-179">Work Queue and Threading Improvements</span></span>](media-foundation-work-queue-and-threading-improvements.md)
</dt> </dl>

 

 
