---
description: Рекомендуемые 8-разрядные форматы YUV для отрисовки видео
ms.assetid: 675d4c60-4c58-4f15-9bae-ffb0c389c608
title: Рекомендуемые 8-разрядные форматы YUV для отрисовки видео
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cc6e30f33c59bedf9a2e842d2d33328bd97d8078d21bda90ae84af9af00ec113
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119722132"
---
# <a name="recommended-8-bit-yuv-formats-for-video-rendering"></a>Рекомендуемые 8-разрядные форматы YUV для отрисовки видео

Гари Салливан и Стивен Естроп

Microsoft Corporation

2002 апреля, Обновлено 2008 ноября

в этом разделе описываются 8-разрядные форматы цвета YUV, рекомендуемые для отрисовки видео в операционной системе Windows. В этой статье представлены методы для преобразования между форматами YUV и RGB, а также методы для избыточного отбора форматов YUV. Эта статья предназначена для всех пользователей, которые работают с декодированием и отрисовкой видео YUV в Windows.

## <a name="introduction"></a>Введение

Многие форматы YUV определяются во всей видеоиндустрии. В этой статье указаны 8-разрядные форматы YUV, Рекомендуемые для отрисовки видео в Windows. Поставщики декодеров и поставщики услуг показа должны поддерживать форматы, описанные в этой статье. В этой статье не рассматриваются другие способы использования цвета YUV, такие как все еще фотографии.

Форматы, описанные в этой статье, используют 8 бит на пиксельное расположение для кодирования канала Y (также называемый каналом яркости) и используют 8 бит на выборку для кодирования каждого образца U или V чрома. Однако большинство форматов YUV используют менее 24 бит на пиксель в среднем, так как они содержат меньшее число выборок и V, чем значение Y. В этой статье не рассматриваются форматы YUV с 10-или более высоким каналом Y.

> [!Note]  
> В рамках этой статьи термин U эквивалентен CB, а термин V эквивалентен CR.

 

В этой статье рассматриваются следующие темы:

-   [Выборка YUV](#yuv-sampling). Описывает наиболее распространенные методы выборки YUV.
-   [Определения поверхности](#surface-definitions). Описывает Рекомендуемые форматы YUV.
-   [Цветовое пространство и преобразование частоты выборки чрома](#color-space-and-chroma-sampling-rate-conversions). Содержит некоторые рекомендации по преобразованию между форматами YUV и RGB и для преобразования между различными форматами YUV.
-   [Определение форматов YUV в Media Foundation](#identifying-yuv-formats-in-media-foundation). Описывает, как описать типы формата YUV в Media Foundation.

## <a name="yuv-sampling"></a>Выборка YUV

Каналы чрома могут иметь меньшую частоту дискретизации, чем канал яркости, без значительной потери качества искусственного. Нотация с именем "А:Б: C" используется для описания того, как часто вы и V выдаете выборку по оси Y:

-   4:4:4 — без понижения разрешения каналов чрома.
-   4:2:2 = 2:1 по горизонтали, без вертикального разрешения. Каждая строка проверки содержит четыре образца Y для каждого из двух примеров U или V.
-   4:2:0 — 2:1. понижение разрешения по горизонтали с 2:1 по вертикали.
-   4:1:1 = 4:1 по горизонтали, без вертикального разрешения. Каждая строка проверки содержит четыре образца по оси Y для каждого примера и V. 4:1:1 выборка менее распространена, чем другие форматы, и не рассматривается подробно в этой статье.

На следующих диаграммах показано, как чрома выборка для каждой из ставок понижения разрешения. Примеры яркости представлены в виде крестика, а чрома-образцы представлены кругом.

![рис. 1. выборка чрома](images/yuv-sampling-grids.png)

Основная форма 4:2:2 выборки определяется в рекомендациях ITU-R BT. 601. Существует два стандартных варианта выборки 4:2:0. один из них используется в видео mpeg-2, а другой используется в mpeg-1 и в ITU-T Рекомендации h. 261 и h. 263.

По сравнению со схемой MPEG-1 проще выполнить преобразование между схемой MPEG-2 и таблицами выборки, определенными для форматов 4:2:2 и 4:4:4. по этой причине схема MPEG-2 предпочтительна в Windows и должна рассматриваться как интерпретация формата 4:2:0 по умолчанию.

## <a name="surface-definitions"></a>Определения Surface

В этом разделе описываются 8-разрядные форматы YUV, Рекомендуемые для отрисовки видео. Они делятся на несколько категорий:

-   [форматы 4:4:4, 32 бит на пиксель](#444-formats-32-bits-per-pixel)
-   [форматы 4:2:2, 16 бит на пиксель](#422-formats-16-bits-per-pixel)
-   [форматы 4:2:0, 16 бит на пиксель](#420-formats-16-bits-per-pixel)
-   [форматы 4:2:0, 12 бит на пиксель](#420-formats-12-bits-per-pixel)

Во первых, необходимо знать о следующих понятиях, чтобы понять, что следует делать:

-   *Источник поверхности*. Для форматов YUV, описанных в этой статье, источник (0, 0) всегда находится в левом верхнем углу поверхности.
-   *Шаг*. Шаг поверхности, иногда называемый тон, — это ширина поверхности в байтах. При наличии источника поверхности в верхнем левом углу шаг всегда положительный.
-   *Выравнивание*. Выравнивание поверхности по собственному выбору является драйвером графического экрана. Поверхность всегда должна быть совмещена с помощью DWORD; Это значит, что отдельные строки внутри поверхности гарантированно поступают на границе 32 бит (DWORD). Однако выравнивание может быть больше 32 бит в зависимости от потребностей оборудования.
-   Упакованный формат и плоский формат. Форматы YUV делятся на *Упакованные* форматы и *плоские* форматы. В упакованном формате компоненты Y, U и V хранятся в одном массиве. Пиксели организованы в группы макропикселс, макет которых зависит от формата. В плоском формате компоненты Y, U и V хранятся в виде трех отдельных плоскостей.

Каждый из форматов YUV, описанных в этой статье, имеет назначенный код FOURCC. Код FOURCC — это 32-разрядное целое число без знака, которое создается путем сцепления четырех символов ASCII.

-   4:4:4 (32 бит)
    -   [айув](#ayuv)
-   4:2:2 (16 бит)
    -   [YUY2](#yuy2)
    -   [UYVY](#uyvy)
-   4:2:0 (16 бит)
    -   [IMC1](#imc1)
    -   [IMC3](#imc3)
-   4:2:0 (12 бит)
    -   [IMC2](#imc2)
    -   [IMC4](#imc4)
    -   [YV12](#yv12)
    -   [NV12](#nv12)

## <a name="444-formats-32-bits-per-pixel"></a>форматы 4:4:4, 32 бит на пиксель

### <a name="ayuv"></a>айув

Рекомендуется использовать один формат 4:4:4 с кодом FOURCC АЙУВ. Это упакованный формат, где каждый пиксель кодируется четырьмя последовательными байтами, упорядоченным в последовательности, показанной на следующем рисунке.

![рис. 2. Макет памяти айув](images/yuvformats01.gif)

Байты, отмеченные, содержат значения для альфа.

## <a name="422-formats-16-bits-per-pixel"></a>форматы 4:2:2, 16 бит на пиксель

Рекомендуется использовать два формата 4:2:2 с приведенными ниже кодами FOURCC.

-   YUY2
-   UYVY

Оба являются упакованными форматами, где каждый макропиксел — два пиксела, закодированных четырьмя последовательными байтами. Это приводит к горизонтальному понижению чрома с коэффициентом 2.

### <a name="yuy2"></a>YUY2

В формате YUY2 данные могут рассматриваться как массив значений типа **char** без знака, где первый байт содержит первый образец Y, второй байт содержит первый экземпляр U (CB), третий байт содержит второй образец y, а четвертый байт — первый (CR) пример, как показано на следующей схеме.

![рис. 3. Макет памяти YUY2](images/yuvformats02.gif)

Если изображение обработано как массив значений **слов** с прямым порядком байтов, то первое **слово** содержит первый образец Y в наименее значимых битах (лсбс) и первый экземпляр U (CB) в наиболее значимых битах (МСБС). Второе **слово** содержит второй пример Y в лсбс и первый пример V (CR) в МСБС.

YUY2 — предпочтительный формат 4:2:2 пикселей для ускорения видео Microsoft DirectX (DirectX ва). Это должно быть промежуточное требование для ускорителей DirectX, поддерживающих видео 4:2:2.

### <a name="uyvy"></a>UYVY

Этот формат совпадает с форматом YUY2, за исключением того, что порядок байтов изменяется на обратный, то есть чрома и яркости байты перемещаются (рис. 4). Если изображение обработано как массив из двух значений **слов** с прямым порядком байтов, первое **слово** содержит U в Лсбс и Y0 в МСБС, а второе **слово** содержит V в лсбс и Y1 в МСБС.

![рис. 4. Макет памяти UYVY](images/yuvformats03.gif)

## <a name="420-formats-16-bits-per-pixel"></a>форматы 4:2:0, 16 бит на пиксель

Рекомендуется использовать два формата: 4:2:0 16 – бит на пиксель (бит в пикселах) с приведенными ниже кодами FOURCC.

-   IMC1
-   IMC3

Оба этих формата YUV имеют плоские форматы. Чрома каналы вычисляются с коэффициентом 2 в горизонтальном и вертикальном измерениях.

### <a name="imc1"></a>IMC1

Все примеры Y отображаются первыми в памяти как массив значений типа **char** без знака. Далее следуют все примеры версии (CR), а затем все примеры U (CB). Плоскости V и U имеют тот же шаг, что и плоскость Y, что приводит к неиспользуемым областям памяти, как показано на рис. 5. Плоскости, которые вы и V должны начать с границ памяти, кратных 16 строкам. На рис. 5 показан источник и V для видеокадра 352 x 240. Начальный адрес плоскостей и плоскости V вычисляется следующим образом:

``` syntax
BYTE* pV = pY + (((Height + 15) & ~15) * Stride);
BYTE* pU = pY + (((((Height * 3) / 2) + 15) & ~15) * Stride);
```

где *корректировка* — это байтовый указатель на начало массива памяти, как показано на следующей схеме.

![рис. 5. Макет памяти imc1 (пример)](images/yuvformats04.gif)

### <a name="imc3"></a>IMC3

Этот формат идентичен IMC1, за исключением того, что вы и V-плоскости меняются, как показано на следующей схеме.

![рис. 6. Макет памяти imc3](images/yuvformats05.gif)

## <a name="420-formats-12-bits-per-pixel"></a>форматы 4:2:0, 12 бит на пиксель

Рекомендуется использовать четыре формата 4:2:0 12-бит с кодами FOURCC:

-   IMC2
-   IMC4
-   YV12
-   NV12

Во всех этих форматах каналы чрома вычисляются с помощью коэффициента 2 в горизонтальном и вертикальном измерениях.

### <a name="imc2"></a>IMC2

Этот формат совпадает с IMC1, за исключением следующего отличия: строки V (CR) и U (CB) чередуются по границам половинного шага. Иными словами, каждая строка с полным шагом в области чрома начинается со строки с примерами V, за которой следуют строки U, которые начинаются со следующей границы половинного шага (рис. 7). Этот макет позволяет более эффективно использовать адресное пространство, чем IMC1. Он вырезает адресное пространство чрома в половину, а значит общее адресное пространство на 25 процентов. В форматах 4:2:0 IMC2 — это второй предпочтительный формат после NV12. Этот процесс показан на следующем рисунке.

![рис. 7. Макет памяти imc2](images/yuvformats07.gif)

### <a name="imc4"></a>IMC4

Этот формат идентичен IMC2, за исключением того, что строки U (CB) и V (CR) меняются местами, как показано на следующем рисунке.

![рис. 8. Макет памяти imc4](images/yuvformats06.gif)

### <a name="yv12"></a>YV12

Все примеры Y отображаются первыми в памяти как массив значений типа **char** без знака. За этим массивом следуют все примеры V (CR). Шаг в плоскости V — половина шага плоскости Y; а плоскость V содержит половину столько же линий, сколько у плоскости Y. В плоскости V сразу идут все примеры U (CB) с тем же шагом и числом строк, что и в плоскости V, как показано на следующем рисунке.

![рис. 9. Макет памяти YV12](images/yuvformats08.gif)

### <a name="nv12"></a>NV12

Все примеры Y отображаются первыми в памяти как массив значений **char** без знака с четным числом строк. За плоскостью Y следует массив значений **char** без знака, содержащий Упакованные примеры U (CB) и V (CR). Если объединенный массив U-V адресован как массив значений **слов** с прямым порядком байтов, лсбс содержит значения U, а МСБС содержит значения V. NV12 — предпочтительный формат 4:2:0 пикселей для DirectX ва. Это должно быть промежуточное требование для ускорителей DirectX, поддерживающих видео 4:2:0. На следующем рисунке показана плоскость Y и массив, которые содержат Упакованные образцы.

![рис. 10. Макет памяти NV12](images/yuvformats09.gif)

## <a name="color-space-and-chroma-sampling-rate-conversions"></a>Цветовое пространство и преобразование частоты выборки Чрома

В этом разделе приводятся рекомендации по преобразованию между YUV и RGB, а также для преобразования между различными форматами YUV. В этом разделе мы рассмотрим две схемы кодирования RGB: *8-разрядный RGB*, также известный как sRGB или RGB с полноэкранным масштабированием, *видео* RGB или "RGB с головным пространством и кабинетом". Они определяются следующим образом.

-   Компьютер RGB использует 8 бит для каждого образца красного, зеленого и синего цветов. Черный представляется R = G = B = 0, а белый представляется R = G = B = 255.
-   В Studio Video RGB используется некоторое количество бит N для каждого образца красного, зеленого и синего, где N — 8 или более. В студии видео RGB используется другой коэффициент масштабирования, отличный от значения RGB компьютера, и он имеет смещение. Черный представляется R = G = B = 16 \* 2 ^ (N-8), а белый представляется r = G = B = 235 \* 2 ^ (N-8). Однако фактические значения могут находиться за пределами этого диапазона.

видео в студии rgb — это предпочтительное определение rgb для видео в Windows, а rgb — предпочтительное определение rgb для приложений, не являющихся видеороликами. В любой форме RGB координаты цветовой области задаются в ITU-R BT. 709 для определения первичных цветов RGB. Координаты (x, y) R, G и B имеют значение (0,64, 0,33), (0,30, 0,60) и (0,15, 0,06) соответственно. Ссылка белого — D65 с координатами (0,3127, 0,3290). Номинальная гамма — 1/0.45 (приблизительно 2,2), с точным определением гаммы в ITU-R BT. 709.

**Преобразование между RGB и 4:4:4 YUV**

Сначала мы рассмотрим преобразование между RGB и 4:4:4 YUV. Чтобы преобразовать 4:2:0 или 4:2:2 YUV в RGB, мы рекомендуем преобразовать данные YUV в 4:4:4 YUV, а затем преобразовать из 4:4:4 YUV в RGB. Формат АЙУВ, который является форматом 4:4:4, использует 8 бит каждый для примеров Y, U и V. YUV можно также определить с помощью более чем 8 бит на выборку для некоторых приложений.

Для цифрового видео были определены два основных преобразования YUV из RGB. Они основаны на спецификации, известной как ITU-R рекомендует BT. 709. Первое преобразование — это старая форма YUV, определенная для использования в 50-Гц в BT. 709. Это то же самое, что и отношение, указанное в рекомендациях ITU-R BT. 601, также известное по старому имени, КЦИР 601. Он должен рассматриваться в качестве предпочтительного формата YUV для стандартного разрешения ТЕЛЕПЕРЕДАЧ (720 x 576) и видео с более низким разрешением. Он характеризуется значениями двух констант *kr* и *KB*:

``` syntax
Kr = 0.299
Kb = 0.114
```

Второе преобразование — это более новая форма YUV, определенная для 60-Гц, используется в BT. 709 и должна считаться предпочтительным форматом для разрешений видео выше СДТВ. Он характеризуется различными значениями для этих двух констант:

``` syntax
Kr = 0.2126
Kb = 0.0722
```

Преобразование из RGB в YUV определяется следующим образом:

``` syntax
L = Kr * R + Kb * B + (1 - Kr - Kb) * G
```

Затем значения YUV получаются следующим образом:

``` syntax
Y =                   floor(2^(M-8) * (219*(L-Z)/S + 16) + 0.5)
U = clip3(0, (2^M)-1, floor(2^(M-8) * (112*(B-L) / ((1-Kb)*S) + 128) + 0.5))
V = clip3(0, (2^M)-1, floor(2^(M-8) * (112*(R-L) / ((1-Kr)*S) + 128) + 0.5))
```

where

-   M — это число битов на каждый пример YUV (M >= 8).
-   Z — это переменная Черного уровня. Для компьютера RGB Z равно 0. Для Video видео RGB Z равно 16 \* 2 ^ (N-8), где N — это число битов на пример RGB (n >= 8).
-   Параметр S является переменной масштабирования. Для компьютеров RGB, S равняется 255. Для Video видео RGB S равняется 219 \* 2 ^ (N-8).

Функция floor (x) возвращает максимальное целое число, которое меньше или равно x. Функция clip3 (x, y, z) определяется следующим образом:

``` syntax
clip3(x, y, z) = ((z < x) ? x : ((z > y) ? y : z))
```

> [!Note]  
> clip3 должен быть реализован как функция, а не как макрос препроцессора; в противном случае возникнет несколько оценок аргументов.

 

Пример «Y» представляет яркость, а примеры «вы» и «V» представляют цветовые отклонения в направлении синего и Красного соответственно. Номинальный диапазон для Y — 16 \* 2 ^ (m-8) до 235 \* 2 ^ (m-8). Черный представляется как 16 \* 2 ^ (m-8), а белый представляется как 235 \* 2 ^ (m-8). Номинальный диапазон для вас и V — 16 \* 2 ^ (m-8) до 240 \* 2 ^ (m-8), со значением 128 \* 2 ^ (m-8), представляющим нейтральный чрома. Однако фактические значения могут находиться за пределами этих диапазонов.

Для входных данных в виде видео RGB в Studio необходимо выполнить операцию Clip, чтобы сохранить значения для вас и V в диапазоне от 0 до (2 ^ M) – 1. Если входными данными является компьютер RGB, операция Clip не требуется, поскольку формула преобразования не может формировать значения за пределами этого диапазона.

Это точные формулы без аппроксимации. Все, что следует за этим документом, является производным от этих формул. В этом разделе рассматриваются следующие преобразования.

-   [Преобразование RGB888 в YUV 4:4:4](#converting-rgb888-to-yuv-444)
-   [Преобразование 8-разрядного YUV в RGB888](#converting-8-bit-yuv-to-rgb888)
-   [Преобразование 4:2:0 YUV в 4:2:2 YUV](#converting-420-yuv-to-422-yuv)
-   [Преобразование 4:2:2 YUV в 4:4:4 YUV](#converting-422-yuv-to-444-yuv)
-   [Преобразование 4:2:0 YUV в 4:4:4 YUV](#converting-420-yuv-to-444-yuv)

## <a name="converting-rgb888-to-yuv-444"></a>Преобразование RGB888 в YUV 4:4:4

В случае входных данных RGB и 8-разрядных выходных данных BT. 601 YUV мы считаем, что формулы, приведенные в предыдущем разделе, могут быть примерно приблизительно ниже:

``` syntax
Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
```

Эти формулы создают 8-разрядные результаты с использованием коэффициентов, для которых требуется не более 8 разрядов (без знака). Промежуточные результаты должны иметь до 16 бит точности.

## <a name="converting-8-bit-yuv-to-rgb888"></a>Преобразование 8-разрядного YUV в RGB888

Исходя из исходных формул RGB-YUV, один из них может наследовать следующие связи для BT. 601.

``` syntax
Y = round( 0.256788 * R + 0.504129 * G + 0.097906 * B) +  16 
U = round(-0.148223 * R - 0.290993 * G + 0.439216 * B) + 128
V = round( 0.439216 * R - 0.367788 * G - 0.071427 * B) + 128
```

Поэтому, учитывая следующее:

``` syntax
C = Y - 16
D = U - 128
E = V - 128
```

формулы для преобразования YUV в RGB могут быть производными следующим образом:

``` syntax
R = clip( round( 1.164383 * C                   + 1.596027 * E  ) )
G = clip( round( 1.164383 * C - (0.391762 * D) - (0.812968 * E) ) )
B = clip( round( 1.164383 * C +  2.017232 * D                   ) )
```

где `clip()` обозначает обрезку диапазона \[ 0.. 255 \] . Мы считаем, что эти формулы могут быть достаточно приблизительными по следующему адресу:

``` syntax
R = clip(( 298 * C           + 409 * E + 128) >> 8)
G = clip(( 298 * C - 100 * D - 208 * E + 128) >> 8)
B = clip(( 298 * C + 516 * D           + 128) >> 8)
```

В этих формулах используются некоторые коэффициенты, для которых требуется более 8 бит точности для создания каждого 8-разрядного результата, а для промежуточных результатов потребуется более 16 разрядов точности.

Чтобы преобразовать 4:2:0 или 4:2:2 YUV в RGB, мы рекомендуем преобразовать данные YUV в 4:4:4 YUV, а затем преобразовать из 4:4:4 YUV в RGB. В последующих разделах представлены некоторые методы преобразования форматов 4:2:0 и 4:2:2 в 4:4:4.

## <a name="converting-420-yuv-to-422-yuv"></a>Преобразование 4:2:0 YUV в 4:2:2 YUV

Преобразование 4:2:0 YUV в 4:2:2 YUV требует вертикального преобразования с коэффициентом 2. В этом разделе описывается пример метода для выполнения преобразования. В методе предполагается, что видеоролики находятся в виде последовательного сканирования.

> [!Note]  
> В процессе преобразования просмотра с 4:2:0 по 4:2:2 возникают нетипичные проблемы, которые трудно реализовать. В этой статье не рассматриваются проблемы преобразования с чередованием развертки с 4:2:0 на 4:2:2.

 

Позвольте, чтобы каждая вертикальная строка входных образцов чрома была массивом `Cin[]` в диапазоне от 0 до N – 1. Соответствующая вертикальная линия на выходном изображении будет массивом в `Cout[]` диапазоне от 0 до 2n-1. Чтобы преобразовать каждую вертикальную линию, выполните следующую процедуру:

``` syntax
Cout[0]     = Cin[0];
Cout[1]     = clip((9 * (Cin[0] + Cin[1]) - (Cin[0] + Cin[2]) + 8) >> 4);
Cout[2]     = Cin[1];
Cout[3]     = clip((9 * (Cin[1] + Cin[2]) - (Cin[0] + Cin[3]) + 8) >> 4);
Cout[4]     = Cin[2]
Cout[5]     = clip((9 * (Cin[2] + Cin[3]) - (Cin[1] + Cin[4]) + 8) >> 4);
...
Cout[2*i]   = Cin[i]
Cout[2*i+1] = clip((9 * (Cin[i] + Cin[i+1]) - (Cin[i-1] + Cin[i+2]) + 8) >> 4);
...
Cout[2*N-3] = clip((9 * (Cin[N-2] + Cin[N-1]) - (Cin[N-3] + Cin[N-1]) + 8) >> 4);
Cout[2*N-2] = Cin[N-1];
Cout[2*N-1] = clip((9 * (Cin[N-1] + Cin[N-1]) - (Cin[N-2] + Cin[N-1]) + 8) >> 4);
```

где Clip () обозначает обрезание до диапазона \[ 0.. 255 \] .

> [!Note]  
> Уравнения для обработки границ могут быть математически упрощены. Они показаны в этой форме, чтобы проиллюстрировать эффект фиксации на краях изображения.

 

По сути, этот метод вычисляет каждое отсутствующее значение путем интерполяции кривой по четырем соседним пикселям, с взвешенным приближением к значениям двух ближайших пикселов (рис. 11). Конкретный метод интерполяции, используемый в этом примере, создает отсутствующие примеры на позициях половинного целого числа с помощью хорошо известного метода, именуемого Catmull-Rom интерполяции, также известного как интерполяция свертки в кубических выпусках.

![рис. 11. на схеме показана выборка с 4:2:0 до 4:2:2](images/yuvformats14.gif)

В терминах обработки сигнала вертикальное преобразование в идеале должно включать в себя компенсацию сдвига на шаг с учетом вертикального смещения (относительно сетки выборке 4:2:2) между расположениями образцов 4:2:0 и расположением всех остальных образцов 4:2:2. Однако введение этого смещения приведет к увеличению объема обработки, необходимого для создания образцов, и сделает невозможным восстановление исходных образцов 4:2:0 из изображения с изображением 4:2:2. Это также сделает невозможным декодирование видео непосредственно в поверхности 4:2:2, а затем использовать эти поверхности как справочные рисунки для декодирования последующих изображений в потоке. Таким образом, предоставленный здесь метод не учитывает точное вертикальное выравнивание образцов. Это, вероятно, не является визуально вредоносным при достаточно высоком разрешении рисунков.

Если вы начинаете с 4:2:0 видео, которое использует сетку выборки, определенную в видео H. 261, H. 263 или MPEG-1, фаза выводимых 4:2:2 чрома также будет смещена по горизонталому смещению на половину пикселя относительно расстояния в сетке выборки яркости (смещение в четвертом пикселе относительно интервала в сетке выборки 4:2:2 чрома). Тем не менее, формат MPEG-2 видео 4:2:0, скорее всего, более широко используется на компьютерах и не страдает от этой проблемы. Более того, различие, вероятно, не является визуально вредоносным при достаточно высоком разрешении рисунков. Попытка исправить эту проблему вызовет те же проблемы, которые обсуждаются для вертикального смещения.

## <a name="converting-422-yuv-to-444-yuv"></a>Преобразование 4:2:2 YUV в 4:4:4 YUV

Преобразование 4:2:2 YUV в 4:4:4 YUV требует горизонтального преобразования с коэффициентом 2. Метод, описанный ранее для вертикального преобразования, можно также применить к горизонтальному преобразованию. Для видео MPEG-2 и ITU-R BT. 601 этот метод будет создавать образцы с правильным выравниванием этапа.

## <a name="converting-420-yuv-to-444-yuv"></a>Преобразование 4:2:0 YUV в 4:4:4 YUV

Чтобы преобразовать 4:2:0 YUV в 4:4:4 YUV, можно просто выполнить два описанных выше метода. Преобразуйте образ 4:2:0 в 4:2:2, а затем преобразуйте образ 4:2:2 в 4:4:4. Можно также переключить порядок двух процессов преобразования, так как порядок операций не имеет значения для визуального качества результата.

## <a name="other-yuv-formats"></a>Другие форматы YUV

Ниже приведены некоторые другие, менее распространенные форматы YUV.

-   AI44 — это формат палеттизед YUV с 8 битами на выборку. Каждый пример содержит индекс в 4 наиболее значимых битах (МСБС) и альфа-значение в 4 самых значимых битах (Лсбс). Индекс ссылается на массив записей в палитре YUV, который должен быть определен в типе мультимедиа для формата. Этот формат в основном используется для изображений подизображений.
-   NV11 имеет формат 4:1:1 с 12 битами на пиксель. Примеры Y отображаются в памяти первыми. За плоскостью Y следует массив из упакованных образцов U (CB) и V (CR). Если комбинированный массив U-V адресован как массив значений **слов** с прямым порядком байтов, примеры U содержатся в Лсбс каждого **слова**, а примеры V содержатся в МСБС. (Эта структура памяти похожа на NV12, хотя выборка чрома отличается.)
-   Y41P является упакованным форматом 4:1:1, где каждый четвертый пиксел по горизонтали выдается в один и тот же интервал. Каждый макропиксел содержит 8 пикселей в трех байтах и следующий формат байта: `U0 Y0 V0 Y1    U4 Y2 V4 Y3    Y4 Y5 Y6 Y7`
-   Y41T идентичен Y41P, за исключением наименее значимого бита каждого из значений Y указывает ключ чрома (0 = прозрачный, 1 = непрозрачный).
-   Y42T идентичен UYVY, за исключением наименее значимого бита каждого из значений Y указывает ключ чрома (0 = прозрачный, 1 = непрозрачный).
-   ИВЮ эквивалентен ЮИВ, за исключением случаев, когда вы и V переключаются между примерами.

## <a name="identifying-yuv-formats-in-media-foundation"></a>Определение форматов YUV в Media Foundation

Каждый из форматов YUV, описанных в этой статье, имеет назначенный код FOURCC. Код FOURCC — это 32-разрядное целое число без знака, которое создается путем сцепления четырех символов ASCII.

Существуют различные макросы C/C++, упрощающие объявление значений FOURCC в исходном коде. Например, макрос **макефауркк** объявляется в ммсистем. h, а макрос **FCC** объявляется в авирифф. h. Используйте их следующим образом:

``` syntax
DWORD fccYUY2 = MAKEFOURCC('Y','U','Y','2');
DWORD fccYUY2 = FCC('YUY2');
```

Кроме того, можно объявить код FOURCC непосредственно в виде строкового литерала, просто отменив порядок символов. Например:

``` syntax
DWORD fccYUY2 = '2YUY';  // Declares the FOURCC 'YUY2'
```

обратный порядок необходим, так как операционная система Windows использует архитектуру с прямым порядком байтов. ' Y ' = 0x59, ' U ' = 0x55, и ' 2 ' = 0x32, поэтому ' 2YUY ' является 0x32595559.

В Media Foundation форматы идентифицируются по идентификатору GUID основного типа и идентификатору GUID подтипа. Основной тип видеоформатов компьютера всегда Мфмедиатипе \_ видео. Подтип может быть создан путем сопоставления кода FOURCC с идентификатором GUID, как показано ниже:

``` syntax
XXXXXXXX-0000-0010-8000-00AA00389B71 
```

где `XXXXXXXX` — код FourCC. Таким образом, идентификатор GUID подтипа для YUY2:

``` syntax
32595559-0000-0010-8000-00AA00389B71 
```

Константы для наиболее распространенных идентификаторов GUID формата YUV определены в файле заголовка мфапи. h. Список этих констант см. в разделе [GUID подтипа видео](video-subtype-guids.md).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Видео о YUV](about-yuv-video.md)
</dt> <dt>

[Типы видеоклипов](video-media-types.md)
</dt> </dl>

 

 



