---
title: Различия между MIDL и MkTypLib
description: Различия между MIDL и MkTypLib
ms.assetid: 86abd70b-7238-49a6-a996-2c8906a14449
keywords:
- MIDL и ODL MIDL, различия между MIDL и MkTypLib
- MkTypLib MIDL
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 43ae20e00dab492a140f48c9de683abeac04676824bd6513ccf086889b4460e8
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118643628"
---
# <a name="differences-between-midl-and-mktyplib"></a>Различия между MIDL и MkTypLib

> [!Note]  
> Средство Mktyplib.exe устарело. Вместо этого используйте компилятор MIDL.

 

Существует несколько ключевых областей, в которых компилятор MIDL отличается от MkTypLib. Большая часть этих различий возникает, поскольку MIDL ориентирован более в сторону C-синтаксиса, чем MkTypLib.

В общем случае вам потребуется использовать синтаксис MIDL в IDL-файлах. Однако если необходимо скомпилировать существующий файл ODL или иным образом поддерживать совместимость с MkTypLib, используйте параметр компилятора [**/Mktyplib203**](-mktyplib203.md) MIDL, чтобы заставить MIDL вести себя так же, как Mkktyplib.exe, версия 2,03. (Это последний выпуск средства MkTypLib.) В частности, параметр **/mktyplib203** разрешает следующие различия:

-   синтаксис typedef для сложных типов данных

    В MkTypLib оба следующих определения создают \_ запись ткинд для "этой \_ структуры" в библиотеке типов. Тег "тег структуры \_ " является необязательным и, если он используется, не будет отображаться в библиотеке типов.

    ``` syntax
    typedef struct struct_tag { ... } this_struct;
    typedef struct { ... } that_struct;
    ```

    Если отсутствует дополнительный тег, MIDL создаст его, фактически добавив тег к определению, предоставленному пользователем. Поскольку первое определение содержит тег, MIDL создает \_ запись ткинд для "этой \_ структуры" и \_ псевдоним ткинд для "этой \_ структуры" (определяя "эту \_ структуру" в качестве псевдонима для "тега структуры" \_ ). Так как тег отсутствует во втором определении, MIDL создает \_ запись ткинд для искаженного имени, internal для MIDL, которая не имеет смысла для пользователя и \_ псевдонима ткинд для "этой \_ структуры".

    Это имеет потенциальные последствия для браузеров библиотек типов, которые просто отображают имя записи в пользовательском интерфейсе. Если предполагается, что \_ запись ткинд имеет реальное имя, нераспознаваемые имена могут появиться в пользовательском интерфейсе. Это поведение также применяется к определениям [**Union**](union.md) и [**enum**](enum.md) , при этом компилятор MIDL создает ткинд \_ объединения и \_ перечисления ткинд соответственно.

    MIDL также допускает определения [**структуры**](struct.md), [**объединения**](union.md)и [**перечисления**](enum.md) в стиле C. Например, следующее определение является допустимым в MIDL:

    ``` syntax
    struct my_struct { ... };
    typedef struct my_struct your_struct;
    ```

-   Логические типы данных

    В MkTypLib логический тип [**Boolean**](boolean.md) и тип данных MkTypLib bool эквивалентны логическому типу VT \_ , который СОПОСТАВЛЯЕТСЯ с типом Variant \_ bool, который определен как [**короткий**](short.md). В MIDL базовый тип **Boolean** эквивалентен VT \_ UI1, который определен как [**символ без знака**](unsigned.md), а тип данных bool определен как [**Long**](long.md). Это приводит к проблемам при использовании синтаксиса IDL и синтаксиса ODL в одном и том же файле и при этом пытаются обеспечить совместимость с MkTypLib. Поскольку типы данных имеют разные размеры, код маршалирования не будет соответствовать описанию в сведениях о типе. Если требуется логическое значение VT \_ в библиотеке типов, следует использовать \_ тип данных Variant bool.

-   Определения GUID в файлах заголовков

    В MkTypLib идентификаторы GUID определяются в файле заголовка с помощью макроса, который может быть условно скомпилирован для создания либо предварительного определения GUID, либо экземпляра GUID. MIDL обычно помещает в создаваемые файлы заголовков определения GUID и создает экземпляры GUID только в файле, созданном с помощью параметра [**/IID**](-iid.md) .

Следующие различия в поведении не могут быть разрешены с помощью параметра [**/mktyplib203**](-mktyplib203.md) :

-   Чувствительность к регистру

    MIDL учитывает регистр, а OLE Automation — нет.

-   Область символов в объявлении перечисления

    В MkTypLib область действия символов в перечислении является локальной. В MIDL область символов в перечислении является глобальной, как и в C. Например, следующий код будет компилироваться в MkTypLib, но создаст ошибку повторяющегося имени в MIDL:

    ``` syntax
    typedef struct { ... } a;
    enum {a=1, b=2, c=3};
    ```

-   Область видимости открытого атрибута

    При применении атрибута [**Public**](public.md) к блоку интерфейса MkTypLib обрабатывает каждое определение типа в этом блоке интерфейса как общедоступное. Для языка MIDL необходимо явно применить атрибут **Public** к этим определениям типов, которые должны быть общедоступными.

-   Importlib порядок поиска

    Если импортируется более одной библиотеки типов, и если эти библиотеки содержат дублирующиеся ссылки, MkTypLib разрешает это с помощью первой найденной ссылки. MIDL будет использовать последнюю найденную ссылку. Например, при использовании приведенного ниже синтаксиса ODL библиотека C будет использовать МУУУ typedef из библиотеки а, если компиляция выполняется с помощью MkTypLib, а МУУУ typedef из библиотеки B, если компиляция выполняется с помощью MIDL:

    ``` syntax
    [...]library A
    {
        typedef struct tagMOO
        {...}MOO
    }

    [...]library B
    {
        typedef struct tagMOO
        {...} MOO
    }

    [...]library C
    {
        importlib (A.TLB)
        importlib (B.TLB)
        typedef struct tagBAA
        {MOO y;}BAA
    }
    ```

    Чтобы устранить эту проблему, необходимо уточнить каждую из этих ссылок, указав правильное имя библиотеки импорта, например:

    ``` syntax
    typedef struct tagBAA
        {A.MOO y;}BAA
    ```

-   Тип данных VOID не распознан

    MIDL распознает тип данных [**void**](void.md) C-Language и не распознает тип данных OLE Automation void. Если у вас есть ODL файл, использующий VOID, поместите это определение в начало файла:

    ``` syntax
#define VOID void
    ```

-   Экспоненциальная нотация

    MIDL требует, чтобы значения, выраженные в экспоненциальной нотации, содержались в кавычках. Например, "-2.5 E + 3"

-   Значения и константы LCID

    Обычно MIDL не учитывает код языка при синтаксическом анализе файлов. Чтобы принудительно применить это поведение к значению или при определении константы необходимо использовать нотацию определенного языкового стандарта, заключите значение или константу в кавычки.

Дополнительные сведения см. в разделе [**/mktyplib203**](-mktyplib203.md), [**/IID**](-iid.md)и [маршалирование типов данных OLE](marshaling-ole-data-types.md).

 

 




