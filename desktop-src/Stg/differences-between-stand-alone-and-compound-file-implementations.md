---
title: Различия между реализацией изолированного и составного файла
description: Изолированная реализация интерфейсов набора свойств и реализации составного файла в некоторых случаях различаются.
ms.assetid: 650d4759-a58a-47a4-922d-5757e356cf56
keywords:
- Ипропертистораже Стрктд STG, реализации
- Ипропертистораже Стрктд STG, реализации, различия
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 988f8a9cfdaca0a131bedf98cd8ff10ae8b89525
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "103888183"
---
# <a name="differences-between-stand-alone-and-compound-file-implementations"></a><span data-ttu-id="310fd-105">Различия между реализацией изолированного и составного файла</span><span class="sxs-lookup"><span data-stu-id="310fd-105">Differences between Stand-alone and Compound File Implementations</span></span>

<span data-ttu-id="310fd-106">Изолированная реализация интерфейсов набора свойств и реализации составного файла в некоторых случаях различаются.</span><span class="sxs-lookup"><span data-stu-id="310fd-106">The stand-alone implementation of the property set interfaces and the compound file implementation differ in some ways.</span></span> <span data-ttu-id="310fd-107">В реализации составных файлов в потоке, хранилище, хранилище наборов свойств и объектах хранилища свойств различные интерфейсы координируются друг с другом, так как они совместно используют общую реализацию.</span><span class="sxs-lookup"><span data-stu-id="310fd-107">In the compound-file implementation of stream, storage, property set storage, and property storage objects, the various interfaces coordinate with each another because they share a common implementation.</span></span> <span data-ttu-id="310fd-108">В изолированной реализации реализации интерфейса отличаются.</span><span class="sxs-lookup"><span data-stu-id="310fd-108">In the stand-alone implementation, the interface implementations are distinct.</span></span>

<span data-ttu-id="310fd-109">В результате реализация составного файла обрабатывает проблемы параллелизма и синхронизирует объект набора свойств с объектом хранилища или потока.</span><span class="sxs-lookup"><span data-stu-id="310fd-109">As a result, the compound-file implementation handles concurrency issues and synchronizes the property set object with the storage or stream object.</span></span> <span data-ttu-id="310fd-110">В изолированной реализации клиент отвечает за обработку проблем параллелизма и синхронизации между объектом хранилища или потока и набором свойств.</span><span class="sxs-lookup"><span data-stu-id="310fd-110">With the stand-alone implementation, the client is responsible for handling concurrency and synchronization issues between the storage or stream object and the property set.</span></span> <span data-ttu-id="310fd-111">Клиент может удовлетворить эти требования, выполнив два простых правила.</span><span class="sxs-lookup"><span data-stu-id="310fd-111">A client can meet these requirements by following two simple rules.</span></span> <span data-ttu-id="310fd-112">Во-первых, никогда не следует манипулировать набором свойств с помощью потока или интерфейсов хранилища, пока на нем открыт объект хранилища свойств.</span><span class="sxs-lookup"><span data-stu-id="310fd-112">First, never manipulate a property set using its stream or storage interfaces while a property storage object is open on it.</span></span> <span data-ttu-id="310fd-113">Во-вторых, всегда вызывайте **commit** для объекта хранилища свойств перед вызовом **CopyTo**, **мовилементто** или **commit** в объекте хранилища предка.</span><span class="sxs-lookup"><span data-stu-id="310fd-113">Second, always call **Commit** on a property storage object before calling **CopyTo**, **MoveElementTo**, or **Commit** on an ancestor storage object.</span></span> <span data-ttu-id="310fd-114">В частности, для следующих элементов требуется вмешательство клиента:</span><span class="sxs-lookup"><span data-stu-id="310fd-114">Specifically, the following items require client attention:</span></span>

-   <span data-ttu-id="310fd-115">В реализации составных файлов один механизм обеспечивает защиту параллелизма для объекта хранилища и связанных с ним объектов свойств.</span><span class="sxs-lookup"><span data-stu-id="310fd-115">In the compound-file implementation, a single mechanism provides concurrency protection for the storage object and its associated property set objects.</span></span> <span data-ttu-id="310fd-116">Однако в изолированной реализации реализация объекта хранилища отделена от реализации набора свойств, и каждый из них предоставляет собственные механизмы параллелизма.</span><span class="sxs-lookup"><span data-stu-id="310fd-116">However, in the stand-alone implementation, the storage object implementation is separate from the property set implementation and each provides its own concurrency mechanisms.</span></span> <span data-ttu-id="310fd-117">Таким способом, в изолированной реализации клиент отвечает за поддержку защиты параллелизма между двумя реализациями посредством механизма взаимного исключения.</span><span class="sxs-lookup"><span data-stu-id="310fd-117">Thus, in the stand-alone implementation, the client is responsible for maintaining concurrency protection between the two implementations through a mechanism of mutual exclusion.</span></span>
-   <span data-ttu-id="310fd-118">В реализации составного файла изменения в наборах свойств буферизуются в кэше, заданном свойством.</span><span class="sxs-lookup"><span data-stu-id="310fd-118">In the compound file implementation, changes to property sets are buffered in a property-set cache.</span></span> <span data-ttu-id="310fd-119">Затем, когда метод [**IStorage:: Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) вызывается для объекта хранилища, реализация составных файлов автоматически сбрасывает изменения набора свойств из буфера набора свойств до фиксации объекта хранилища.</span><span class="sxs-lookup"><span data-stu-id="310fd-119">Then, when the [**IStorage::Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) method is called on the storage object, the compound files implementation automatically flushes the property-set changes from the property-set buffer before the storage object is committed.</span></span> <span data-ttu-id="310fd-120">Таким образом, изменения, внесенные в набор свойств, становятся видимыми в процессе фиксации транзакции.</span><span class="sxs-lookup"><span data-stu-id="310fd-120">Thus, the property-set changes are made visible as part of the transaction being committed.</span></span>

    <span data-ttu-id="310fd-121">В изолированной реализации клиент должен явным образом очистить буфер набора свойств, вызвав [**ипропертистораже:: Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) перед вызовом метода [**IStorage:: Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) в хранилище.</span><span class="sxs-lookup"><span data-stu-id="310fd-121">In the stand-alone implementation, the client must explicitly flush the property-set buffer by calling [**IPropertyStorage::Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) before calling the [**IStorage::Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) method on the storage.</span></span> <span data-ttu-id="310fd-122">Кроме того, клиент может использовать новое ПРОПСЕТФЛАГ \_ значение без буферизации в изолированной реализации для записи непосредственно в набор свойств вместо кэширования изменений во внутреннем буфере набора свойств.</span><span class="sxs-lookup"><span data-stu-id="310fd-122">Alternatively, the client can use the new PROPSETFLAG\_UNBUFFERED value in the stand-alone implementation to write directly to the property set instead of caching changes to the property set's internal buffer.</span></span> <span data-ttu-id="310fd-123">Если используется ПРОПСЕТФЛАГ без \_ буферизации, обязанности клиента выполняются автоматически.</span><span class="sxs-lookup"><span data-stu-id="310fd-123">If PROPSETFLAG\_UNBUFFERED is used, the client's responsibilities are automatically met.</span></span> <span data-ttu-id="310fd-124">Реализация составного файла не поддерживает значение ПРОПСЕТФЛАГ без \_ буферизации.</span><span class="sxs-lookup"><span data-stu-id="310fd-124">The compound file implementation does not support the PROPSETFLAG\_UNBUFFERED value.</span></span> <span data-ttu-id="310fd-125">Дополнительные сведения см. в разделе [**константы пропсетфлаг**](propsetflag-constants.md).</span><span class="sxs-lookup"><span data-stu-id="310fd-125">For more information, see [**PROPSETFLAG Constants**](propsetflag-constants.md).</span></span>

-   <span data-ttu-id="310fd-126">Как и в случае с транзакционными хранилищами, реализация составного файла обновляет набор свойств путем очистки его внутреннего буфера перед выполнением вызова метода [**IStorage:: CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) или [**IStorage:: мовилементто**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span><span class="sxs-lookup"><span data-stu-id="310fd-126">As with transacted storages, the compound file implementation updates the property set by flushing its internal buffer before executing a call to [**IStorage::CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) or [**IStorage::MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span></span> <span data-ttu-id="310fd-127">Поэтому изменения в наборе свойств отражаются в скопированном или перемещенном элементе Storage.</span><span class="sxs-lookup"><span data-stu-id="310fd-127">Thus, changes to the property set are reflected in the copied or moved storage element.</span></span>

    <span data-ttu-id="310fd-128">В изолированной реализации клиент должен явным образом очистить буфер набора свойств путем вызова [**ипропертистораже:: Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) перед вызовом [**IStorage:: CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) или [**IStorage:: мовилементто**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span><span class="sxs-lookup"><span data-stu-id="310fd-128">In the stand-alone implementation, the client must explicitly flush the property set buffer by calling [**IPropertyStorage::Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) before calling [**IStorage::CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) or [**IStorage::MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span></span> <span data-ttu-id="310fd-129">Кроме того, клиент может использовать новое ПРОПСЕТФЛАГ \_ значение без буферизации для записи непосредственно в набор свойств вместо кэширования изменений в буфере набора свойств.</span><span class="sxs-lookup"><span data-stu-id="310fd-129">Alternatively, the client can use the new PROPSETFLAG\_UNBUFFERED value to write directly to the property set instead of caching changes to the property set buffer.</span></span> <span data-ttu-id="310fd-130">Дополнительные сведения см. в разделе [**константы пропсетфлаг**](propsetflag-constants.md).</span><span class="sxs-lookup"><span data-stu-id="310fd-130">For more information, see [**PROPSETFLAG Constants**](propsetflag-constants.md).</span></span>

 

 




