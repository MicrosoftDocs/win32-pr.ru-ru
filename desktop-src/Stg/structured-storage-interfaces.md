---
title: Структурированные интерфейсы хранения
description: Структурированные службы хранилища организованы в три категории интерфейсов.
ms.assetid: a4281f07-eae4-4bcb-8d16-b6c0bd3c5b21
keywords:
- Структурированные интерфейсы хранения
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0010a0d4dec4908111c8a5bb939f795f0a2b2eb3
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "105661750"
---
# <a name="structured-storage-interfaces"></a><span data-ttu-id="bace9-104">Структурированные интерфейсы хранения</span><span class="sxs-lookup"><span data-stu-id="bace9-104">Structured Storage Interfaces</span></span>

<span data-ttu-id="bace9-105">Структурированные службы хранилища организованы в три категории [интерфейсов](interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="bace9-105">Structured Storage services are organized into three categories of [interfaces](interfaces.md).</span></span> <span data-ttu-id="bace9-106">Каждый набор представляет последовательный уровень косвенного обращения или абстракции между составным файлом, содержащимся в нем объектами и физическим носителем, в котором хранятся эти отдельные компоненты.</span><span class="sxs-lookup"><span data-stu-id="bace9-106">Each set represents a successive level of indirection or abstraction between a compound file, the objects it contains, and the physical media in which these individual components are stored.</span></span>

<span data-ttu-id="bace9-107">Первая категория интерфейсов состоит из [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage), [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream)и [**ирутстораже**](/windows/desktop/api/Objidl/nn-objidl-irootstorage).</span><span class="sxs-lookup"><span data-stu-id="bace9-107">The first category of interfaces consists of [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage), [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream), and [**IRootStorage**](/windows/desktop/api/Objidl/nn-objidl-irootstorage).</span></span> <span data-ttu-id="bace9-108">Первые два интерфейса определяют, как объекты хранятся в составном файле.</span><span class="sxs-lookup"><span data-stu-id="bace9-108">The first two interfaces define how objects are stored within a compound file.</span></span> <span data-ttu-id="bace9-109">Эти интерфейсы предоставляют методы для открытия элементов хранилища, фиксации и возврата изменений, копирования и перемещения элементов, а затем чтения и записи потоков.</span><span class="sxs-lookup"><span data-stu-id="bace9-109">These interfaces provide methods for opening storage elements, committing and reverting changes, copying and moving elements, and reading and writing streams.</span></span> <span data-ttu-id="bace9-110">Эти интерфейсы не распознают собственные форматы данных отдельных объектов и, следовательно, не имеют методов для сохранения этих объектов в постоянное хранилище.</span><span class="sxs-lookup"><span data-stu-id="bace9-110">These interfaces do not recognize the native data formats of the individual objects and therefore have no methods for saving those objects to persistent storage.</span></span> <span data-ttu-id="bace9-111">Интерфейс **ирутстораже** имеет один метод для связывания составного документа с базовым именем файловой системы.</span><span class="sxs-lookup"><span data-stu-id="bace9-111">The **IRootStorage** interface has a single method for associating a compound document with an underlying file system name.</span></span> <span data-ttu-id="bace9-112">Клиенты должны реализовать эти интерфейсы для их составных файлов.</span><span class="sxs-lookup"><span data-stu-id="bace9-112">Clients must implement these interfaces for their compound files.</span></span>

<span data-ttu-id="bace9-113">Вторая категория интерфейсов состоит из интерфейсов [**IPersist**](/windows/win32/api/objidl/nn-objidl-ipersist) , которые реализуются объектами для управления их постоянными данными.</span><span class="sxs-lookup"><span data-stu-id="bace9-113">The second category of interfaces consists of the [**IPersist**](/windows/win32/api/objidl/nn-objidl-ipersist) interfaces, which objects implement to manage their persistent data.</span></span> <span data-ttu-id="bace9-114">Эти интерфейсы предоставляют методы для чтения форматов данных отдельных объектов и, следовательно, их хранения.</span><span class="sxs-lookup"><span data-stu-id="bace9-114">These interfaces provide methods to read the data formats of individual objects and therefore know how to store them.</span></span> <span data-ttu-id="bace9-115">Объекты отвечают за реализацию этих интерфейсов, так как клиенты не узнают собственные форматы данных своих вложенных объектов.</span><span class="sxs-lookup"><span data-stu-id="bace9-115">Objects are responsible for implementing these interfaces because clients do not know the native data formats of their nested objects.</span></span> <span data-ttu-id="bace9-116">Однако эти интерфейсы не имеют сведений о конкретном носителе физического хранилища.</span><span class="sxs-lookup"><span data-stu-id="bace9-116">These interfaces, however, have no knowledge of specific physical storage media.</span></span>

<span data-ttu-id="bace9-117">Третья категория состоит из одного интерфейса [**ILockBytes**](/windows/desktop/api/Objidl/nn-objidl-ilockbytes), который предоставляет методы для записи файлов на конкретный физический носитель, например жесткий диск или ленточный накопитель.</span><span class="sxs-lookup"><span data-stu-id="bace9-117">A third category consists of a single interface, [**ILockBytes**](/windows/desktop/api/Objidl/nn-objidl-ilockbytes), which provides methods for writing files to specific physical media, such as a hard disk or tape drive.</span></span> <span data-ttu-id="bace9-118">Однако большинство приложений не будут реализовывать интерфейс **ILockBytes** , так как com уже предоставляет реализации для двух наиболее распространенных ситуаций, которые являются реализацией на основе файлов и реализацией на основе памяти.</span><span class="sxs-lookup"><span data-stu-id="bace9-118">However, most applications will not implement the **ILockBytes** interface because COM already provides implementations for the two most common situations, which are File-based implementation and Memory-based implementation.</span></span> <span data-ttu-id="bace9-119">Объект хранилища составных файлов вызывает методы **ILockBytes** , которые не вызываются напрямую в реализации.</span><span class="sxs-lookup"><span data-stu-id="bace9-119">The compound file storage object calls the **ILockBytes** methods you do not call them directly in the implementation.</span></span>

## <a name="compound-file-implementation-limits"></a><span data-ttu-id="bace9-120">Ограничения реализации составных файлов</span><span class="sxs-lookup"><span data-stu-id="bace9-120">Compound File Implementation Limits</span></span>

<span data-ttu-id="bace9-121">Реализация структурированной архитектуры хранилища COM называется *составными файлами*.</span><span class="sxs-lookup"><span data-stu-id="bace9-121">The COM implementation of Structured Storage architecture is called *compound files*.</span></span> <span data-ttu-id="bace9-122">Объекты хранилища, реализованные в составных файлах, включают реализацию интерфейсов [**ипропертистораже**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) и [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) .</span><span class="sxs-lookup"><span data-stu-id="bace9-122">Storage objects, as implemented in compound files, include an implementation of the [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) and [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) interfaces.</span></span>

<span data-ttu-id="bace9-123">Указатели на реализацию составных файлов этих интерфейсов получаются путем вызова функции [**стгкреатесторажеекс**](/windows/desktop/api/coml2api/nf-coml2api-stgcreatestorageex) для создания нового объекта составного файла или [**стгопенсторажеекс**](/windows/desktop/api/coml2api/nf-coml2api-stgopenstorageex) для открытия ранее созданного составного файла.</span><span class="sxs-lookup"><span data-stu-id="bace9-123">Pointers to the compound file implementation of these interfaces are acquired by calling the [**StgCreateStorageEx**](/windows/desktop/api/coml2api/nf-coml2api-stgcreatestorageex) function to create a new compound file object, or [**StgOpenStorageEx**](/windows/desktop/api/coml2api/nf-coml2api-stgopenstorageex) to open a previously created compound file.</span></span>

<span data-ttu-id="bace9-124">Альтернативный способ получения указателя на реализацию составного файла этих интерфейсов заключается в вызове более старой и более ограниченной функции [**стгкреатедокфиле**](/windows/desktop/api/coml2api/nf-coml2api-stgcreatedocfile) или [**стгопенстораже**](/windows/desktop/api/coml2api/nf-coml2api-stgopenstorage) .</span><span class="sxs-lookup"><span data-stu-id="bace9-124">An alternative method for acquiring a pointer to the compound file implementation of these interfaces is by calling the older and more limited [**StgCreateDocfile**](/windows/desktop/api/coml2api/nf-coml2api-stgcreatedocfile) or [**StgOpenStorage**](/windows/desktop/api/coml2api/nf-coml2api-stgopenstorage) function.</span></span> <span data-ttu-id="bace9-125">Все четыре функции обрабатываются как реализации составных файлов.</span><span class="sxs-lookup"><span data-stu-id="bace9-125">All four functions are treated as compound file implementations.</span></span>

<span data-ttu-id="bace9-126">Реализация составного файла может быть настроена на использование секторов 512 или 4096 байт, как определено в структуре [**стгоптионс**](/windows/win32/api/coml2api/ns-coml2api-stgoptions) .</span><span class="sxs-lookup"><span data-stu-id="bace9-126">The compound file implementation can be configured to use 512 or 4096 byte sectors, as defined in the [**STGOPTIONS**](/windows/win32/api/coml2api/ns-coml2api-stgoptions) structure.</span></span>

<span data-ttu-id="bace9-127">Реализация составного файла для составных файлов подчиняется следующим ограничениям реализации.</span><span class="sxs-lookup"><span data-stu-id="bace9-127">The compound file implementation of compound files is subject to the following implementation constraints.</span></span>



| <span data-ttu-id="bace9-128">Ограничение</span><span class="sxs-lookup"><span data-stu-id="bace9-128">Limit</span></span>                                           | <span data-ttu-id="bace9-129">Составной файл</span><span class="sxs-lookup"><span data-stu-id="bace9-129">Compound file</span></span>                                                                                                                                                                      |
|-------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="bace9-130">Ограничения размера файлов:</span><span class="sxs-lookup"><span data-stu-id="bace9-130">File size limits:</span></span>                               | <span data-ttu-id="bace9-131">512:2 гигабайта (ГБ) 4096: до ограничений файловой системы</span><span class="sxs-lookup"><span data-stu-id="bace9-131">512: 2 gigabytes (GB) 4096: Up to file system limits</span></span><br/>                                                                                                                    |
| <span data-ttu-id="bace9-132">Максимальный размер кучи, необходимый для открытых элементов:</span><span class="sxs-lookup"><span data-stu-id="bace9-132">Maximum heap size required for open elements:</span></span>   | <span data-ttu-id="bace9-133">512:4 мегабайта (МБ) 4096: пределы виртуальной памяти</span><span class="sxs-lookup"><span data-stu-id="bace9-133">512: 4 megabytes (MB) 4096: Up to virtual memory limits</span></span><br/>                                                                                                                 |
| <span data-ttu-id="bace9-134">Параллельное корневое открытие (открытие того же файла):</span><span class="sxs-lookup"><span data-stu-id="bace9-134">Concurrent root opens (opens of the same file):</span></span> | <span data-ttu-id="bace9-135">Если \_ заданы стгм Read и стгм \_ Share \_ Deny \_ Write, ограничения определяются ограничениями файловой системы.</span><span class="sxs-lookup"><span data-stu-id="bace9-135">If STGM\_READ and STGM\_SHARE\_DENY\_WRITE are specified, limits are dictated by the file-system limits.</span></span> <span data-ttu-id="bace9-136">В противном случае существует ограничение в 20 параллельных корневых папок одного и того же файла.</span><span class="sxs-lookup"><span data-stu-id="bace9-136">Otherwise, there is a limit of 20 concurrent root opens of the same file.</span></span> |
| <span data-ttu-id="bace9-137">Число элементов в файле:</span><span class="sxs-lookup"><span data-stu-id="bace9-137">Number of elements in a file:</span></span>                   | <span data-ttu-id="bace9-138">512: не ограничено, но производительность может снизиться, если число элементов в тысячах 4096: неограниченное</span><span class="sxs-lookup"><span data-stu-id="bace9-138">512: Unlimited, but performance may degrade if elements number in the thousands 4096: Unlimited</span></span><br/>                                                                         |



 

<span data-ttu-id="bace9-139">Из-за ограничения размера кучи 4 МБ число открытых элементов в режиме транзакций обычно ограничено несколькими тысячами элементов.</span><span class="sxs-lookup"><span data-stu-id="bace9-139">Due to the 4-MB heap-size limit, the number of open elements in transacted mode is typically limited to several thousand elements.</span></span>

 

