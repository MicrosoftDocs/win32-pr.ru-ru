---
description: Хотя этот механизм достаточно для простых приложений, он не поддерживает сложные требования к диспетчеризации сообщений для более сложных приложений, таких как использование модели многодокументного интерфейса (MDI).
ms.assetid: e4558e71-bbec-415a-a7c2-9025a4d6c474
title: Блокирующий обработчик
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2dcd098692784a662456c990a238bd309db0c321
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "105711043"
---
# <a name="blocking-hook"></a><span data-ttu-id="e3f32-103">Блокирующий обработчик</span><span class="sxs-lookup"><span data-stu-id="e3f32-103">Blocking Hook</span></span>

<span data-ttu-id="e3f32-104">Хотя этот механизм достаточно для простых приложений, он не поддерживает сложные требования к диспетчеризации сообщений для более сложных приложений, таких как использование модели многодокументного интерфейса (MDI).</span><span class="sxs-lookup"><span data-stu-id="e3f32-104">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications such as those using the Multiple Document Interface (MDI) model.</span></span> <span data-ttu-id="e3f32-105">Для таких приложений обработчик блокировки конкретного потока может быть установлен приложением.</span><span class="sxs-lookup"><span data-stu-id="e3f32-105">For such applications, a thread-specific blocking hook may be installed by the application.</span></span> <span data-ttu-id="e3f32-106">Он будет вызван поставщиком услуг вместо обработчика блокировки по умолчанию, описанного выше.</span><span class="sxs-lookup"><span data-stu-id="e3f32-106">This will be called by the service provider instead of the default blocking hook described in the preceding.</span></span> <span data-ttu-id="e3f32-107">Поставщик услуг должен получить указатель на обработчик блокировки для каждого потока из \_32.dll Ws2, вызвав [**впукуериблоккингкаллбакк**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span><span class="sxs-lookup"><span data-stu-id="e3f32-107">A service provider must retrieve a pointer to the per-thread blocking hook from the Ws2\_32.dll by calling [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span></span> <span data-ttu-id="e3f32-108">Если приложение не установило собственный обработчик блокировки, будет возвращен указатель на блокирующую функцию-ловушку по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="e3f32-108">If the application has not installed its own blocking hook a pointer to the default blocking hook function will be returned.</span></span>

<span data-ttu-id="e3f32-109">Поставщик услуг Windows Sockets не может предположить, что предоставляемый приложением блокирующий обработчик позволяет продолжать обработку сообщений в качестве блокирующего обработчика по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="e3f32-109">A Windows Sockets service provider cannot assume that an application-supplied blocking hook allows message processing to continue as the default blocking hook does.</span></span> <span data-ttu-id="e3f32-110">Некоторые приложения не допускают возможность повторного использования сообщений во время выполнения блокирующей операции.</span><span class="sxs-lookup"><span data-stu-id="e3f32-110">Some applications cannot tolerate the possibility of reentrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="e3f32-111">Такая функция блокировки приложения будет просто возвращать **значение false**.</span><span class="sxs-lookup"><span data-stu-id="e3f32-111">Such an application's blocking hook function would simply return **FALSE**.</span></span> <span data-ttu-id="e3f32-112">Если поставщик услуг зависит от сообщений для своей внутренней операции, он может выполнить **PeekMessage**(хмивнд...) перед выполнением обработчика блокировки приложения, чтобы он мог получать собственные сообщения, не влияя на остальную часть системы.</span><span class="sxs-lookup"><span data-stu-id="e3f32-112">If a service provider depends on messages for its internal operation, it may execute **PeekMessage**(hMyWnd...) before executing the application's blocking hook so that it can get its own messages without affecting the rest of the system.</span></span>

<span data-ttu-id="e3f32-113">Не установлен обработчик блокировки по умолчанию в многопоточных версиях Windows с вытеснением.</span><span class="sxs-lookup"><span data-stu-id="e3f32-113">There is no default blocking hook installed in preemptive multithreaded versions of Windows.</span></span> <span data-ttu-id="e3f32-114">Это связано с тем, что другие процессы не блокируются, если одно приложение ожидает завершения операции (и, следовательно, не вызывает **PeekMessage** или yield, что приводит к тому **, что приложение** выдает процессор в окнах без вытеснений).</span><span class="sxs-lookup"><span data-stu-id="e3f32-114">This is because other processes will not be blocked if a single application is waiting for an operation to complete (and hence not calling **PeekMessage** or **GetMessage** which causes the application to yield the processor in nonpreemptive Windows).</span></span> <span data-ttu-id="e3f32-115">Когда поставщик услуг вызывает [**впукуериблоккингкаллбакк**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) , будет возвращен пустой указатель, указывающий, что поставщик должен использовать встроенные функции блокировки операционной системы.</span><span class="sxs-lookup"><span data-stu-id="e3f32-115">When the service provider calls [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) a null pointer will be returned indicating that the provider is to use native operating system blocking functions.</span></span> <span data-ttu-id="e3f32-116">Однако, чтобы сохранить обратную совместимость, предоставляемый приложением блокирующий обработчик по-прежнему может быть установлен на основе каждого потока в Windows.</span><span class="sxs-lookup"><span data-stu-id="e3f32-116">However, in order to preserve backward compatibility, an application-supplied blocking hook can still be installed on a per-thread basis in Windows.</span></span>

<span data-ttu-id="e3f32-117">Поставщик услуг Winsock вызывает блокирующий ловушку только в том случае, если выполняются все следующие условия: подпрограммы, которые определены как возможность блокировки, указанный сокет является блокирующим, и запрос не может быть выполнен немедленно.</span><span class="sxs-lookup"><span data-stu-id="e3f32-117">The Winsock service provider calls the blocking hook only if all of the following are true: the routine is one which is defined as being able to block, the specified socket is a blocking socket, and the request cannot be completed immediately.</span></span> <span data-ttu-id="e3f32-118">Если используются только неблокирующие сокеты и [**вспасинкселект**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85)) / [**вспевентселект**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) вместо [**вспселект**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) , блокирующий обработчик никогда не будет вызываться.</span><span class="sxs-lookup"><span data-stu-id="e3f32-118">If only nonblocking sockets and [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85))/[**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) instead of [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) are used, then the blocking hook will never be called.</span></span>

> [!Note]  
> <span data-ttu-id="e3f32-119">Если в течение времени, когда псеудоблоккинг используется для блокировки потока, для потока получено сообщение Windows, существует риск, что поток попытается выдать другой вызов Winsock.</span><span class="sxs-lookup"><span data-stu-id="e3f32-119">If, during the time pseudoblocking is being used to block a thread, a Windows message is received for the thread, there is a risk that the thread will attempt to issue another Winsock call.</span></span> <span data-ttu-id="e3f32-120">В связи с тем, что сложность управления этим условием безопасно, спецификация Windows Sockets 1,1 не позволяла это поведение.</span><span class="sxs-lookup"><span data-stu-id="e3f32-120">Because of the difficulty of managing this condition safely, the Windows Sockets 1.1 specification disallowed this behavior.</span></span> <span data-ttu-id="e3f32-121">Данный поток не является допустимым для выполнения нескольких вложенных вызовов функций Winsock.</span><span class="sxs-lookup"><span data-stu-id="e3f32-121">It is not permissible for a given thread to make multiple, nested Winsock function calls.</span></span> <span data-ttu-id="e3f32-122">Для конкретного потока допускается только один невыполненный вызов функции.</span><span class="sxs-lookup"><span data-stu-id="e3f32-122">Only one outstanding function call is allowed for a particular thread.</span></span> <span data-ttu-id="e3f32-123">Все вложенные вызовы функции Winsock завершаются ошибкой с ошибкой ВСАЕИНПРОГРЕСС.</span><span class="sxs-lookup"><span data-stu-id="e3f32-123">Any nested Winsock function calls fail with the error WSAEINPROGRESS.</span></span> <span data-ttu-id="e3f32-124">Следует подчеркнуть, что это ограничение применяется как к блокирующей, так и к неблокирующей операциям, но только в средах Windows Sockets 1,1.</span><span class="sxs-lookup"><span data-stu-id="e3f32-124">It should be emphasized that this restriction applies to both blocking and nonblocking operations, but only in Windows Sockets 1.1 environments.</span></span> <span data-ttu-id="e3f32-125">Существует несколько исключений из этого правила, включая две функции, позволяющие приложению определить, выполняется ли операция псеудоблоккинг, а также отменить такую операцию, если это необходимо.</span><span class="sxs-lookup"><span data-stu-id="e3f32-125">There are a few exceptions to this rule, including two functions that allow an application to determine whether a pseudoblocking operation is in fact in progress, and to cancel such an operation if need be.</span></span> <span data-ttu-id="e3f32-126">Они описаны в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="e3f32-126">These are described in the following.</span></span>

 

 

 
