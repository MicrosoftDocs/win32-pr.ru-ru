---
description: Одной из серьезных проблем при переносе приложений из среды Berkeley Sockets в среду Windows является блокировка. то есть вызов функции, которая не возвращает значение до завершения связанной операции.
ms.assetid: 13aedad7-5f3b-4d73-b8e5-be3a095294bc
title: Подпрограммы блокировки Windows Sockets 1,1 и ЕИНПРОГРЕСС
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1ea6d45b4d25578505a3cb4ab4beb7c2c2fe90e4
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "105711380"
---
# <a name="windows-sockets-11-blocking-routines-and-einprogress"></a><span data-ttu-id="37e63-103">Подпрограммы блокировки Windows Sockets 1,1 и ЕИНПРОГРЕСС</span><span class="sxs-lookup"><span data-stu-id="37e63-103">Windows Sockets 1.1 Blocking Routines and EINPROGRESS</span></span>

<span data-ttu-id="37e63-104">Одной из серьезных проблем при переносе приложений из среды Berkeley Sockets в среду Windows является блокировка. то есть вызов функции, которая не возвращает значение до завершения связанной операции.</span><span class="sxs-lookup"><span data-stu-id="37e63-104">One major issue in porting applications from a Berkeley Sockets environment to a Windows environment involves blocking; that is, invoking a function that does not return until the associated operation is completed.</span></span> <span data-ttu-id="37e63-105">Проблема возникает, когда операция требует произвольного времени для выполнения. пример представляет собой функцию [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) , которая может блокироваться до получения данных от одноранговой системы.</span><span class="sxs-lookup"><span data-stu-id="37e63-105">A problem arises when the operation takes an arbitrarily long time to complete: an example is a [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) function, which might block until data has been received from the peer system.</span></span> <span data-ttu-id="37e63-106">Поведение по умолчанию в модели BIND-сокетов заключается в том, что сокет должен работать в блокирующем режиме, если программист явно не запрашивает, что операции обрабатываются как неблокирующие.</span><span class="sxs-lookup"><span data-stu-id="37e63-106">The default behavior within the Berkeley Sockets model is for a socket to operate in blocking mode unless the programmer explicitly requests that operations be treated as nonblocking.</span></span> <span data-ttu-id="37e63-107">Среды Windows Sockets 1,1 не могут предположить приоритетное планирование.</span><span class="sxs-lookup"><span data-stu-id="37e63-107">Windows Sockets 1.1 environments could not assume preemptive scheduling.</span></span> <span data-ttu-id="37e63-108">Поэтому настоятельно рекомендуется, чтобы программисты использовали неблокируемые (асинхронные) операции, если это возможно с сокетами Windows 1,1.</span><span class="sxs-lookup"><span data-stu-id="37e63-108">Therefore, it was strongly recommended that programmers use the nonblocking (asynchronous) operations if at all possible with Windows Sockets 1.1.</span></span> <span data-ttu-id="37e63-109">Так как это было не всегда возможно, были предоставлены средства псевдо-блокировки, описанные ниже.</span><span class="sxs-lookup"><span data-stu-id="37e63-109">Because this was not always possible, the pseudo-blocking facilities described in the following were provided.</span></span>

> [!Note]  
> <span data-ttu-id="37e63-110">Сокеты Windows 2 работают только в вытеснениях 32-разрядных операционных системах, в которых взаимоблокировки не являются проблемой.</span><span class="sxs-lookup"><span data-stu-id="37e63-110">Windows Sockets 2 only runs on preemptive 32-bit operating systems where deadlocks are not a problem.</span></span> <span data-ttu-id="37e63-111">Рекомендации по программированию для сокетов Windows 1,1 не требуются в сокетах Windows 2.</span><span class="sxs-lookup"><span data-stu-id="37e63-111">Programming practices recommended for Windows Sockets 1.1 are not necessary in Windows Sockets 2.</span></span>

 

<span data-ttu-id="37e63-112">Даже на блокирующем сокете некоторые функции, например [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind), [**жетсоккопт**](/windows/desktop/api/winsock/nf-winsock-getsockopt)и [**жетпирнаме**](/windows/desktop/api/winsock/nf-winsock-getpeername) , выполняются немедленно.</span><span class="sxs-lookup"><span data-stu-id="37e63-112">Even on a blocking socket, some functions — [**bind**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt), and [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) for example — complete immediately.</span></span> <span data-ttu-id="37e63-113">Нет никакой разницы между блокировкой и неблокирующей операцией для этих функций.</span><span class="sxs-lookup"><span data-stu-id="37e63-113">There is no difference between a blocking and a nonblocking operation for those functions.</span></span> <span data-ttu-id="37e63-114">Другие операции, такие как [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), могут завершиться немедленно или выполнить произвольное время, в зависимости от различных условий транспорта.</span><span class="sxs-lookup"><span data-stu-id="37e63-114">Other operations, such as [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), can complete immediately or take an arbitrary time to complete, depending on various transport conditions.</span></span> <span data-ttu-id="37e63-115">При применении к блокирующему сокету эти операции называются операциями блокировки.</span><span class="sxs-lookup"><span data-stu-id="37e63-115">When applied to a blocking socket, these operations are referred to as blocking operations.</span></span> <span data-ttu-id="37e63-116">Следующие функции могут блокироваться:</span><span class="sxs-lookup"><span data-stu-id="37e63-116">The following functions can block:</span></span>

-   [<span data-ttu-id="37e63-117">**полученных**</span><span class="sxs-lookup"><span data-stu-id="37e63-117">**recv**</span></span>](/windows/desktop/api/winsock/nf-winsock-recv)
-   [<span data-ttu-id="37e63-118">**реквфром**</span><span class="sxs-lookup"><span data-stu-id="37e63-118">**recvfrom**</span></span>](/windows/desktop/api/winsock/nf-winsock-recvfrom)
-   [<span data-ttu-id="37e63-119">**Отправить**</span><span class="sxs-lookup"><span data-stu-id="37e63-119">**send**</span></span>](/windows/desktop/api/Winsock2/nf-winsock2-send)
-   [<span data-ttu-id="37e63-120">**cервера**</span><span class="sxs-lookup"><span data-stu-id="37e63-120">**sendto**</span></span>](/windows/desktop/api/winsock/nf-winsock-sendto)

<span data-ttu-id="37e63-121">При использовании 16-разрядных сокетов Windows 1,1 операция блокирования, которая не может быть завершена немедленно, обрабатывается с помощью псевдо-блокировки следующим образом.</span><span class="sxs-lookup"><span data-stu-id="37e63-121">With 16-bit Windows Sockets 1.1, a blocking operation that cannot complete immediately is handled by pseudo-blocking as follows.</span></span>

<span data-ttu-id="37e63-122">Поставщик услуг инициирует операцию, затем вводит цикл, в котором он отправляет все сообщения Windows (при необходимости передавая процессор другому потоку), а затем проверяет завершение функции сокетов Windows.</span><span class="sxs-lookup"><span data-stu-id="37e63-122">The service provider initiates the operation, then enters a loop in which it dispatches any Windows messages (yielding the processor to another thread, if necessary), and then checks for the completion of the Windows Sockets function.</span></span> <span data-ttu-id="37e63-123">Если функция завершена или при вызове [**всаканцелблоккингкалл**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) , функция блокировки завершается с соответствующим результатом.</span><span class="sxs-lookup"><span data-stu-id="37e63-123">If the function has completed, or if [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) has been invoked, the blocking function completes with an appropriate result.</span></span>

<span data-ttu-id="37e63-124">Поставщик услуг должен разрешить установку блокирующего ловушки, которая не обрабатывает сообщения, чтобы избежать возможности повторного входа в систему во время выполнения блокирующей операции.</span><span class="sxs-lookup"><span data-stu-id="37e63-124">A service provider must allow installation of a blocking hook function that does not process messages in order to avoid the possibility of re-entrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="37e63-125">Простейшая функция блокирующего ловушки возвратит **значение false**.</span><span class="sxs-lookup"><span data-stu-id="37e63-125">The simplest such blocking hook function would return **FALSE**.</span></span> <span data-ttu-id="37e63-126">Если библиотека DLL Windows Sockets зависит от сообщений для внутренней операции, она может выполнить **PeekMessage**(**хмивнд**...) перед выполнением ловушки блокировки приложения, чтобы он мог получать свои сообщения, не влияя на остальную часть системы.</span><span class="sxs-lookup"><span data-stu-id="37e63-126">If a Windows Sockets DLL depends on messages for internal operation, it can execute **PeekMessage**(**hMyWnd**...) before executing the application blocking hook so that it can get its messages without affecting the rest of the system.</span></span>

<span data-ttu-id="37e63-127">В 16-разрядной среде Windows Sockets 1,1, если получено сообщение Windows для процесса, для которого выполняется операция блокировки, существует риск, что приложение попытается выдать другой вызов сокетов Windows.</span><span class="sxs-lookup"><span data-stu-id="37e63-127">In a 16-bit Windows Sockets 1.1 environment, if a Windows message is received for a process for which a blocking operation is in progress, there is a risk that the application will attempt to issue another Windows Sockets call.</span></span> <span data-ttu-id="37e63-128">Из-за трудностей в безопасном управлении этим состоянием Windows Sockets 1,1 не поддерживает такое поведение приложения.</span><span class="sxs-lookup"><span data-stu-id="37e63-128">Because of the difficulty in managing this condition safely, Windows Sockets 1.1 does not support such application behavior.</span></span> <span data-ttu-id="37e63-129">Приложению не разрешено выполнять несколько вложенных вызовов функций сокетов Windows.</span><span class="sxs-lookup"><span data-stu-id="37e63-129">An application is not permitted to make more than one nested Windows Sockets function call.</span></span> <span data-ttu-id="37e63-130">Для конкретной задачи допускается только один невыполненный вызов функции.</span><span class="sxs-lookup"><span data-stu-id="37e63-130">Only one outstanding function call is allowed for a particular task.</span></span> <span data-ttu-id="37e63-131">Единственными исключениями являются две функции, которые помогают программисту в такой ситуации: [**всаисблоккинг**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) и [**всаканцелблоккингкалл**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span><span class="sxs-lookup"><span data-stu-id="37e63-131">The only exceptions are two functions that are provided to assist the programmer in this situation: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) and [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span></span>

<span data-ttu-id="37e63-132">Функцию [**всаисблоккинг**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) можно вызвать в любое время, чтобы определить, выполняется ли блокирующий вызов сокетов Windows 1,1.</span><span class="sxs-lookup"><span data-stu-id="37e63-132">The [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) function can be called at any time to determine whether or not a blocking Windows Sockets 1.1 call is in progress.</span></span> <span data-ttu-id="37e63-133">Аналогичным образом функцию [**всаканцелблоккингкалл**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) можно вызвать в любое время, чтобы отменить выполняющийся блокирующий вызов.</span><span class="sxs-lookup"><span data-stu-id="37e63-133">Similarly, the [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) function can be called at any time to cancel an in-progress blocking call.</span></span> <span data-ttu-id="37e63-134">Любое другое вложение функций сокетов Windows завершается сбоем с ошибкой ВСАЕИНПРОГРЕСС.</span><span class="sxs-lookup"><span data-stu-id="37e63-134">Any other nesting of Windows Sockets functions fails with the error WSAEINPROGRESS.</span></span>

<span data-ttu-id="37e63-135">Следует подчеркнуть, что это ограничение применяется как к блокирующей, так и к неблокирующей операциям.</span><span class="sxs-lookup"><span data-stu-id="37e63-135">It should be emphasized that this restriction applies to both blocking and nonblocking operations.</span></span> <span data-ttu-id="37e63-136">Для приложений Windows Sockets 2, которые согласовывают версию 2,0 или более позднюю во время вызова [**сбой WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), никаких ограничений на вложение операций не выполняется.</span><span class="sxs-lookup"><span data-stu-id="37e63-136">For Windows Sockets 2 applications that negotiate version 2.0 or higher at the time of calling [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), no restriction on the nesting of operations exits.</span></span> <span data-ttu-id="37e63-137">Операции могут быть вложенными в редкие обстоятельства, например во время обратного вызова условного приема [**всаакцепт**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) , или если поставщик услуг в свою очередь вызывает функцию Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="37e63-137">Operations can become nested under rare circumstances, such as during a [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) conditional-acceptance callback, or if a service provider in turn invokes a Windows Sockets 2 function.</span></span>

<span data-ttu-id="37e63-138">Хотя этот механизм достаточно для простых приложений, он не поддерживает сложные требования к диспетчеризации сообщений для более сложных приложений (например, с помощью модели MDI).</span><span class="sxs-lookup"><span data-stu-id="37e63-138">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications (for example, those using the MDI model).</span></span> <span data-ttu-id="37e63-139">Для таких приложений API сокетов Windows включает функцию [**всасетблоккингхук**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), которая позволяет приложению указать специальную подпрограмму, которую можно вызвать вместо подпрограммы диспетчеризации сообщений по умолчанию, описанной в предыдущем обсуждении.</span><span class="sxs-lookup"><span data-stu-id="37e63-139">For such applications, the Windows Sockets API includes the function [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), which allows the application to specify a special routine which can be called instead of the default message dispatch routine described in the preceding discussion.</span></span>

<span data-ttu-id="37e63-140">Поставщик сокетов Windows вызывает блокирующий ловушку только в том случае, если выполняются все перечисленные ниже условия.</span><span class="sxs-lookup"><span data-stu-id="37e63-140">The Windows Sockets provider calls the blocking hook only if all of the following are true:</span></span>

-   <span data-ttu-id="37e63-141">Подпрограммы — это одна из них, которая определяется как возможность блокировки.</span><span class="sxs-lookup"><span data-stu-id="37e63-141">The routine is one that is defined as being able to block.</span></span>
-   <span data-ttu-id="37e63-142">Указанный сокет является блокирующим сокетом.</span><span class="sxs-lookup"><span data-stu-id="37e63-142">The specified socket is a blocking socket.</span></span>
-   <span data-ttu-id="37e63-143">Запрос не может быть выполнен немедленно.</span><span class="sxs-lookup"><span data-stu-id="37e63-143">The request cannot be completed immediately.</span></span>

<span data-ttu-id="37e63-144">По умолчанию для сокета задано блокирование, но функция [**иоктлсоккет**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) с функцией **Фионбио** ioctl или [**всаасинкселект**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) может установить сокет в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="37e63-144">A socket is set to blocking by default, but the [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) function with the **FIONBIO** IOCTL or the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) function can set a socket to nonblocking mode.</span></span>

<span data-ttu-id="37e63-145">Ловушка блокировки никогда не вызывается, и приложению не нужно беспокоиться о проблемах повторного входа, которые могут возникнуть в блокирующем ловушке, если приложение соответствует следующим рекомендациям:</span><span class="sxs-lookup"><span data-stu-id="37e63-145">The blocking hook is never called and the application does not need to be concerned with the re-entrancy issues the blocking hook can introduce, if an application follows these guidelines:</span></span>

-   <span data-ttu-id="37e63-146">Он использует только неблокируемые сокеты.</span><span class="sxs-lookup"><span data-stu-id="37e63-146">It uses only nonblocking sockets.</span></span>
-   <span data-ttu-id="37e63-147">В нем используются подпрограммы [**всаасинкселект**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) и/или **всаасинкжетксбии** вместо [**SELECT**](/windows/desktop/api/Winsock2/nf-winsock2-select) и подпрограмм **жетксбии** .</span><span class="sxs-lookup"><span data-stu-id="37e63-147">It uses the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) and/or the **WSAAsyncGetXByY** routines instead of [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) and the **getXbyY** routines.</span></span>

<span data-ttu-id="37e63-148">Если приложение Windows Sockets 1,1 вызывает асинхронную или неблочную операцию, которая принимает указатель на объект памяти (например, в буфер или глобальную переменную) в качестве аргумента, то ответственность за то, что объект будет доступен для сокетов Windows в ходе операции, несет приложение.</span><span class="sxs-lookup"><span data-stu-id="37e63-148">If a Windows Sockets 1.1 application invokes an asynchronous or nonblocking operation that takes a pointer to a memory object (a buffer or a global variable, for example) as an argument, it is the responsibility of the application to ensure that the object is available to Windows Sockets throughout the operation.</span></span> <span data-ttu-id="37e63-149">Приложение не должно вызывать функции Windows, которые могут повлиять на сопоставление или устранить жизнеспособность задействованной памяти.</span><span class="sxs-lookup"><span data-stu-id="37e63-149">The application must not invoke any Windows function that might affect the mapping or address viability of the memory involved.</span></span>

 

 



