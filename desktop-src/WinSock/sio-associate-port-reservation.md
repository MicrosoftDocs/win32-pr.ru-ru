---
description: Управляющий код связывает сокет с постоянным или резервным резервированием для блока TCP или UDP, идентифицируемого маркером резервирования портов.
ms.assetid: 4CBFB5F8-1FA1-44BA-9932-6F0329A465CB
title: Код элемента управления SIO_ASSOCIATE_PORT_RESERVATION
ms.topic: reference
ms.date: 05/20/2019
req.target-min-winverclnt: Windows Vista [desktop apps only]
req.target-min-winversvr: Windows Server 2008 [desktop apps only]
api_location:
- mstcpip.h
ms.openlocfilehash: 69af4f396fabd32f948d7e43cbf348aa34fb1a9f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104265766"
---
# <a name="sio_associate_port_reservation-control-code"></a>Код элемента управления SIO_ASSOCIATE_PORT_RESERVATION

## <a name="description"></a>Описание

Управляющий код для **\_ \_ \_ резервирования порта SIO** связывает сокет с постоянным или резервным резервированием для блока TCP или UDP, идентифицируемого маркером резервирования портов.
Этот запрос IOCTL должен быть выдан перед привязкой к сокету.
Если и при привязке сокета, назначенный ему порт будет выбран из резервирования портов, определенного данным токеном.
Если из указанного резервирования нет доступных портов, вызов функции [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind) завершится ошибкой.

Чтобы выполнить эту операцию, вызовите функцию [**всаиоктл**](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) или **вспиоктл** со следующими параметрами.

```cpp
int WSAIoctl(
  (socket) s,             // descriptor identifying a socket
  SIO_ASSOCIATE_PORT_RESERVATION, // dwIoControlCode
  (LPVOID) lpvInBuffer,  // pointer to an INET_PORT_RESERVATION_TOKEN
  (DWORD) cbInBuffer,    // size, in bytes, of the input buffer
  NULL,           // lpvOutBuffer is a pointer to the output buffer
  0,              // cbOutBuffer is the size, in bytes, of the output buffer
  (LPDWORD) lpcbBytesReturned,    // number of bytes returned
  (LPWSAOVERLAPPED) lpOverlapped,   // OVERLAPPED structure
  (LPWSAOVERLAPPED_COMPLETION_ROUTINE) lpCompletionRoutine,  // completion routine
);
```

```cpp
int WSPIoctl(
  (socket) s,             // descriptor identifying a socket
  SIO_ASSOCIATE_PORT_RESERVATION, // dwIoControlCode
  (LPVOID) lpvInBuffer,  // pointer to an INET_PORT_RESERVATION_TOKEN
  (DWORD) cbInBuffer,    // size, in bytes, of the input buffer
  NULL,           // lpvOutBuffer is a pointer to the output buffer
  0,              // cbOutBuffer is the size, in bytes, of the output buffer
  (LPDWORD) lpcbBytesReturned,    // number of bytes returned
  (LPWSAOVERLAPPED) lpOverlapped,   // OVERLAPPED structure
  (LPWSAOVERLAPPED_COMPLETION_ROUTINE) lpCompletionRoutine,  // completion routine
  (LPWSATHREADID) lpThreadId,   // a WSATHREADID structure
  (LPINT) lpErrno   // a pointer to the error code.
);
```

## <a name="parameters"></a>Параметры

### <a name="s"></a>s

Дескриптор, идентифицирующий сокет.

### <a name="dwiocontrolcode"></a>двиоконтролкоде

Управляющий код для операции.
Для этой операции используйте **\_ \_ \_ резервирование порта для сопоставления SIO** .

### <a name="lpvinbuffer"></a>лпвинбуффер

Указатель на входной буфер.
Этот параметр содержит указатель на структуру [**INET_PORT_RESERVATION_TOKEN**](/windows/desktop/api/mstcpip/ns-mstcpip-inet_port_reservation_token) с маркером резервирования портов TCP или UDP для связи с сокетом.

### <a name="cbinbuffer"></a>кбинбуффер

Размер входного буфера в байтах.
Этот параметр должен быть не меньше размера структуры [**INET_PORT_RESERVATION_TOKEN**](/windows/desktop/api/mstcpip/ns-mstcpip-inet_port_reservation_token) .

### <a name="lpvoutbuffer"></a>лпваутбуффер

Указатель на выходной буфер.
Этот параметр не используется для этой операции.

### <a name="cboutbuffer"></a>кбаутбуффер

Размер выходного буфера в байтах.
Этот параметр должен иметь значение 0.

### <a name="lpcbbytesreturned"></a>лпкббитесретурнед

Указатель на переменную, которая получает размер данных, хранящихся в выходном буфере, в байтах.

Если выходной буфер слишком мал, вызов завершается ошибкой, [**всажетластеррор**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) возвращает [**всаеинвал**](windows-sockets-error-codes-2.md), а параметр *лпкббитесретурнед* указывает на значение **DWORD** , равное нулю.

Если *лповерлаппед* имеет значение **null**, то значение **DWORD** , на которое указывает параметр *лпкббитесретурнед* , возвращаемое при успешном вызове, не может быть нулевым.

Если параметр *лповерлаппед* имеет значение, отличное от **null** , для перекрывающихся сокетов, то операции, которые не могут быть выполнены немедленно, будут инициированы, а завершение будет указано позже.
Значение **DWORD** , на которое указывает возвращаемый параметр *лпкббитесретурнед* , может быть равно нулю, так как размер хранимых данных не может быть определен до завершения операции перекрытия.
Окончательное состояние завершения можно получить, если при выполнении операции будет получен сигнал о соответствующем методе завершения.

### <a name="lpvoverlapped"></a>лпвоверлаппед

Указатель на структуру [**всаоверлаппед**](/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped) .

Если *сокеты были созданы* без атрибута OVERLAPPED, параметр *лповерлаппед* игнорируется.

Если *конструктор* был открыт с атрибутом OVERLAPPED и параметр *Лповерлаппед* не равен **null**, операция выполняется как перекрытый (асинхронная) операция.
В этом случае параметр *лповерлаппед* должен указывать на допустимую структуру [**всаоверлаппед**](/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped) .

Для операций с перекрытием функция [**всаиоктл**](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) или **вспиоктл** возвращает значение немедленно, и соответствующий метод завершения получает сигнал о завершении операции.
В противном случае функция не возвращает значение до тех пор, пока операция не будет завершена или произойдет ошибка.

### <a name="lpcompletionroutine"></a>лпкомплетионраутине

Тип: \_ In_opt \_ [ **LPWSAOVERLAPPED_COMPLETION_ROUTINE**](/windows/win32/api/winsock2/nc-winsock2-lpwsaoverlapped_completion_routine)

Указатель на подпрограммы завершения, вызываемую при завершении операции (игнорируется для сокетов без перекрытия).

### <a name="lpthreadid"></a>лпсреадид

Указатель на структуру [**всасреадид**](/windows/desktop/api/ws2spi/ns-ws2spi-wsathreadid) , которая будет использоваться поставщиком при последующем вызове [**впукуеуеапк**](/windows/desktop/api/ws2spi/nf-ws2spi-wpuqueueapc).
Поставщик должен хранить указанную [**всасреадид**](/windows/desktop/api/ws2spi/ns-ws2spi-wsathreadid) структуру (а не указатель на то же значение) до тех пор, пока функция [**впукуеуеапк**](/windows/desktop/api/ws2spi/nf-ws2spi-wpuqueueapc) не вернет значение.

**Примечание**  .  Этот параметр применяется только к функции **вспиоктл** .

### <a name="lperrno"></a>лперрно

Указатель на код ошибки.

**Примечание**  .  Этот параметр применяется только к функции **вспиоктл** .

## <a name="return-value"></a>Возвращаемое значение

Если операция завершается успешно, функция [**всаиоктл**](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) или **вспиоктл** возвращает ноль.

Если операция завершается ошибкой или находится в состоянии ожидания, функция [**всаиоктл**](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) или **Вспиоктл** возвращает **\_ ошибку сокета**.
Чтобы получить расширенные сведения об ошибке, вызовите [**всажетластеррор**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror).

| Код ошибки | Значение |
|------------|---------|
|**\_ожидается ввод-вывод WSA \_** | Выполняется перекрывающаяся операция ввода-вывода. Это значение возвращается в том случае, если операция перекрытия была успешно инициирована и ее завершение будет указано позже. |
| **\_Операция WSA \_ прервана** | Операция ввода-вывода прервана из-за завершения потока или запроса приложения. Эта ошибка возвращается, если перекрывающаяся операция была отменена из-за закрытия сокета или выполнения команды **\_ ioctl Flush суперконтроллера** ввода/вывода. |
| **всаеакцес** | Предпринята попытка доступа к сокету методом, запрещенным его разрешениями на доступ. Эта ошибка возникает при нескольких условиях для постоянных резервирований портов, которые включают следующее: у пользователя отсутствуют необходимые права администратора на локальном компьютере, или приложение не работает в расширенной оболочке как встроенное администратор ( `RunAs administrator` ). |
| **WSAEFAULT** | Система обнаружила недопустимый адрес указателя при попытке использовать аргумент указателя в вызове. Эта ошибка возвращается параметром *лпвинбуффер*, *лпваутбуффер*, *лпкббитесретурнед*, *лповерлаппед* или *лпкомплетионраутине* , который полностью не содержится в допустимой части адресного пространства пользователя. |
| **всаеинпрогресс** | В данный момент выполняется блокирующая операция. Эта ошибка возвращается, если функция вызывается при выполнении обратного вызова. |
| **всаеинтр** | Операция блокировки была прервана вызовом [**всаканцелблоккингкалл**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall). Эта ошибка возвращается в случае прерывания блокирующей операции. |
| **всаеинвал** | Указан недопустимый аргумент. Эта ошибка возвращается, если параметр *двиоконтролкоде* не является допустимой командой или указан недопустимый входной параметр, либо команда неприменима к указанному типу сокета. |
| **WSAENETDOWN** | Операция на сокете обнаружила отключение сети. Эта ошибка возвращается в случае сбоя сетевой подсистемы. |
| **всаенотсокк** | Предпринята попытка выполнить операцию для объекта, который не является сокетом. Эта ошибка возвращается, если дескриптор *s* не является сокетом. |
| **всаеопнотсупп** | Предпринятая операция не поддерживается для типа объекта, на который указывает ссылка. Эта ошибка возвращается, если указанная команда IOCTL не поддерживается. Эта ошибка также возвращается, если поставщик транспорта не поддерживает запрос IOCTL для **\_ \_ \_ резервирования порта SIO** . Эта ошибка также возвращается, если попытка использовать запрос на **\_ \_ \_ зарезервированный номер порта** для подключения SIO выполняется на сокете, отличном от UDP или TCP. |

## <a name="remarks"></a>Комментарии

В Windows Vista и более поздних версиях операционной системы поддерживается запрос IOCTL для **\_ сопоставления \_ порта \_ SIO** .

Приложения и службы, которым необходимо резервировать порты, делятся на две категории.
Первая категория включает компоненты, которым требуется определенный порт в рамках своей работы.
Такие компоненты, как правило, предпочитают указывать требуемый порт во время установки (например, в манифесте приложения).
Вторая категория включает компоненты, которым требуется любой доступный порт или блок портов во время выполнения.
Эти две категории соответствуют конкретным и запросам резервирования портов с подстановочными знаками.
Определенные запросы на резервирование могут быть постоянными или средой выполнения, тогда как запросы резервирования портов с подстановочными знаками поддерживаются только во время выполнения.

Для сопоставления резервирования портов TCP или UDP с постоянным резервированием или резервированиями времени выполнения используется запрос IOCTL **\_ \_ \_ резервирования порта SIO** .

Функция [**креатеперсистентткппортресерватион**](/windows/desktop/api/iphlpapi/nf-iphlpapi-createpersistenttcpportreservation) или [**креатеперсистентудппортресерватион**](/windows/desktop/api/iphlpapi/nf-iphlpapi-createpersistentudpportreservation) предоставляет приложению или службе возможность зарезервировать постоянный блок портов TCP или UDP.
Постоянные резервирования портов записываются в постоянном хранилище для модуля TCP или UDP в Windows.
Обратите внимание, что маркер для заданной постоянного резервирования портов может изменяться при каждом перезапуске системы.

После получения постоянного резервирования порта TCP или UDP приложение может запрашивать назначения портов из резервирования портов, открывая сокет TCP или UDP, а затем вызывая функцию [**всаиоктл**](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) , указывающую на подключение суперконтроллера ввода/вывода, и передав маркер резервирования перед вызовом функции [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind) на сокете. **\_ \_ \_**

[**SIO_ACQUIRE_PORT_RESERVATION**](sio-acquire-port-reservation.md) ioctl можно использовать для запроса резервирования времени выполнения для блока портов TCP или UDP.
Для резервирования портов во время выполнения пул портов требует, чтобы резервирования использовались в процессе, для которого было предоставлено резервирование.
Количество резервирований портов среды выполнения последний раз, пока время существования сокета, на котором вызывался [**SIO_ACQUIRE_PORT_RESERVATION**](sio-acquire-port-reservation.md) IOCTL.
Напротив, постоянные резервирования портов, созданные с помощью функции [**креатеперсистентткппортресерватион**](/windows/desktop/api/iphlpapi/nf-iphlpapi-createpersistenttcpportreservation) или [**креатеперсистентудппортресерватион**](/windows/desktop/api/iphlpapi/nf-iphlpapi-createpersistentudpportreservation) , могут быть использованы любым процессом с возможностью получения постоянных резервирований.

После получения резервирования порта времени выполнения TCP или UDP приложение может запрашивать назначения портов из резервирования портов, открыв сокет TCP или UDP, а затем вызывая функцию [**всаиоктл**](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) , указывающую на подключение SIO, и передав маркер резервирования перед вызовом функции [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind) на сокете. **\_ \_ \_**

Если оба параметра *лповерлаппед* и *лпкомплетионраутине* равны NULL, сокет в этой функции будет рассматриваться как сокет без перекрытия.
Для не перекрывающихся сокетов параметры *лповерлаппед* и *лпкомплетионраутине* игнорируются, за исключением того, что функция может блокироваться, *Если сокеты* находятся в блокирующем режиме.
Если *сокеты* находятся в режиме без блокировки, эта функция по-прежнему будет заблокирована, так как этот КОНКРЕТНЫЙ запрос IOCTL не поддерживает режим без блокировки.

Для перекрывающихся сокетов операции, которые не могут быть выполнены немедленно, будут инициированы, а завершение будет указано позже.

Любой запрос IOCTL может блокироваться неограниченно в зависимости от реализации поставщика услуг.
Если приложение не допускает блокировку в вызове функции [**всаиоктл**](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) или **вспиоктл** , перекрывающиеся операции ввода-вывода будут рекомендованы для ioctl, которые, скорее всего, блокируются.

Запрос IOCTL для **\_ \_ \_ резервирования порта SIO** может завершиться ошибкой с **всаеинтр** или **WSA_OPERATION_ABORTED** в следующих случаях:

* Запрос отменяется диспетчером ввода-вывода.
* Сокет закрыт.

Запрос IOCTL для **\_ \_ \_ резервирования порта** , переданный функции [**всаиоктл**](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) или **вспиоктл** для постоянного резервирования портов, может использоваться в приложении только в том случае, если пользователь вошел в систему как член группы администраторов.
Если в приложении используется запрос на **\_ \_ \_ зарезервированный номер порта** (IOCTL), если пользователь не является членом группы "Администраторы", вызов функции завершится неудачей и возвращается **всаеакцес** .
Использование функции IOCTL для **\_ \_ \_ резервирования порта SIO** также может завершиться сбоем из-за контроля учетных записей (UAC) в Windows Vista и более поздних версиях.
Если приложение, использующее этот запрос IOCTL с постоянным резервированием портов, выполняется пользователем, который вошел в систему в качестве члена группы администраторов, отличной от встроенного администратора, этот вызов завершится ошибкой, если приложение не будет помечено в файле манифеста с параметром **requestedExecutionLevel** , равным *requireAdministrator*.
Если в приложении отсутствует этот файл манифеста, пользователь, вошедший в систему в качестве члена группы администраторов, кроме встроенного администратора, должен запустить приложение в расширенной оболочке как встроенное администратор ( `RunAs administrator` ) для выполнения этой функции.

## <a name="see-also"></a>См. также раздел

[**выполняется**](/windows/desktop/api/winsock/nf-winsock-bind)

[**креатеперсистентткппортресерватион**](/windows/desktop/api/iphlpapi/nf-iphlpapi-createpersistenttcpportreservation)

[**креатеперсистентудппортресерватион**](/windows/desktop/api/iphlpapi/nf-iphlpapi-createpersistentudpportreservation)

[**делетеперсистентткппортресерватион**](/windows/desktop/api/iphlpapi/nf-iphlpapi-deletepersistenttcpportreservation)

[**делетеперсистентудппортресерватион**](/windows/desktop/api/iphlpapi/nf-iphlpapi-deletepersistentudpportreservation)

[**INET_PORT_RESERVATION_TOKEN**](/windows/desktop/api/mstcpip/ns-mstcpip-inet_port_reservation_token)

[**лукупперсистентткппортресерватион**](/windows/desktop/api/iphlpapi/nf-iphlpapi-lookuppersistenttcpportreservation)

[**лукупперсистентудппортресерватион**](/windows/desktop/api/iphlpapi/nf-iphlpapi-lookuppersistentudpportreservation)

[**SIO_ACQUIRE_PORT_RESERVATION**](sio-acquire-port-reservation.md)

[**SIO_RELEASE_PORT_RESERVATION**](sio-release-port-reservation.md)

[фиксатор](/windows/desktop/api/winsock2/nf-winsock2-socket)

[**всажетластеррор**](/windows/desktop/api/winsock2/nf-winsock2-wsagetlasterror)

[**всажетоверлаппедресулт**](/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult)

[**всаиоктл**](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)

[**всаоверлаппед**](/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped)

[**всасоккета**](/windows/desktop/api/winsock2/nf-winsock2-wsasocketa)

[**всасоккетв**](/windows/desktop/api/winsock2/nf-winsock2-wsasocketw)
