---
description: 'Существует два типа синхронизации ввода-вывода: синхронный ввод-вывод и асинхронный ввод-вывод. Асинхронный ввод-вывод также называется перекрытой операцией ввода-вывода.'
ms.assetid: ade51d98-cc9d-4b33-9c52-559a9cb14707
title: Синхронный и асинхронный ввод-вывод
ms.topic: article
ms.date: 05/31/2018
ms.custom: project-verbatim
ms.openlocfilehash: 99ab06fac66c0ff3033407326c190ce0d08e643ca30b24ff17b7420e61782222
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119981832"
---
# <a name="synchronous-and-asynchronous-io"></a>Синхронный и асинхронный ввод-вывод

См. также [примеры приложений, связанных с вводом-выводом](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).

Существует два типа синхронизации ввода-вывода: синхронный ввод-вывод и асинхронный ввод-вывод. Асинхронный ввод-вывод также называется перекрытой операцией ввода-вывода.

В *синхронных файловых операциях ввода-вывода* поток запускает операцию ввода-вывода и сразу переходит в состояние ожидания до тех пор, пока запрос ввода-вывода не будет завершен. Поток, выполняющий *Асинхронный файловый ввод-вывод* , отправляет в ядро запрос ввода-вывода, вызывая соответствующую функцию. Если запрос принимается ядром, вызывающий поток продолжит обработку другого задания, пока ядро не выведет сигнал о завершении операции ввода-вывода. Затем он прерывает свое текущее задание и обрабатывает данные из операции ввода-вывода по мере необходимости.

На следующем рисунке показаны два типа синхронизации.

![синхронный и асинхронный ввод-вывод](images/fig2bedit.png)

В ситуациях, когда ожидается, что запрос ввода-вывода занимает много времени, например обновление или резервное копирование большой базы данных или канала медленной связи, асинхронный ввод-вывод обычно является хорошим способом оптимизации эффективности обработки. Однако для относительно быстрых операций ввода-вывода затраты на обработку запросов ввода-вывода ядра и сигналы ядра могут быть менее полезными для асинхронного ввода-вывода, особенно в случае, если необходимо выполнить много быстрых операций ввода-вывода. В этом случае синхронный ввод-вывод будет лучше. Механизмы и сведения о реализации выполнения этих задач зависят от типа используемого обработчика устройства и конкретных потребностей приложения. Иными словами, обычно существует несколько способов решения проблемы.

## <a name="synchronous-and-asynchronous-io-considerations"></a>Синхронные и асинхронные вопросы ввода-вывода

Если файл или устройство открыто для синхронного ввода-вывода (то есть не задано **\_ \_ Перекрытие флага файла** ), последующие вызовы функций, таких как [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) , могут блокировать выполнение вызывающего потока до тех пор, пока не произойдет одно из следующих событий:

-   Операция ввода-вывода завершается (в этом примере — запись данных).
-   Ошибка ввода-вывода. (Например, канал закрывается с другого конца.)
-   В самом вызове произошла ошибка (например, один или несколько параметров недопустимы).
-   Другой поток в процессе вызывает функцию [**канцелсинчронаусио**](cancelsynchronousio-func.md) с помощью обработчика потока заблокированного потока, который прерывает операции ввода-вывода для этого потока и завершает операцию ввода-вывода.
-   Заблокированный поток завершается системой; Например, сам процесс завершается, или другой поток вызывает функцию [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) с помощью обработчика заблокированного потока. (Обычно это рассматривается как Последнее средство, а не хорошая разработка приложений.)

В некоторых случаях эта задержка может быть неприемлемой для проектирования и целей приложения, поэтому разработчикам приложений следует использовать асинхронный ввод-вывод с соответствующими объектами синхронизации потоков, такими как [порты завершения ввода-вывода](i-o-completion-ports.md). Дополнительные сведения о синхронизации потоков см. в разделе [о синхронизации](/windows/desktop/Sync/about-synchronization).

Процесс открывает файл для асинхронного ввода-вывода при вызове функции [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) путем указания флага **File \_ Flag \_ OVERLAPPED** в параметре *двфлагсандаттрибутес* . Если **\_ \_ Перекрытие флага файла** не задано, файл открывается для синхронного ввода-вывода. Когда файл был открыт для асинхронного ввода-вывода, указатель на структуру [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) передается в вызов [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) и [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile). При выполнении синхронного ввода-вывода эта структура не требуется в вызовах функций **ReadFile** и **WriteFile**.

> [!Note]  
> Если файл или устройство открыто для асинхронного ввода-вывода, последующие вызовы функций, таких как [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) с помощью этого маркера, обычно возвращают немедленно, но также могут вести себя синхронно с учетом заблокированного выполнения. Дополнительные сведения см. на веб-сайте [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).

 

Хотя [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) — это наиболее распространенная функция, используемая для открытия файлов, томов диска, анонимных каналов и других аналогичных устройств, операции ввода-вывода также можно выполнять с помощью *приведением* к другим системным объектам, таким как сокет, созданный [**сокетом**](/windows/desktop/api/winsock2/nf-winsock2-socket) или функцией [**Accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) .

Дескрипторы объектов каталога получаются путем вызова функции [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) с помощью атрибута **File \_ Flag \_ BACKUP \_ семантика** . Дескрипторы каталогов практически никогда не используются — приложения резервного копирования являются одним из нескольких приложений, которые обычно их используют.

После открытия объекта File для асинхронного ввода-вывода [**ПЕРЕкрывающаяся**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) структура должна быть правильно создана, инициализирована и передана в каждый вызов таких функций, как [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) и [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile). При использовании [**ПЕРЕкрывающейся**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) структуры в асинхронных операциях чтения и записи учитывайте следующее.

-   Не выделяйте или не изменяйте [**перекрывающиеся**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) структуры или буфер данных до тех пор, пока не будут завершены все асинхронные операции ввода-вывода в объект File.
-   Если вы объявили указатель на структуру [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) как локальную переменную, не выработайте локальную функцию до тех пор, пока не завершится выполнение всех асинхронных операций ввода-вывода в файловый объект. Если локальная функция завершается преждевременно, **ПЕРЕкрывающаяся** структура выходит из области, и она будет недоступна для любых функций [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) или [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) , которые он обнаруживает вне этой функции.

Можно также создать событие и разместить его в структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) ; [функции ожидания](/windows/desktop/Sync/wait-functions) можно затем использовать для ожидания завершения операции ввода-вывода, ожидая обработчик события.

Как отмечалось ранее, при работе с асинхронным маркером приложения должны соблюдать осторожность при определении того, когда следует освобождать ресурсы, связанные с заданной операцией ввода-вывода для этого маркера. Если маркер освобожден преждевременно, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) или [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) может неправильно сообщить о том, что операция ввода-вывода завершена. Кроме того, функция **WriteFile** иногда возвращает **true** со значением [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) , равной **Success Error, несмотря на то, что использует асинхронный обработчик (который также может \_** возвращать **значение false** с **\_ \_ ожидающими операциями ввода-вывода с ошибками**). Программисты, привыкшие к синхронному проектированию операций ввода-вывода, обычно освобождают ресурсы буфера данных на этом этапе, так как **значение true** и **Ошибка \_** означают, что операция завершена. Однако, если [порты завершения ввода-вывода](i-o-completion-ports.md) используются с этим асинхронным маркером, пакет завершения также будет отправлен, даже если операция ввода-вывода завершается немедленно. Иными словами, если приложение освобождает ресурсы после того, как функция **WriteFile** возвращает **значение true** , а в подпрограммы порта завершения ввода-вывода возникнет ошибка, то в нем будет выводится ошибка двойной свободной ситуации. **\_** В этом примере рекомендуется разрешить подпрограммы порта завершения, чтобы она отвечала исключительно за все операции освобождения таких ресурсов.

Система не поддерживает указатель файла на асинхронных дескрипторах для файлов и устройств, поддерживающих указатели на файлы (то есть поиск устройств), поэтому позиция файла должна быть передана в функции чтения и записи в соответствующих элементах данных смещения в структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) . Дополнительные сведения см. в разделе [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) и [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).

Расположение указателя файла для синхронного маркера поддерживается системой по мере чтения или записью данных, а также может быть обновлено с помощью функции [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) или [**сетфилепоинтерекс**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) .

Приложение также может ожидать завершения операции ввода-вывода в файле, но это требует особой осторожности. При каждом запуске операции ввода-вывода операционная система устанавливает для дескриптора файла несигнальное состояние. Каждый раз при завершении операции ввода-вывода операционная система устанавливает для дескриптора файла сигнальное состояние. Таким образом, если приложение запускает две операции ввода-вывода и ожидает дескриптора файла, невозможно определить, какая операция завершена, когда дескриптору присвоено сигнальное состояние. Если приложение должно выполнять несколько асинхронных операций ввода-вывода в одном файле, оно должно ожидать обработчика событий в конкретной структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) для каждой операции ввода-вывода, а не для общего файла.

Чтобы отменить все ожидающие асинхронные операции ввода-вывода, используйте один из следующих способов.

-   [**Канцелио**](cancelio.md)— эта функция отменяет только операции, выданные вызывающим потоком для указанного маркера файла.
-   [**Канцелиоекс**](cancelioex-func.md)— эта функция отменяет все операции, выданные потоками для указанного маркера файла.

Используйте [**канцелсинчронаусио**](cancelsynchronousio-func.md) для отмены ожидающих синхронных операций ввода-вывода.

Функции [**реадфиликс**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) и [**вритефиликс**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) позволяют приложению указать подпрограммы для выполнения (см. [**филеиокомплетионраутине**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) по завершении асинхронного запроса ввода-вывода.

 

 
