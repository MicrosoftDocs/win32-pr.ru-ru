---
description: 'Существует два типа синхронизации ввода-вывода: синхронный ввод-вывод и асинхронный ввод-вывод. Асинхронный ввод-вывод также называется перекрытой операцией ввода-вывода.'
ms.assetid: ade51d98-cc9d-4b33-9c52-559a9cb14707
title: Синхронный и асинхронный ввод-вывод
ms.topic: article
ms.date: 05/31/2018
ms.custom: project-verbatim
ms.openlocfilehash: 071dd2943537dcb6aff67a95cb5e2c3d514f4c1a
ms.sourcegitcommit: af120ad5c30da2fc5eb717ca2a1c4c45878efd71
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/20/2021
ms.locfileid: "105685020"
---
# <a name="synchronous-and-asynchronous-io"></a><span data-ttu-id="53456-104">Синхронный и асинхронный ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="53456-104">Synchronous and Asynchronous I/O</span></span>

<span data-ttu-id="53456-105">См. также [примеры приложений, связанных с вводом-выводом](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span><span class="sxs-lookup"><span data-stu-id="53456-105">Also see [I/O-related sample applications](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span></span>

<span data-ttu-id="53456-106">Существует два типа синхронизации ввода-вывода: синхронный ввод-вывод и асинхронный ввод-вывод.</span><span class="sxs-lookup"><span data-stu-id="53456-106">There are two types of input/output (I/O) synchronization: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="53456-107">Асинхронный ввод-вывод также называется перекрытой операцией ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="53456-107">Asynchronous I/O is also referred to as overlapped I/O.</span></span>

<span data-ttu-id="53456-108">В *синхронных файловых операциях ввода-вывода* поток запускает операцию ввода-вывода и сразу переходит в состояние ожидания до тех пор, пока запрос ввода-вывода не будет завершен.</span><span class="sxs-lookup"><span data-stu-id="53456-108">In *synchronous file I/O*, a thread starts an I/O operation and immediately enters a wait state until the I/O request has completed.</span></span> <span data-ttu-id="53456-109">Поток, выполняющий *Асинхронный файловый ввод-вывод* , отправляет в ядро запрос ввода-вывода, вызывая соответствующую функцию.</span><span class="sxs-lookup"><span data-stu-id="53456-109">A thread performing *asynchronous file I/O* sends an I/O request to the kernel by calling an appropriate function.</span></span> <span data-ttu-id="53456-110">Если запрос принимается ядром, вызывающий поток продолжит обработку другого задания, пока ядро не выведет сигнал о завершении операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="53456-110">If the request is accepted by the kernel, the calling thread continues processing another job until the kernel signals to the thread that the I/O operation is complete.</span></span> <span data-ttu-id="53456-111">Затем он прерывает свое текущее задание и обрабатывает данные из операции ввода-вывода по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="53456-111">It then interrupts its current job and processes the data from the I/O operation as necessary.</span></span>

<span data-ttu-id="53456-112">На следующем рисунке показаны два типа синхронизации.</span><span class="sxs-lookup"><span data-stu-id="53456-112">The two synchronization types are illustrated in the following figure.</span></span>

![синхронный и асинхронный ввод-вывод](images/fig2bedit.png)

<span data-ttu-id="53456-114">В ситуациях, когда ожидается, что запрос ввода-вывода занимает много времени, например обновление или резервное копирование большой базы данных или канала медленной связи, асинхронный ввод-вывод обычно является хорошим способом оптимизации эффективности обработки.</span><span class="sxs-lookup"><span data-stu-id="53456-114">In situations where an I/O request is expected to take a large amount of time, such as a refresh or backup of a large database or a slow communications link, asynchronous I/O is generally a good way to optimize processing efficiency.</span></span> <span data-ttu-id="53456-115">Однако для относительно быстрых операций ввода-вывода затраты на обработку запросов ввода-вывода ядра и сигналы ядра могут быть менее полезными для асинхронного ввода-вывода, особенно в случае, если необходимо выполнить много быстрых операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="53456-115">However, for relatively fast I/O operations, the overhead of processing kernel I/O requests and kernel signals may make asynchronous I/O less beneficial, particularly if many fast I/O operations need to be made.</span></span> <span data-ttu-id="53456-116">В этом случае синхронный ввод-вывод будет лучше.</span><span class="sxs-lookup"><span data-stu-id="53456-116">In this case, synchronous I/O would be better.</span></span> <span data-ttu-id="53456-117">Механизмы и сведения о реализации выполнения этих задач зависят от типа используемого обработчика устройства и конкретных потребностей приложения.</span><span class="sxs-lookup"><span data-stu-id="53456-117">The mechanisms and implementation details of how to accomplish these tasks vary depending on the type of device handle that is used and the particular needs of the application.</span></span> <span data-ttu-id="53456-118">Иными словами, обычно существует несколько способов решения проблемы.</span><span class="sxs-lookup"><span data-stu-id="53456-118">In other words, there are usually multiple ways to solve the problem.</span></span>

## <a name="synchronous-and-asynchronous-io-considerations"></a><span data-ttu-id="53456-119">Синхронные и асинхронные вопросы ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="53456-119">Synchronous and Asynchronous I/O Considerations</span></span>

<span data-ttu-id="53456-120">Если файл или устройство открыто для синхронного ввода-вывода (то есть не задано **\_ \_ Перекрытие флага файла** ), последующие вызовы функций, таких как [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) , могут блокировать выполнение вызывающего потока до тех пор, пока не произойдет одно из следующих событий:</span><span class="sxs-lookup"><span data-stu-id="53456-120">If a file or device is opened for synchronous I/O (that is, **FILE\_FLAG\_OVERLAPPED** is not specified), subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) can block execution of the calling thread until one of the following events occurs:</span></span>

-   <span data-ttu-id="53456-121">Операция ввода-вывода завершается (в этом примере — запись данных).</span><span class="sxs-lookup"><span data-stu-id="53456-121">The I/O operation completes (in this example, a data write).</span></span>
-   <span data-ttu-id="53456-122">Ошибка ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="53456-122">An I/O error occurs.</span></span> <span data-ttu-id="53456-123">(Например, канал закрывается с другого конца.)</span><span class="sxs-lookup"><span data-stu-id="53456-123">(For example, the pipe is closed from the other end.)</span></span>
-   <span data-ttu-id="53456-124">В самом вызове произошла ошибка (например, один или несколько параметров недопустимы).</span><span class="sxs-lookup"><span data-stu-id="53456-124">An error was made in the call itself (for example, one or more parameters are not valid).</span></span>
-   <span data-ttu-id="53456-125">Другой поток в процессе вызывает функцию [**канцелсинчронаусио**](cancelsynchronousio-func.md) с помощью обработчика потока заблокированного потока, который прерывает операции ввода-вывода для этого потока и завершает операцию ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="53456-125">Another thread in the process calls the [**CancelSynchronousIo**](cancelsynchronousio-func.md) function using the blocked thread's thread handle, which terminates I/O for that thread, failing the I/O operation.</span></span>
-   <span data-ttu-id="53456-126">Заблокированный поток завершается системой; Например, сам процесс завершается, или другой поток вызывает функцию [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) с помощью обработчика заблокированного потока.</span><span class="sxs-lookup"><span data-stu-id="53456-126">The blocked thread is terminated by the system; for example, the process itself is terminated, or another thread calls the [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) function using the blocked thread's handle.</span></span> <span data-ttu-id="53456-127">(Обычно это рассматривается как Последнее средство, а не хорошая разработка приложений.)</span><span class="sxs-lookup"><span data-stu-id="53456-127">(This is generally considered a last resort and not good application design.)</span></span>

<span data-ttu-id="53456-128">В некоторых случаях эта задержка может быть неприемлемой для проектирования и целей приложения, поэтому разработчикам приложений следует использовать асинхронный ввод-вывод с соответствующими объектами синхронизации потоков, такими как [порты завершения ввода-вывода](i-o-completion-ports.md).</span><span class="sxs-lookup"><span data-stu-id="53456-128">In some cases, this delay may be unacceptable to the application's design and purpose, so application designers should consider using asynchronous I/O with appropriate thread synchronization objects such as [I/O completion ports](i-o-completion-ports.md).</span></span> <span data-ttu-id="53456-129">Дополнительные сведения о синхронизации потоков см. в разделе [о синхронизации](/windows/desktop/Sync/about-synchronization).</span><span class="sxs-lookup"><span data-stu-id="53456-129">For more information about thread synchronization, see [About Synchronization](/windows/desktop/Sync/about-synchronization).</span></span>

<span data-ttu-id="53456-130">Процесс открывает файл для асинхронного ввода-вывода при вызове функции [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) путем указания флага **File \_ Flag \_ OVERLAPPED** в параметре *двфлагсандаттрибутес* .</span><span class="sxs-lookup"><span data-stu-id="53456-130">A process opens a file for asynchronous I/O in its call to [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) by specifying the **FILE\_FLAG\_OVERLAPPED** flag in the *dwFlagsAndAttributes* parameter.</span></span> <span data-ttu-id="53456-131">Если **\_ \_ Перекрытие флага файла** не задано, файл открывается для синхронного ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="53456-131">If **FILE\_FLAG\_OVERLAPPED** is not specified, the file is opened for synchronous I/O.</span></span> <span data-ttu-id="53456-132">Когда файл был открыт для асинхронного ввода-вывода, указатель на структуру [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) передается в вызов [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) и [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="53456-132">When the file has been opened for asynchronous I/O, a pointer to an [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure is passed into the call to [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="53456-133">При выполнении синхронного ввода-вывода эта структура не требуется в вызовах функций **ReadFile** и **WriteFile**.</span><span class="sxs-lookup"><span data-stu-id="53456-133">When performing synchronous I/O, this structure is not required in calls to **ReadFile** and **WriteFile**.</span></span>

> [!Note]  
> <span data-ttu-id="53456-134">Если файл или устройство открыто для асинхронного ввода-вывода, последующие вызовы функций, таких как [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) с помощью этого маркера, обычно возвращают немедленно, но также могут вести себя синхронно с учетом заблокированного выполнения.</span><span class="sxs-lookup"><span data-stu-id="53456-134">If a file or device is opened for asynchronous I/O, subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) using that handle generally return immediately but can also behave synchronously with respect to blocked execution.</span></span> <span data-ttu-id="53456-135">Дополнительные сведения см. на веб-сайте [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span><span class="sxs-lookup"><span data-stu-id="53456-135">For more information, see [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span></span>

 

<span data-ttu-id="53456-136">Хотя [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) — это наиболее распространенная функция, используемая для открытия файлов, томов диска, анонимных каналов и других аналогичных устройств, операции ввода-вывода также можно выполнять с помощью *приведением* к другим системным объектам, таким как сокет, созданный [**сокетом**](/windows/desktop/api/winsock2/nf-winsock2-socket) или функцией [**Accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) .</span><span class="sxs-lookup"><span data-stu-id="53456-136">Although [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) is the most common function to use for opening files, disk volumes, anonymous pipes, and other similar devices, I/O operations can also be performed using a handle *typecast* from other system objects such as a socket created by the [**socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) or [**accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) functions.</span></span>

<span data-ttu-id="53456-137">Дескрипторы объектов каталога получаются путем вызова функции [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) с помощью атрибута **File \_ Flag \_ BACKUP \_ семантика** .</span><span class="sxs-lookup"><span data-stu-id="53456-137">Handles to directory objects are obtained by calling the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function with the **FILE\_FLAG\_BACKUP\_SEMANTICS** attribute.</span></span> <span data-ttu-id="53456-138">Дескрипторы каталогов практически никогда не используются — приложения резервного копирования являются одним из нескольких приложений, которые обычно их используют.</span><span class="sxs-lookup"><span data-stu-id="53456-138">Directory handles are almost never used—backup applications are one of the few applications that will typically use them.</span></span>

<span data-ttu-id="53456-139">После открытия объекта File для асинхронного ввода-вывода [**ПЕРЕкрывающаяся**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) структура должна быть правильно создана, инициализирована и передана в каждый вызов таких функций, как [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) и [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="53456-139">After opening the file object for asynchronous I/O, an [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure must be properly created, initialized, and passed into each call to functions such as [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="53456-140">При использовании [**ПЕРЕкрывающейся**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) структуры в асинхронных операциях чтения и записи учитывайте следующее.</span><span class="sxs-lookup"><span data-stu-id="53456-140">Keep the following in mind when using the [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure in asynchronous read and write operations:</span></span>

-   <span data-ttu-id="53456-141">Не выделяйте или не изменяйте [**перекрывающиеся**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) структуры или буфер данных до тех пор, пока не будут завершены все асинхронные операции ввода-вывода в объект File.</span><span class="sxs-lookup"><span data-stu-id="53456-141">Do not deallocate or modify the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure or the data buffer until all asynchronous I/O operations to the file object have been completed.</span></span>
-   <span data-ttu-id="53456-142">Если вы объявили указатель на структуру [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) как локальную переменную, не выработайте локальную функцию до тех пор, пока не завершится выполнение всех асинхронных операций ввода-вывода в файловый объект.</span><span class="sxs-lookup"><span data-stu-id="53456-142">If you declare your pointer to the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure as a local variable, do not exit the local function until all asynchronous I/O operations to the file object have been completed.</span></span> <span data-ttu-id="53456-143">Если локальная функция завершается преждевременно, **ПЕРЕкрывающаяся** структура выходит из области, и она будет недоступна для любых функций [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) или [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) , которые он обнаруживает вне этой функции.</span><span class="sxs-lookup"><span data-stu-id="53456-143">If the local function is exited prematurely, the **OVERLAPPED** structure will go out of scope and it will be inaccessible to any [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) functions it encounters outside of that function.</span></span>

<span data-ttu-id="53456-144">Можно также создать событие и разместить его в структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) ; [функции ожидания](/windows/desktop/Sync/wait-functions) можно затем использовать для ожидания завершения операции ввода-вывода, ожидая обработчик события.</span><span class="sxs-lookup"><span data-stu-id="53456-144">You can also create an event and put the handle in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure; the [wait functions](/windows/desktop/Sync/wait-functions) can then be used to wait for the I/O operation to complete by waiting on the event handle.</span></span>

<span data-ttu-id="53456-145">Как отмечалось ранее, при работе с асинхронным маркером приложения должны соблюдать осторожность при определении того, когда следует освобождать ресурсы, связанные с заданной операцией ввода-вывода для этого маркера.</span><span class="sxs-lookup"><span data-stu-id="53456-145">As previously stated, when working with an asynchronous handle, applications should use care when making determinations about when to free resources associated with a specified I/O operation on that handle.</span></span> <span data-ttu-id="53456-146">Если маркер освобожден преждевременно, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) или [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) может неправильно сообщить о том, что операция ввода-вывода завершена.</span><span class="sxs-lookup"><span data-stu-id="53456-146">If the handle is deallocated prematurely, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) may incorrectly report that the I/O operation is complete.</span></span> <span data-ttu-id="53456-147">Кроме того, функция **WriteFile** иногда возвращает **true** со значением [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) , равной **Success Error, несмотря на то, что использует асинхронный обработчик (который также может \_** возвращать **значение false** с **\_ \_ ожидающими операциями ввода-вывода с ошибками**).</span><span class="sxs-lookup"><span data-stu-id="53456-147">Further, the **WriteFile** function will sometimes return **TRUE** with a [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) value of **ERROR\_SUCCESS**, even though it is using an asynchronous handle (which can also return **FALSE** with **ERROR\_IO\_PENDING**).</span></span> <span data-ttu-id="53456-148">Программисты, привыкшие к синхронному проектированию операций ввода-вывода, обычно освобождают ресурсы буфера данных на этом этапе, так как **значение true** и **Ошибка \_** означают, что операция завершена.</span><span class="sxs-lookup"><span data-stu-id="53456-148">Programmers accustomed to synchronous I/O design will usually release data buffer resources at this point because **TRUE** and **ERROR\_SUCCESS** signify the operation is complete.</span></span> <span data-ttu-id="53456-149">Однако, если [порты завершения ввода-вывода](i-o-completion-ports.md) используются с этим асинхронным маркером, пакет завершения также будет отправлен, даже если операция ввода-вывода завершается немедленно.</span><span class="sxs-lookup"><span data-stu-id="53456-149">However, if [I/O completion ports](i-o-completion-ports.md) are being used with this asynchronous handle, a completion packet will also be sent even though the I/O operation completed immediately.</span></span> <span data-ttu-id="53456-150">Иными словами, если приложение освобождает ресурсы после того, как функция **WriteFile** возвращает **значение true** , а в подпрограммы порта завершения ввода-вывода возникнет ошибка, то в нем будет выводится ошибка двойной свободной ситуации. **\_**</span><span class="sxs-lookup"><span data-stu-id="53456-150">In other words, if the application frees resources after **WriteFile** returns **TRUE** with **ERROR\_SUCCESS** in addition to in the I/O completion port routine, it will have a double-free error condition.</span></span> <span data-ttu-id="53456-151">В этом примере рекомендуется разрешить подпрограммы порта завершения, чтобы она отвечала исключительно за все операции освобождения таких ресурсов.</span><span class="sxs-lookup"><span data-stu-id="53456-151">In this example, the recommendation would be to allow the completion port routine to be solely responsible for all freeing operations for such resources.</span></span>

<span data-ttu-id="53456-152">Система не поддерживает указатель файла на асинхронных дескрипторах для файлов и устройств, поддерживающих указатели на файлы (то есть поиск устройств), поэтому позиция файла должна быть передана в функции чтения и записи в соответствующих элементах данных смещения в структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="53456-152">The system does not maintain the file pointer on asynchronous handles to files and devices that support file pointers (that is, seeking devices), therefore the file position must be passed to the read and write functions in the related offset data members of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="53456-153">Дополнительные сведения см. в разделе [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) и [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span><span class="sxs-lookup"><span data-stu-id="53456-153">For more information, see [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) and [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span></span>

<span data-ttu-id="53456-154">Расположение указателя файла для синхронного маркера поддерживается системой по мере чтения или записью данных, а также может быть обновлено с помощью функции [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) или [**сетфилепоинтерекс**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) .</span><span class="sxs-lookup"><span data-stu-id="53456-154">File pointer position for a synchronous handle is maintained by the system as data is read or written and can also be updated using the [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) or [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) function.</span></span>

<span data-ttu-id="53456-155">Приложение также может ожидать завершения операции ввода-вывода в файле, но это требует особой осторожности.</span><span class="sxs-lookup"><span data-stu-id="53456-155">An application can also wait on the file handle to synchronize the completion of an I/O operation, but doing so requires extreme caution.</span></span> <span data-ttu-id="53456-156">При каждом запуске операции ввода-вывода операционная система устанавливает для дескриптора файла несигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="53456-156">Each time an I/O operation is started, the operating system sets the file handle to the nonsignaled state.</span></span> <span data-ttu-id="53456-157">Каждый раз при завершении операции ввода-вывода операционная система устанавливает для дескриптора файла сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="53456-157">Each time an I/O operation is completed, the operating system sets the file handle to the signaled state.</span></span> <span data-ttu-id="53456-158">Таким образом, если приложение запускает две операции ввода-вывода и ожидает дескриптора файла, невозможно определить, какая операция завершена, когда дескриптору присвоено сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="53456-158">Therefore, if an application starts two I/O operations and waits on the file handle, there is no way to determine which operation is finished when the handle is set to the signaled state.</span></span> <span data-ttu-id="53456-159">Если приложение должно выполнять несколько асинхронных операций ввода-вывода в одном файле, оно должно ожидать обработчика событий в конкретной структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) для каждой операции ввода-вывода, а не для общего файла.</span><span class="sxs-lookup"><span data-stu-id="53456-159">If an application must perform multiple asynchronous I/O operations on a single file, it should wait on the event handle in the specific [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure for each I/O operation, rather than on the common file handle.</span></span>

<span data-ttu-id="53456-160">Чтобы отменить все ожидающие асинхронные операции ввода-вывода, используйте один из следующих способов.</span><span class="sxs-lookup"><span data-stu-id="53456-160">To cancel all pending asynchronous I/O operations, use either:</span></span>

-   <span data-ttu-id="53456-161">[**Канцелио**](cancelio.md)— эта функция отменяет только операции, выданные вызывающим потоком для указанного маркера файла.</span><span class="sxs-lookup"><span data-stu-id="53456-161">[**CancelIo**](cancelio.md)—this function only cancels operations issued by the calling thread for the specified file handle.</span></span>
-   <span data-ttu-id="53456-162">[**Канцелиоекс**](cancelioex-func.md)— эта функция отменяет все операции, выданные потоками для указанного маркера файла.</span><span class="sxs-lookup"><span data-stu-id="53456-162">[**CancelIoEx**](cancelioex-func.md)—this function cancels all operations issued by the threads for the specified file handle.</span></span>

<span data-ttu-id="53456-163">Используйте [**канцелсинчронаусио**](cancelsynchronousio-func.md) для отмены ожидающих синхронных операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="53456-163">Use [**CancelSynchronousIo**](cancelsynchronousio-func.md) to cancel pending synchronous I/O operations.</span></span>

<span data-ttu-id="53456-164">Функции [**реадфиликс**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) и [**вритефиликс**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) позволяют приложению указать подпрограммы для выполнения (см. [**филеиокомплетионраутине**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) по завершении асинхронного запроса ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="53456-164">The [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) functions enable an application to specify a routine to execute (see [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) when the asynchronous I/O request is completed.</span></span>

 

 
