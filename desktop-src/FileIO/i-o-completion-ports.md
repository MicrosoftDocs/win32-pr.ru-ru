---
description: Порты завершения ввода-вывода предоставляют эффективную потоковую модель для обработки нескольких асинхронных запросов ввода-вывода в многопроцессорной системе.
ms.assetid: 213c48e8-bb21-43ed-9c00-2a5cf8ac25f0
title: Порты завершения ввода-вывода
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 882363ef99821a0b0b40810f45d609c5b5f7760c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105664430"
---
# <a name="io-completion-ports"></a><span data-ttu-id="bf818-103">Порты завершения ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="bf818-103">I/O Completion Ports</span></span>

<span data-ttu-id="bf818-104">Порты завершения ввода-вывода предоставляют эффективную потоковую модель для обработки нескольких асинхронных запросов ввода-вывода в многопроцессорной системе.</span><span class="sxs-lookup"><span data-stu-id="bf818-104">I/O completion ports provide an efficient threading model for processing multiple asynchronous I/O requests on a multiprocessor system.</span></span> <span data-ttu-id="bf818-105">Когда процесс создает порт завершения ввода-вывода, система создает связанный объект очереди для запросов, предназначенных исключительно для обслуживания этих запросов.</span><span class="sxs-lookup"><span data-stu-id="bf818-105">When a process creates an I/O completion port, the system creates an associated queue object for requests whose sole purpose is to service these requests.</span></span> <span data-ttu-id="bf818-106">Процессы, обрабатывающие множество параллельных асинхронных запросов ввода-вывода, могут сделать это быстрее и эффективнее с помощью портов завершения ввода-вывода в сочетании с предварительно выделенным пулом потоков, чем при создании потоков на момент получения запроса ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-106">Processes that handle many concurrent asynchronous I/O requests can do so more quickly and efficiently by using I/O completion ports in conjunction with a pre-allocated thread pool than by creating threads at the time they receive an I/O request.</span></span>

## <a name="how-io-completion-ports-work"></a><span data-ttu-id="bf818-107">Как работают порты завершения ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="bf818-107">How I/O Completion Ports Work</span></span>

<span data-ttu-id="bf818-108">Функция [**CreateIoCompletionPort**](createiocompletionport.md) создает порт завершения ввода-вывода и связывает один или несколько дескрипторов файлов с этим портом.</span><span class="sxs-lookup"><span data-stu-id="bf818-108">The [**CreateIoCompletionPort**](createiocompletionport.md) function creates an I/O completion port and associates one or more file handles with that port.</span></span> <span data-ttu-id="bf818-109">При завершении асинхронной операции ввода-вывода с одним из этих дескрипторов файлов пакет завершения ввода-вывода помещается в очередь в порядке "первым вошел — первым обслужен" (FIFO) к соответствующему порту завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-109">When an asynchronous I/O operation on one of these file handles completes, an I/O completion packet is queued in first-in-first-out (FIFO) order to the associated I/O completion port.</span></span> <span data-ttu-id="bf818-110">Одним из мощных способов использования этого механизма является объединение точки синхронизации для нескольких дескрипторов файлов в один объект, хотя существуют и другие полезные приложения.</span><span class="sxs-lookup"><span data-stu-id="bf818-110">One powerful use for this mechanism is to combine the synchronization point for multiple file handles into a single object, although there are also other useful applications.</span></span> <span data-ttu-id="bf818-111">Обратите внимание, что хотя пакеты помещаются в очередь в порядке FIFO, они могут быть выведены из очереди в другом порядке.</span><span class="sxs-lookup"><span data-stu-id="bf818-111">Please note that while the packets are queued in FIFO order they may be dequeued in a different order.</span></span>

> [!Note]
>
> <span data-ttu-id="bf818-112">Термин используемый здесь *описатель файла* означает абстракцию системы, представляющую перекрывающиеся конечные точки ввода-вывода, а не только файл на диске.</span><span class="sxs-lookup"><span data-stu-id="bf818-112">The term *file handle* as used here refers to a system abstraction representing an overlapped I/O endpoint, not only a file on disk.</span></span> <span data-ttu-id="bf818-113">Например, это может быть конечная точка сети, TCP-сокет, именованный канал или почтовый слот.</span><span class="sxs-lookup"><span data-stu-id="bf818-113">For example, it can be a network endpoint, TCP socket, named pipe, or mail slot.</span></span> <span data-ttu-id="bf818-114">Можно использовать любой системный объект, поддерживающий перекрывающиеся операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-114">Any system object that supports overlapped I/O can be used.</span></span> <span data-ttu-id="bf818-115">Список связанных функций ввода-вывода см. в конце этого раздела.</span><span class="sxs-lookup"><span data-stu-id="bf818-115">For a list of related I/O functions, see the end of this topic.</span></span>

 

<span data-ttu-id="bf818-116">Если маркер файла связан с портом завершения, переданный блок состояния не будет обновляться до тех пор, пока пакет не будет удален из порта завершения.</span><span class="sxs-lookup"><span data-stu-id="bf818-116">When a file handle is associated with a completion port, the status block passed in will not be updated until the packet is removed from the completion port.</span></span> <span data-ttu-id="bf818-117">Единственное исключение — если исходная операция возвращает синхронное значение с ошибкой.</span><span class="sxs-lookup"><span data-stu-id="bf818-117">The only exception is if the original operation returns synchronously with an error.</span></span> <span data-ttu-id="bf818-118">Поток (созданный основным потоком или собственно основным потоком) использует функцию [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) , чтобы ждать, пока пакет завершения помещается в очередь на порт завершения ввода-вывода, а не непосредственно в ожидании завершения асинхронного ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-118">A thread (either one created by the main thread or the main thread itself) uses the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function to wait for a completion packet to be queued to the I/O completion port, rather than waiting directly for the asynchronous I/O to complete.</span></span> <span data-ttu-id="bf818-119">Потоки, которые блокируют выполнение на порте завершения ввода-вывода, освобождаются в порядке ЛИФО, а следующий пакет завершения извлекается из очереди FIFO порта завершения ввода-вывода для этого потока.</span><span class="sxs-lookup"><span data-stu-id="bf818-119">Threads that block their execution on an I/O completion port are released in last-in-first-out (LIFO) order, and the next completion packet is pulled from the I/O completion port's FIFO queue for that thread.</span></span> <span data-ttu-id="bf818-120">Это означает, что при отпускании пакета завершения в поток система освобождает последний (самый последний) поток, связанный с этим портом, и передает ему сведения о завершении для самого старого завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-120">This means that, when a completion packet is released to a thread, the system releases the last (most recent) thread associated with that port, passing it the completion information for the oldest I/O completion.</span></span>

<span data-ttu-id="bf818-121">Хотя любое количество потоков может вызывать [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) для указанного порта завершения ввода-вывода, когда указанный поток вызывает **жеткуеуедкомплетионстатус** в первый раз, он связывается с указанным портом завершения ввода-вывода до тех пор, пока не произойдет одно из трех действий: поток завершает работу, задает другой порт завершения ввода-вывода или закрывает порт завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-121">Although any number of threads can call [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) for a specified I/O completion port, when a specified thread calls **GetQueuedCompletionStatus** the first time, it becomes associated with the specified I/O completion port until one of three things occurs: The thread exits, specifies a different I/O completion port, or closes the I/O completion port.</span></span> <span data-ttu-id="bf818-122">Иными словами, один поток может быть связан с, по крайней мере, одним портом завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-122">In other words, a single thread can be associated with, at most, one I/O completion port.</span></span>

<span data-ttu-id="bf818-123">Когда пакет завершения помещается в очередь на порт завершения ввода-вывода, система сначала проверяет, сколько потоков, связанных с этим портом, выполняется.</span><span class="sxs-lookup"><span data-stu-id="bf818-123">When a completion packet is queued to an I/O completion port, the system first checks how many threads associated with that port are running.</span></span> <span data-ttu-id="bf818-124">Если число выполняемых потоков меньше значения параллелизма (рассматривается в следующем разделе), одному из ожидающих потоков (самая последняя) разрешено обрабатывать пакет завершения.</span><span class="sxs-lookup"><span data-stu-id="bf818-124">If the number of threads running is less than the concurrency value (discussed in the next section), one of the waiting threads (the most recent one) is allowed to process the completion packet.</span></span> <span data-ttu-id="bf818-125">Когда выполняющийся поток завершает свою обработку, он обычно вызывает [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) снова, после чего он либо возвращается со следующим пакетом завершения, либо ожидает, если очередь пуста.</span><span class="sxs-lookup"><span data-stu-id="bf818-125">When a running thread completes its processing, it typically calls [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) again, at which point it either returns with the next completion packet or waits if the queue is empty.</span></span>

<span data-ttu-id="bf818-126">Потоки могут использовать функцию [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) для размещения пакетов завершения в очереди порта завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-126">Threads can use the [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) function to place completion packets in an I/O completion port's queue.</span></span> <span data-ttu-id="bf818-127">Таким образом, порт завершения можно использовать для получения сообщений от других потоков процесса в дополнение к получению пакетов завершения ввода-вывода из системы ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-127">By doing so, the completion port can be used to receive communications from other threads of the process, in addition to receiving I/O completion packets from the I/O system.</span></span> <span data-ttu-id="bf818-128">Функция **PostQueuedCompletionStatus** позволяет приложению ставить в очередь собственные пакеты завершения специального назначения для порта завершения ввода-вывода, не запуская асинхронную операцию ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-128">The **PostQueuedCompletionStatus** function allows an application to queue its own special-purpose completion packets to the I/O completion port without starting an asynchronous I/O operation.</span></span> <span data-ttu-id="bf818-129">Это полезно, например, для уведомления о рабочих потоках внешних событий.</span><span class="sxs-lookup"><span data-stu-id="bf818-129">This is useful for notifying worker threads of external events, for example.</span></span>

<span data-ttu-id="bf818-130">Обработчик порта завершения ввода-вывода и все файлы, связанные с этим конкретным портом завершения ввода-вывода, называются *ссылками на порт завершения ввода*-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-130">The I/O completion port handle and every file handle associated with that particular I/O completion port are known as *references to the I/O completion port*.</span></span> <span data-ttu-id="bf818-131">Порт завершения ввода-вывода освобождается при отсутствии ссылок на него.</span><span class="sxs-lookup"><span data-stu-id="bf818-131">The I/O completion port is released when there are no more references to it.</span></span> <span data-ttu-id="bf818-132">Поэтому все эти дескрипторы должны быть должным образом закрыты, чтобы освободить порт завершения ввода-вывода и связанные с ним системные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="bf818-132">Therefore, all of these handles must be properly closed to release the I/O completion port and its associated system resources.</span></span> <span data-ttu-id="bf818-133">После выполнения этих условий приложение должно закрыть обработчик порта завершения ввода-вывода, вызвав функцию [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) .</span><span class="sxs-lookup"><span data-stu-id="bf818-133">After these conditions are satisfied, an application should close the I/O completion port handle by calling the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function.</span></span>

> [!Note]
>
> <span data-ttu-id="bf818-134">Порт завершения ввода-вывода связан с процессом, который его создал, и не может совместно находиться между процессами.</span><span class="sxs-lookup"><span data-stu-id="bf818-134">An I/O completion port is associated with the process that created it and is not sharable between processes.</span></span> <span data-ttu-id="bf818-135">Однако один и тот же обработчик может совместно работать между потоками в одном процессе.</span><span class="sxs-lookup"><span data-stu-id="bf818-135">However, a single handle is sharable between threads in the same process.</span></span>

 

## <a name="threads-and-concurrency"></a><span data-ttu-id="bf818-136">Потоки и параллелизм</span><span class="sxs-lookup"><span data-stu-id="bf818-136">Threads and Concurrency</span></span>

<span data-ttu-id="bf818-137">Наиболее важным свойством порта завершения ввода-вывода, который следует тщательно рассмотреть, является значение параллелизма.</span><span class="sxs-lookup"><span data-stu-id="bf818-137">The most important property of an I/O completion port to consider carefully is the concurrency value.</span></span> <span data-ttu-id="bf818-138">Значение параллелизма порта завершения указывается при его создании с помощью [**CreateIoCompletionPort**](createiocompletionport.md) через параметр *нумберофконкуррентсреадс* .</span><span class="sxs-lookup"><span data-stu-id="bf818-138">The concurrency value of a completion port is specified when it is created with [**CreateIoCompletionPort**](createiocompletionport.md) via the *NumberOfConcurrentThreads* parameter.</span></span> <span data-ttu-id="bf818-139">Это значение ограничивает количество готовых к запуску потоков, связанных с портом завершения.</span><span class="sxs-lookup"><span data-stu-id="bf818-139">This value limits the number of runnable threads associated with the completion port.</span></span> <span data-ttu-id="bf818-140">Когда общее число готовых к работе потоков, связанных с портом завершения, достигает значения параллелизма, система блокирует выполнение всех последующих потоков, связанных с этим портом завершения, пока количество выполняемых потоков не станет меньше значения параллелизма.</span><span class="sxs-lookup"><span data-stu-id="bf818-140">When the total number of runnable threads associated with the completion port reaches the concurrency value, the system blocks the execution of any subsequent threads associated with that completion port until the number of runnable threads drops below the concurrency value.</span></span>

<span data-ttu-id="bf818-141">Наиболее эффективный сценарий возникает, когда в очереди находятся ожидающие пакеты, но ожидания не могут быть удовлетворены, так как порт достиг ограничения параллелизма.</span><span class="sxs-lookup"><span data-stu-id="bf818-141">The most efficient scenario occurs when there are completion packets waiting in the queue, but no waits can be satisfied because the port has reached its concurrency limit.</span></span> <span data-ttu-id="bf818-142">Рассмотрим, что происходит со значением параллелизма одного и нескольких потоков, ожидающих в вызове функции [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) .</span><span class="sxs-lookup"><span data-stu-id="bf818-142">Consider what happens with a concurrency value of one and multiple threads waiting in the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function call.</span></span> <span data-ttu-id="bf818-143">В этом случае, если очередь всегда содержит ожидающие выполнения пакеты, когда выполняющийся поток вызывает **жеткуеуедкомплетионстатус**, он не будет блокировать выполнение, поскольку, как упоминалось ранее, очередь потока — ЛИФО.</span><span class="sxs-lookup"><span data-stu-id="bf818-143">In this case, if the queue always has completion packets waiting, when the running thread calls **GetQueuedCompletionStatus**, it will not block execution because, as mentioned earlier, the thread queue is LIFO.</span></span> <span data-ttu-id="bf818-144">Вместо этого этот поток немедленно будет принимать следующий пакет завершения в очереди.</span><span class="sxs-lookup"><span data-stu-id="bf818-144">Instead, this thread will immediately pick up the next queued completion packet.</span></span> <span data-ttu-id="bf818-145">Переключение контекста потока не произойдет, так как запущенный поток постоянно выбирает пакеты завершения, и другие потоки не могут быть запущены.</span><span class="sxs-lookup"><span data-stu-id="bf818-145">No thread context switches will occur, because the running thread is continually picking up completion packets and the other threads are unable to run.</span></span>

> [!Note]
>
> <span data-ttu-id="bf818-146">В предыдущем примере дополнительные потоки могут быть бесполезными и никогда не запускаться, но это предполагает, что запущенный поток никогда не помещается в состояние ожидания каким-либо другим механизмом, завершается или закрывает связанный с ним порт завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-146">In the previous example, the extra threads appear to be useless and never run, but that assumes that the running thread never gets put in a wait state by some other mechanism, terminates, or otherwise closes its associated I/O completion port.</span></span> <span data-ttu-id="bf818-147">Учитывайте все подобные последствия выполнения потоков при проектировании приложения.</span><span class="sxs-lookup"><span data-stu-id="bf818-147">Consider all such thread execution ramifications when designing the application.</span></span>

 

<span data-ttu-id="bf818-148">Наибольшее общее максимальное значение, которое нужно выбрать для параметра параллелизма, — число процессоров на компьютере.</span><span class="sxs-lookup"><span data-stu-id="bf818-148">The best overall maximum value to pick for the concurrency value is the number of CPUs on the computer.</span></span> <span data-ttu-id="bf818-149">Если для транзакции требуется длительное вычисление, большее значение параллелизма позволит выполнять больше потоков.</span><span class="sxs-lookup"><span data-stu-id="bf818-149">If your transaction required a lengthy computation, a larger concurrency value will allow more threads to run.</span></span> <span data-ttu-id="bf818-150">Каждый пакет завершения может занять больше времени, но пакеты завершения будут обрабатываться одновременно.</span><span class="sxs-lookup"><span data-stu-id="bf818-150">Each completion packet may take longer to finish, but more completion packets will be processed at the same time.</span></span> <span data-ttu-id="bf818-151">Можно поэкспериментировать со значением параллелизма в сочетании со средствами профилирования, чтобы добиться оптимального результата для приложения.</span><span class="sxs-lookup"><span data-stu-id="bf818-151">You can experiment with the concurrency value in conjunction with profiling tools to achieve the best effect for your application.</span></span>

<span data-ttu-id="bf818-152">Система также позволяет потоку, ожидающему в [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) , обрабатывать пакет завершения, если другой выполняющийся поток, связанный с тем же портом завершения ввода-вывода, переходит в состояние ожидания по другим причинам, например к функции [**суспендсреад**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) .</span><span class="sxs-lookup"><span data-stu-id="bf818-152">The system also allows a thread waiting in [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) to process a completion packet if another running thread associated with the same I/O completion port enters a wait state for other reasons, for example the [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) function.</span></span> <span data-ttu-id="bf818-153">Когда поток в состоянии ожидания начинает выполняться снова, может быть короткий период, когда число активных потоков превысит значение параллелизма.</span><span class="sxs-lookup"><span data-stu-id="bf818-153">When the thread in the wait state begins running again, there may be a brief period when the number of active threads exceeds the concurrency value.</span></span> <span data-ttu-id="bf818-154">Однако система быстро сокращает это число, не разрешая никаких новых активных потоков, пока число активных потоков не станет меньше значения параллелизма.</span><span class="sxs-lookup"><span data-stu-id="bf818-154">However, the system quickly reduces this number by not allowing any new active threads until the number of active threads falls below the concurrency value.</span></span> <span data-ttu-id="bf818-155">Это одна из причин того, что приложение создаст больше потоков в пуле потоков, чем значение параллелизма.</span><span class="sxs-lookup"><span data-stu-id="bf818-155">This is one reason to have your application create more threads in its thread pool than the concurrency value.</span></span> <span data-ttu-id="bf818-156">Управление пулом потоков выходит за рамки этого раздела, но хорошим правилом для Thumb является минимум два потока в пуле потоков, так как в системе есть процессоры.</span><span class="sxs-lookup"><span data-stu-id="bf818-156">Thread pool management is beyond the scope of this topic, but a good rule of thumb is to have a minimum of twice as many threads in the thread pool as there are processors on the system.</span></span> <span data-ttu-id="bf818-157">Дополнительные сведения о пуле потоков см. в разделе [Пулы потоков](/windows/desktop/ProcThread/thread-pools).</span><span class="sxs-lookup"><span data-stu-id="bf818-157">For additional information about thread pooling, see [Thread Pools](/windows/desktop/ProcThread/thread-pools).</span></span>

## <a name="supported-io-functions"></a><span data-ttu-id="bf818-158">Поддерживаемые функции ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="bf818-158">Supported I/O Functions</span></span>

<span data-ttu-id="bf818-159">Следующие функции можно использовать для запуска операций ввода-вывода, которые завершаются с помощью портов завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="bf818-159">The following functions can be used to start I/O operations that complete by using I/O completion ports.</span></span> <span data-ttu-id="bf818-160">Необходимо передать функцию экземпляр [**ПЕРЕкрывающейся**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) структуры и файловый обработчик, который ранее был связан с портом завершения ввода-вывода (путем вызова [**CreateIoCompletionPort**](createiocompletionport.md)), чтобы включить механизм порта завершения ввода-вывода:</span><span class="sxs-lookup"><span data-stu-id="bf818-160">You must pass the function an instance of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure and a file handle previously associated with an I/O completion port (by a call to [**CreateIoCompletionPort**](createiocompletionport.md)) to enable the I/O completion port mechanism:</span></span>

-   [<span data-ttu-id="bf818-161">**коннектнамедпипе**</span><span class="sxs-lookup"><span data-stu-id="bf818-161">**ConnectNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)
-   [<span data-ttu-id="bf818-162">**DeviceIoControl**</span><span class="sxs-lookup"><span data-stu-id="bf818-162">**DeviceIoControl**</span></span>](/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol)
-   [<span data-ttu-id="bf818-163">**локкфиликс**</span><span class="sxs-lookup"><span data-stu-id="bf818-163">**LockFileEx**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-lockfileex)
-   [<span data-ttu-id="bf818-164">**реаддиректоричанжесв**</span><span class="sxs-lookup"><span data-stu-id="bf818-164">**ReadDirectoryChangesW**</span></span>](/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesw)
-   [<span data-ttu-id="bf818-165">**ReadFile**</span><span class="sxs-lookup"><span data-stu-id="bf818-165">**ReadFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-readfile)
-   [<span data-ttu-id="bf818-166">**трансактнамедпипе**</span><span class="sxs-lookup"><span data-stu-id="bf818-166">**TransactNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)
-   [<span data-ttu-id="bf818-167">**ваиткоммевент**</span><span class="sxs-lookup"><span data-stu-id="bf818-167">**WaitCommEvent**</span></span>](/windows/desktop/api/winbase/nf-winbase-waitcommevent)
-   [<span data-ttu-id="bf818-168">**WriteFile**</span><span class="sxs-lookup"><span data-stu-id="bf818-168">**WriteFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-writefile)
-   [<span data-ttu-id="bf818-169">**всасендмсг**</span><span class="sxs-lookup"><span data-stu-id="bf818-169">**WSASendMsg**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg)
-   [<span data-ttu-id="bf818-170">**всасендто**</span><span class="sxs-lookup"><span data-stu-id="bf818-170">**WSASendTo**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendto)
-   [<span data-ttu-id="bf818-171">**всасенд**</span><span class="sxs-lookup"><span data-stu-id="bf818-171">**WSASend**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasend)
-   [<span data-ttu-id="bf818-172">**всареквфром**</span><span class="sxs-lookup"><span data-stu-id="bf818-172">**WSARecvFrom**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom)
-   [<span data-ttu-id="bf818-173">**LPFN_WSARECVMSG (Всареквмсг)**</span><span class="sxs-lookup"><span data-stu-id="bf818-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span></span>](/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg)
-   [<span data-ttu-id="bf818-174">**всарекв**</span><span class="sxs-lookup"><span data-stu-id="bf818-174">**WSARecv**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecv)

## <a name="related-topics"></a><span data-ttu-id="bf818-175">См. также</span><span class="sxs-lookup"><span data-stu-id="bf818-175">Related topics</span></span>

<dl> <span data-ttu-id="bf818-176"><dt>


</dt> <dt></span><span class="sxs-lookup"><span data-stu-id="bf818-176"><dt>


</dt> <dt></span></span>

[<span data-ttu-id="bf818-177">Процессы и потоки</span><span class="sxs-lookup"><span data-stu-id="bf818-177">About Processes and Threads</span></span>](/windows/desktop/ProcThread/about-processes-and-threads)
</dt> <dt>

[<span data-ttu-id="bf818-178">**BindIoCompletionCallback**</span><span class="sxs-lookup"><span data-stu-id="bf818-178">**BindIoCompletionCallback**</span></span>](/windows/desktop/api/winbase/nf-winbase-bindiocompletioncallback)
</dt> <dt>

[<span data-ttu-id="bf818-179">**CreateIoCompletionPort**</span><span class="sxs-lookup"><span data-stu-id="bf818-179">**CreateIoCompletionPort**</span></span>](createiocompletionport.md)
</dt> <dt>

[<span data-ttu-id="bf818-180">**жеткуеуедкомплетионстатус**</span><span class="sxs-lookup"><span data-stu-id="bf818-180">**GetQueuedCompletionStatus**</span></span>](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus)
</dt> <dt>

[<span data-ttu-id="bf818-181">**жеткуеуедкомплетионстатусекс**</span><span class="sxs-lookup"><span data-stu-id="bf818-181">**GetQueuedCompletionStatusEx**</span></span>](getqueuedcompletionstatusex-func.md)
</dt> <dt>

[<span data-ttu-id="bf818-182">**PostQueuedCompletionStatus**</span><span class="sxs-lookup"><span data-stu-id="bf818-182">**PostQueuedCompletionStatus**</span></span>](postqueuedcompletionstatus.md)
</dt> </dl>

 

 
