---
description: Описывает вопросы управления приложениями для буферизации файлов, которые также называются небуферизованными файлами ввода-вывода.
ms.assetid: ae1e5d0f-9b55-4aae-8402-b9c8e33d9363
title: Буферизации файла
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a44f6724622b2c3116fa24a6109efb6c0d9f1d9f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104272278"
---
# <a name="file-buffering"></a><span data-ttu-id="d9c43-103">Буферизации файла</span><span class="sxs-lookup"><span data-stu-id="d9c43-103">File Buffering</span></span>

<span data-ttu-id="d9c43-104">В этом разделе рассматриваются различные вопросы управления приложениями для буферизации файлов, которые также называются небуферизованными файлами ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="d9c43-104">This topic covers the various considerations for application control of file buffering, also known as unbuffered file input/output (I/O).</span></span> <span data-ttu-id="d9c43-105">Буферизация файлов обычно обрабатывается системой в фоновом режиме и считается частью [кэширования файлов](file-caching.md) в операционной системе Windows, если не указано иное.</span><span class="sxs-lookup"><span data-stu-id="d9c43-105">File buffering is usually handled by the system behind the scenes and is considered part of [file caching](file-caching.md) within the Windows operating system unless otherwise specified.</span></span> <span data-ttu-id="d9c43-106">Несмотря на то, что термины *кэширование* и *буферизация* иногда взаимозаменяемы, в этом разделе используется функция *буферизации* , в которой объясняется, как взаимодействовать с данными, которые не кэшируются в кэше (буферизованные) системой, где в основном нет непосредственного управления приложениями пользовательского режима.</span><span class="sxs-lookup"><span data-stu-id="d9c43-106">Although the terms *caching* and *buffering* are sometimes used interchangeably, this topic uses the term *buffering* specifically in the context of explaining how to interact with data that is not being cached (buffered) by the system, where it is otherwise largely out of the direct control of user-mode applications.</span></span>

<span data-ttu-id="d9c43-107">При открытии или создании файла с помощью функции [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) флаг **файла \_ \_ не \_** может быть указан для отключения системного кэширования данных, считываемых из файла или записываемых в него.</span><span class="sxs-lookup"><span data-stu-id="d9c43-107">When opening or creating a file with the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function, the **FILE\_FLAG\_NO\_BUFFERING** flag can be specified to disable system caching of data being read from or written to the file.</span></span> <span data-ttu-id="d9c43-108">Хотя это дает полный и прямой контроль над буферизацией ввода-вывода данных, в случае файлов и аналогичных устройств существуют требования к выравниванию данных, которые необходимо учитывать.</span><span class="sxs-lookup"><span data-stu-id="d9c43-108">Although this gives complete and direct control over data I/O buffering, in the case of files and similar devices there are data alignment requirements that must be considered.</span></span>

> [!Note]  
> <span data-ttu-id="d9c43-109">Эти сведения о выравнивании применяются к операциям ввода-вывода на устройствах, например файлов, поддерживающих поиск, и концепции указателей позиции файла (или *смещений*).</span><span class="sxs-lookup"><span data-stu-id="d9c43-109">This alignment information applies to I/O on devices such as files that support seeking and the concept of file position pointers (or *offsets*).</span></span> <span data-ttu-id="d9c43-110">Для устройств, которые не выполняют поиск, например именованные каналы или устройства связи, отключение буферизации может не требовать определенного выравнивания.</span><span class="sxs-lookup"><span data-stu-id="d9c43-110">For devices that do not seek, such as named pipes or communications devices, turning off buffering may not require any particular alignment.</span></span> <span data-ttu-id="d9c43-111">Все ограничения и эффективность, которые могут быть предоставлены по выравниванию в этом случае, зависят от базовой технологии.</span><span class="sxs-lookup"><span data-stu-id="d9c43-111">Any limitations or efficiencies that may be gained by alignment in that case are dependent on the underlying technology.</span></span>

 

<span data-ttu-id="d9c43-112">В простом примере приложение откроет файл для доступа на запись с флагом **файла без флага \_ \_ \_ буферизации** , а затем выполнит вызов функции [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) , используя буфер данных, определенный в приложении.</span><span class="sxs-lookup"><span data-stu-id="d9c43-112">In a simple example, the application would open a file for write access with the **FILE\_FLAG\_NO\_BUFFERING** flag and then perform a call to the [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) function using a data buffer defined within the application.</span></span> <span data-ttu-id="d9c43-113">Этот локальный буфер в этом случае фактически является единственным буфером файла, который существует для данной операции.</span><span class="sxs-lookup"><span data-stu-id="d9c43-113">This local buffer is, in these circumstances, effectively the only file buffer that exists for this operation.</span></span> <span data-ttu-id="d9c43-114">Из-за структуры физических дисков, структуры хранилища файловой системы и отслеживания положения указателя файлов на уровне системы эта операция записи завершится ошибкой, если только локально определенные буферы данных не удовлетворяют определенным критериям выравнивания, описанным в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="d9c43-114">Because of physical disk layout, file system storage layout, and system-level file pointer position tracking, this write operation will fail unless the locally-defined data buffers meet certain alignment criteria, discussed in the following section.</span></span>

> [!Note]  
> <span data-ttu-id="d9c43-115">Обсуждение кэширования не учитывает аппаратное кэширование на самом физическом диске, которое не обязательно должно находиться в непосредственном управлении системой в любом случае.</span><span class="sxs-lookup"><span data-stu-id="d9c43-115">Discussion of caching does not consider any hardware caching on the physical disk itself, which is not guaranteed to be within the direct control of the system in any case.</span></span> <span data-ttu-id="d9c43-116">Это не влияет на требования, указанные в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="d9c43-116">This has no effect on the requirements specified in this topic.</span></span>

 

<span data-ttu-id="d9c43-117">Дополнительные сведения о том, **как \_ флаг файла \_ без \_ буферизации** взаимодействует с другими флагами, связанными с кэшем, см. в разделе [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span><span class="sxs-lookup"><span data-stu-id="d9c43-117">For more information on how **FILE\_FLAG\_NO\_BUFFERING** interacts with other cache-related flags, see [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span></span>

## <a name="alignment-and-file-access-requirements"></a><span data-ttu-id="d9c43-118">Требования к выравниванию и доступу к файлам</span><span class="sxs-lookup"><span data-stu-id="d9c43-118">Alignment and File Access Requirements</span></span>

<span data-ttu-id="d9c43-119">Как уже говорилось, приложение должно удовлетворять определенным требованиям при работе с файлами, открытыми с **\_ флагом файла \_ без \_ буферизации**.</span><span class="sxs-lookup"><span data-stu-id="d9c43-119">As previously discussed, an application must meet certain requirements when working with files opened with **FILE\_FLAG\_NO\_BUFFERING**.</span></span> <span data-ttu-id="d9c43-120">Применяются следующие особенности.</span><span class="sxs-lookup"><span data-stu-id="d9c43-120">The following specifics apply:</span></span>

-   <span data-ttu-id="d9c43-121">Размеры доступа к файлам, включая необязательное смещение файла в структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) , если оно указано, должно быть целым числом, кратным размеру сектора тома.</span><span class="sxs-lookup"><span data-stu-id="d9c43-121">File access sizes, including the optional file offset in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure, if specified, must be for a number of bytes that is an integer multiple of the volume sector size.</span></span> <span data-ttu-id="d9c43-122">Например, если размер сектора составляет 512 байт, приложение может запрашивать операции чтения и записи для 512, 1 024, 1 536 или 2 048 байт, но не из 335, 981 или 7 171 байт.</span><span class="sxs-lookup"><span data-stu-id="d9c43-122">For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1,024, 1,536, or 2,048 bytes, but not of 335, 981, or 7,171 bytes.</span></span>
-   <span data-ttu-id="d9c43-123">Буферы доступа к файлам для операций чтения и записи должны быть согласованы с физическим сектором, что означает согласование по адресам в памяти, которые являются целыми числами, кратными размеру физического сектора тома.</span><span class="sxs-lookup"><span data-stu-id="d9c43-123">File access buffer addresses for read and write operations should be physical sector-aligned, which means aligned on addresses in memory that are integer multiples of the volume's physical sector size.</span></span> <span data-ttu-id="d9c43-124">В зависимости от диска это требование может быть не применено.</span><span class="sxs-lookup"><span data-stu-id="d9c43-124">Depending on the disk, this requirement may not be enforced.</span></span>

<span data-ttu-id="d9c43-125">Разработчикам приложений следует заметку о новых типах устройств хранения, представленных на рынке, с физическим размером сектора в 4 096 байт.</span><span class="sxs-lookup"><span data-stu-id="d9c43-125">Application developers should take note of new types of storage devices being introduced into the market with a physical media sector size of 4,096 bytes.</span></span> <span data-ttu-id="d9c43-126">Название отрасли для этих устройств — "Расширенный формат".</span><span class="sxs-lookup"><span data-stu-id="d9c43-126">The industry name for these devices is "Advanced Format".</span></span> <span data-ttu-id="d9c43-127">Так как могут возникнуть проблемы совместимости с прямым введением 4 096 байт в качестве единицы адресации для носителя, временное решение совместимости предназначено для введения устройств, которые имитируют регулярное хранилище 512-байтового хранилища, но предоставляют доступ к информации о истинном размере сектора с помощью стандартных команд ATA и SCSI.</span><span class="sxs-lookup"><span data-stu-id="d9c43-127">As there may be compatibility issues with directly introducing 4,096 bytes as the unit of addressing for the media, a temporary compatibility solution is to introduce devices that emulate a regular 512-byte sector storage device but make available information about the true sector size through standard ATA and SCSI commands.</span></span>

<span data-ttu-id="d9c43-128">В результате эмуляции существует два размера секторов, которые разработчики должны понимать:</span><span class="sxs-lookup"><span data-stu-id="d9c43-128">As a result of this emulation, there are in essence two sector sizes that developers will need to understand:</span></span>

-   <span data-ttu-id="d9c43-129">Логический сектор: единица, используемая для адресации логических блоков носителя.</span><span class="sxs-lookup"><span data-stu-id="d9c43-129">Logical Sector: The unit that is used for logical block addressing for the media.</span></span> <span data-ttu-id="d9c43-130">Мы также можем рассматривать его как наименьшую единицу записи, которую может принимать хранилище.</span><span class="sxs-lookup"><span data-stu-id="d9c43-130">We can also think of it as the smallest unit of write that the storage can accept.</span></span> <span data-ttu-id="d9c43-131">Это «эмуляция».</span><span class="sxs-lookup"><span data-stu-id="d9c43-131">This is the "emulation".</span></span>
-   <span data-ttu-id="d9c43-132">Физический сектор. единица, для которой операции чтения и записи на устройстве выполняются за одну операцию.</span><span class="sxs-lookup"><span data-stu-id="d9c43-132">Physical Sector: The unit for which read and write operations to the device are completed in a single operation.</span></span> <span data-ttu-id="d9c43-133">Это единица атомарной операции записи, которую необходимо вычислить для небуферизованного ввода-вывода, чтобы обеспечить оптимальные характеристики производительности и надежности.</span><span class="sxs-lookup"><span data-stu-id="d9c43-133">This is the unit of atomic write, and what unbuffered I/O will need to be aligned to in order to have optimal performance and reliability characteristics.</span></span>

<span data-ttu-id="d9c43-134">Большинство текущих интерфейсов API Windows, таких как [**ioctl \_ диска \_ Get \_ Drive \_ Geometry**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) и [**жетдискфриспаце**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), возвращают размер логического сектора, но размер физического сектора можно получить с помощью управляющего кода [**\_ \_ запроса \_ на хранение**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) , с соответствующей информацией, содержащейся в элементе **битесперфисикалсектор** в структуре [**\_ \_ \_ дескриптора выравнивания доступа к хранилищу**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) .</span><span class="sxs-lookup"><span data-stu-id="d9c43-134">Most current Windows APIs, such as [**IOCTL\_DISK\_GET\_DRIVE\_GEOMETRY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) and [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), will return the logical sector size, but the physical sector size can be retrieved through the [**IOCTL\_STORAGE\_QUERY\_PROPERTY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) control code, with the relevant information contained in the **BytesPerPhysicalSector** member in the [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure.</span></span> <span data-ttu-id="d9c43-135">Пример см. в примере кода в [**\_ \_ \_ дескрипторе выравнивания доступа к хранилищу**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span><span class="sxs-lookup"><span data-stu-id="d9c43-135">For an example, see the sample code at [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span></span> <span data-ttu-id="d9c43-136">Корпорация Майкрософт настоятельно рекомендует разработчикам выдавать небуферизованные операции ввода-вывода в физический размер сектора, как показано в коде элемента управления **\_ \_ \_ Свойства запроса на хранение ioctl** , чтобы обеспечить подготовку приложений к переходу на этот размер сектора.</span><span class="sxs-lookup"><span data-stu-id="d9c43-136">Microsoft strongly recommends that developers align unbuffered I/O to the physical sector size as reported by the **IOCTL\_STORAGE\_QUERY\_PROPERTY** control code to help ensure their applications are prepared for this sector size transition.</span></span>

<span data-ttu-id="d9c43-137">**Windows Server 2003 и Windows XP:** Структура [**\_ \_ \_ дескриптора выравнивания доступа к хранилищу**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) недоступна.</span><span class="sxs-lookup"><span data-stu-id="d9c43-137">**Windows Server 2003 and Windows XP:** The [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure is not available.</span></span> <span data-ttu-id="d9c43-138">Он появился в Windows Vista и Windows Server 2008.</span><span class="sxs-lookup"><span data-stu-id="d9c43-138">It was introduced with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="d9c43-139">Так как буферные адреса для операций чтения и записи должны быть согласованы по секторам, приложение должно иметь прямой контроль над способом выделения этих буферов.</span><span class="sxs-lookup"><span data-stu-id="d9c43-139">Because buffer addresses for read and write operations must be sector-aligned, the application must have direct control of how these buffers are allocated.</span></span> <span data-ttu-id="d9c43-140">Одним из способов распределения буферов по секторам является использование функции [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) для выделения буферов.</span><span class="sxs-lookup"><span data-stu-id="d9c43-140">One way to sector-align buffers is to use the [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function to allocate the buffers.</span></span> <span data-ttu-id="d9c43-141">Рассмотрим следующий пример.</span><span class="sxs-lookup"><span data-stu-id="d9c43-141">Consider the following:</span></span>

-   <span data-ttu-id="d9c43-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) выделяет память, согласованную по адресам, которые являются целыми числами, кратными размеру страницы системы.</span><span class="sxs-lookup"><span data-stu-id="d9c43-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) allocates memory that is aligned on addresses that are integer multiples of the system's page size.</span></span> <span data-ttu-id="d9c43-143">Размер страницы составляет 4 096 байт на x64 и x86 или 8 192 байт для систем на базе процессоров Itanium.</span><span class="sxs-lookup"><span data-stu-id="d9c43-143">Page size is 4,096 bytes on x64 and x86 or 8,192 bytes for Itanium-based systems.</span></span> <span data-ttu-id="d9c43-144">Дополнительные сведения см. в описании функции [**жетсистеминфо**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) .</span><span class="sxs-lookup"><span data-stu-id="d9c43-144">For additional information, see the [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) function.</span></span>
-   <span data-ttu-id="d9c43-145">Размер сектора обычно 512 – 4 096 байт для устройств хранения с прямым доступом (жестких дисков) и 2 048 байт для компакт-дисков.</span><span class="sxs-lookup"><span data-stu-id="d9c43-145">Sector size is typically 512 to 4,096 bytes for direct-access storage devices (hard drives) and 2,048 bytes for CD-ROMs.</span></span>
-   <span data-ttu-id="d9c43-146">Размеры страниц и секторов — это степени 2.</span><span class="sxs-lookup"><span data-stu-id="d9c43-146">Both page and sector sizes are powers of 2.</span></span>

<span data-ttu-id="d9c43-147">Таким образом, в большинстве случаев память с согласованием по страницам также будет соответствовать секторам, так как размер сектора больше, чем размер страницы, редко.</span><span class="sxs-lookup"><span data-stu-id="d9c43-147">Therefore, in most situations, page-aligned memory will also be sector-aligned, because the case where the sector size is larger than the page size is rare.</span></span>

<span data-ttu-id="d9c43-148">Другой способ получить буферы памяти, выданный вручную, — использовать функцию с [ \_ согласованной функцией \_ malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) из библиотеки C Run-Time.</span><span class="sxs-lookup"><span data-stu-id="d9c43-148">Another way to obtain manually-aligned memory buffers is to use the [\_aligned\_malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) function from the C Run-Time library.</span></span> <span data-ttu-id="d9c43-149">Пример того, как можно вручную управлять выравниванием буфера, см. в примере кода языка C++ в разделе пример кода в [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="d9c43-149">For an example of how to manually control buffer alignment, see the C++ language code example in the Example Code section of [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span>

 

 
