---
description: Операция блочного клона указывает файловой системе копировать диапазон байт файлов от имени приложения.
ms.assetid: E18E8D79-3985-40B8-A4C5-A73A21E5C527
title: Блокировать клонирование
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b33aa1c1eee693b6ed4b502aedc6da6176ece3e9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104546703"
---
# <a name="block-cloning"></a><span data-ttu-id="259e2-103">Блокировать клонирование</span><span class="sxs-lookup"><span data-stu-id="259e2-103">Block Cloning</span></span>

<span data-ttu-id="259e2-104">Операция *блочного клона* указывает файловой системе копировать диапазон байт файлов от имени приложения.</span><span class="sxs-lookup"><span data-stu-id="259e2-104">A *block clone* operation instructs the file system to copy a range of file bytes on behalf of an application.</span></span> <span data-ttu-id="259e2-105">Конечный файл может совпадать с исходным файлом или отличаться от него.</span><span class="sxs-lookup"><span data-stu-id="259e2-105">The destination file may be the same as, or different from, the source file.</span></span>

<span data-ttu-id="259e2-106">Файловая система управляет сопоставлениями [кластеров и экстентов](clusters-and-extents.md)и может выполнять копирование путем изменения номера виртуального кластера (VCN) на сопоставления номеров логических кластеров (LCN) как операции с недорогими метаданными вместо чтения и записи базовых данных файла.</span><span class="sxs-lookup"><span data-stu-id="259e2-106">A file system manages the mappings of [Clusters and Extents](clusters-and-extents.md), and may be able to perform the copy by altering the virtual cluster number (VCN) to logical cluster number (LCN) mappings as a low-cost metadata operation, rather than reading and writing the underlying file data.</span></span> <span data-ttu-id="259e2-107">Это позволяет быстрее завершить копирование и выдает меньше операций ввода-вывода в базовое хранилище.</span><span class="sxs-lookup"><span data-stu-id="259e2-107">This allows the copy to complete faster and generates less I/O to the underlying storage.</span></span> <span data-ttu-id="259e2-108">Более того, несколько файлов теперь могут совместно использовать логические кластеры после клонирования блока, сохраняя емкость, не сохраняя идентичные кластеры несколько раз на диске.</span><span class="sxs-lookup"><span data-stu-id="259e2-108">Moreover, multiple files may now share logical clusters after the block clone, saving capacity by not storing identical clusters multiple times on disk.</span></span>

<span data-ttu-id="259e2-109">Операция блочной клонирования не нарушает изоляцию, предоставленную между файлами.</span><span class="sxs-lookup"><span data-stu-id="259e2-109">A block clone operation does not break the isolation provided between files.</span></span> <span data-ttu-id="259e2-110">После завершения клонирования блока записи в исходный файл не отображаются в месте назначения или наоборот.</span><span class="sxs-lookup"><span data-stu-id="259e2-110">After a block clone completes, writes to the source file do not appear in the destination, or vice versa.</span></span>

<span data-ttu-id="259e2-111">Клонирование блоков доступно только для типа [файловой системы ReFS](/windows/desktop/w8cookbook/resilient-file-system--refs-) , начиная с Windows Server 2016.</span><span class="sxs-lookup"><span data-stu-id="259e2-111">Block cloning is available only on the [ReFS file system](/windows/desktop/w8cookbook/resilient-file-system--refs-) type beginning with Windows Server 2016.</span></span>

## <a name="block-cloning-on-refs"></a><span data-ttu-id="259e2-112">Блокировать клонирование в ReFS</span><span class="sxs-lookup"><span data-stu-id="259e2-112">Block Cloning on ReFS</span></span>

<span data-ttu-id="259e2-113">ReFS на Windows Server 2016 реализует клонирование блоков путем повторного сопоставления логических кластеров (т. е. физических расположений на томе) из исходного региона в целевой.</span><span class="sxs-lookup"><span data-stu-id="259e2-113">ReFS on Windows Server 2016 implements block cloning by remapping logical clusters (that is, physical locations on a volume) from the source region to the destination region.</span></span> <span data-ttu-id="259e2-114">Затем для обеспечения изоляции между этими регионами используется механизм выделения и записи.</span><span class="sxs-lookup"><span data-stu-id="259e2-114">It then uses an allocate-on-write mechanism to ensure isolation between those regions.</span></span> <span data-ttu-id="259e2-115">Исходный и конечный регионы могут находиться в одном или разных файлах.</span><span class="sxs-lookup"><span data-stu-id="259e2-115">The source and destination regions may be in the same, or different, files.</span></span>

<span data-ttu-id="259e2-116">Для этой реализации требуется, чтобы начальные и конечные смещения файлов были согласованы с границами кластера.</span><span class="sxs-lookup"><span data-stu-id="259e2-116">This implementation requires that the starting and ending file offsets be aligned to cluster boundaries.</span></span> <span data-ttu-id="259e2-117">В ReFS на Windows Server 2016 размер кластеров по умолчанию составляет 4 КБ, но при необходимости можно установить значение 64 КБ.</span><span class="sxs-lookup"><span data-stu-id="259e2-117">In ReFS on Windows Server 2016, clusters are 4KB in size by default, but can optionally be set to 64KB.</span></span> <span data-ttu-id="259e2-118">Размер кластера является набором параметров на уровне всего тома во время форматирования.</span><span class="sxs-lookup"><span data-stu-id="259e2-118">The cluster size is a volume-wide parameter set at format time.</span></span>

## <a name="restrictions-and-remarks"></a><span data-ttu-id="259e2-119">Ограничения и примечания</span><span class="sxs-lookup"><span data-stu-id="259e2-119">Restrictions and Remarks</span></span>

-   <span data-ttu-id="259e2-120">Исходный и конечный регионы должны начинаться и заканчиваться на границе кластера.</span><span class="sxs-lookup"><span data-stu-id="259e2-120">The source and destination regions must begin and end at a cluster boundary.</span></span>
-   <span data-ttu-id="259e2-121">Размер клонированной области должен быть меньше 4 ГБ.</span><span class="sxs-lookup"><span data-stu-id="259e2-121">The cloned region must be less than 4GB in length.</span></span>
-   <span data-ttu-id="259e2-122">Регион назначения не должен превышать конец файла.</span><span class="sxs-lookup"><span data-stu-id="259e2-122">The destination region must not extend past the end of file.</span></span> <span data-ttu-id="259e2-123">Если приложению нужно расширить целевой объект с клонированными данными, сначала необходимо вызвать [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span><span class="sxs-lookup"><span data-stu-id="259e2-123">If the application wishes to extend the destination with cloned data, it must first call [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span></span>
-   <span data-ttu-id="259e2-124">Если исходная и конечная области находятся в одном файле, они не должны пересекаться.</span><span class="sxs-lookup"><span data-stu-id="259e2-124">If the source and destination regions are in the same file, they must not overlap.</span></span> <span data-ttu-id="259e2-125">(Приложение может выполнить процедуру, разделив операцию клонирования блока на несколько клонов блоков, которые больше не перекрываются.)</span><span class="sxs-lookup"><span data-stu-id="259e2-125">(The application may able to proceed by splitting up the block clone operation into multiple block clones that no longer overlap.)</span></span>
-   <span data-ttu-id="259e2-126">Исходный и конечный файлы должны размещаться на одном томе ReFS.</span><span class="sxs-lookup"><span data-stu-id="259e2-126">The source and destination files must be on the same ReFS volume.</span></span>
-   <span data-ttu-id="259e2-127">Исходный и конечный файлы должны иметь одинаковые параметры [**потоков целостности**](file-attribute-constants.md) (то есть потоки целостности должны быть включены в обоих файлах или отключены в обоих файлах).</span><span class="sxs-lookup"><span data-stu-id="259e2-127">The source and destination files must have the same [**Integrity Streams**](file-attribute-constants.md) setting (that is, Integrity Streams must be enabled in both files, or disabled in both files).</span></span>
-   <span data-ttu-id="259e2-128">Если исходный файл разреженные, конечный файл также должен быть разреженным.</span><span class="sxs-lookup"><span data-stu-id="259e2-128">If the source file is sparse, the destination file must also be sparse.</span></span>
-   <span data-ttu-id="259e2-129">Операция клонирования блока приведет к нарушению общих уступающей блокировок (также известных как [оппортунистической блокировки уровня 2](types-of-opportunistic-locks.md)).</span><span class="sxs-lookup"><span data-stu-id="259e2-129">The block clone operation will break Shared Opportunistic Locks (also known as [Level 2 Opportunistic Locks](types-of-opportunistic-locks.md)).</span></span>
-   <span data-ttu-id="259e2-130">Том ReFS должен быть отформатирован в Windows Server 2016, и если используется отказоустойчивая кластеризация Windows, функциональный уровень кластеризации должен быть Windows Server 2016 или более поздней версии во время форматирования.</span><span class="sxs-lookup"><span data-stu-id="259e2-130">The ReFS volume must have been formatted with Windows Server 2016, and if Windows Failover Clustering is in use, the Clustering Functional Level must have been Windows Server 2016 or later at format time.</span></span>

## <a name="example"></a><span data-ttu-id="259e2-131">Пример</span><span class="sxs-lookup"><span data-stu-id="259e2-131">Example</span></span>

<span data-ttu-id="259e2-132">Предположим, что у нас есть два файла: X и Y, каждый из которых состоит из трех различных регионов.</span><span class="sxs-lookup"><span data-stu-id="259e2-132">Suppose we have two files, X and Y, where each file is composed of 3 distinct regions.</span></span> <span data-ttu-id="259e2-133">Каждая область файла хранится в отдельном регионе тома.</span><span class="sxs-lookup"><span data-stu-id="259e2-133">Each file region is stored on a distinct region of the volume.</span></span> <span data-ttu-id="259e2-134">Файловая система хранит набор знаний, на который ссылается каждый из этих регионов тома в одной области файла:</span><span class="sxs-lookup"><span data-stu-id="259e2-134">The file system stores the knowledge that each of those volume regions is referenced in one file region:</span></span>

![перед клонированием](images/before-clone.png)

<span data-ttu-id="259e2-136">Теперь предположим, что приложение создает операцию блочного клонирования из файла X, в регионах файлов A и B, в файл Y на смещении, где в настоящее время находится.</span><span class="sxs-lookup"><span data-stu-id="259e2-136">Now suppose an application issues a block clone operation from File X, over file regions A and B, to File Y at the offset where E currently is.</span></span> <span data-ttu-id="259e2-137">Будет получено следующее состояние файловой системы:</span><span class="sxs-lookup"><span data-stu-id="259e2-137">The following file system state would result:</span></span>

![После клонирования](images/after-clone.png)

<span data-ttu-id="259e2-139">Данные в регионах A и B были фактически дублируются из файла X в файл Y путем изменения сопоставлений VCN и LCN в томе ReFS.</span><span class="sxs-lookup"><span data-stu-id="259e2-139">The data in regions A and B were effectively duplicated from File X to File Y by altering the VCN to LCN mappings within the ReFS volume.</span></span> <span data-ttu-id="259e2-140">Области диска, на которых находятся резервные регионы A и B, не были прочитаны, а также не были сохранены в дисках старые регионы E и F, перезаписанные во время операции.</span><span class="sxs-lookup"><span data-stu-id="259e2-140">The disk extents backing regions A and B were not read, nor were the disk extents backing the old regions E and F overwritten during the operation.</span></span>

<span data-ttu-id="259e2-141">Файлы X и Y теперь совместно используют логические кластеры на диске.</span><span class="sxs-lookup"><span data-stu-id="259e2-141">Files X and Y now share logical clusters on disk.</span></span> <span data-ttu-id="259e2-142">Это отражено в счетчиках ссылок, показанных в таблице.</span><span class="sxs-lookup"><span data-stu-id="259e2-142">This is reflected in the reference counts shown in the table.</span></span> <span data-ttu-id="259e2-143">Общий доступ приводит к снижению емкости тома, чем в случае дублирования регионов A и B на базовом томе.</span><span class="sxs-lookup"><span data-stu-id="259e2-143">The sharing results in lower volume capacity consumption than if regions A and B were duplicated on the underlying volume.</span></span>

<span data-ttu-id="259e2-144">Теперь предположим, что приложение перезаписывает регион а в файле X. ReFS создает копию, которая теперь будет вызывать G. ReFS, затем сопоставляет G с файлом X и применяет изменения.</span><span class="sxs-lookup"><span data-stu-id="259e2-144">Now, suppose the application overwrites region A in File X. ReFS makes a duplicate copy of A, which we’ll now call G. ReFS then maps G into File X, and applies the modification.</span></span> <span data-ttu-id="259e2-145">Это сохраняет изоляцию между файлами.</span><span class="sxs-lookup"><span data-stu-id="259e2-145">This ensures that isolation between the files is preserved.</span></span> <span data-ttu-id="259e2-146">Счетчики ссылок обновляются соответствующим образом:</span><span class="sxs-lookup"><span data-stu-id="259e2-146">Reference counts are updated appropriately:</span></span>

![После изменения записи](images/after-modifying-write.png)

<span data-ttu-id="259e2-148">После изменения записи, регион б по-прежнему будет совместно использоваться на диске.</span><span class="sxs-lookup"><span data-stu-id="259e2-148">After the modifying write, region B is still shared on disk.</span></span> <span data-ttu-id="259e2-149">Обратите внимание, что если область A больше кластера, только измененный кластер будет дублирован, а оставшееся часть останется общей.</span><span class="sxs-lookup"><span data-stu-id="259e2-149">Note that if region A were larger than a cluster, only the modified cluster would have been duplicated, and the remaining portion would have remained shared.</span></span>

## <a name="related-topics"></a><span data-ttu-id="259e2-150">См. также</span><span class="sxs-lookup"><span data-stu-id="259e2-150">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="259e2-151">**ДУБЛИРОВАНие \_ данных экстентов \_**</span><span class="sxs-lookup"><span data-stu-id="259e2-151">**DUPLICATE\_EXTENTS\_DATA**</span></span>](/windows/desktop/api/WinIoCtl/ns-winioctl-duplicate_extents_data)
</dt> <dt>

[<span data-ttu-id="259e2-152">**ФСКТЛ \_ дубликаты \_ экстентов \_ в \_ файл**</span><span class="sxs-lookup"><span data-stu-id="259e2-152">**FSCTL\_DUPLICATE\_EXTENTS\_TO\_FILE**</span></span>](/windows/win32/api/winioctl/ni-winioctl-fsctl_duplicate_extents_to_file)
</dt> </dl>

 

 
