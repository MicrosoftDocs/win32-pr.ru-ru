---
description: В этом разделе описывается запуск и завершение потока обработки заданий печати.
ms.assetid: CA3A81D6-332F-4867-881F-AC6859A076CF
title: Как запускать и прекращать поток печати
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d9a47f81e384a135bb70e6deabefe15a3408a04
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104272487"
---
# <a name="how-to-start-and-stop-a-printing-thread"></a>Как запускать и прекращать поток печати

В этом разделе описывается запуск и завершение потока обработки заданий печати.

## <a name="overview"></a>Обзор

Чтобы запретить действиям печати блокировать ответ пользовательского интерфейса, создайте отдельный поток для обработки задания печати. Поток, запускаемый при запуске программы, — это поток, который обрабатывает сообщения окна, являющиеся результатом взаимодействия с пользователем, и, следовательно, поток пользовательского интерфейса. Программа должна обрабатывать эти сообщения без задержки, чтобы пользовательский интерфейс своевременно отвечал на вход пользователя и на клавиатуру. Чтобы программа могла быстро реагировать на эти сообщения, объем обработки, который может быть выполнен в рамках одного сообщения, ограничен. Когда для запроса пользователя требуется расширенная обработка, другой поток должен выполнить эту обработку, чтобы обеспечить обработку последующего взаимодействия с пользователем в программе.

Обработка данных в отдельном потоке требует, чтобы программа координирует работу потока пользовательского интерфейса и потока обработки. Например, пока поток обработки обрабатывает данные, основной поток не должен изменять эти данные. Одним из способов управления это является поточно-ориентированные объекты синхронизации, такие как семафоры, события и мьютексы.

В то же время во время выполнения потока обработки необходимо предотвратить некоторое вмешательство пользователя. В демонстрационной программе данные приложения защищаются, и взаимодействие с пользователем ограничено за счет управления обработкой заданий печати с помощью диалогового окна "модальное выполнение". Модальное диалоговое окно предотвращает взаимодействие пользователя с главным окном программы, что предотвращает изменение пользователем данных программы во время печати данных.

Единственным действием, которое может выполнить пользователь во время обработки задания печати, является отмена задания печати. Это ограничение сообщает пользователю по форме курсора. Когда курсор находится над кнопкой **Отмена** , отображается курсор со стрелкой, который указывает, что пользователь может нажать эту кнопку. Когда курсор находится над любой другой частью области окна программы, отображается курсор ожидания, который указывает, что программа занята и не может ответить на ввод данных пользователем.

## <a name="creating-the-printing-thread-procedure"></a>Создание процедуры потока печати

Мы рекомендуем включить эти функции во время обработки печати.

-   **Обработка печати делится на этапы**

    Можно разделить обработку печати на дискретные этапы обработки, которые можно прервать, если пользователь нажмет кнопку **Отмена** . Это полезно, поскольку обработка печати может включать ресурсоемкие операции. Разбиение этой обработки на шаги может помешать обработке печати блокировать или откладывать другие потоки или процессы. Разбиение обработки на логические шаги также позволяет четко завершить обработку печати в любой момент, чтобы завершить задание печати до его завершения, не покидая ни одного потерянного ресурса.

    Это пример списка шагов печати.

    ```C++
    HRESULT PrintStep_1_StartJob (PPRINTTHREADINFO threadInfo);
    HRESULT PrintStep_2_DoOnePackage (PPRINTTHREADINFO threadInfo);
    HRESULT PrintStep_3_DoOneDoc (PPRINTTHREADINFO threadInfo);
    HRESULT PrintStep_4_DoOnePage (PPRINTTHREADINFO threadInfo);
    HRESULT PrintStep_5_ClosePackage (PPRINTTHREADINFO threadInfo);
    HRESULT PrintStep_6_CloseJob (PPRINTTHREADINFO threadInfo);
    ```

    

-   **Проверка события Cancel между шагами**

    Когда пользователь нажимает кнопку **Отмена** , поток пользовательского интерфейса сигнализирует о событии Cancel. Поток обработки должен периодически проверять событие Cancel, чтобы узнать, когда пользователь нажмет кнопку **"Отмена** ". Инструкции [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) выполняют эту проверку, а также предоставляют другим программам возможность запуска, чтобы обработка задания печати не блокировала или не задерживает другие потоки или процессы.

    В следующем примере кода показан один из тестов, позволяющий определить, произошло ли событие Cancel.

    ```C++
    waitStatus = WaitForSingleObject (
                    threadInfo->quitEvent, 
                    stepDelay);
    if (WAIT_OBJECT_0 == waitStatus)
    {
        hr = E_ABORT;
    }
    ```

    

-   **Отправка обновлений состояния в поток пользовательского интерфейса**

    Как и каждый шаг обработки печати, поток обработки печати отправляет сообщения обновления в диалоговое окно "ход печати", чтобы оно может обновить индикатор выполнения. Обратите внимание, что диалоговое окно "ход печати" выполняется в потоке пользовательского интерфейса.

    В следующем примере кода показано одно из вызовов сообщения об обновлении.

    ```C++
    // Update print status
    PostMessage (
        threadInfo->parentWindow, 
        USER_PRINT_STATUS_UPDATE, 
        0L, 
        0L);
    ```

    

## <a name="starting-the-printing-thread"></a>Запуск потока печати

Поток обработки печати выполняется до тех пор, пока функция Принтсреадпрок не вернет значение. Чтобы запустить поток печати, выполните следующие действия.

1.  **Подготовьте данные и элементы пользовательского интерфейса для печати.**

    Перед запуском потока обработки печати необходимо инициализировать элементы данных, которые описывают задание печати и элементы пользовательского интерфейса. Эти элементы включают состояние курсора, поэтому курсор ожидания будет отображаться соответствующим образом. Также необходимо настроить индикатор выполнения, чтобы он отражал размер задания печати. Эти подготовительные действия подробно описаны в статье [как получить сведения о задании печати от пользователя](preparing-to-print.md).

    В следующем примере кода показано, как настроить индикатор выполнения, чтобы отразить размер задания печати, запрошенного пользователем.

    ```C++
    // Compute the number of steps in this job.
    stepCount = (((
                // One copy of a document contains
                //  one step for each page +
                //  one step for the document
                ((threadInfo->documentContent)->pages + 1) * 
                // Each copy of the document includes
                //  two steps to open and close the document
                threadInfo->copies) + 2) * 
                // Each job includes one step to start the job
                threadInfo->packages) + 1;
    // Send the total number of steps to the progress bar control.
    SendMessage (
        dlgInfo->progressBarWindow, 
        PBM_SETRANGE32, 
        0L, 
        (stepCount));
    ```

    

2.  **Запустите поток обработки печати.**

    Вызовите функцию [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) , чтобы запустить поток обработки.

    В следующем примере кода запускается поток обработки.

    ```C++
    // Start the printing thread
    threadInfo->printThreadHandle = CreateThread (
                    NULL, 
                    0L, 
                    (LPTHREAD_START_ROUTINE)PrintThreadProc,
                    (LPVOID)threadInfo, 
                    0L, 
                    &threadInfo->printThreadId);
    ```

    

3.  **Проверьте, не завершилась ли обработка печати при запуске.**

    Функция [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) возвращает маркер созданному потоку, если поток был успешно создан. Функция Принтсреадпрок, которая была запущена в новом потоке, проверяет некоторые условия до того, как начнется фактическая обработка задания печати. Если обнаруживаются ошибки в этих проверках, Принтсреадпрок может вернуть данные без обработки каких бы то ни было данных задания печати. Поток пользовательского интерфейса может проверить, успешно ли запущен поток обработки, ожидая обработки в течение определенного периода времени, превышающего время, необходимое для выполнения начальных тестов, но больше не нужно. Когда поток завершает работу, дескриптор потока получает сигнал. Код проверяет состояние потока на короткий период времени после запуска потока обработки. Функция [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) возвращает значение, если истекло время ожидания или когда дескриптор потока получает сигнал. Если функция **WaitForSingleObject** возвращает состояние **ожидания \_ объекта \_ 0** , поток завершился раньше, поэтому следует закрыть диалоговое окно хода выполнения, как показано в следующем примере кода.

    ```C++
    // Make sure the printing thread started OK
    //  by waiting to see if it is still running after
    //  a short period of time. This time delay should be
    //  long enough to know that it's running but shorter
    //  than the shortest possible print job.
    waitStatus = WaitForSingleObject (
        threadInfo->printThreadHandle, 
        THREAD_START_WAIT);

    // If the object is signaled, that means that the
    //  thread terminated before the timeout period elapsed.
    if (WAIT_OBJECT_0 == waitStatus)
    {
        // The thread exited, so post close messages.
        PostMessage (hDlg, USER_PRINT_CLOSING, 0L, (LPARAM)E_FAIL);
        PostMessage (hDlg, USER_PRINT_COMPLETE, 0L, (LPARAM)E_FAIL);
    }
    ```

    

## <a name="stopping-the-printing-thread"></a>Остановка потока печати

Когда пользователь нажимает кнопку **"Отмена** " в диалоговом окне "ход печати", поток печати получает уведомления, чтобы он мог прекратить обработку задания печати упорядоченным образом. Хотя кнопка **Cancel** и событие **куитевент** являются важными аспектами этой обработки, необходимо спроектировать всю последовательность обработки для успешного прерывания. Это означает, что шаги последовательности не должны оставлять выделенные ресурсы, которые не освобождаются, если пользователь отменит последовательность до ее завершения.

В следующем примере кода показано, как образец программы проверяет **куитевент** перед обработкой каждой страницы печатаемого документа. Если **куитевент** получает сигнал или обнаружена ошибка, обработка печати останавливается.


```C++
// While no errors and the user hasn't clicked cancel...
while (((waitStatus = WaitForSingleObject (
                        threadInfo->quitEvent, 
                        stepDelay)) == WAIT_TIMEOUT) &&
        SUCCEEDED(hr))
{
    // ...print one page
    hr = PrintStep_4_DoOnePage (threadInfo);

    // Update print status
    PostMessage (
        threadInfo->parentWindow, 
        USER_PRINT_STATUS_UPDATE, 
        0L, 
        0L);
    

    if (threadInfo->currentPage < (threadInfo->documentContent)->pages)
    {
        // More pages, so continue to the next one
        threadInfo->currentPage++;
    }
    else
    {
        // Last page printed so exit loop and close
        break;
    }
}
```



 

 
