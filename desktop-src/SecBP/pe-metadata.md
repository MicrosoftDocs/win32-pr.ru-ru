---
description: В этой статье содержатся дополнительные сведения о метаданных Guard в потоках управления в образах PE.
title: Метаданные PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105664650"
---
# <a name="pe-metadata"></a><span data-ttu-id="2d1a1-103">Метаданные PE</span><span class="sxs-lookup"><span data-stu-id="2d1a1-103">PE metadata</span></span>

<span data-ttu-id="2d1a1-104">В этой статье содержатся дополнительные сведения о метаданных (CFG) управляющего потока управления в образах PE.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-104">This article provides additional details for Control Flow Guard (CFG) metadata in PE images.</span></span> <span data-ttu-id="2d1a1-105">Предполагается знание структуры для метаданных CFG в образах PE.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-105">Familiarity with the structure for CFG metadata in PE images is assumed.</span></span> <span data-ttu-id="2d1a1-106">См. раздел [Формат PE](../debug/pe-format.md) для высокоуровневой документации по метаданным cfg в образах PE.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-106">See the [PE Format](../debug/pe-format.md) topic for high-level documentation for CFG metadata in PE images.</span></span>

- <span data-ttu-id="2d1a1-107">Функции, которые являются допустимыми целями косвенных вызовов, перечислены в **гуардкффунктионтабле** , прикрепленном к каталогу конфигурации загрузки, иногда **гфидс** таблицу для краткости.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-107">Functions that are valid indirect call targets are listed in the **GuardCFFunctionTable** attached to the load configuration directory, sometimes termed the **GFIDS** table for brevity.</span></span> <span data-ttu-id="2d1a1-108">Это отсортированный список относительных виртуальных адресов (RVA), содержащих сведения о допустимых целевых объектах вызова CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-108">This is a sorted list of relative virtual addresses (RVA) that contain information about valid CFG call targets.</span></span> <span data-ttu-id="2d1a1-109">Обычно это говорят, что используются символы функции.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-109">These are, generally speaking, address taken function symbols.</span></span> <span data-ttu-id="2d1a1-110">Образ, которому требуется принудительное применение CFG, должен перечислить все символы, созданные в своей таблице **гфидс** .</span><span class="sxs-lookup"><span data-stu-id="2d1a1-110">An image that wants CFG enforcement must enumerate all address taken function symbols in its **GFIDS** table.</span></span> <span data-ttu-id="2d1a1-111">Список RVA в таблице **гфидс** должен быть отсортирован правильно или изображение не будет загружено.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-111">The RVA list in the **GFIDS** table must be sorted properly or the image will not be loaded.</span></span> <span data-ttu-id="2d1a1-112">Таблица **гфидс** представляет собой массив из 4 + *n* байт, где *n* задается ((гуардфлагс & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span><span class="sxs-lookup"><span data-stu-id="2d1a1-112">The **GFIDS** table is an array of 4 + *n* bytes, where *n* is given by ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span></span> <span data-ttu-id="2d1a1-113">"Гуардфлагс" — это поле Гуардфлагс в каталоге конфигурации загрузки.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-113">“GuardFlags” is the GuardFlags field of the load configuration directory.</span></span> <span data-ttu-id="2d1a1-114">Это позволяет прикреплять дополнительные метаданные к целям вызова CFG в будущем.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-114">This allows for extra metadata to be attached to CFG call targets in the future.</span></span> <span data-ttu-id="2d1a1-115">Единственными определенными в данный момент метаданными является необязательное дополнительное поле дополнительных флагов ("ГФИДС Flags"), присоединенное к каждой записи **гфидс** , если у целей вызова есть метаданные.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-115">The only currently defined metadata is an optional 1-byte extra flags field (“GFIDS flags”) that is attached to each **GFIDS** entry if any call targets have metadata.</span></span> <span data-ttu-id="2d1a1-116">Определены два флага **гфидс** :</span><span class="sxs-lookup"><span data-stu-id="2d1a1-116">There are two **GFIDS** flags defined:</span></span>
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | <span data-ttu-id="2d1a1-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span><span class="sxs-lookup"><span data-stu-id="2d1a1-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span></span> | <span data-ttu-id="2d1a1-118">Цель вызова явно подавлена (не обрабатывать ее как допустимую для целей CFG)</span><span class="sxs-lookup"><span data-stu-id="2d1a1-118">Call target is explicitly suppressed (do not treat it as valid for purposes of CFG)</span></span> |
  | <span data-ttu-id="2d1a1-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span><span class="sxs-lookup"><span data-stu-id="2d1a1-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span></span> | <span data-ttu-id="2d1a1-120">Целевой объект вызова является подавленным.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-120">Call target is export suppressed.</span></span> <span data-ttu-id="2d1a1-121">Дополнительные сведения см. в разделе о [подавлении экспорта](#export-suppression) .</span><span class="sxs-lookup"><span data-stu-id="2d1a1-121">See [Export suppression](#export-suppression) for more details</span></span> |
  
  <span data-ttu-id="2d1a1-122">Для обеспечения совместимости с будущими версиями средства не должны устанавливать флаги **гфидс** , которые еще не были определены, и не должны включать дополнительные байты **гфидс** дополнительных метаданных, превышающие 1 байт, определенный в настоящее время, так как значения других флагов или дополнительных метаданных еще не назначены.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-122">For future compatibility, tools should not set **GFIDS** flags that have not yet been defined and should not include additional **GFIDS** extra metadata bytes beyond the 1-byte currently defined since the meanings for other flags or additional metadata are not yet assigned.</span></span> <span data-ttu-id="2d1a1-123">Примеры образов, которые содержат дополнительные байты метаданных, можно найти, выполнив дамп таблицы **гфидс** двоичных файлов, например Ntdll.dll, в современной версии ОС Windows 10.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-123">You can find examples of images that include extra metadata bytes by dumping the **GFIDS** table of binaries such as Ntdll.dll on a modern Windows 10 OS version.</span></span>

  <span data-ttu-id="2d1a1-124">Средства должны объявлять символы функций только как допустимые целевые объекты вызова, которые могут доставлять дополнительные соображения для кода ассемблера, где могут быть созданы метки.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-124">Tools should only declare function symbols as valid call targets which may merit additional consideration for assembler code where labels might be address taken.</span></span> <span data-ttu-id="2d1a1-125">По историческим причинам код ассемблера может полагаться на метки кода, отличные от PROC или алтентри, так как не преобразуется в цели вызова CFG компоновщиком.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-125">For historical reasons, assembler code may rely on code labels other than PROC or .altentry as not being converted into CFG call targets by the linker.</span></span>

  <span data-ttu-id="2d1a1-126">Кроме того, по историческим причинам код может намеренно объявить код как данные, чтобы избежать включения в таблицу **гфидс** .</span><span class="sxs-lookup"><span data-stu-id="2d1a1-126">Also for historical reasons, code may deliberately declare code as data to avoid inclusion in the **GFIDS** table.</span></span> <span data-ttu-id="2d1a1-127">Например, один объектный файл может реализовать символ как код, а другой может объявить его как данные, чтобы получить адрес символа без создания допустимой целевой записи CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-127">For example, one object file may implement a symbol as code while another may declare it as data in order to take the address of the symbol without generating a valid CFG target record.</span></span> <span data-ttu-id="2d1a1-128">Для обеспечения совместимости рекомендуется, чтобы наборы инструментов поддерживали эту методику.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-128">For compatibility, it is recommended that toolsets support this practice.</span></span>

- <span data-ttu-id="2d1a1-129">Образы, поддерживающие CFG и требующие или выполняющие проверки CFG, должны устанавливать IMAGE_GUARD_CF_INSTRUMENTED и IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT бит Гуардфлагс и устанавливать бит IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics в заголовках образа.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-129">Images that support CFG and that want or perform CFG checks should set the IMAGE_GUARD_CF_INSTRUMENTED and IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags bits, and should set the IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics bit in the image headers.</span></span>

- <span data-ttu-id="2d1a1-130">Каталог конфигурации загрузки объявляет два указателя на функции: Гуардкфчеккфунктионпоинтер и Гуардкфдиспатчфунктионпоинтер (последний поддерживается только для определенных архитектур, таких как AMD64).</span><span class="sxs-lookup"><span data-stu-id="2d1a1-130">The load configuration directory advertises two function pointers: GuardCFCheckFunctionPointer and GuardCFDispatchFunctionPointer (the latter is only supported for certain architectures such as AMD64).</span></span> <span data-ttu-id="2d1a1-131">Эти указатели функций должны указывать на память только для чтения для обеспечения безопасности в целях CFG. загрузчик DLL операционной системы будет повторно защищать память во время загрузки образа для хранения указателей функций.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-131">These function pointers should point to read only memory for CFG security to be effective; the operating system’s DLL loader will reprotect the memory transiently during image loading to store the function pointers.</span></span> <span data-ttu-id="2d1a1-132">Обычно их использование может быть объединено в тот же раздел, который содержит таблицу адресов импорта (IAT).</span><span class="sxs-lookup"><span data-stu-id="2d1a1-132">Typical usage might be to merge these into the same section that contains the Import Address Table (IAT).</span></span> <span data-ttu-id="2d1a1-133">Гуардкфчеккфунктионпоинтер предоставляет адрес предоставленного загрузчиком ОС символа, который может быть вызван с указателем на функцию в первом регистре целочисленного аргумента (ECX для x86), который вернется при успешном выполнении или приведет к прерыванию процесса, если цель вызова не является допустимым целевым объектом CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-133">The GuardCFCheckFunctionPointer provides the address of an OS-loader provided symbol that can be called with a function pointer in the first integer argument register (ECX on x86) which will return on success or will abort the process if the call target is not a valid CFG target.</span></span> <span data-ttu-id="2d1a1-134">Гуардкфдиспатчфунктионпоинтер предоставляет адрес символа загрузчика ОС, который принимает целевой объект вызова в Register RAX и выполняет объединенную проверку CFG и оптимизированный вызов метода хвостовой ветви в целевой объект вызова (регистры R10/R11 зарезервированы для использования в параметрах Гуардкфдиспатчфунктионпоинтер и целочисленных регистров, зарезервированных для использования в конечном объекте вызова).</span><span class="sxs-lookup"><span data-stu-id="2d1a1-134">The GuardCFDispatchFunctionPointer provides the address of an OS-loader provided symbol that takes a call target in register RAX and performs a combined CFG check and tail branch optimized call to the call target (registers R10/R11 are reserved for use by the GuardCFDispatchFunctionPointer and integer argument registers are reserved for use by the ultimate call target).</span></span> <span data-ttu-id="2d1a1-135">Адрес по умолчанию символов CFG в изображении должен указывать на функцию, которая просто возвращает (Гуардкфчеккфунктионпоинтер) или которая возвращает символ подавленного давления (или вообще полностью опускается из символа таблицы **гфидс** ), выполняющего инструкцию "переход RAX".</span><span class="sxs-lookup"><span data-stu-id="2d1a1-135">The default address of the CFG symbols in an image should point to a function that just returns (GuardCFCheckFunctionPointer) or that returns a guard-suppressed symbol (or is preferably entirely omitted from the **GFIDS** table symbol) that executes a “jmp rax” instruction.</span></span> <span data-ttu-id="2d1a1-136">Для AMD64 Гуардкфдиспатчфунктионпоинтер, когда изображение загружается в операционную систему с поддержкой CFG, а CFG включается, загрузчик DLL-файлов операционной системы установит соответствующие указатели функций, которые поддерживают обратную совместимость.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-136">For AMD64 GuardCFDispatchFunctionPointer, when an image is loaded on a CFG-aware operating system, and CFG is enabled, the OS DLL loader will install appropriate function pointers, which facilities backwards compatibility.</span></span> <span data-ttu-id="2d1a1-137">Образ может предоставить значение 0 для Гуардкфдиспатчфунктионпоинтер в конфигурации загрузки, если он не планирует использовать механизм отправки CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-137">An image can supply 0 for the GuardCFDispatchFunctionPointer in the load config if it does not intend to use the CFG dispatch facility.</span></span> <span data-ttu-id="2d1a1-138">Это следует делать для архитектур, отличных от AMD64, для обеспечения совместимости в будущем, если эти архитектуры в конечном итоге поддерживают механизм диспетчеризации CFG в некоторой форме.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-138">This should be done for non-AMD64 architectures for future compatibility, in case these architectures eventually support the CFG dispatch mechanism in some form.</span></span> <span data-ttu-id="2d1a1-139">Обратите внимание, что Windows 8.1 AMD64 не поддерживал отправку CFG и оставить указатель на функцию по умолчанию вместо Гуардкфдиспатчфунктионпоинтер.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-139">Note that Windows 8.1 AMD64 did not support CFG dispatch and would leave the default function pointer in place for GuardCFDispatchFunctionPointer.</span></span> <span data-ttu-id="2d1a1-140">Отправка CFG поддерживается только в операционных системах Windows 10 и более поздних версий.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-140">CFG dispatch is only supported on Windows 10 and later operating systems.</span></span>

- <span data-ttu-id="2d1a1-141">CFG в пользовательском режиме может применяться только для образов, которые помечены как совместимые с помощью функции случайного выбора макета адресного пространства (определяется параметром/DYNAMICBASE в компоновщике Microsoft).</span><span class="sxs-lookup"><span data-stu-id="2d1a1-141">User mode CFG might only be enforced for images that are marked as address space layout randomization (ASLR) compatible (specified by the /DYNAMICBASE option with the Microsoft linker).</span></span> <span data-ttu-id="2d1a1-142">Это происходит из-за того, как ОС внутренне обрабатывает CFG, где она фактически продается в инфраструктуре ASLR.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-142">This is due to how the OS internally handles CFG where it is essentially wired in to the ASLR infrastructure.</span></span> <span data-ttu-id="2d1a1-143">Как правило, пользователи CFG должны включить ASLR для образов в качестве первого шага.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-143">In general, users of CFG should enable ASLR for their images as a first step.</span></span> <span data-ttu-id="2d1a1-144">Средства не должны рассчитывать на то, что операционная система всегда будет игнорировать CFG без установки ASLR, но обычно оба они должны быть установлены одновременно.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-144">Tools should not assume that the OS will always ignore CFG without ASLR set but should generally set both at the same time.</span></span>

## <a name="compiler-directives"></a><span data-ttu-id="2d1a1-145">Директивы компилятора</span><span class="sxs-lookup"><span data-stu-id="2d1a1-145">Compiler directives</span></span>

- <span data-ttu-id="2d1a1-146">Цели вызова можно пометить явным образом с помощью модификатора __declspec (Guard (подавлять)) или с помощью директивы компоновщика/гуардсим: симнаме, S (например, для кода ASM).</span><span class="sxs-lookup"><span data-stu-id="2d1a1-146">Call targets can be marked as explicitly suppressed with the __declspec(guard(suppress)) modifier, or with the /guardsym:symname,S linker directive (for asm code for example).</span></span> <span data-ttu-id="2d1a1-147">Это приводит к тому, что цель вызова включается в таблицу **гфидс** , но помечается таким образом, чтобы операционная система обработала цель вызова как недопустимую.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-147">This causes the call target to be included in the **GFIDS** table but marked in such a way that the OS will treat the call target as not valid.</span></span> <span data-ttu-id="2d1a1-148">В некоторых непроизводственных сценариях, например при включении определенного инструментария средства проверки приложений в некоторых старых операционных системах, может быть разрешено, чтобы подавленные целевые объекты считались допустимыми, но в общем случае эти сценарии не должны быть рабочими.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-148">Some non-production scenarios, such as with certain application verifier instrumentation enabled on some older operating systems, may enable suppressed call targets to be treated as valid, but in general these scenarios are not expected to be production scenarios.</span></span> <span data-ttu-id="2d1a1-149">Эта директива полезна для аннотирования "опасных" функций, которые не должны рассматриваться как допустимые цели вызова, даже несмотря на то, что они будут включены в правило "нормальное".</span><span class="sxs-lookup"><span data-stu-id="2d1a1-149">This directive is useful for annotating “dangerous” functions that should not be considered as valid call targets, even though the normal CFG rule would include them.</span></span>

- <span data-ttu-id="2d1a1-150">Код может означать, что проверки CFG не нужны с помощью модификатора __declspec (Guard (нокф)).</span><span class="sxs-lookup"><span data-stu-id="2d1a1-150">Code can indicate CFG checks are not wanted with the __declspec(guard(nocf)) modifier.</span></span> <span data-ttu-id="2d1a1-151">Это направляет компилятору возможность не вставлять проверки CFG для всей функции.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-151">This directs the compiler to not insert any CFG checks for the entire function.</span></span> <span data-ttu-id="2d1a1-152">Компилятор должен соблюдать осторожность при распространении этой директивы в любой код, который повлияет на встроенную функцию, помеченную как не имеющая проверки CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-152">The compiler should take care to propagate this directive to any code contributed by an inlined function that is marked as not wanting CFG checks.</span></span> <span data-ttu-id="2d1a1-153">Этот подход обычно используется только в тех ситуациях, когда программист автоматически вставил «CFG-эквивалентный» уровень защиты.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-153">This approach is typically used only sparingly in specific situations where the programmer has manually inserted “CFG-equivalent” protection.</span></span> <span data-ttu-id="2d1a1-154">Программист знает, что они вызывают через некоторую таблицу функций только для чтения, адрес которой получается через ссылки памяти только для чтения, для которых индекс замаскирован на ограничение таблицы функции.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-154">The programmer knows that they are calling through some read only function table whose address is obtained through read only memory references and for which the index is masked to the function table limit.</span></span> <span data-ttu-id="2d1a1-155">Этот подход также можно применить к небольшим функциям-оболочкам, которые не являются встроенными и не делают вызов через указатель функции.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-155">This approach may also be applied to small wrapper functions that are not inlined and that do nothing more than make a call through a function pointer.</span></span> <span data-ttu-id="2d1a1-156">Поскольку неправильное использование этой директивы может поставить под угрозу безопасность CFG, программист должен быть очень осторожным при использовании директивы.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-156">Since incorrect usage of this directive can compromise the security of CFG, the programmer must be very careful using the directive.</span></span> <span data-ttu-id="2d1a1-157">Как правило, это использование ограничено очень малыми функциями, которые вызывают только одну функцию.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-157">Typically, this usage is limited to very small functions that only call one function.</span></span>

## <a name="import-handling"></a><span data-ttu-id="2d1a1-158">Обработка импорта</span><span class="sxs-lookup"><span data-stu-id="2d1a1-158">Import handling</span></span>

- <span data-ttu-id="2d1a1-159">Вызовы через IAT не должны использовать защиту CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-159">Calls through the IAT should not use CFG protection.</span></span> <span data-ttu-id="2d1a1-160">Таблица IAT доступна только для чтения в современных образах (предполагая, что таблица IAT объявлена в заголовках PE, в этом случае она должна располагаться на собственных страницах).</span><span class="sxs-lookup"><span data-stu-id="2d1a1-160">The IAT is read only in modern images (assuming that the IAT is declared in the PE headers in which case it must be on its own pages).</span></span> <span data-ttu-id="2d1a1-161">IAT можно использовать для обращения к функциям, которые являются защищенными, поэтому это требование верно.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-161">The IAT can be used to reach functions that are guard suppressed, so this is a correctness requirement.</span></span> <span data-ttu-id="2d1a1-162">Защита памяти только для чтения с помощью IAT заменяет параметр CFG, так как привязка цели вызова является неизменяемой после разрешения привязок импорта изображений, и разрешение привязки детализировано.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-162">Read only memory protection through the IAT supersedes that of CFG since the call target binding is immutable after the image import snaps are resolved, and the binding resolution is fine grained.</span></span>

- <span data-ttu-id="2d1a1-163">Защищенная задержка загрузки: вызовы с помощью IAT с отложенной нагрузкой не должны использовать защиту CFG по тем же причинам, что и стандартная IAT.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-163">Protected delay load: Calls through the delay load IAT should not use CFG protection, for the same reasons as the standard IAT.</span></span> <span data-ttu-id="2d1a1-164">Таблица IAT с отложенной загрузкой должна находиться в отдельном разделе, а образ должен установить IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT Гуардфлагс бит.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-164">The delay load IAT should be in its own section and the image should set the IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit.</span></span> <span data-ttu-id="2d1a1-165">Это означает, что загрузчик DLL операционной системы должен изменить защиту для отложенной загрузки IAT при разрешении экспорта, если используется собственная поддержка отложенной загрузки операционной системы в Windows 8 и более поздних операционных системах.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-165">This indicates that the operating system’s DLL loader should change protections for the delay load IAT during export resolution if using the operating system’s delay load support native to Windows 8 and later operating systems.</span></span> <span data-ttu-id="2d1a1-166">Синхронизация этого шага осуществляется загрузчиком библиотек DLL операционной системы, если используется собственная поддержка отложенной загрузки операционной системы (например, Ресолведелайлоадедапи), поэтому никакой другой компонент не должен повторно защищать страницы, охватывающие объявленную IAT с отложенной загрузкой.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-166">The synchronization of this step is managed by the operating system DLL loader if native operating system delay load support is in use (e.g. ResolveDelayLoadedAPI) so no other component should reprotect the pages spanning the declared delay load IAT.</span></span> <span data-ttu-id="2d1a1-167">Для обеспечения обратной совместимости с более старыми операционными системами, предшествующими CFG, средства могут включать возможность перемещения IAT с отложенной нагрузкой в свой собственный раздел (каноническо ". Дидат"), защищенную для чтения и записи в заголовках изображений, а также устанавливать флаг IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-167">For backwards compatibility with older pre-CFG operating systems, tools may enable the option to move the delay load IAT into its own section (canonically “.didat”), protected as read/write in the image headers, and additionally set the IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION flag.</span></span> <span data-ttu-id="2d1a1-168">Этот параметр приведет к тому, что загрузчик DLL-файлов операционной системы с поддержкой CFG будет повторно защищать весь раздел, содержащий таблицу IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT, на чтение только памяти во время загрузки образа.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-168">This setting will cause CFG-aware operating system DLL loaders to reprotect the entire section containing the IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT table to read only memory during image loading.</span></span> <span data-ttu-id="2d1a1-169">Возможность размещения IAT с отложенной загрузкой в собственном разделе может не требоваться, если вы не следите за запуском образа в операционных системах с предварительной поддержкой CFG, но средства должны принимать это решение на основе минимальной поддержки операционной системы, необходимой для образа.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-169">The option to place the delay load IAT in its own section may not be required if you do not care about running an image on operating systems that predate CFG support, but tools should make that decision based on the minimum operating system support that an image needs.</span></span>

  <span data-ttu-id="2d1a1-170">Если образ не использует встроенную поддержку отложенной загрузки операционной системы, он по-прежнему может установить связанные биты Гуардфлагс с защищенной задержкой.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-170">If an image does not use the operating system’s native delay load support, it can still set the protected delay load related GuardFlags bits.</span></span> <span data-ttu-id="2d1a1-171">В этой конфигурации загрузчик операционной системы просто предоставляет поддержку для защиты немедленной загрузки IAT как прочитанной во время выполнения, если она поддерживается платформой, и она становится обязанностью заглушки разрешения внутренней задержки загрузки образа для синхронизации и управления защитой IAT с отложенной загрузкой.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-171">In this configuration, the operating system loader will just provide support to protect the delay load IAT as read only at runtime if supported by the platform, and it becomes the responsibility of the image’s internal delay load resolution stubs to synchronize and manage protection of the delay load IAT.</span></span> <span data-ttu-id="2d1a1-172">При условии, что таблица конфигурации загрузки хранится в памяти только для чтения (рекомендуемый вариант), присутствие или отсутствие бита с защищенной задержкой IAT в поле Гуардфлагс изображения может быть полезно в качестве внутренней подсказки в заглушках разрешения внутренней загрузки с задержкой изображения, чтобы указать, должна ли она защищать отправку с задержкой.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-172">Provided that the load configuration table is stored in read only memory (which is recommended), the presence or absence of the protected delay load IAT bit in the image’s GuardFlags field might be useful as an internal hint to the image’s internal delay load resolution stubs to indicate whether or not it should protect the delay load IAT.</span></span>

  <span data-ttu-id="2d1a1-173">Если параметр CFG включен, рекомендуется включить защищенную отложенную загрузку по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-173">It is recommended that protected delay load be enabled by default if CFG is enabled.</span></span> <span data-ttu-id="2d1a1-174">Образы, работающие в более старых версиях операционной системы и использующие встроенную поддержку отложенной загрузки операционной системы, могут использовать для обеспечения обратной совместимости в собственном разделе поддержку немедленных загрузок.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-174">Images that run on older operating system versions and that use the operating system’s native delay load support, as noted, may use the delay load IAT in its own section support for backwards compatibility.</span></span> <span data-ttu-id="2d1a1-175">В противоположность этому помечать IAT с отложенной нагрузкой как доступную только для чтения и объединять ее с другим разделом, что привело бы к нарушению защиты от старых операционных систем, которые не понимают защищенную загрузку и обеспечивают поддержку собственного разрешения отложенной загрузки.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-175">This is opposed to marking the delay load IAT as read only and merging it with another section, which would break on older operating system’s that do not understand protected delay loads and which provide native delay load resolution support.</span></span> <span data-ttu-id="2d1a1-176">Все выпуски Windows 10 и первая Windows 8.1/Windows Server 2012 R2, которые поддерживают CFG (то есть обновление за Ноябрь 2014), обеспечивают поддержку защищенной отложенной нагрузки в операционной системе.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-176">All Windows 10 releases and the first Windows 8.1/Windows Server 2012 R2 builds that supported CFG (meaning the November 2014 update) introduce support for protected delay load in the operating system.</span></span>

## <a name="function-alignment"></a><span data-ttu-id="2d1a1-177">Выравнивание функций</span><span class="sxs-lookup"><span data-stu-id="2d1a1-177">Function alignment</span></span>

- <span data-ttu-id="2d1a1-178">Функции, которые были взяты из адреса и, следовательно, включены в таблицу **гфидс** , должны быть упорядочены по 16 байт, если это возможно.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-178">Functions that are address taken and are therefore included in the **GFIDS** table should be made 16-byte aligned, if possible.</span></span> <span data-ttu-id="2d1a1-179">Это не всегда возможно.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-179">This may not always be possible.</span></span> <span data-ttu-id="2d1a1-180">Например, для функций, не являющихся функциями COMDAT, которые являются частью объектных файлов, собранных в виде одной единицы с помощью средств, не учитывающих конечные средства, которые могут быть созданы некоторыми средствами сборки, пользователь средства, создавшего файлы, должен соответствующим образом задать выравнивание.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-180">For example, for non-COMDAT functions that are a part of object files assembled together as one unit by non-CFG aware tools, which some assemblers may produce, the user of the tool that produced the files must appropriately set the alignment.</span></span> <span data-ttu-id="2d1a1-181">В этом случае средства могут выдавать диагностические предупреждения, чтобы пользователь мог предпринять соответствующие корректирующие действия.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-181">Tools may elect to issue a diagnostic warning in this situation so that the user can take appropriate corrective action.</span></span> <span data-ttu-id="2d1a1-182">Причина этого заключается в том, что CFG помечает целевые объекты как допустимые или недопустимые в 16-байтовых границах для повышения эффективности проверок на основе CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-182">The reason for this is that CFG marks call targets as valid or not valid on 16-byte boundaries for efficiency of fast CFG checks.</span></span> <span data-ttu-id="2d1a1-183">Если функция не имеет 16-байтовое значение, то весь 16-байтовый слот должен быть помечен как допустимый, что не так безопасно, так как вы можете вызвать неверное согласование кода, который не находится в самом начале функции.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-183">If a function is not 16-byte aligned, then the entire 16-byte slot must be marked as valid, which is not as secure since you can call misaligned into code that is not at the very start of a function.</span></span> <span data-ttu-id="2d1a1-184">Этот сценарий поддерживается для простоты взаимодействия при первом внесении в проект.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-184">This scenario is supported for ease of interoperability when first bringing CFG up for a project.</span></span> <span data-ttu-id="2d1a1-185">Изображения, не поддерживающие CFG, аналогично помечены как допустимые для любого выравнивания цели вызова для обеспечения совместимости.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-185">Non-CFG aware images are similarly marked as valid for any call target alignment for compatibility.</span></span> <span data-ttu-id="2d1a1-186">Как и ранее, наличие несогласованных целевых объектов приводит к снижению преимуществ безопасности для CFG, поэтому средства должны автоматически согласовать 16-байтовую границу для любого объекта в таблице **гфидс** , когда для изображения требуется cfg.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-186">As before, having misaligned call targets reduces the security benefits of CFG, so tools should automatically align to a 16-byte boundary for anything in the **GFIDS** table when CFG is desired for an image.</span></span> <span data-ttu-id="2d1a1-187">Символы, которых нет в таблице **гфидс** , не должны иметь определенных выравниваний для cfg.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-187">Symbols that are not in the **GFIDS** table do not need to have particular alignments for CFG.</span></span>

## <a name="export-suppression"></a><span data-ttu-id="2d1a1-188">Подавление экспорта</span><span class="sxs-lookup"><span data-stu-id="2d1a1-188">Export suppression</span></span>

- <span data-ttu-id="2d1a1-189">Подавление экспорта CFG (CFG ES) — это необязательный режим, который позволяет процессу указать, что цели вызова, которые были допустимы только потому, что они были символами-dllexport, и которые еще не были динамически разрешены с помощью GetProcAddress, будут рассматриваться как недопустимые для целей CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-189">CFG export suppression (CFG ES) is an optional mode that enables a process to indicate that call targets which were only valid because they were dllexport symbols, and which have not yet been dynamically resolved by GetProcAddress, will be considered as not valid for purposes of CFG.</span></span> <span data-ttu-id="2d1a1-190">Это сокращает контактную зону CFG из системных библиотек DLL.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-190">This reduces the surface area of CFG from system DLL exports.</span></span> <span data-ttu-id="2d1a1-191">Подавление экспорта включает в себя передачу подходящего запроса "экспорт подавленных", помечая их флагами IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **гфидс** .</span><span class="sxs-lookup"><span data-stu-id="2d1a1-191">Export suppression involves communicating eligible “export suppressed” dllexport call targets by marking them with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flags.</span></span> <span data-ttu-id="2d1a1-192">Символы dllexport и точка входа образа PE должны быть неявно считаться адресом, предпринимаемым инструментами для создания таблицы **гфидс** .</span><span class="sxs-lookup"><span data-stu-id="2d1a1-192">Dllexport symbols and the PE image entry point should be implicitly considered address taken by tools for purposes of generating the **GFIDS** table.</span></span>  <span data-ttu-id="2d1a1-193">Если для символа экспорта задано 16-байтовое согласование, и его адрес получен не так, как dllexport, он может быть помечен с помощью флага Export подавлено **гфидс** в таблице функций.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-193">If an export symbol is 16-byte aligned and it is address taken for no other reason than being a dllexport, then it can be marked with the export suppressed **GFIDS** flag in the function table.</span></span> <span data-ttu-id="2d1a1-194">Целевые объекты вызова, которые не являются 16-байтовыми, не **должны** быть помечены флагом IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **гфидс** и не могут быть ограничены динамически, как допустимые целевые объекты вызова во время GetProcAddress.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-194">Call targets that are not 16-byte aligned **must not** be marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag and cannot be restricted to only being dynamically enabled as valid call targets at GetProcAddress time.</span></span>

  <span data-ttu-id="2d1a1-195">Образ, поддерживающий CFG ES, включает Гуардаддресстакениатентритабле, число которых предоставляется Гуардаддресстакениатентрикаунт в составе каталога конфигурации нагрузки.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-195">An image that supports CFG ES includes a GuardAddressTakenIatEntryTable whose count is provided by the GuardAddressTakenIatEntryCount as part of its load configuration directory.</span></span> <span data-ttu-id="2d1a1-196">Эта таблица имеет структуру, отформатированную таким же образом, как и таблица **гфидс** .</span><span class="sxs-lookup"><span data-stu-id="2d1a1-196">This table is structurally formatted the same as the **GFIDS** table.</span></span> <span data-ttu-id="2d1a1-197">Он использует один и тот же механизм IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK Гуардфлагс для кодирования дополнительных байтов необязательных метаданных в таблице Address, который использует таблицу IAT, хотя все байты метаданных должны быть равны нулю для таблицы IAT и зарезервированы.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-197">It uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode extra optional metadata bytes in the address taken IAT table, though all metadata bytes must be zero for the address taken IAT table and are reserved.</span></span> <span data-ttu-id="2d1a1-198">В таблице адресная таблица IAT указывается упорядоченный массив RVA преобразователей импорта, который импортирован в качестве адреса символа, полученного с целью вызова.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-198">The address taken IAT table indicates a sorted array of RVAs of import thunks which have the imported as a symbol address taken call target.</span></span> <span data-ttu-id="2d1a1-199">Эта конструкция поддерживает адрес, используемый для создания символов, которые существуют в удаленном модуле, и которые являются dllexport с использованием CFG ES.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-199">This construct supports address taken symbols that exist in a remote module, and which are dllexports, with CFG ES in use.</span></span> <span data-ttu-id="2d1a1-200">Пример такой конструкции кода выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="2d1a1-200">An example of such a code construct would be:</span></span>

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  <span data-ttu-id="2d1a1-201">Все преобразователи импорта, созданные этим адресом, должны быть перечислены, чтобы загрузчик операционной системы мог найти их и обеспечить допустимость соответствующих целевых объектов вызова при загрузке изображения и привязке его импорта.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-201">All such address taken import thunks must be enumerated so that the operating system loader can find them and make the appropriate call targets valid when loading an image and snapping its imports.</span></span> <span data-ttu-id="2d1a1-202">Таблица и количество могут быть равны 0, если не были сделаны преобразователи импорта.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-202">The table and count can be 0 if there are no import thunks that were address taken.</span></span>

  <span data-ttu-id="2d1a1-203">Модуль задает IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT бит Гуардфлагс, чтобы указать, что он перечислил все преобразователи, созданные в адресе таблицы IAT, и все экспортируемые элементы, имеющие соответствующий CFG, будут помечены флагом IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **гфидс** .</span><span class="sxs-lookup"><span data-stu-id="2d1a1-203">A module sets the IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags bit to indicate that it has enumerated all address taken thunks in its address taken IAT table and that all exports that are CFG ES eligible are marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag.</span></span> <span data-ttu-id="2d1a1-204">Обратите внимание, что такие преобразователи могут иметь нулевое значение, а также могут быть нулевые символы dllexport.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-204">Note that there may be zero such thunks and that there may also be zero such dllexport symbols.</span></span> <span data-ttu-id="2d1a1-205">Невозможность обслуживания адреса, полученного в таблице IAT, может быть проблемой, так как некоторые целевые объекты вызова могут быть недействительными, если они должны быть загружены на момент загрузки библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-205">Failure to maintain the address taken IAT table can be a correctness issue as some call targets might not be made valid when they should be at DLL load time.</span></span>

  <span data-ttu-id="2d1a1-206">Модуль задает IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION бит Гуардфлагс, чтобы указать, что ему нужно включить CFG ES для процесса.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-206">A module sets the IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags bit to indicate that it wants to enable CFG ES for the process.</span></span> <span data-ttu-id="2d1a1-207">На практике это имеет смысл только для exe-заданий в настоящее время.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-207">In practice, this is only meaningful for EXEs today.</span></span> <span data-ttu-id="2d1a1-208">Процесс, позволяющий CFG ES, не должен загружать библиотеки DLL, не созданные с помощью CFG ES, или сбои во время выполнения из-за неназначенного адреса, полученного в виде символов IAT.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-208">A process enabling CFG ES should not load DLLs not built with CFG ES or runtime failures may occur because of undesignated address taken IAT symbols.</span></span> <span data-ttu-id="2d1a1-209">Поддержка включения CFG ES должна быть отдельным вариантом согласия на включение CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-209">Support for enabling CFG ES should be a separate opt-in option from enabling CFG.</span></span> <span data-ttu-id="2d1a1-210">Предоставление метаданных CFG ES является типобезопасным и рекомендуется по умолчанию с помощью CFG, хотя наборы инструментов должны следить за тем, чтобы они выдают правильные метаданные.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-210">Providing CFG ES metadata is safe and recommended by default with CFG, though toolsets must take care to ensure they produce correct metadata.</span></span> <span data-ttu-id="2d1a1-211">В противном случае созданные образы могут не работать должным образом в процессе CFG ES.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-211">If not, their generated images may not run properly in a CFG ES process.</span></span> <span data-ttu-id="2d1a1-212">Такая поддержка должна быть тщательно протестирована в процессе тестирования, который принудительно применяет CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-212">Such support should be thoroughly tested in a test process that enforces CFG ES.</span></span> <span data-ttu-id="2d1a1-213">Встроенные системные библиотеки DLL операционной системы поддерживают метаданные CFG ES для современных версий операционной системы Windows 10, которые понимают, что такое CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-213">The operating system built-in system DLLs support CFG ES metadata for modern Windows 10 operating system versions that understand CFG ES.</span></span> <span data-ttu-id="2d1a1-214">Версии операционной системы до этой поддержки не понимают «CFG», а все директивы, связанные с CFG, будут игнорироваться в образе.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-214">Operating system versions prior to this support do not understand CFG ES at all and will ignore any CFG ES related directives in the image.</span></span> <span data-ttu-id="2d1a1-215">Такие образы по-прежнему совместимы с более старыми версиями операционной системы.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-215">Such images are still backwards compatible to older operating system versions.</span></span>

  <span data-ttu-id="2d1a1-216">Поддержка CFG ES является необязательной с точки зрения набора инструментов, но рекомендуется, чтобы наборы инструментов включали в себя по крайней мере поддержку для перечисления достаточной информации, чтобы образы выполнялись в процессе, который помещает CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-216">CFG ES support is optional from a toolset perspective, but it is recommended that toolsets at least include support to enumerate enough information for images to run in a process that desires CFG ES.</span></span> <span data-ttu-id="2d1a1-217">Как уже упоминалось, очень важно, чтобы поддержка набора инструментов была тщательно протестирована для обеспечения совместимости с CFG ES, так как большинство процессов еще не включают CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-217">As mentioned, it is critical that toolset support be thoroughly tested to ensure that it is compatible with CFG ES, as most processes don’t yet enable CFG ES.</span></span>

## <a name="exception-handling-and-unwinding"></a><span data-ttu-id="2d1a1-218">Обработка исключений и их очистка</span><span class="sxs-lookup"><span data-stu-id="2d1a1-218">Exception handling and unwinding</span></span>

- <span data-ttu-id="2d1a1-219">Обработчики конкретного языка, такие как __C_specific_handler, обозначенные сведениями обработчика исключений в регистрации pData, не должны помечаться как допустимые цели вызова в таблице **гфидс** .</span><span class="sxs-lookup"><span data-stu-id="2d1a1-219">Language specific handlers like __C_specific_handler, as designated by the exception handler information in a .pdata registration, should not be marked as valid call targets in the **GFIDS** table.</span></span> <span data-ttu-id="2d1a1-220">Вместо этого они ищутся путем обхода памяти только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-220">They are instead looked up by traversing read only memory.</span></span> <span data-ttu-id="2d1a1-221">Аналогично, обработчик конкретного языка Microsoft C использует поиск в памяти только для чтения, чтобы найти функлетс для обработчиков исключений и, таким образом, не объявил его функлетс как допустимые цели вызова в таблице **гфидс** .</span><span class="sxs-lookup"><span data-stu-id="2d1a1-221">Similarly, the Microsoft C language specific handler uses read only memory searches to locate funclets for exception handlers and thus does not declare its funclets as valid call targets in the **GFIDS** table.</span></span>

- <span data-ttu-id="2d1a1-222">Длительная обработка переходов (для целевых платформ, отличных от x86): наборы инструментов, компилируемые с помощью CFG и поддерживающие setjmp ()/лонгжмп (), должны реализовывать длительный переход, как в случае "безопасного длинного перехода", взаимодействующего со структурной обработкой исключений (SEH).</span><span class="sxs-lookup"><span data-stu-id="2d1a1-222">Long jump handling (for non-x86 targets like AMD64):  Toolsets compiling with CFG and supporting setjmp()/longjmp() should implement long jump as “safe long jump” that interoperates with structured exception handling (SEH).</span></span> <span data-ttu-id="2d1a1-223">Это означает, что длительный переход реализуется как вызов Ртлунвиндекс с STATUS_LONGJUMP в качестве кода состояния в предоставленной записи исключения и стандартного _JUMP_BUFFER, на который указывает матрице ExceptionInformation [0].</span><span class="sxs-lookup"><span data-stu-id="2d1a1-223">This means long jump is implemented as a call to RtlUnwindEx with STATUS_LONGJUMP as the status code in the supplied exception record and a standard _JUMP_BUFFER pointed to by ExceptionInformation[0].</span></span> <span data-ttu-id="2d1a1-224">Цель очистки перехода должна быть Таржетипой очистки.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-224">The jump unwind target should be the TargetIp of the unwind.</span></span> <span data-ttu-id="2d1a1-225">Буфер переходов представляет контекст регистра, который восстанавливается операционной системой после завершения длительного перехода.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-225">The jump buffer represents the register context that is restored by the operating system after the long jump has completed.</span></span> <span data-ttu-id="2d1a1-226">Ртлунвинд (ex) при вызове с STATUS_LONGJUMP имеет специальное значение, уникальное для CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-226">RtlUnwind(Ex) when called with STATUS_LONGJUMP has special significance unique to CFG.</span></span> <span data-ttu-id="2d1a1-227">Длинный целевой объект перехода (_JUMP_BUFFER. Копирование или _JUMP_BUFFER. LR в ARM64) ищется в списке загруженных модулей, поддерживаемом операционной системой в памяти только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-227">The long jump target (_JUMP_BUFFER.Rip or _JUMP_BUFFER.Lr on ARM64) is looked up in the loaded module list maintained by the operating system in read only memory.</span></span> <span data-ttu-id="2d1a1-228">Если содержащий модуль для целевого объекта перехода ("целевой модуль") имеет флаг IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT, установленный в поле Гуардфлагс, то каталог конфигурации загрузки содержит Гуардлонгжумптаржеттабле вхис число элементов, заданное в поле Load Configuration Гуардлонгжумптаржеткаунт (загрузка конфигурации).</span><span class="sxs-lookup"><span data-stu-id="2d1a1-228">If the containing module for the jump target (the “target module”) has the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag set in its GuardFlags field, then the load configuration directory has a GuardLongJumpTargetTable whith an element count specified by the load configuration GuardLongJumpTargetCount field.</span></span> <span data-ttu-id="2d1a1-229">Эта таблица имеет структуру, отформатированную так же, как и таблицу **гфидс** , и использует тот же механизм гуардфлагс IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK для кодирования необязательных байтов метаданных в длинной таблице переходов.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-229">This table is structurally formatted the same as the **GFIDS** table and uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode optional extra metadata bytes in the long jump table.</span></span> <span data-ttu-id="2d1a1-230">Все байты метаданных должны быть нулевыми для длинной таблицы переходов и зарезервированы.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-230">All metadata bytes must be zero for the long jump table and are reserved.</span></span>

  <span data-ttu-id="2d1a1-231">Таблица длинных переходов представляет упорядоченный массив RVA, которые являются допустимыми целевыми объектами для перехода.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-231">The long jump table represents a sorted array of RVAs that are valid long jump targets.</span></span> <span data-ttu-id="2d1a1-232">Если модуль длинного целевого объекта перехода задает IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT в поле Гуардфлагс, все длинные цели перехода должны перечисляться в Лонгжумптаржеттабле.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-232">If a long jump target module sets IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT in its GuardFlags field, then all long jump targets must be enumerated in the LongJumpTargetTable.</span></span> <span data-ttu-id="2d1a1-233">Даже если модуль имеет нулевые целевые объекты для перехода, он по-прежнему должен установить флаг IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT, если набор инструментов поддерживает длительное повышение безопасности для CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-233">Even if a module has zero long jump targets, it should still set the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag if the toolset supports long jump hardening for CFG.</span></span> <span data-ttu-id="2d1a1-234">Это явно означает, что образ не имеет больших целевых объектов для перехода и не является старым образом, который операционная система должна предположить, может иметь допустимые длительные цели перехода в непомеченных расположениях, для которых не удается выполнить длительную проверку целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-234">This explicitly means that the image has no long jump targets and is not an old image that the operating system must assume could have valid long jump targets at unmarked locations for which it cannot perform long jump target checking.</span></span>

  <span data-ttu-id="2d1a1-235">Если параметр CFG поддерживается, рекомендуется включить длительное усиление защиты по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-235">Long jump hardening is recommended to be enabled by default if CFG is supported.</span></span> <span data-ttu-id="2d1a1-236">Это расположение компиляторов Майкрософт.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-236">This is the disposition of Microsoft compilers.</span></span> <span data-ttu-id="2d1a1-237">Операционные системы, которые не понимают длительное повышение уровня защиты (до Windows 10 или более ранних версий Windows 10), не выполняют длительные проверки на переходы и не пропускают каких-либо длинных метаданных о повышении безопасности, так что длительное повышение уровня защиты обеспечивает обратную совместимость с более старыми выпусками операционной системы.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-237">Operating systems that do not understand long jump hardening (pre-Windows 10 or older Windows 10 versions) will not perform long jump hardening checks and ignore any long jump hardening metadata, so long jump hardening is backwards compatible with older operating system releases.</span></span>

  <span data-ttu-id="2d1a1-238">В случае с образами в режиме ядра Целевая таблица защиты от длительного перехода не должна включаться в отброшенный раздел.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-238">For kernel mode images, the guard long jump target table should not be included in a discardable section.</span></span> <span data-ttu-id="2d1a1-239">Чтобы свойства безопасности были эффективными, необходимо хранить целевую таблицу с длительным переходом в память только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-239">The guard long jump target table should always be stored in read only memory for its security properties to be effective.</span></span>

## <a name="coff-information"></a><span data-ttu-id="2d1a1-240">Сведения о COFF</span><span class="sxs-lookup"><span data-stu-id="2d1a1-240">COFF information</span></span>

- <span data-ttu-id="2d1a1-241">Существуют пометки объектных файлов, которые объявляют, соответствует ли объектный файл CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-241">There are object file markings to declare whether an object file conforms to CFG or not.</span></span> <span data-ttu-id="2d1a1-242">Объектный файл, который соответствует CFG, выводит список допустимых целевых объектов вызова, которые он создает, явно, а также любой адрес, который получает метаданные IAT.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-242">An object file that conforms to CFG will list the valid call targets that it produces, explicitly, as well as any address taken IAT metadata.</span></span> <span data-ttu-id="2d1a1-243">Объектный файл, который не соответствует CFG, должен иметь выводимые объекты вызова путем проверки перерасположений COFF файла OBJ, чтобы найти перемещения, указывающие на начало символа функции.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-243">An object file that does not conform to CFG must have call targets inferred by examining the COFF relocations of the obj file to find relocations that point to the start of a function symbol.</span></span> <span data-ttu-id="2d1a1-244">Это может быть избыточно допустимые целевые объекты вызова CFG, поэтому желательно, чтобы средства помечают свои OBJ-файлы с учетом конечных файлов и включали метаданные файла OBJ, если компиляция выполняется с помощью CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-244">This may overapproximate valid CFG call targets so it is desirable that tools mark their obj files that are CFG-aware and include the CFG obj file metadata if compiling with CFG.</span></span>

- <span data-ttu-id="2d1a1-245">Существуют пометки объектных файлов для объявления длинных целевых объектов перехода для длительных переходов CFG, которые должны быть заполнены для режима компиляции CFG.</span><span class="sxs-lookup"><span data-stu-id="2d1a1-245">There are object file markings to declare long jump targets for CFG hardened long jump which should be populated for CFG compilation mode.</span></span>
