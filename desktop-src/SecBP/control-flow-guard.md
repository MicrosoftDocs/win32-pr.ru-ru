---
description: Защита потока управления (CFG) — это функция обеспечения безопасности платформы с высокой степенью оптимизации, которая была создана для борьбы с уязвимостями повреждения памяти.
ms.assetid: 116EAD64-7CAE-455C-BA43-9492F78DE873
title: Защита потока управления
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 91cf97a648443135e7fee666ea4c259b1c32104e
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104156870"
---
# <a name="control-flow-guard"></a><span data-ttu-id="eb04b-103">Защита потока управления</span><span class="sxs-lookup"><span data-stu-id="eb04b-103">Control Flow Guard</span></span>

## <a name="what-is-control-flow-guard"></a><span data-ttu-id="eb04b-104">Что такое защита потока управления?</span><span class="sxs-lookup"><span data-stu-id="eb04b-104">What is Control Flow Guard?</span></span>

<span data-ttu-id="eb04b-105">Защита потока управления (CFG) — это функция обеспечения безопасности платформы с высокой степенью оптимизации, которая была создана для борьбы с уязвимостями повреждения памяти.</span><span class="sxs-lookup"><span data-stu-id="eb04b-105">Control Flow Guard (CFG) is a highly-optimized platform security feature that was created to combat memory corruption vulnerabilities.</span></span> <span data-ttu-id="eb04b-106">Устанавливая строгие ограничения на то, где приложение может выполнять код из, злоумышленники могут намного сложнее выполнять произвольный код с помощью уязвимостей, таких как переполнение буфера.</span><span class="sxs-lookup"><span data-stu-id="eb04b-106">By placing tight restrictions on where an application can execute code from, it makes it much harder for exploits to execute arbitrary code through vulnerabilities such as buffer overflows.</span></span> <span data-ttu-id="eb04b-107">CFG расширяет предыдущие технологии защиты от эксплойтов, такие как [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md)и [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span><span class="sxs-lookup"><span data-stu-id="eb04b-107">CFG extends previous exploit mitigation technologies such as [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md), and [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span></span>

<span data-ttu-id="eb04b-108">Эта функция доступна в Microsoft Visual Studio 2015 и работает в версиях Windows с поддержкой CFG — 32-и 64-разрядных версий для настольных и серверных систем Windows 10 и Windows 8.1 Update (KB3000850).</span><span class="sxs-lookup"><span data-stu-id="eb04b-108">This feature is available in Microsoft Visual Studio 2015, and runs on "CFG-Aware" versions of Windows—the x86 and x64 releases for Desktop and Server of Windows 10 and Windows 8.1 Update (KB3000850).</span></span>

<span data-ttu-id="eb04b-109">Мы настоятельно рекомендуем разработчикам включить CFG для своих приложений.</span><span class="sxs-lookup"><span data-stu-id="eb04b-109">We strongly encourage developers to enable CFG for their applications.</span></span> <span data-ttu-id="eb04b-110">Не нужно включать CFG для каждой части кода, так как сочетание CFG и код, поддерживающий неcfg, будут выполняться нормально.</span><span class="sxs-lookup"><span data-stu-id="eb04b-110">You don't have to enable CFG for every part of your code, as a mixture of CFG enabled and non-CFG enabled code will execute fine.</span></span> <span data-ttu-id="eb04b-111">Но если не включить CFG для всего кода, можно открыть зазоры в защите.</span><span class="sxs-lookup"><span data-stu-id="eb04b-111">But failing to enable CFG for all code can open gaps in the protection.</span></span> <span data-ttu-id="eb04b-112">Кроме того, код с поддержкой CFG прекрасно работает в версиях Windows, не поддерживающих CFG, и поэтому полностью совместим с ними.</span><span class="sxs-lookup"><span data-stu-id="eb04b-112">Furthermore, CFG enabled code works fine on "CFG-Unaware" versions of Windows and is therefore fully compatible with them.</span></span>

## <a name="how-can-i-enable-cfg"></a><span data-ttu-id="eb04b-113">Как включить CFG?</span><span class="sxs-lookup"><span data-stu-id="eb04b-113">How Can I Enable CFG?</span></span>

<span data-ttu-id="eb04b-114">В большинстве случаев нет необходимости изменять исходный код.</span><span class="sxs-lookup"><span data-stu-id="eb04b-114">In most cases, there is no need to change source code.</span></span> <span data-ttu-id="eb04b-115">Вам нужно только добавить параметр в проект Visual Studio 2015, а компилятор и компоновщик включит CFG.</span><span class="sxs-lookup"><span data-stu-id="eb04b-115">All you have to do is add an option to your Visual Studio 2015 project, and the compiler and linker will enable CFG.</span></span>

<span data-ttu-id="eb04b-116">Самый простой способ — переход к свойству **проекта свойства \| \| конфигурации \| \| Создание кода C/C++** и выбор **Да (/Guard: CF)** для защиты потока управления.</span><span class="sxs-lookup"><span data-stu-id="eb04b-116">The simplest method is to navigate to **Project \| Properties \| Configuration Properties \| C/C++ \| Code Generation** and choose **Yes (/guard:cf)** for Control Flow Guard.</span></span>

![Свойство cfg в Visual Studio](images/cfg-vs.png)

<span data-ttu-id="eb04b-118">Кроме того, можно добавить **/Guard: CF** в **проект свойства конфигурации свойства \| \| настройки \| C/C++ \| Командная строка \| Дополнительные параметры** (для компилятора) и **/Guard: CF** в **проект \| Свойства конфигурации свойства \| настройки \| компоновщика \| \| Дополнительные параметры** (для компоновщика).</span><span class="sxs-lookup"><span data-stu-id="eb04b-118">Alternatively, add **/guard:cf** to **Project \| Properties \| Configuration Properties \| C/C++ \| Command Line \| Additional Options** (for the compiler) and **/guard:cf** to **Project \| Properties \| Configuration Properties \| Linker \| Command Line \| Additional Options** (for the linker).</span></span>

![Свойство cfg для компилятора](images/cfg-compiler.png)![Свойство cfg для компоновщика](images/cfg-linker.png)

<span data-ttu-id="eb04b-121">Дополнительные сведения см. в разделе [/Guard (Включение защиты потока управления)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) .</span><span class="sxs-lookup"><span data-stu-id="eb04b-121">See [/guard (Enable Control Flow Guard)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) for additional info.</span></span>

<span data-ttu-id="eb04b-122">При сборке проекта из командной строки можно добавить те же параметры.</span><span class="sxs-lookup"><span data-stu-id="eb04b-122">If you are building your project from the command line, you can add the same options.</span></span> <span data-ttu-id="eb04b-123">Например, при компиляции проекта с именем Test. cpp используйте **CL/Guard: CF Test. cpp/Link/Guard: CF**.</span><span class="sxs-lookup"><span data-stu-id="eb04b-123">For example, if you are compiling a project called test.cpp, use **cl /guard:cf test.cpp /link /guard:cf**.</span></span>

<span data-ttu-id="eb04b-124">Вы также можете динамически управлять набором конечных адресов в формате iCal, которые считаются допустимыми с помощью CFG с использованием [**сетпроцессвалидкаллтаржетс**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) из API управления памятью.</span><span class="sxs-lookup"><span data-stu-id="eb04b-124">You also have the option of dynamically controlling the set of icall target addresses that are considered valid by CFG using the [**SetProcessValidCallTargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) from the Memory Management API.</span></span> <span data-ttu-id="eb04b-125">Один и тот же API можно использовать, чтобы указать, являются ли страницы недопустимыми или допустимыми целевыми объектами для CFG.</span><span class="sxs-lookup"><span data-stu-id="eb04b-125">The same API can be used to specify whether pages are invalid or valid targets for CFG.</span></span> <span data-ttu-id="eb04b-126">Функции [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) и [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) по умолчанию обрабатывают указанную область исполняемых и зафиксированных страниц как допустимые цели косвенного вызова.</span><span class="sxs-lookup"><span data-stu-id="eb04b-126">The [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) and [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) functions will by default treat a specified region of executable and committed pages as valid indirect call targets.</span></span> <span data-ttu-id="eb04b-127">Это поведение можно переопределить, например при реализации JIT-компилятора, указав **\_ \_ недопустимые цели страницы** при вызове **VirtualAlloc** или **\_ целевых объектов страницы \_ без \_ обновления** при вызове **VirtualProtect** , как описано в разделе [**константы защиты памяти**](/windows/desktop/Memory/memory-protection-constants).</span><span class="sxs-lookup"><span data-stu-id="eb04b-127">It is possible to override this behavior, such as when implementing a Just-in-Time compiler, by specifying **PAGE\_TARGETS\_INVALID** when calling **VirtualAlloc** or **PAGE\_TARGETS\_NO\_UPDATE** when calling **VirtualProtect** as detailed under [**Memory Protection Constants**](/windows/desktop/Memory/memory-protection-constants).</span></span>

## <a name="how-do-i-tell-that-a-binary-is-under-control-flow-guard"></a><span data-ttu-id="eb04b-128">Как определить, что двоичный файл находится под защитой потока управления?</span><span class="sxs-lookup"><span data-stu-id="eb04b-128">How Do I Tell That a Binary is under Control Flow Guard?</span></span>

<span data-ttu-id="eb04b-129">Запустите [средство DUMPBIN](/cpp/build/reference/dumpbin-reference) (входит в установку visual Studio 2015) из командной строки Visual Studio с параметрами */headers* и */лоадконфиг* : **DUMPBIN/HEADERS/лоадконфиг test.exe**.</span><span class="sxs-lookup"><span data-stu-id="eb04b-129">Run the [dumpbin tool](/cpp/build/reference/dumpbin-reference) (included in the Visual Studio 2015 installation) from the Visual Studio command prompt with the */headers* and */loadconfig* options: **dumpbin /headers /loadconfig test.exe**.</span></span> <span data-ttu-id="eb04b-130">Выходные данные для двоичного файла в CFG должны показывать, что значения заголовков включают "Guard" и что значения конфигурации загрузки включают "CF инструментированный" и "Таблица FID Present".</span><span class="sxs-lookup"><span data-stu-id="eb04b-130">The output for a binary under CFG should show that the header values include "Guard", and that the load config values include "CF Instrumented" and "FID table present".</span></span>

![выходные данные подпрограммы DUMPBIN/HEADERS](images/cfg-dumpbin-headers.png)

![выходные данные/лоадконфиг DUMPBIN](images/cfg-dumpbin-loadconfig.png)

## <a name="how-does-cfg-really-work"></a><span data-ttu-id="eb04b-133">Как работает CFG?</span><span class="sxs-lookup"><span data-stu-id="eb04b-133">How Does CFG Really Work?</span></span>

<span data-ttu-id="eb04b-134">Уязвимости программного обеспечения часто используют, предоставляя маловероятное, необычные или экстремальные данные для выполняющейся программы.</span><span class="sxs-lookup"><span data-stu-id="eb04b-134">Software vulnerabilities are often exploited by providing unlikely, unusual, or extreme data to a running program.</span></span> <span data-ttu-id="eb04b-135">Например, злоумышленник может воспользоваться уязвимостью переполнения буфера, предоставляя для программы больше входных данных, чем ожидалось, тем самым заставляя область, зарезервированную программой, для хранения ответа.</span><span class="sxs-lookup"><span data-stu-id="eb04b-135">For example, an attacker can exploit a buffer overflow vulnerability by providing more input to a program than expected, thereby over-running the area reserved by the program to hold a response.</span></span> <span data-ttu-id="eb04b-136">Это может привести к повреждению смежной памяти, в которой может содержаться указатель на функцию.</span><span class="sxs-lookup"><span data-stu-id="eb04b-136">This could corrupt adjacent memory that may hold a function pointer.</span></span> <span data-ttu-id="eb04b-137">Когда программа вызывает эту функцию, она может перейти к непреднамеренному расположению, указанному злоумышленником.</span><span class="sxs-lookup"><span data-stu-id="eb04b-137">When the program calls through this function it may then jump to an unintended location specified by the attacker.</span></span>

<span data-ttu-id="eb04b-138">Однако потент комбинация поддержки компиляции и времени выполнения из CFG реализует целостность потока управления, которая жестко ограничена, где могут выполняться косвенные инструкции по вызову.</span><span class="sxs-lookup"><span data-stu-id="eb04b-138">However, a potent combination of compile and run-time support from CFG implements control flow integrity that tightly restricts where indirect call instructions can execute.</span></span>

<span data-ttu-id="eb04b-139">Компилятор выполняет следующие действия:</span><span class="sxs-lookup"><span data-stu-id="eb04b-139">The compiler does the following:</span></span>

1.  <span data-ttu-id="eb04b-140">Добавляет упрощенные проверки безопасности в скомпилированный код.</span><span class="sxs-lookup"><span data-stu-id="eb04b-140">Adds lightweight security checks to the compiled code.</span></span>
2.  <span data-ttu-id="eb04b-141">Определяет набор функций в приложении, которые являются допустимыми целевыми объектами для косвенных вызовов.</span><span class="sxs-lookup"><span data-stu-id="eb04b-141">Identifies the set of functions in the application that are valid targets for indirect calls.</span></span>

<span data-ttu-id="eb04b-142">Поддержка среды выполнения, предоставляемая ядром Windows:</span><span class="sxs-lookup"><span data-stu-id="eb04b-142">The runtime support, provided by the Windows kernel:</span></span>

1.  <span data-ttu-id="eb04b-143">Эффективно сохраняет состояние, определяющее допустимые цели косвенного вызова.</span><span class="sxs-lookup"><span data-stu-id="eb04b-143">Efficiently maintains state that identifies valid indirect call targets.</span></span>
2.  <span data-ttu-id="eb04b-144">Реализует логику, проверяющую допустимость непрямого целевого объекта вызова.</span><span class="sxs-lookup"><span data-stu-id="eb04b-144">Implements the logic that verifies that an indirect call target is valid.</span></span>

<span data-ttu-id="eb04b-145">Для иллюстрации:</span><span class="sxs-lookup"><span data-stu-id="eb04b-145">To illustrate:</span></span>

![псевдокод](images/cfg-pseudocode.jpg)

<span data-ttu-id="eb04b-147">Если во время выполнения проверка CFG завершается сбоем, Windows немедленно завершает программу, тем самым нарушая тем самым атаку, которая пытается косвенно вызвать недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="eb04b-147">When a CFG check fails at runtime, Windows immediately terminates the program, thus breaking any exploit that attempts to indirectly call an invalid address.</span></span>

 

 
