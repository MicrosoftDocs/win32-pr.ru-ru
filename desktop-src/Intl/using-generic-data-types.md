---
description: Если в коде используются универсальные типы данных, их можно скомпилировать для Юникода просто с помощью директивы препроцессора для определения &\# 0034; Юникод&\# 0034; перед \# инструкциями include для файлов заголовков.
ms.assetid: 1c9cbb18-9295-4847-86c1-d596668cbe57
title: Использование универсальных типов данных
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d0e2604f87b12e86076bed47f509c6398fa8482b
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105684605"
---
# <a name="using-generic-data-types"></a>Использование универсальных типов данных

Если в коде используются универсальные типы данных, их можно скомпилировать для [Юникода](unicode.md) просто с помощью директивы препроцессора, чтобы определить "Unicode" перед инструкциями **\# include** для файлов заголовков. Чтобы скомпилировать код кодовых [страниц Windows (ANSI)](code-pages.md), опустите определение "Unicode". Новые приложения Windows должны использовать Юникод, чтобы избежать несоответствий между различными кодовыми страницами и упростить локализацию.

Для создания исходного кода, который может быть скомпилирован либо для использования символов и строк Юникода, либо для использования символов и строк из кодовых страниц Windows:

1.  Для всех символьных и строковых типов, используемых для текста, используются универсальные типы данных, такие как TCHAR, LPTSTR и ЛПТЧ. Дополнительные сведения об универсальных типах см. в разделе [типы данных Windows для строк](windows-data-types-for-strings.md).
2.  Убедитесь, что указатели на нетекстовые буферы данных или двоичные байтовые массивы кодируются с помощью таких типов данных, как LPBYTE или ЛПВОРД, а не типа LPTSTR или ЛПТЧ.
3.  Объявите указатели неопределенного типа явным образом как пустые указатели с помощью ЛПВОИД, как нужно.
4.  Сделать арифметический тип, не зависящий от указателя. Использование единиц размера TCHAR дает переменные размером 2 байта, если определен Юникод, и 1 байт, если Юникод не определен. Использование арифметики указателей всегда возвращает число элементов, обозначенных указателем, независимо от размера элементов: 1 или 2 байта. Следующее выражение всегда получает количество элементов, независимо от того, определено ли значение Юникод.

    ```C++
    cCount = lpEnd - lpStart;
    ```

    

    Следующее выражение определяет количество используемых байтов.

    ```C++
    cByteCount = (lpEnd - lpStart) * sizeof(TCHAR);
    ```

    

    Нет необходимости изменять инструкцию, подобную следующей, поскольку шаг указателя указывает на следующий элемент символа.

    ```C++
    chNext = *++lpText;
    ```

    

5.  Замените литеральные строки и символьные константы манифеста макросами. Измените такие выражения, как приведенные ниже.

    ```C++
    while(*lpFileName++ != '\\')
    {
        // ...
    }
    ```

    

    Используйте [**текстовый**](/windows/desktop/api/Winnt/nf-winnt-text) макрос, как показано ниже в этом выражении.

    ```C++
    while(*lpFileName++ != TEXT('\\'))
    {
        // ...
    }
    ```

    

    [**Текстовый**](/windows/desktop/api/Winnt/nf-winnt-text) макрос приводит к тому, что строки будут оцениваться как L "строка", когда определен Юникод, а как "строка" в противном случае. Для упрощения управления переместите строковые литералы в ресурсы, особенно если они содержат символы вне диапазона ASCII (от 0x00 до 0x7F) или предоставляются в пользовательском интерфейсе. Для поддержки локализации приложения для разных национальных языков очень важно, чтобы все строки пользовательского интерфейса набыли в локализуемых ресурсах.

6.  Используйте универсальные версии функций Windows. Дополнительные сведения см. в разделе [соглашения для прототипов функций](conventions-for-function-prototypes.md).
7.  Используйте универсальные версии стандартных строковых функций библиотеки C и не забудьте определить " \_ Unicode", а также "Unicode", как описано в [стандартных функциях c](standard-c-functions.md).
8.  При адаптации приложения, изначально написанного для кодовых страниц Windows, не забудьте изменить код, который использует 255 в качестве самого крупного значения для символа.

При компиляции кода, описанного выше, компилятор может создавать версии приложения на основе кодовой страницы в Юникоде и Windows из одного источника. В зависимости от определений Юникода универсальные функции разрешаются для создания тех же двоичных файлов, что и при написании кода исключительно для Юникода или исключительно для кодовых страниц Windows.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Использование Юникода и кодировок](using-unicode-and-character-sets.md)
</dt> </dl>

 

 



