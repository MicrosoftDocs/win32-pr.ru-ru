---
title: Реализации интерфейсов и интерфейсов
description: COM делает фундаментальное различие между определениями интерфейсов и их реализациями.
ms.assetid: f50b3e8f-bf87-4525-b47b-96e75b3a05b9
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: db8df92ac8b851925d82a4b03505fa4c5ab3dc39
ms.sourcegitcommit: 80d74c0bf4fc402865a1ad223480abe1ce4d1115
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/12/2020
ms.locfileid: "104069673"
---
# <a name="interfaces-and-interface-implementations"></a><span data-ttu-id="38ffc-103">Реализации интерфейсов и интерфейсов</span><span class="sxs-lookup"><span data-stu-id="38ffc-103">Interfaces and Interface Implementations</span></span>

<span data-ttu-id="38ffc-104">COM делает фундаментальное различие между определениями интерфейсов и их реализациями.</span><span class="sxs-lookup"><span data-stu-id="38ffc-104">COM makes a fundamental distinction between interface definitions and their implementations.</span></span>

<span data-ttu-id="38ffc-105">*Интерфейс* фактически является контрактом, состоящим из группы связанных прототипов функций, использование которых определено, но его реализация не имеет.</span><span class="sxs-lookup"><span data-stu-id="38ffc-105">An *interface* is actually a contract that consists of a group of related function prototypes whose usage is defined but whose implementation is not.</span></span> <span data-ttu-id="38ffc-106">Эти прототипы функций эквивалентны чисто виртуальным базовым классам в программировании на C++.</span><span class="sxs-lookup"><span data-stu-id="38ffc-106">These function prototypes are equivalent to pure virtual base classes in C++ programming.</span></span> <span data-ttu-id="38ffc-107">Определение интерфейса определяет функции элементов интерфейса, называемые *методами*, типы возвращаемых данных, число и типы их параметров, а также то, что они должны делать.</span><span class="sxs-lookup"><span data-stu-id="38ffc-107">An interface definition specifies the interface's member functions, called *methods*, their return types, the number and types of their parameters, and what they must do.</span></span> <span data-ttu-id="38ffc-108">Нет реализации, связанной с интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="38ffc-108">There is no implementation associated with an interface.</span></span>

<span data-ttu-id="38ffc-109">*Реализация интерфейса* — это код, предоставляемый программистом для выполнения действий, указанных в определении интерфейса.</span><span class="sxs-lookup"><span data-stu-id="38ffc-109">An *interface implementation* is the code a programmer supplies to carry out the actions specified in an interface definition.</span></span> <span data-ttu-id="38ffc-110">Реализации многих интерфейсов, которые программист может использовать в приложении на основе объектов, включены в библиотеки COM.</span><span class="sxs-lookup"><span data-stu-id="38ffc-110">Implementations of many of the interfaces a programmer can use in an object-based application are included in the COM libraries.</span></span> <span data-ttu-id="38ffc-111">Однако программисты могут игнорировать эти реализации и написать свои собственные.</span><span class="sxs-lookup"><span data-stu-id="38ffc-111">However, programmers are free to ignore these implementations and write their own.</span></span> <span data-ttu-id="38ffc-112">Реализация интерфейса должна быть связана с объектом при создании экземпляра этого объекта, а реализация предоставляет службы, предлагаемые объектом.</span><span class="sxs-lookup"><span data-stu-id="38ffc-112">An interface implementation is to be associated with an object when an instance of that object is created, and the implementation provides the services that the object offers.</span></span>

<span data-ttu-id="38ffc-113">Например, гипотетический интерфейс с именем "noreturn" может определять два метода: Push и POP, которые указывают, что последовательные вызовы метода Pop возвращают в обратном порядке значения, ранее переданные методу Push.</span><span class="sxs-lookup"><span data-stu-id="38ffc-113">For example, a hypothetical interface named IStack might define two methods, named Push and Pop, specifying that successive calls to the Pop method return, in reverse order, values previously passed to the Push method.</span></span> <span data-ttu-id="38ffc-114">Это определение интерфейса не будет указывать, как функции должны быть реализованы в коде.</span><span class="sxs-lookup"><span data-stu-id="38ffc-114">This interface definition would not specify how the functions are to be implemented in code.</span></span> <span data-ttu-id="38ffc-115">При реализации интерфейса один программист может реализовать стек как массив и реализовать методы push и POP таким образом, чтобы получить доступ к этому массиву, тогда как другой программист может использовать связанный список и реализовать соответствующие методы.</span><span class="sxs-lookup"><span data-stu-id="38ffc-115">In implementing the interface, one programmer might implement the stack as an array and implement the Push and Pop methods in such a way as to access that array, while another programmer might use a linked list and would implement the methods accordingly.</span></span> <span data-ttu-id="38ffc-116">Независимо от конкретной реализации методов push и POP, в памяти представление указателя на интерфейс «гвоздика» и, следовательно, его использование клиентом, полностью определяется определением интерфейса.</span><span class="sxs-lookup"><span data-stu-id="38ffc-116">Regardless of a particular implementation of the Push and Pop methods, the in-memory representation of a pointer to an IStack interface, and therefore its use by a client, is completely determined by the interface definition.</span></span>

<span data-ttu-id="38ffc-117">Простые объекты поддерживают только один интерфейс.</span><span class="sxs-lookup"><span data-stu-id="38ffc-117">Simple objects support only a single interface.</span></span> <span data-ttu-id="38ffc-118">Более сложные объекты, такие как внедряемые объекты, обычно поддерживают несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="38ffc-118">More complicated objects, such as embeddable objects, typically support several interfaces.</span></span> <span data-ttu-id="38ffc-119">Клиенты имеют доступ к COM-объекту только через указатель на один из его интерфейсов, который, в свою очередь, позволяет клиенту вызывать любой из методов, составляющих этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="38ffc-119">Clients have access to a COM object only through a pointer to one of its interfaces, which, in turn, allows the client to call any of the methods that make up that interface.</span></span> <span data-ttu-id="38ffc-120">Эти методы определяют, как клиент может использовать данные объекта.</span><span class="sxs-lookup"><span data-stu-id="38ffc-120">These methods determine how a client can use the object's data.</span></span>

<span data-ttu-id="38ffc-121">Интерфейсы определяют контракт между объектом и его клиентами.</span><span class="sxs-lookup"><span data-stu-id="38ffc-121">Interfaces define a contract between an object and its clients.</span></span> <span data-ttu-id="38ffc-122">В контракте указываются методы, которые должны быть связаны с каждым интерфейсом, и поведение каждого из этих методов должно быть в терминах ввода и вывода.</span><span class="sxs-lookup"><span data-stu-id="38ffc-122">The contract specifies the methods that must be associated with each interface and what the behavior of each of the methods must be in terms of input and output.</span></span> <span data-ttu-id="38ffc-123">Контракт обычно не определяет, как реализовать методы в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="38ffc-123">The contract generally does not define how to implement the methods in an interface.</span></span> <span data-ttu-id="38ffc-124">Еще один важный аспект контракта заключается в том, что если объект поддерживает интерфейс, он должен поддерживать все методы этого интерфейса каким-либо образом.</span><span class="sxs-lookup"><span data-stu-id="38ffc-124">Another important aspect of the contract is that if an object supports an interface, it must support all of that interface's methods in some way.</span></span> <span data-ttu-id="38ffc-125">Не все методы в реализации должны выполнять какие-либо действия.</span><span class="sxs-lookup"><span data-stu-id="38ffc-125">Not all of the methods in an implementation need to do something.</span></span> <span data-ttu-id="38ffc-126">Если объект не поддерживает функцию, подразумеваемую методом, его реализация может быть простым возвратом или, возможно, возвратом осмысленного сообщения об ошибке, но методы должны существовать.</span><span class="sxs-lookup"><span data-stu-id="38ffc-126">If an object does not support the function implied by a method, its implementation may be a simple return or perhaps the return of a meaningful error message—but the methods must exist.</span></span>

## <a name="related-topics"></a><span data-ttu-id="38ffc-127">См. также</span><span class="sxs-lookup"><span data-stu-id="38ffc-127">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="38ffc-128">COM-объекты и интерфейсы</span><span class="sxs-lookup"><span data-stu-id="38ffc-128">COM Objects and Interfaces</span></span>](com-objects-and-interfaces.md)
</dt> </dl>

 

 




