---
title: Правила управления памятью
description: Правила управления памятью
ms.assetid: 769127a1-1a14-4ed4-9d38-7cf3e571b661
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 56e7ad2483b794ec5c2e9c325bca8e469ff4ae0b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104134674"
---
# <a name="memory-management-rules"></a><span data-ttu-id="44855-103">Правила управления памятью</span><span class="sxs-lookup"><span data-stu-id="44855-103">Memory Management Rules</span></span>

<span data-ttu-id="44855-104">Время существования указателей на интерфейсы всегда управляется с помощью методов [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) для каждого COM-интерфейса.</span><span class="sxs-lookup"><span data-stu-id="44855-104">The lifetime of pointers to interfaces is always managed through the [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) methods on every COM interface.</span></span> <span data-ttu-id="44855-105">Дополнительные сведения см. в разделе [правила управления счетчиками ссылок](rules-for-managing-reference-counts.md).</span><span class="sxs-lookup"><span data-stu-id="44855-105">For more information, see [Rules for Managing Reference Counts](rules-for-managing-reference-counts.md).</span></span>

<span data-ttu-id="44855-106">Для всех остальных параметров важно соблюдать определенные правила для управления памятью.</span><span class="sxs-lookup"><span data-stu-id="44855-106">For all other parameters, it is important to adhere to certain rules for managing memory.</span></span> <span data-ttu-id="44855-107">Следующие правила применяются ко всем параметрам интерфейса месодсâ € ", включая Return валуеâ €", которые не передаются по значению:</span><span class="sxs-lookup"><span data-stu-id="44855-107">The following rules apply to all parameters of interface methodsâ€”including the return valueâ€”that are not passed by value:</span></span>

-   <span data-ttu-id="44855-108">В параметрах должны выделяться и освобождаться вызывающим объектом.</span><span class="sxs-lookup"><span data-stu-id="44855-108">In-parameters must be allocated and freed by the caller.</span></span>
-   <span data-ttu-id="44855-109">Out — параметры должны выделяться одним из вызываемых; они освобождаются вызывающим объектом с помощью механизма выделения памяти для задачи COM уровня "Стандартный".</span><span class="sxs-lookup"><span data-stu-id="44855-109">Out-parameters must be allocated by the one called; they are freed by the caller using the standard COM task memory allocator.</span></span> <span data-ttu-id="44855-110">Дополнительные сведения см. [в разделе распределитель памяти OLE](the-ole-memory-allocator.md) .</span><span class="sxs-lookup"><span data-stu-id="44855-110">See [The OLE Memory Allocator](the-ole-memory-allocator.md) for more information.</span></span>
-   <span data-ttu-id="44855-111">Входные и выходные параметры изначально выделяются вызывающим объектом, а затем освобождаются и повторно выделяются при необходимости.</span><span class="sxs-lookup"><span data-stu-id="44855-111">In/out-parameters are initially allocated by the caller, and then freed and reallocated by the one called, if necessary.</span></span> <span data-ttu-id="44855-112">Как справедливо для параметров out, вызывающий отвечает за освобождение окончательного возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="44855-112">As is true for out parameters, the caller is responsible for freeing the final returned value.</span></span> <span data-ttu-id="44855-113">Необходимо использовать стандартный распределитель памяти COM.</span><span class="sxs-lookup"><span data-stu-id="44855-113">The standard COM memory allocator must be used.</span></span>

<span data-ttu-id="44855-114">В двух последних случаях, когда один фрагмент кода выделяет память, а другой фрагмент кода освобождает его, использование распределителя COM гарантирует, что два фрагмента кода используют одни и те же методы выделения.</span><span class="sxs-lookup"><span data-stu-id="44855-114">In the latter two cases, where one piece of code allocates the memory and a different piece of code frees it, using the COM allocator ensures that the two pieces of code are using the same allocation methods.</span></span>

<span data-ttu-id="44855-115">Еще одной областью, требующей особого внимания, является обработка параметров out и out в условиях сбоя.</span><span class="sxs-lookup"><span data-stu-id="44855-115">Another area that needs special attention is the treatment of out and in-out parameters in failure conditions.</span></span> <span data-ttu-id="44855-116">Если функция возвращает код ошибки, у вызывающего объекта обычно нет способа очистить параметры out или out.</span><span class="sxs-lookup"><span data-stu-id="44855-116">If a function returns a failure code, the caller typically has no way to clean up the out or in-out parameters.</span></span> <span data-ttu-id="44855-117">Это приводит к следующим дополнительным правилам.</span><span class="sxs-lookup"><span data-stu-id="44855-117">This leads to the following additional rules:</span></span>

-   <span data-ttu-id="44855-118">В случае ошибки параметры всегда должны быть надежно установлены в значение, которое будет очищено без каких-либо действий вызывающим.</span><span class="sxs-lookup"><span data-stu-id="44855-118">In case of an error condition, parameters must always be reliably set to a value that will be cleaned up without any action by the caller.</span></span>
-   <span data-ttu-id="44855-119">Все параметры указателя out должны быть явно установлены в **значение NULL**.</span><span class="sxs-lookup"><span data-stu-id="44855-119">All out pointer parameters must explicitly be set to **NULL**.</span></span> <span data-ttu-id="44855-120">Обычно они передаются в параметре указателя на указатель, но также могут передаваться как члены структуры, выделенной вызывающим объектом, и вызываемый код заполняется.</span><span class="sxs-lookup"><span data-stu-id="44855-120">These are usually passed in a pointer-to-pointer parameter but can also be passed as members of a structure that the caller allocates and the called code fills.</span></span> <span data-ttu-id="44855-121">Самый простой способ убедиться, что этот параметр (в части) присвоить этим значениям значение **null** при вводе функции.</span><span class="sxs-lookup"><span data-stu-id="44855-121">The most straightforward way to ensure this is (in part) to set these values to **NULL** on function entry.</span></span> <span data-ttu-id="44855-122">Это правило важно, так как оно повышает надежность взаимодействия приложений.</span><span class="sxs-lookup"><span data-stu-id="44855-122">This rule is important because it promotes more robust application interoperability.</span></span>
-   <span data-ttu-id="44855-123">В условиях ошибки все параметры out должны быть оставлены по отдельности в коде (таким образом, остается в значении, для которого они были инициализированы вызывающим объектом) или явно заданы, как в случае с параметром out Error.</span><span class="sxs-lookup"><span data-stu-id="44855-123">Under error conditions, all in-out parameters must either be left alone by the code called (thus remaining at the value to which they were initialized by the caller) or be explicitly set, as in the out parameter error return case.</span></span>

<span data-ttu-id="44855-124">Помните, что эти соглашения об управлении памятью для COM-приложений применяются только к открытым интерфейсам и Аписâ € "нет необходимости в том, чтобы выделение памяти, строго внутреннее для COM-приложения, было выполнено с помощью этих механизмов.</span><span class="sxs-lookup"><span data-stu-id="44855-124">Remember that these memory management conventions for COM applications apply only across public interfaces and APIsâ€”there is no requirement at all that memory allocation strictly internal to a COM application need be done using these mechanisms.</span></span>

<span data-ttu-id="44855-125">COM внутренне использует удаленные вызовы процедур (RPC) для обмена данными между клиентами и серверами.</span><span class="sxs-lookup"><span data-stu-id="44855-125">COM internally uses Remote Procedure Calls (RPC) to communicate between clients and servers.</span></span> <span data-ttu-id="44855-126">Дополнительные сведения об управлении памятью в заглушках RPC-сервера см. в разделе [сервер-заглушка управления памятью](../rpc/server-stub-memory-management.md) .</span><span class="sxs-lookup"><span data-stu-id="44855-126">For more information about managing memory in RPC server stubs, see the [Server-stub Memory Management](../rpc/server-stub-memory-management.md) topic.</span></span>

## <a name="related-topics"></a><span data-ttu-id="44855-127">См. также</span><span class="sxs-lookup"><span data-stu-id="44855-127">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="44855-128">Управление выделением памяти</span><span class="sxs-lookup"><span data-stu-id="44855-128">Managing Memory Allocation</span></span>](managing-memory-allocation.md)
</dt> </dl>

 

 