---
title: Правила управления счетчиками ссылок
description: Использование счетчика ссылок для управления временем существования объекта позволяет нескольким клиентам получать и освобождать доступ к одному объекту, не обращаясь друг к другу к управлению временем существования объекта.
ms.assetid: bbe7d16c-fcb7-474d-a22d-5a3b33dd800e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a9520cbbc88cb73c6e2abbd7908bed3754bb3945
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104413793"
---
# <a name="rules-for-managing-reference-counts"></a>Правила управления счетчиками ссылок

Использование счетчика ссылок для управления временем существования объекта позволяет нескольким клиентам получать и освобождать доступ к одному объекту, не обращаясь друг к другу к управлению временем существования объекта. Пока клиентский объект соответствует определенным правилам использования, объект, в действительности, предоставляет это управление. Эти правила определяют, как управлять ссылками между объектами. (В COM не указываются внутренние реализации объектов, хотя эти правила являются разумной отправной точкой для политики в объекте.)

По сути, указатели на интерфейсы можно рассматривать как находящиеся в переменных указателя, которые включают все внутреннее состояние вычисления, содержащее указатель интерфейса. Это могут быть переменные в расположениях в памяти, во внутренних регистрах процессора, а как переменные, сформированные программистом, так и созданные компилятором. Присваивание или инициализации переменной указателя подразумевает создание новой копии уже существующего указателя. При наличии одной копии указателя в некоторой переменной (значение, используемое в назначении или инициализации), теперь есть два. Присваивание переменной-указателю уничтожает копию, которая в настоящее время находится в переменной, так же как и уничтожение самой переменной. (То есть область, в которой находится переменная, например кадр стека, уничтожается.)

С точки зрения клиента COM, подсчет ссылок всегда выполняется для каждого интерфейса. Клиенты никогда не должны рассчитывать, что объект использует один и тот же счетчик для всех интерфейсов.

Значение по умолчанию заключается в том, что метод [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) должен вызываться для каждой новой копии указателя интерфейса, а [**выпуск**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) должен вызываться для каждого уничтожения указателя интерфейса, за исключением тех случаев, когда следующие правила разрешены в противном случае.

-   **Выходные параметры для функций.** Вызывающий объект должен вызвать [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) для параметра, так как он будет освобожден (с вызовом [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) в коде реализации, когда значение out хранится поверх него.
-   **Получение глобальной переменной.** При создании локальной копии указателя интерфейса из существующей копии указателя в глобальной переменной необходимо вызвать [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) для локальной копии, так как другая функция может уничтожить копию в глобальной переменной, пока локальная копия остается действительной.
-   **Новые указатели, синтезированные из «тонкого воздуха».** Функция, которая синтезирована указатель интерфейса с помощью специальных внутренних знаний, вместо того чтобы получать ее из другого источника, должна сначала вызвать [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) для вновь созданного указателя. К важным примерам таких подпрограмм относятся подпрограммы создания экземпляров, реализации [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))и т. д.
-   **Получение копии внутреннего сохраненного указателя.** Когда функция извлекает копию указателя, который хранится внутри объекта с именем, код этого объекта должен вызвать [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) в указателе перед возвратом функции. После получения указателя исходный объект не имеет другого способа определить, как его время существования связано с внутренним хранимым экземпляром указателя.

Единственным исключением из регистра по умолчанию является необходимость, чтобы управляющий код знал отношения времени существования двух или более копий указателя на один и тот же интерфейс в объекте и просто гарантировать, что объект не будет уничтожен, разрешая его число ссылок равным нулю. Обычно существует два варианта, как показано ниже.

-   Если одна копия указателя уже существует, а вторая создается в дальнейшем, а затем уничтожается, а затем удаляется, пока не будет создана первая копия, можно опустить вызовы [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)для второй копии.
-   Когда существует одна копия указателя и создается вторая, а затем первый удаляется до второй, можно опустить вызовы [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)для второй копии и [**выпуска**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) для первой копии.

Ниже приведены конкретные примеры таких ситуаций, в которых первые два являются особенно распространенными:

-   **В параметрах функции.** Время существования копии указателя интерфейса, переданного в качестве параметра функции, вложено в указатель, используемый для инициализации значения, поэтому нет необходимости в отдельном счетчике ссылок для параметра.
-   **Выходные параметры из функций, включая возвращаемые значения.** Чтобы задать выходной параметр, функция должна иметь устойчивую копию указателя интерфейса. При возврате вызывающий объект отвечает за освобождение указателя. Таким образом, параметр out не требует отдельного счетчика ссылок.
-   **Локальные переменные.** Реализация метода имеет контроль над временем существования всех переменных-указателей, выделенных в кадре стека, и может использовать его для определения способа опустить [](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)избыточные пары в / [**выпуске**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) AddRef.
-   **Курсоры.** Некоторые структуры данных содержат два объекта, каждый из которых имеет указатель на другой. Если время существования первого объекта известно для того, чтобы оно содержало время существования во втором объекте, нет необходимости иметь счетчик ссылок на указатель второго объекта на первый объект. Как правило, избежание этого цикла важно для поддержания соответствующего поведения при освобождении. Однако подсчитанные указатели следует использовать с особой осторожностью, так как часть операционной системы, обрабатывающая удаленную обработку, не имеет способа узнать об этой связи. Поэтому почти во всех случаях, когда у курсора есть второй, «дружественный» объект первого указателя (таким образом, избегая цикличности) является предпочтительным решением. Архитектура подключаемых объектов COM, например, использует этот подход.

При реализации или использовании объектов, подсчитанных по ссылке, может быть полезно применять *искусственные счетчики ссылок*, что гарантирует стабильность объектов во время обработки функции. При реализации метода интерфейса можно вызывать функции, которые могут привести к уменьшению числа ссылок на объект, что приводит к преждевременному выпуску объекта и сбою реализации. Надежный способ избежать этого — вставить вызов [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) в начале реализации метода и связать его с вызовом функции [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) непосредственно перед возвратом метода.

В некоторых ситуациях возвращаемые значения [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) могут быть нестабильными и не должны рассчитываться на них. они должны использоваться только в целях отладки или диагностики.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Управление жизненным циклом объектов с помощью подсчета ссылок](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 