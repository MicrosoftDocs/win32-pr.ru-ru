---
title: Правила управления счетчиками ссылок
description: Использование счетчика ссылок для управления временем существования объекта позволяет нескольким клиентам получать и освобождать доступ к одному объекту, не обращаясь друг к другу к управлению временем существования объекта.
ms.assetid: bbe7d16c-fcb7-474d-a22d-5a3b33dd800e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a9520cbbc88cb73c6e2abbd7908bed3754bb3945
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104413793"
---
# <a name="rules-for-managing-reference-counts"></a><span data-ttu-id="221bd-103">Правила управления счетчиками ссылок</span><span class="sxs-lookup"><span data-stu-id="221bd-103">Rules for Managing Reference Counts</span></span>

<span data-ttu-id="221bd-104">Использование счетчика ссылок для управления временем существования объекта позволяет нескольким клиентам получать и освобождать доступ к одному объекту, не обращаясь друг к другу к управлению временем существования объекта.</span><span class="sxs-lookup"><span data-stu-id="221bd-104">Using a reference count to manage an object's lifetime allows multiple clients to obtain and release access to a single object without having to coordinate with one another in managing the object's lifetime.</span></span> <span data-ttu-id="221bd-105">Пока клиентский объект соответствует определенным правилам использования, объект, в действительности, предоставляет это управление.</span><span class="sxs-lookup"><span data-stu-id="221bd-105">As long as the client object conforms to certain rules of use, the object, in effect, provides this management.</span></span> <span data-ttu-id="221bd-106">Эти правила определяют, как управлять ссылками между объектами.</span><span class="sxs-lookup"><span data-stu-id="221bd-106">These rules specify how to manage references between objects.</span></span> <span data-ttu-id="221bd-107">(В COM не указываются внутренние реализации объектов, хотя эти правила являются разумной отправной точкой для политики в объекте.)</span><span class="sxs-lookup"><span data-stu-id="221bd-107">(COM does not specify internal implementations of objects, although these rules are a reasonable starting point for a policy within an object.)</span></span>

<span data-ttu-id="221bd-108">По сути, указатели на интерфейсы можно рассматривать как находящиеся в переменных указателя, которые включают все внутреннее состояние вычисления, содержащее указатель интерфейса.</span><span class="sxs-lookup"><span data-stu-id="221bd-108">Conceptually, interface pointers can be thought of as residing within pointer variables that include all the internal computation state that holds an interface pointer.</span></span> <span data-ttu-id="221bd-109">Это могут быть переменные в расположениях в памяти, во внутренних регистрах процессора, а как переменные, сформированные программистом, так и созданные компилятором.</span><span class="sxs-lookup"><span data-stu-id="221bd-109">This would include variables in memory locations, in internal processor registers, and both programmer-generated and compiler-generated variables.</span></span> <span data-ttu-id="221bd-110">Присваивание или инициализации переменной указателя подразумевает создание новой копии уже существующего указателя.</span><span class="sxs-lookup"><span data-stu-id="221bd-110">Assignment to or initialization of a pointer variable involves creating a new copy of an already existing pointer.</span></span> <span data-ttu-id="221bd-111">При наличии одной копии указателя в некоторой переменной (значение, используемое в назначении или инициализации), теперь есть два.</span><span class="sxs-lookup"><span data-stu-id="221bd-111">Where there was one copy of the pointer in some variable (the value used in the assignment/initialization), there are now two.</span></span> <span data-ttu-id="221bd-112">Присваивание переменной-указателю уничтожает копию, которая в настоящее время находится в переменной, так же как и уничтожение самой переменной.</span><span class="sxs-lookup"><span data-stu-id="221bd-112">An assignment to a pointer variable destroys the pointer copy presently in the variable, as does the destruction of the variable itself.</span></span> <span data-ttu-id="221bd-113">(То есть область, в которой находится переменная, например кадр стека, уничтожается.)</span><span class="sxs-lookup"><span data-stu-id="221bd-113">(That is, the scope in which the variable is found, such as the stack frame, is destroyed.)</span></span>

<span data-ttu-id="221bd-114">С точки зрения клиента COM, подсчет ссылок всегда выполняется для каждого интерфейса.</span><span class="sxs-lookup"><span data-stu-id="221bd-114">From a COM client's perspective, reference counting is always done for each interface.</span></span> <span data-ttu-id="221bd-115">Клиенты никогда не должны рассчитывать, что объект использует один и тот же счетчик для всех интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="221bd-115">Clients should never assume that an object uses the same counter for all interfaces.</span></span>

<span data-ttu-id="221bd-116">Значение по умолчанию заключается в том, что метод [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) должен вызываться для каждой новой копии указателя интерфейса, а [**выпуск**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) должен вызываться для каждого уничтожения указателя интерфейса, за исключением тех случаев, когда следующие правила разрешены в противном случае.</span><span class="sxs-lookup"><span data-stu-id="221bd-116">The default case is that [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) must be called for every new copy of an interface pointer and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) must be called for every destruction of an interface pointer, except where the following rules permit otherwise:</span></span>

-   <span data-ttu-id="221bd-117">**Выходные параметры для функций.**</span><span class="sxs-lookup"><span data-stu-id="221bd-117">**In-out parameters to functions.**</span></span> <span data-ttu-id="221bd-118">Вызывающий объект должен вызвать [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) для параметра, так как он будет освобожден (с вызовом [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) в коде реализации, когда значение out хранится поверх него.</span><span class="sxs-lookup"><span data-stu-id="221bd-118">The caller must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the parameter because it will be released (with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) in the implementing code when the out value is stored on top of it.</span></span>
-   <span data-ttu-id="221bd-119">**Получение глобальной переменной.**</span><span class="sxs-lookup"><span data-stu-id="221bd-119">**Fetching a global variable.**</span></span> <span data-ttu-id="221bd-120">При создании локальной копии указателя интерфейса из существующей копии указателя в глобальной переменной необходимо вызвать [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) для локальной копии, так как другая функция может уничтожить копию в глобальной переменной, пока локальная копия остается действительной.</span><span class="sxs-lookup"><span data-stu-id="221bd-120">When creating a local copy of an interface pointer from an existing copy of the pointer in a global variable, you must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the local copy because another function might destroy the copy in the global variable while the local copy is still valid.</span></span>
-   <span data-ttu-id="221bd-121">**Новые указатели, синтезированные из «тонкого воздуха».**</span><span class="sxs-lookup"><span data-stu-id="221bd-121">**New pointers synthesized out of "thin air."**</span></span> <span data-ttu-id="221bd-122">Функция, которая синтезирована указатель интерфейса с помощью специальных внутренних знаний, вместо того чтобы получать ее из другого источника, должна сначала вызвать [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) для вновь созданного указателя.</span><span class="sxs-lookup"><span data-stu-id="221bd-122">A function that synthesizes an interface pointer using special internal knowledge rather than obtaining it from some other source must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) initially on the newly synthesized pointer.</span></span> <span data-ttu-id="221bd-123">К важным примерам таких подпрограмм относятся подпрограммы создания экземпляров, реализации [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))и т. д.</span><span class="sxs-lookup"><span data-stu-id="221bd-123">Important examples of such routines include instance creation routines, implementations of [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), and so on.</span></span>
-   <span data-ttu-id="221bd-124">**Получение копии внутреннего сохраненного указателя.**</span><span class="sxs-lookup"><span data-stu-id="221bd-124">**Retrieving a copy of an internally stored pointer.**</span></span> <span data-ttu-id="221bd-125">Когда функция извлекает копию указателя, который хранится внутри объекта с именем, код этого объекта должен вызвать [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) в указателе перед возвратом функции.</span><span class="sxs-lookup"><span data-stu-id="221bd-125">When a function retrieves a copy of a pointer that is stored internally by the object called, that object's code must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the pointer before the function returns.</span></span> <span data-ttu-id="221bd-126">После получения указателя исходный объект не имеет другого способа определить, как его время существования связано с внутренним хранимым экземпляром указателя.</span><span class="sxs-lookup"><span data-stu-id="221bd-126">Once the pointer has been retrieved, the originating object has no other way of determining how its lifetime relates to that of the internally stored copy of the pointer.</span></span>

<span data-ttu-id="221bd-127">Единственным исключением из регистра по умолчанию является необходимость, чтобы управляющий код знал отношения времени существования двух или более копий указателя на один и тот же интерфейс в объекте и просто гарантировать, что объект не будет уничтожен, разрешая его число ссылок равным нулю.</span><span class="sxs-lookup"><span data-stu-id="221bd-127">The only exceptions to the default case require that the managing code know the relationships of the lifetimes of two or more copies of a pointer to the same interface on an object and simply ensure that the object is not destroyed by allowing its reference count to go to zero.</span></span> <span data-ttu-id="221bd-128">Обычно существует два варианта, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="221bd-128">There are generally two cases, as follows:</span></span>

-   <span data-ttu-id="221bd-129">Если одна копия указателя уже существует, а вторая создается в дальнейшем, а затем уничтожается, а затем удаляется, пока не будет создана первая копия, можно опустить вызовы [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)для второй копии.</span><span class="sxs-lookup"><span data-stu-id="221bd-129">When one copy of a pointer already exists and a second is created subsequently and then is destroyed while the first copy still exists, calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)for the second copy can be omitted.</span></span>
-   <span data-ttu-id="221bd-130">Когда существует одна копия указателя и создается вторая, а затем первый удаляется до второй, можно опустить вызовы [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)для второй копии и [**выпуска**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) для первой копии.</span><span class="sxs-lookup"><span data-stu-id="221bd-130">When one copy of a pointer exists and a second is created and then the first is destroyed before the second, the calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)for the second copy and to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) for the first copy can be omitted.</span></span>

<span data-ttu-id="221bd-131">Ниже приведены конкретные примеры таких ситуаций, в которых первые два являются особенно распространенными:</span><span class="sxs-lookup"><span data-stu-id="221bd-131">The following are specific examples of these situations, the first two being especially common:</span></span>

-   <span data-ttu-id="221bd-132">**В параметрах функции.**</span><span class="sxs-lookup"><span data-stu-id="221bd-132">**In parameters to functions.**</span></span> <span data-ttu-id="221bd-133">Время существования копии указателя интерфейса, переданного в качестве параметра функции, вложено в указатель, используемый для инициализации значения, поэтому нет необходимости в отдельном счетчике ссылок для параметра.</span><span class="sxs-lookup"><span data-stu-id="221bd-133">The lifetime of the copy of an interface pointer passed as a parameter to a function is nested in that of the pointer used to initialize the value, so there is no need for a separate reference count on the parameter.</span></span>
-   <span data-ttu-id="221bd-134">**Выходные параметры из функций, включая возвращаемые значения.**</span><span class="sxs-lookup"><span data-stu-id="221bd-134">**Out parameters from functions, including return values.**</span></span> <span data-ttu-id="221bd-135">Чтобы задать выходной параметр, функция должна иметь устойчивую копию указателя интерфейса.</span><span class="sxs-lookup"><span data-stu-id="221bd-135">To set the out parameter, the function must have a stable copy of the interface pointer.</span></span> <span data-ttu-id="221bd-136">При возврате вызывающий объект отвечает за освобождение указателя.</span><span class="sxs-lookup"><span data-stu-id="221bd-136">On return, the caller is responsible for releasing the pointer.</span></span> <span data-ttu-id="221bd-137">Таким образом, параметр out не требует отдельного счетчика ссылок.</span><span class="sxs-lookup"><span data-stu-id="221bd-137">Therefore, the out parameter does not need a separate reference count.</span></span>
-   <span data-ttu-id="221bd-138">**Локальные переменные.**</span><span class="sxs-lookup"><span data-stu-id="221bd-138">**Local variables.**</span></span> <span data-ttu-id="221bd-139">Реализация метода имеет контроль над временем существования всех переменных-указателей, выделенных в кадре стека, и может использовать его для определения способа опустить [](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)избыточные пары в / [**выпуске**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) AddRef.</span><span class="sxs-lookup"><span data-stu-id="221bd-139">A method implementation has control of the lifetimes of each of the pointer variables allocated on the stack frame and can use this to determine how to omit redundant [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)/[**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) pairs.</span></span>
-   <span data-ttu-id="221bd-140">**Курсоры.**</span><span class="sxs-lookup"><span data-stu-id="221bd-140">**Backpointers.**</span></span> <span data-ttu-id="221bd-141">Некоторые структуры данных содержат два объекта, каждый из которых имеет указатель на другой.</span><span class="sxs-lookup"><span data-stu-id="221bd-141">Some data structures contain two objects, each with a pointer to the other.</span></span> <span data-ttu-id="221bd-142">Если время существования первого объекта известно для того, чтобы оно содержало время существования во втором объекте, нет необходимости иметь счетчик ссылок на указатель второго объекта на первый объект.</span><span class="sxs-lookup"><span data-stu-id="221bd-142">If the lifetime of the first object is known to contain the lifetime of the second, it is not necessary to have a reference count on the second object's pointer to the first object.</span></span> <span data-ttu-id="221bd-143">Как правило, избежание этого цикла важно для поддержания соответствующего поведения при освобождении.</span><span class="sxs-lookup"><span data-stu-id="221bd-143">Often, avoiding this cycle is important in maintaining the appropriate deallocation behavior.</span></span> <span data-ttu-id="221bd-144">Однако подсчитанные указатели следует использовать с особой осторожностью, так как часть операционной системы, обрабатывающая удаленную обработку, не имеет способа узнать об этой связи.</span><span class="sxs-lookup"><span data-stu-id="221bd-144">However, uncounted pointers should be used with extreme caution because the portion of the operating system that handles remote processing has no way of knowing about this relationship.</span></span> <span data-ttu-id="221bd-145">Поэтому почти во всех случаях, когда у курсора есть второй, «дружественный» объект первого указателя (таким образом, избегая цикличности) является предпочтительным решением.</span><span class="sxs-lookup"><span data-stu-id="221bd-145">Therefore, in almost all cases, having the backpointer see a second, "friend" object of the first pointer (thus avoiding the circularity) is the preferred solution.</span></span> <span data-ttu-id="221bd-146">Архитектура подключаемых объектов COM, например, использует этот подход.</span><span class="sxs-lookup"><span data-stu-id="221bd-146">COM's connectable objects architecture, for example, uses this approach.</span></span>

<span data-ttu-id="221bd-147">При реализации или использовании объектов, подсчитанных по ссылке, может быть полезно применять *искусственные счетчики ссылок*, что гарантирует стабильность объектов во время обработки функции.</span><span class="sxs-lookup"><span data-stu-id="221bd-147">When implementing or using reference-counted objects, it may be useful to apply *artificial reference counts*, which guarantee object stability during processing of a function.</span></span> <span data-ttu-id="221bd-148">При реализации метода интерфейса можно вызывать функции, которые могут привести к уменьшению числа ссылок на объект, что приводит к преждевременному выпуску объекта и сбою реализации.</span><span class="sxs-lookup"><span data-stu-id="221bd-148">In implementing a method of an interface, you might call functions that have a chance of decrementing your reference count to an object, causing a premature release of the object and failure of the implementation.</span></span> <span data-ttu-id="221bd-149">Надежный способ избежать этого — вставить вызов [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) в начале реализации метода и связать его с вызовом функции [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) непосредственно перед возвратом метода.</span><span class="sxs-lookup"><span data-stu-id="221bd-149">A robust way to avoid this is to insert a call to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) at the beginning of the method implementation and pair it with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) just before the method returns.</span></span>

<span data-ttu-id="221bd-150">В некоторых ситуациях возвращаемые значения [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) могут быть нестабильными и не должны рассчитываться на них. они должны использоваться только в целях отладки или диагностики.</span><span class="sxs-lookup"><span data-stu-id="221bd-150">In some situations, the return values of [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) may be unstable and should not be relied upon; they should be used only for debugging or diagnostic purposes.</span></span>

## <a name="related-topics"></a><span data-ttu-id="221bd-151">См. также</span><span class="sxs-lookup"><span data-stu-id="221bd-151">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="221bd-152">Управление жизненным циклом объектов с помощью подсчета ссылок</span><span class="sxs-lookup"><span data-stu-id="221bd-152">Managing Object Lifetimes Through Reference Counting</span></span>](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 