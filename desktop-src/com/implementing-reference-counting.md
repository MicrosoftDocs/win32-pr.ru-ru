---
title: Реализация подсчета ссылок
description: Реализация подсчета ссылок
ms.assetid: d4fd98c9-afa4-4c5c-a3c9-44d34881cbdb
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a0d4dfe2b0faf2fc6557d1b089e33ae6ce4b98cb
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "105710391"
---
# <a name="implementing-reference-counting"></a><span data-ttu-id="7e85a-103">Реализация подсчета ссылок</span><span class="sxs-lookup"><span data-stu-id="7e85a-103">Implementing Reference Counting</span></span>

<span data-ttu-id="7e85a-104">Для подсчета ссылок требуется работа в части класса, реализующего класс, и клиентов, использующих объекты этого класса.</span><span class="sxs-lookup"><span data-stu-id="7e85a-104">Reference counting requires work on the part of both the implementor of a class and the clients who use objects of that class.</span></span> <span data-ttu-id="7e85a-105">При реализации класса необходимо реализовать методы [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) в составе интерфейса [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) .</span><span class="sxs-lookup"><span data-stu-id="7e85a-105">When you implement a class, you must implement the [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) methods as part of the [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) interface.</span></span> <span data-ttu-id="7e85a-106">Эти два метода имеют следующие простые реализации:</span><span class="sxs-lookup"><span data-stu-id="7e85a-106">These two methods have the following simple implementations:</span></span>

-   <span data-ttu-id="7e85a-107">[**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) увеличивает число внутренних ссылок объекта.</span><span class="sxs-lookup"><span data-stu-id="7e85a-107">[**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) increments the object's internal reference count.</span></span>
-   <span data-ttu-id="7e85a-108">Сначала [**выпуск**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) уменьшает внутренний счетчик ссылок объекта, а затем проверяет, не было ли значение счетчика ссылок в ноль.</span><span class="sxs-lookup"><span data-stu-id="7e85a-108">[**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) first decrements the object's internal reference count, and then it checks whether the reference count has fallen to zero.</span></span> <span data-ttu-id="7e85a-109">Если он имеет значение, это означает, что никто больше не использует объект, поэтому функция **выпуска** освобождает объект.</span><span class="sxs-lookup"><span data-stu-id="7e85a-109">If it has, that means no one is using the object any longer, so the **Release** function deallocates the object.</span></span>

<span data-ttu-id="7e85a-110">Распространенный подход к реализации большинства объектов заключается в наличии только одной реализации этих методов (вместе с [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))), которая является общей для всех интерфейсов и, следовательно, является счетчиком ссылок, который применяется ко всему объекту.</span><span class="sxs-lookup"><span data-stu-id="7e85a-110">A common implementation approach for most objects is to have only one implementation of these methods (along with [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))), which is shared between all interfaces, and therefore a reference count that applies to the entire object.</span></span> <span data-ttu-id="7e85a-111">Однако с точки зрения клиента подсчет ссылок является строго и четко понятным представлением указателя по интерфейсу, поэтому объекты, использующие эту возможность, динамически создают, уничтожают, загружают или выгружая части их функций на основе указателей на екстант интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="7e85a-111">However, from a client's perspective, reference counting is strictly and clearly a per-interface-pointer notion, and therefore objects that take advantage of this capability by dynamically constructing, destroying, loading, or unloading portions of their functionality based on the currently extant interface pointers may be implemented.</span></span> <span data-ttu-id="7e85a-112">Эти разговорной речи называются *интерфейсами разрыва*.</span><span class="sxs-lookup"><span data-stu-id="7e85a-112">These are colloquially called *tear-off interfaces*.</span></span>

<span data-ttu-id="7e85a-113">Всякий раз, когда клиент вызывает метод (или функцию API), например [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), который возвращает новый указатель интерфейса, вызываемый метод отвечает за увеличение счетчика ссылок с помощью возвращаемого указателя.</span><span class="sxs-lookup"><span data-stu-id="7e85a-113">Whenever a client calls a method (or API function), such as [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), that returns a new interface pointer, the method being called is responsible for incrementing the reference count through the returned pointer.</span></span> <span data-ttu-id="7e85a-114">Например, когда клиент впервые создает объект, он получает указатель интерфейса на объект, который, начиная с точки зрения клиента, имеет счетчик ссылок на один.</span><span class="sxs-lookup"><span data-stu-id="7e85a-114">For example, when a client first creates an object, it receives an interface pointer to an object that, from the client's point of view, has a reference count of one.</span></span> <span data-ttu-id="7e85a-115">Если клиент вызывает [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) для указателя интерфейса, счетчик ссылок преобразуется в два.</span><span class="sxs-lookup"><span data-stu-id="7e85a-115">If the client then calls [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the interface pointer, the reference count becomes two.</span></span> <span data-ttu-id="7e85a-116">Клиент должен дважды вызвать метод [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) в указателе интерфейса, чтобы удалить все ссылки на объект.</span><span class="sxs-lookup"><span data-stu-id="7e85a-116">The client must call [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) twice on the interface pointer to drop all of its references to the object.</span></span>

<span data-ttu-id="7e85a-117">Пример того, как счетчики ссылок строго определяются по интерфейсу, возникает, когда клиент вызывает [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) в первом указателе для нового интерфейса или того же интерфейса.</span><span class="sxs-lookup"><span data-stu-id="7e85a-117">An example of how reference counts are strictly per-interface-pointer occurs when a client calls [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) on the first pointer for either a new interface or the same interface.</span></span> <span data-ttu-id="7e85a-118">В любом из этих случаев клиент должен вызывать метод [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) один раз для каждого указателя.</span><span class="sxs-lookup"><span data-stu-id="7e85a-118">In either of these cases, the client is required to call [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) once for each pointer.</span></span> <span data-ttu-id="7e85a-119">COM не требует, чтобы объект возвращал один и тот же указатель при запросе одного интерфейса несколько раз.</span><span class="sxs-lookup"><span data-stu-id="7e85a-119">COM does not require that an object return the same pointer when asked for the same interface multiple times.</span></span> <span data-ttu-id="7e85a-120">(Единственное исключение — запрос [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), который определяет объект для com.) Это позволяет эффективно управлять ресурсами с помощью реализации объекта.</span><span class="sxs-lookup"><span data-stu-id="7e85a-120">(The only exception to this is a query to [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), which identifies an object to COM.) This allows the object implementation to manage resources efficiently.</span></span>

<span data-ttu-id="7e85a-121">Безопасность потоков также является важной проблемой при реализации [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span><span class="sxs-lookup"><span data-stu-id="7e85a-121">Thread-safety is also an important issue in implementing [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span></span> <span data-ttu-id="7e85a-122">Дополнительные сведения см. в разделе [процессы, потоки и подразделения](processes--threads--and-apartments.md).</span><span class="sxs-lookup"><span data-stu-id="7e85a-122">For more information, see [Processes, Threads, and Apartments](processes--threads--and-apartments.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="7e85a-123">См. также</span><span class="sxs-lookup"><span data-stu-id="7e85a-123">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="7e85a-124">Управление жизненным циклом объектов с помощью подсчета ссылок</span><span class="sxs-lookup"><span data-stu-id="7e85a-124">Managing Object Lifetimes Through Reference Counting</span></span>](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 