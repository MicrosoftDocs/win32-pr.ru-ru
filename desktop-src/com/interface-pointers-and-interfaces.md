---
title: Указатели интерфейса и интерфейсы
description: Указатели интерфейса и интерфейсы
ms.assetid: 8a8671fe-f0b2-4698-8c98-89753fffce0b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: aa23d53f529c43fa7529d657108cc75cb6a23b15
ms.sourcegitcommit: d482e4276cc06515e9fade2f253a257ffc418ce5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/24/2019
ms.locfileid: "105700465"
---
# <a name="interface-pointers-and-interfaces"></a>Указатели интерфейса и интерфейсы

Экземпляр реализации интерфейса на самом деле является указателем на массив указателей на методы, то есть таблицу функций, которая ссылается на реализацию всех методов, указанных в интерфейсе. Объекты с несколькими интерфейсами могут предоставлять указатели более чем на одну таблицу функций. Любой код, имеющий указатель, с помощью которого он может получить доступ к массиву, может вызывать методы в этом интерфейсе.

Говорить точно об этом множественном обращении неудобно, поэтому вместо этого указатель на таблицу функций интерфейса, которую должен иметь другой объект для вызова его методов, называется просто *указателем интерфейса*. Можно вручную создавать таблицы функций в приложении C или почти автоматически с помощью Visual C++ (или других объектно-ориентированных языков, поддерживающих COM).

При наличии соответствующей поддержки компилятора (которая встроена в C и C++) клиент может вызвать метод интерфейса через его имя, а не его расположение в массиве. Поскольку интерфейс — это тип, компилятор с учетом имен методов может проверять типы параметров и возвращаемые значения каждого вызова метода интерфейса. В отличие от этого, если клиент использует схему вызова на основе позиций, такая проверка типов недоступна даже в C или C++.

Каждый интерфейс является неизменяемым контрактом функциональной группы методов. Вы ссылаетесь на интерфейс во время выполнения с помощью глобального уникального идентификатора интерфейса (IID). Этот IID, который является конкретным экземпляром глобального уникального идентификатора (GUID), поддерживаемого COM, позволяет клиенту точно запрашивать объект независимо от того, поддерживает ли он семантику интерфейса, без лишних издержек и без путаницы, которая может возникнуть в системе из нескольких версий одного интерфейса с одинаковым именем.

В итоге важно понимать, что такое COM-интерфейс и не является ли он следующим:

-   COM-интерфейс отличается от класса C++. Чисто виртуальное определение не выполняет никаких реализаций. Программист C++ может определить реализацию интерфейса в качестве класса, но это будет находиться под заголовком сведений о реализации, которые не указываются в COM. Для фактического существования интерфейса необходимо создать экземпляр объекта, который реализует интерфейс. Более того, различные классы объектов могут реализовывать интерфейс по-другому, но в двоичном виде они взаимозаменяемы, если поведение соответствует определению интерфейса.
-   COM-интерфейс не является объектом. Это просто связанная группа функций и является двоичным стандартом, с помощью которого происходит обмен данными между клиентами и объектами. Пока он может предоставлять указатели на методы интерфейса, объект может быть реализован на любом языке с любым внутренним представлением состояния.
-   Интерфейсы COM являются строго типизированными. Каждый интерфейс имеет собственный идентификатор интерфейса (GUID), который исключает возможность дублирования, которая может возникнуть при использовании любой другой схемы именования.
-   COM-интерфейсы являются неизменяемыми. Нельзя определить новую версию старого интерфейса и присвоить ей тот же идентификатор. При добавлении или удалении методов интерфейса или измененной семантики создается новый интерфейс, а не новая версия старого интерфейса. Поэтому новый интерфейс не может конфликтовать со старым интерфейсом. Однако объекты могут поддерживать несколько интерфейсов одновременно и предоставлять интерфейсы, которые являются последовательными редакциями интерфейса, с разными идентификаторами. Таким образом, каждый интерфейс является отдельным контрактом, и общедоступные объекты не должны беспокоиться о том, является ли версия интерфейса, которую они вызывают, ожидаемой. Идентификатор интерфейса (IID) определяет явный и уникальный контракт интерфейса.

## <a name="related-topics"></a>См. также

<dl> <dt>

[COM-объекты и интерфейсы](com-objects-and-interfaces.md)
</dt> </dl>

 

 




