---
title: Указатели интерфейса и интерфейсы
description: Указатели интерфейса и интерфейсы
ms.assetid: 8a8671fe-f0b2-4698-8c98-89753fffce0b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: aa23d53f529c43fa7529d657108cc75cb6a23b15
ms.sourcegitcommit: d482e4276cc06515e9fade2f253a257ffc418ce5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/24/2019
ms.locfileid: "105700465"
---
# <a name="interface-pointers-and-interfaces"></a><span data-ttu-id="de078-103">Указатели интерфейса и интерфейсы</span><span class="sxs-lookup"><span data-stu-id="de078-103">Interface Pointers and Interfaces</span></span>

<span data-ttu-id="de078-104">Экземпляр реализации интерфейса на самом деле является указателем на массив указателей на методы, то есть таблицу функций, которая ссылается на реализацию всех методов, указанных в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="de078-104">An instance of an interface implementation is actually a pointer to an array of pointers to methods - that is, a function table that refers to an implementation of all of the methods specified in the interface.</span></span> <span data-ttu-id="de078-105">Объекты с несколькими интерфейсами могут предоставлять указатели более чем на одну таблицу функций.</span><span class="sxs-lookup"><span data-stu-id="de078-105">Objects with multiple interfaces can provide pointers to more than one function table.</span></span> <span data-ttu-id="de078-106">Любой код, имеющий указатель, с помощью которого он может получить доступ к массиву, может вызывать методы в этом интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="de078-106">Any code that has a pointer through which it can access the array can call the methods in that interface.</span></span>

<span data-ttu-id="de078-107">Говорить точно об этом множественном обращении неудобно, поэтому вместо этого указатель на таблицу функций интерфейса, которую должен иметь другой объект для вызова его методов, называется просто *указателем интерфейса*.</span><span class="sxs-lookup"><span data-stu-id="de078-107">Speaking precisely about this multiple indirection is inconvenient, so instead, the pointer to the interface function table that another object must have to call its methods is called simply an *interface pointer*.</span></span> <span data-ttu-id="de078-108">Можно вручную создавать таблицы функций в приложении C или почти автоматически с помощью Visual C++ (или других объектно-ориентированных языков, поддерживающих COM).</span><span class="sxs-lookup"><span data-stu-id="de078-108">You can manually create function tables in a C application or almost automatically by using Visual C++ (or other object-oriented languages that support COM).</span></span>

<span data-ttu-id="de078-109">При наличии соответствующей поддержки компилятора (которая встроена в C и C++) клиент может вызвать метод интерфейса через его имя, а не его расположение в массиве.</span><span class="sxs-lookup"><span data-stu-id="de078-109">With appropriate compiler support (which is inherent in C and C++), a client can call an interface method through its name, not its position in the array.</span></span> <span data-ttu-id="de078-110">Поскольку интерфейс — это тип, компилятор с учетом имен методов может проверять типы параметров и возвращаемые значения каждого вызова метода интерфейса.</span><span class="sxs-lookup"><span data-stu-id="de078-110">Because an interface is a type, the compiler, given the names of methods, can check the types of parameters and return values of each interface method call.</span></span> <span data-ttu-id="de078-111">В отличие от этого, если клиент использует схему вызова на основе позиций, такая проверка типов недоступна даже в C или C++.</span><span class="sxs-lookup"><span data-stu-id="de078-111">In contrast, if a client uses a position-based calling scheme, such type-checking is not available, even in C or C++.</span></span>

<span data-ttu-id="de078-112">Каждый интерфейс является неизменяемым контрактом функциональной группы методов.</span><span class="sxs-lookup"><span data-stu-id="de078-112">Each interface is an immutable contract of a functional group of methods.</span></span> <span data-ttu-id="de078-113">Вы ссылаетесь на интерфейс во время выполнения с помощью глобального уникального идентификатора интерфейса (IID).</span><span class="sxs-lookup"><span data-stu-id="de078-113">You reference an interface at run time with a globally unique interface identifier (IID).</span></span> <span data-ttu-id="de078-114">Этот IID, который является конкретным экземпляром глобального уникального идентификатора (GUID), поддерживаемого COM, позволяет клиенту точно запрашивать объект независимо от того, поддерживает ли он семантику интерфейса, без лишних издержек и без путаницы, которая может возникнуть в системе из нескольких версий одного интерфейса с одинаковым именем.</span><span class="sxs-lookup"><span data-stu-id="de078-114">This IID, which is a specific instance of a globally unique identifier (GUID) supported by COM, allows a client to ask an object precisely whether it supports the semantics of the interface, without unnecessary overhead and without the confusion that could arise in a system from having multiple versions of the same interface with the same name.</span></span>

<span data-ttu-id="de078-115">В итоге важно понимать, что такое COM-интерфейс и не является ли он следующим:</span><span class="sxs-lookup"><span data-stu-id="de078-115">To summarize, it is important to understand what a COM interface is, and is not:</span></span>

-   <span data-ttu-id="de078-116">COM-интерфейс отличается от класса C++.</span><span class="sxs-lookup"><span data-stu-id="de078-116">A COM interface is not the same as a C++ class.</span></span> <span data-ttu-id="de078-117">Чисто виртуальное определение не выполняет никаких реализаций.</span><span class="sxs-lookup"><span data-stu-id="de078-117">The pure virtual definition carries no implementation.</span></span> <span data-ttu-id="de078-118">Программист C++ может определить реализацию интерфейса в качестве класса, но это будет находиться под заголовком сведений о реализации, которые не указываются в COM.</span><span class="sxs-lookup"><span data-stu-id="de078-118">If you are a C++ programmer, you can define your implementation of an interface as a class, but this falls under the heading of implementation details, which COM does not specify.</span></span> <span data-ttu-id="de078-119">Для фактического существования интерфейса необходимо создать экземпляр объекта, который реализует интерфейс.</span><span class="sxs-lookup"><span data-stu-id="de078-119">An instance of an object that implements an interface must be created for the interface actually to exist.</span></span> <span data-ttu-id="de078-120">Более того, различные классы объектов могут реализовывать интерфейс по-другому, но в двоичном виде они взаимозаменяемы, если поведение соответствует определению интерфейса.</span><span class="sxs-lookup"><span data-stu-id="de078-120">Furthermore, different object classes may implement an interface differently yet be used interchangeably in binary form, as long as the behavior conforms to the interface definition.</span></span>
-   <span data-ttu-id="de078-121">COM-интерфейс не является объектом.</span><span class="sxs-lookup"><span data-stu-id="de078-121">A COM interface is not an object.</span></span> <span data-ttu-id="de078-122">Это просто связанная группа функций и является двоичным стандартом, с помощью которого происходит обмен данными между клиентами и объектами.</span><span class="sxs-lookup"><span data-stu-id="de078-122">It is simply a related group of functions and is the binary standard through which clients and objects communicate.</span></span> <span data-ttu-id="de078-123">Пока он может предоставлять указатели на методы интерфейса, объект может быть реализован на любом языке с любым внутренним представлением состояния.</span><span class="sxs-lookup"><span data-stu-id="de078-123">As long as it can provide pointers to interface methods, the object can be implemented in any language with any internal state representation.</span></span>
-   <span data-ttu-id="de078-124">Интерфейсы COM являются строго типизированными.</span><span class="sxs-lookup"><span data-stu-id="de078-124">COM interfaces are strongly typed.</span></span> <span data-ttu-id="de078-125">Каждый интерфейс имеет собственный идентификатор интерфейса (GUID), который исключает возможность дублирования, которая может возникнуть при использовании любой другой схемы именования.</span><span class="sxs-lookup"><span data-stu-id="de078-125">Every interface has its own interface identifier (a GUID), which eliminates the possibility of duplication that could occur with any other naming scheme.</span></span>
-   <span data-ttu-id="de078-126">COM-интерфейсы являются неизменяемыми.</span><span class="sxs-lookup"><span data-stu-id="de078-126">COM interfaces are immutable.</span></span> <span data-ttu-id="de078-127">Нельзя определить новую версию старого интерфейса и присвоить ей тот же идентификатор.</span><span class="sxs-lookup"><span data-stu-id="de078-127">You cannot define a new version of an old interface and give it the same identifier.</span></span> <span data-ttu-id="de078-128">При добавлении или удалении методов интерфейса или измененной семантики создается новый интерфейс, а не новая версия старого интерфейса.</span><span class="sxs-lookup"><span data-stu-id="de078-128">Adding or removing methods of an interface or changing semantics creates a new interface, not a new version of an old interface.</span></span> <span data-ttu-id="de078-129">Поэтому новый интерфейс не может конфликтовать со старым интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="de078-129">Therefore, a new interface cannot conflict with an old interface.</span></span> <span data-ttu-id="de078-130">Однако объекты могут поддерживать несколько интерфейсов одновременно и предоставлять интерфейсы, которые являются последовательными редакциями интерфейса, с разными идентификаторами.</span><span class="sxs-lookup"><span data-stu-id="de078-130">However, objects can support multiple interfaces simultaneously and can expose interfaces that are successive revisions of an interface, with different identifiers.</span></span> <span data-ttu-id="de078-131">Таким образом, каждый интерфейс является отдельным контрактом, и общедоступные объекты не должны беспокоиться о том, является ли версия интерфейса, которую они вызывают, ожидаемой.</span><span class="sxs-lookup"><span data-stu-id="de078-131">Thus, each interface is a separate contract, and systemwide objects need not be concerned about whether the version of the interface they are calling is the one they expect.</span></span> <span data-ttu-id="de078-132">Идентификатор интерфейса (IID) определяет явный и уникальный контракт интерфейса.</span><span class="sxs-lookup"><span data-stu-id="de078-132">The interface ID (IID) defines the interface contract explicitly and uniquely.</span></span>

## <a name="related-topics"></a><span data-ttu-id="de078-133">См. также</span><span class="sxs-lookup"><span data-stu-id="de078-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="de078-134">COM-объекты и интерфейсы</span><span class="sxs-lookup"><span data-stu-id="de078-134">COM Objects and Interfaces</span></span>](com-objects-and-interfaces.md)
</dt> </dl>

 

 




