---
title: Связь Inter-Object
description: Модель COM разработана таким образом, чтобы клиенты могли прозрачно взаимодействовать с объектами независимо от того, где они выполняются в одном процессе, на одном компьютере или на другом компьютере.
ms.assetid: dd4adafb-a7e4-44ba-ae4a-80585875ecb6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9356ba2bcb9dd3a6a56ac16c354f3abcb752d717
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104134619"
---
# <a name="inter-object-communication"></a><span data-ttu-id="ebad6-103">Связь Inter-Object</span><span class="sxs-lookup"><span data-stu-id="ebad6-103">Inter-Object Communication</span></span>

<span data-ttu-id="ebad6-104">Модель COM разработана таким образом, чтобы клиенты могли прозрачно взаимодействовать с объектами, независимо от того, где эти объекты являются руннингâ, в одном и том же процессе, на одном компьютере или на другом компьютере.</span><span class="sxs-lookup"><span data-stu-id="ebad6-104">COM is designed to allow clients to communicate transparently with objects, regardless of where those objects are runningâ€”in the same process, on the same computer, or on a different computer.</span></span> <span data-ttu-id="ebad6-105">Это обеспечивает единую модель программирования для всех типов объектов, а также для клиентов объектов и серверов объектов.</span><span class="sxs-lookup"><span data-stu-id="ebad6-105">This provides a single programming model for all types of objects, and for both object clients and object servers.</span></span>

<span data-ttu-id="ebad6-106">С точки зрения клиента доступ ко всем объектам осуществляется через указатели интерфейса.</span><span class="sxs-lookup"><span data-stu-id="ebad6-106">From a client's point of view, all objects are accessed through interface pointers.</span></span> <span data-ttu-id="ebad6-107">Указатель должен быть внутри процесса.</span><span class="sxs-lookup"><span data-stu-id="ebad6-107">A pointer must be in-process.</span></span> <span data-ttu-id="ebad6-108">Фактически любой вызов функции интерфейса всегда достигает некоторого фрагмента внутрипроцессного кода.</span><span class="sxs-lookup"><span data-stu-id="ebad6-108">In fact, any call to an interface function always reaches some piece of in-process code first.</span></span> <span data-ttu-id="ebad6-109">Если объект находится внутри процесса, вызов напрямую достигает него без промежуточного кода инфраструктуры системы.</span><span class="sxs-lookup"><span data-stu-id="ebad6-109">If the object is in-process, the call reaches it directly, with no intervening system-infrastructure code.</span></span> <span data-ttu-id="ebad6-110">Если объект находится вне процесса, вызов сначала достигает того, что называется прокси-объектом, предоставляемым COM или объектом (если это необходимо для реализации).</span><span class="sxs-lookup"><span data-stu-id="ebad6-110">If the object is out-of-process, the call first reaches what is called a "proxy" object provided either by COM or by the object (if the implementor wishes).</span></span> <span data-ttu-id="ebad6-111">Пакеты прокси-сервера вызывают параметры (включая все указатели интерфейсов) и создают соответствующий удаленный вызов процедуры (или другой механизм связи в случае настраиваемых прокси-серверов) для другого процесса или другого компьютера, на котором находится реализация объекта.</span><span class="sxs-lookup"><span data-stu-id="ebad6-111">The proxy packages call parameters (including any interface pointers) and generate the appropriate remote procedure call (or other communication mechanism in the case of custom generated proxies) to the other process or the other computer where the object implementation is located.</span></span> <span data-ttu-id="ebad6-112">Этот процесс упаковки указателей для передачи через границы процесса называется *упаковкой*.</span><span class="sxs-lookup"><span data-stu-id="ebad6-112">This process of packaging pointers for transmission across process boundaries is called *marshaling*.</span></span>

<span data-ttu-id="ebad6-113">С точки зрения сервера все вызовы функций интерфейса объекта выполняются через указатель на этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="ebad6-113">From a server's point of view, all calls to an object's interface functions are made through a pointer to that interface.</span></span> <span data-ttu-id="ebad6-114">Опять же, указатель имеет контекст только в одном процессе, и вызывающий объект всегда должен быть частью внутрипроцессного кода.</span><span class="sxs-lookup"><span data-stu-id="ebad6-114">Again, a pointer has context only in a single process, and the caller must always be some piece of in-process code.</span></span> <span data-ttu-id="ebad6-115">Если объект находится в процессе, вызывающий является сам клиент.</span><span class="sxs-lookup"><span data-stu-id="ebad6-115">If the object is in-process, the caller is the client itself.</span></span> <span data-ttu-id="ebad6-116">В противном случае вызывающий объект является объектом-заглушкой, предоставляемым либо COM, либо самим объектом.</span><span class="sxs-lookup"><span data-stu-id="ebad6-116">Otherwise, the caller is a "stub" object provided either by COM or by the object itself.</span></span> <span data-ttu-id="ebad6-117">Заглушка получает удаленный вызов процедуры (или другой механизм связи в случае настраиваемых прокси-серверов) от "прокси" в клиентском процессе, расмаршалирует параметры и вызывает соответствующий интерфейс в объекте сервера.</span><span class="sxs-lookup"><span data-stu-id="ebad6-117">The stub receives the remote procedure call (or other communication mechanism in the case of custom generated proxies) from the "proxy" in the client process, unmarshals the parameters, and calls the appropriate interface on the server object.</span></span> <span data-ttu-id="ebad6-118">С точки зрения клиентов и серверов они всегда взаимодействуют напрямую с каким-либо другим внутрипроцессный код.</span><span class="sxs-lookup"><span data-stu-id="ebad6-118">From the points of view of both clients and servers, they always communicate directly with some other in-process code.</span></span>

<span data-ttu-id="ebad6-119">COM обеспечивает реализацию маршалирования, называемую *стандартным упаковкой*.</span><span class="sxs-lookup"><span data-stu-id="ebad6-119">COM provides an implementation of marshaling, referred to as *standard marshaling*.</span></span> <span data-ttu-id="ebad6-120">Эта реализация очень хорошо работает для большинства объектов и значительно сокращает требования к программированию, делая процесс упаковки эффективным прозрачным.</span><span class="sxs-lookup"><span data-stu-id="ebad6-120">This implementation works very well for most objects and greatly reduces programming requirements, making the marshaling process effectively transparent.</span></span>

<span data-ttu-id="ebad6-121">Тем не менее, четкое разделение интерфейса от реализации прозрачности процесса COM может быть получено в некоторых ситуациях.</span><span class="sxs-lookup"><span data-stu-id="ebad6-121">The clear separation of interface from implementation of COM's process transparency can, however, get in the way in some situations.</span></span> <span data-ttu-id="ebad6-122">Структура интерфейса, нацеленного на свою функцию с точки зрения клиента, иногда может привести к проектированию решений, которые конфликтуют с эффективной реализацией этого интерфейса в сети.</span><span class="sxs-lookup"><span data-stu-id="ebad6-122">The design of an interface that focuses on its function from the client's point of view can sometimes lead to design decisions that conflict with efficient implementation of that interface across a network.</span></span> <span data-ttu-id="ebad6-123">В таких случаях, что требуется, не является чисто прозрачным процессом, но «обработка прозрачности», если не требуется.</span><span class="sxs-lookup"><span data-stu-id="ebad6-123">In cases like this, what is needed is not pure process transparency but "process transparency, unless you need to care."</span></span> <span data-ttu-id="ebad6-124">COM предоставляет эту возможность, позволяя разработчику объектов поддерживать *Пользовательский маршалирование* (также называемый [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) упаковкой).</span><span class="sxs-lookup"><span data-stu-id="ebad6-124">COM provides this capability by allowing an object implementor to support *custom marshaling* (also called [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) marshaling).</span></span> <span data-ttu-id="ebad6-125">Стандартная упаковка на самом деле является экземпляром пользовательского маршалирования; Это реализация по умолчанию, используемая, когда объекту не требуется пользовательская упаковка.</span><span class="sxs-lookup"><span data-stu-id="ebad6-125">Standard marshaling is, in fact, an instance of custom marshaling; it is the default implementation used when an object does not require custom marshaling.</span></span>

<span data-ttu-id="ebad6-126">Можно реализовать настраиваемую упаковку, чтобы объект мог принимать различные действия при использовании из сети, чем при локальном доступе, и он полностью прозрачен для клиента.</span><span class="sxs-lookup"><span data-stu-id="ebad6-126">You can implement custom marshaling to allow an object to take different actions when used from across a network than it takes under local access and it is completely transparent to the client.</span></span> <span data-ttu-id="ebad6-127">Эта архитектура позволяет разрабатывать интерфейсы клиента и объекта без проблем с производительностью сети, а затем в дальнейшем устранять проблемы с производительностью сети, не нарушая установленный проект.</span><span class="sxs-lookup"><span data-stu-id="ebad6-127">This architecture makes it possible to design client/object interfaces without regard to network performance issues and then later to address network performance issues without disrupting the established design.</span></span>

<span data-ttu-id="ebad6-128">COM не указывает, как структурированы компоненты. Он указывает, как они взаимодействуют.</span><span class="sxs-lookup"><span data-stu-id="ebad6-128">COM does not specify how components are structured; it specifies how they interact.</span></span> <span data-ttu-id="ebad6-129">COM оставляет сведения о внутренней структуре компонента для языков программирования и сред разработки.</span><span class="sxs-lookup"><span data-stu-id="ebad6-129">COM leaves the concern about the internal structure of a component to programming languages and development environments.</span></span> <span data-ttu-id="ebad6-130">И наоборот, в средах программирования нет установленных стандартов для работы с объектами за пределами немедленного приложения.</span><span class="sxs-lookup"><span data-stu-id="ebad6-130">Conversely, programming environments have no set standards for working with objects outside of the immediate application.</span></span> <span data-ttu-id="ebad6-131">Microsoft Visual C++, например, очень хорошо работает для манипулирования объектами внутри приложения, но не поддерживает работу с объектами вне приложения.</span><span class="sxs-lookup"><span data-stu-id="ebad6-131">Microsoft Visual C++, for example, works extremely well for manipulating objects inside an application but has no support for working with objects outside the application.</span></span> <span data-ttu-id="ebad6-132">Как правило, все остальные языки программирования одинаковы в этом отношении.</span><span class="sxs-lookup"><span data-stu-id="ebad6-132">Generally, all other programming languages are the same in this regard.</span></span> <span data-ttu-id="ebad6-133">Таким образом, чтобы обеспечить взаимодействие готовность, COM, через независимые от языка интерфейсы, выбирает, где не выходит языки программирования.</span><span class="sxs-lookup"><span data-stu-id="ebad6-133">Therefore, to provide networkwide interoperability, COM, through language-independent interfaces, picks up where programming languages leave off.</span></span>

<span data-ttu-id="ebad6-134">Двойное косвенное обращение к структуре VTBL означает, что указатели в таблице указателей функций не должны указывать непосредственно на реальную реализацию в реальном объекте.</span><span class="sxs-lookup"><span data-stu-id="ebad6-134">The double indirection of the vtbl structure means that the pointers in the table of function pointers do not need to point directly to the real implementation in the real object.</span></span> <span data-ttu-id="ebad6-135">Это основа прозрачности процесса.</span><span class="sxs-lookup"><span data-stu-id="ebad6-135">This is the heart of process transparency.</span></span>

<span data-ttu-id="ebad6-136">Для внутрипроцессного сервера, где объект загружается непосредственно в клиентский процесс, указатели функций в таблице указывают непосредственно на фактическую реализацию.</span><span class="sxs-lookup"><span data-stu-id="ebad6-136">For in-process servers, where the object is loaded directly into the client process, the function pointers in the table point directly to the actual implementation.</span></span> <span data-ttu-id="ebad6-137">В этом случае вызов функции от клиента к методу интерфейса напрямую передает управление выполнением методу.</span><span class="sxs-lookup"><span data-stu-id="ebad6-137">In this case, a function call from the client to an interface method directly transfers execution control to the method.</span></span> <span data-ttu-id="ebad6-138">Однако это не может работать для локальных и удаленных объектов, так как указатели на память не могут совместно использоваться процессами.</span><span class="sxs-lookup"><span data-stu-id="ebad6-138">However, this cannot work for local, let alone remote, objects because pointers to memory cannot be shared between processes.</span></span> <span data-ttu-id="ebad6-139">Тем не менее, клиент должен иметь возможность вызывать методы интерфейса, как если бы он вызывал фактическую реализацию.</span><span class="sxs-lookup"><span data-stu-id="ebad6-139">Nevertheless, the client must be able to call interface methods as if it were calling the actual implementation.</span></span> <span data-ttu-id="ebad6-140">Таким образом, клиент равномерно передает управление методу в некоторый объект, делая вызов.</span><span class="sxs-lookup"><span data-stu-id="ebad6-140">Thus, the client uniformly transfers control to a method in some object by making the call.</span></span>

<span data-ttu-id="ebad6-141">Клиент всегда вызывает методы интерфейса в некоторых внутрипроцессный объект.</span><span class="sxs-lookup"><span data-stu-id="ebad6-141">A client always calls interface methods in some in-process object.</span></span> <span data-ttu-id="ebad6-142">Если фактический объект является локальным или удаленным, выполняется вызов прокси-объекта, который затем выполняет удаленный вызов процедуры к фактическому объекту.</span><span class="sxs-lookup"><span data-stu-id="ebad6-142">If the actual object is local or remote, the call is made to a proxy object, which then makes a remote procedure call to the actual object.</span></span>

<span data-ttu-id="ebad6-143">Так какой же метод фактически выполняется?</span><span class="sxs-lookup"><span data-stu-id="ebad6-143">So what method is actually executed?</span></span> <span data-ttu-id="ebad6-144">Ответ заключается в том, что при вызове необработанного интерфейса каждый метод интерфейса реализуется прокси-объектом.</span><span class="sxs-lookup"><span data-stu-id="ebad6-144">The answer is that whenever there is a call to an out-of-process interface, each interface method is implemented by a proxy object.</span></span> <span data-ttu-id="ebad6-145">Прокси-объект всегда является внутрипроцессный объект, который действует от имени вызываемого объекта.</span><span class="sxs-lookup"><span data-stu-id="ebad6-145">The proxy object is always an in-process object that acts on behalf of the object being called.</span></span> <span data-ttu-id="ebad6-146">Этот прокси-объект знает, что фактический объект выполняется на локальном или удаленном сервере.</span><span class="sxs-lookup"><span data-stu-id="ebad6-146">This proxy object knows that the actual object is running in a local or remote server.</span></span>

<span data-ttu-id="ebad6-147">Прокси-объект упаковывает параметры функции в некоторые пакеты данных и создает вызов RPC к локальному или удаленному объекту.</span><span class="sxs-lookup"><span data-stu-id="ebad6-147">The proxy object packages up the function parameters in some data packets and generates an RPC call to the local or remote object.</span></span> <span data-ttu-id="ebad6-148">Этот пакет забирается объектом-заглушкой в процессе сервера на локальном или удаленном компьютере, который распаковать параметры и вызовет реальную реализацию метода.</span><span class="sxs-lookup"><span data-stu-id="ebad6-148">That packet is picked up by a stub object in the server's process on the local or a remote computer, which unpacks the parameters and makes the call to the real implementation of the method.</span></span> <span data-ttu-id="ebad6-149">Когда эта функция возвращает, заглушка упаковывает все выходные параметры и возвращаемое значение и отправляет их обратно прокси-серверу, который распаковать их и вернет к исходному клиенту.</span><span class="sxs-lookup"><span data-stu-id="ebad6-149">When that function returns, the stub packages up any out-parameters and the return value and sends it back to the proxy, which unpacks them and returns them to the original client.</span></span>

<span data-ttu-id="ebad6-150">Таким образом, клиент и сервер всегда взаимодействуют друг с другом, как если бы все выполнялось в процессе.</span><span class="sxs-lookup"><span data-stu-id="ebad6-150">Thus, client and server always talk to each other as if everything was in-process.</span></span> <span data-ttu-id="ebad6-151">Все вызовы клиента и все вызовы сервера в какой-то момент находятся в процессе.</span><span class="sxs-lookup"><span data-stu-id="ebad6-151">All calls from the client and all calls to the server are, at some point, in-process.</span></span> <span data-ttu-id="ebad6-152">Но поскольку структура VTBL позволяет некоторым агентам, например COM, перехватывать все вызовы функций и возвратить из функций, этот агент может перенаправлять эти вызовы в вызов RPC по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="ebad6-152">But because the vtbl structure allows some agent, like COM, to intercept all function calls and all returns from functions, that agent can redirect those calls to an RPC call as necessary.</span></span> <span data-ttu-id="ebad6-153">Хотя вызовы внутри процесса выполняются быстрее, чем необработанные вызовы, различия в процессах полностью прозрачны для клиента и сервера.</span><span class="sxs-lookup"><span data-stu-id="ebad6-153">Although in-process calls are faster than out-of-process calls, the process differences are completely transparent to the client and server.</span></span>

<span data-ttu-id="ebad6-154">Дополнительные сведения см. в следующих разделах:</span><span class="sxs-lookup"><span data-stu-id="ebad6-154">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="ebad6-155">Сведения о маршалировании</span><span class="sxs-lookup"><span data-stu-id="ebad6-155">Marshaling Details</span></span>](marshaling-details.md)
-   [<span data-ttu-id="ebad6-156">Прокси</span><span class="sxs-lookup"><span data-stu-id="ebad6-156">Proxy</span></span>](proxy.md)
-   [<span data-ttu-id="ebad6-157">Заглушка</span><span class="sxs-lookup"><span data-stu-id="ebad6-157">Stub</span></span>](stub.md)
-   [<span data-ttu-id="ebad6-158">Канал</span><span class="sxs-lookup"><span data-stu-id="ebad6-158">Channel</span></span>](channel.md)
-   [<span data-ttu-id="ebad6-159">Microsoft RPC</span><span class="sxs-lookup"><span data-stu-id="ebad6-159">Microsoft RPC</span></span>](microsoft-rpc.md)

## <a name="related-topics"></a><span data-ttu-id="ebad6-160">См. также</span><span class="sxs-lookup"><span data-stu-id="ebad6-160">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="ebad6-161">COM-клиенты и серверы</span><span class="sxs-lookup"><span data-stu-id="ebad6-161">COM Clients and Servers</span></span>](com-clients-and-servers.md)
</dt> <dt>

[<span data-ttu-id="ebad6-162">Маршалирование интерфейса</span><span class="sxs-lookup"><span data-stu-id="ebad6-162">Interface Marshaling</span></span>](interface-marshaling.md)
</dt> </dl>

 

 