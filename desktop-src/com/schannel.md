---
title: Schannel
description: 'Пакет безопасности безопасного канала (Schannel), идентификатор службы проверки подлинности которого — RPC \_ C \_ AUTHN \_ GSS \_ , поддерживает следующие протоколы на основе открытых ключей: SSL (SSL) версии 2,0 и 3,0, TLS 1,0 и частная технология связи (PCT) 1,0. TLS 1,0 — это стандартизированная, немного измененная версия SSL 3,0, которая была выпущена IETF в январе 1999 (Internet Engineering Task Force) в документе RFC 2246. Поскольку протокол TLS был стандартизован, разработчикам рекомендуется использовать TLS, а не SSL. Параметр PCT включен только в целях обратной совместимости и не должен использоваться для новой разработки. Если используется пакет безопасности SChannel, DCOM автоматически согласовывает оптимальный протокол в зависимости от возможностей клиента и сервера.'
ms.assetid: 03a5f987-f668-4f19-9b58-d62711f58734
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 01ab40ed9d87013f646137e23ccc755dfdf9ab6b8f2ded367940b4ae630d7b4b
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119047852"
---
# <a name="schannel"></a>Schannel

Пакет безопасности безопасного канала (Schannel), идентификатор службы проверки подлинности которого — RPC \_ C \_ AUTHN \_ GSS \_ , поддерживает следующие протоколы на основе открытых ключей: SSL (SSL) версии 2,0 и 3,0, TLS 1,0 и частная технология связи (PCT) 1,0. TLS 1,0 — это стандартизированная, немного измененная версия SSL 3,0, которая была выпущена IETF в январе 1999 (Internet Engineering Task Force) в документе [RFC 2246](https://www.ietf.org/rfc/rfc2246.txt). Поскольку протокол TLS был стандартизован, разработчикам рекомендуется использовать TLS, а не SSL. Параметр PCT включен только в целях обратной совместимости и не должен использоваться для новой разработки. Если используется пакет безопасности SChannel, DCOM автоматически согласовывает оптимальный протокол в зависимости от возможностей клиента и сервера.

В следующих разделах кратко описывается протокол TLS и принципы его работы с DCOM.

-   [Когда следует использовать TLS](#when-to-use-tls)
-   [Краткий обзор работы протокола TLS](#brief-overview-of-how-tls-works)
-   [Сертификаты X. 509](#x509-certificates)
    -   [Сертификаты клиента](#client-certificates)
-   [Использование TLS в COM](#using-tls-in-com)
    -   [Как сервер устанавливает контракт безопасности](#how-a-server-sets-the-security-blanket)
    -   [Как клиент устанавливает параметр безопасности](#how-a-client-sets-the-security-blanket)
    -   [Изменение клиентом общего доступа](#how-a-client-changes-the-security-blanket)
    -   [Пример. клиент изменяет контракт безопасности](#example-client-changes-the-security-blanket)
-   [Связанные темы](#related-topics)

> [!Note]  
> Все сведения о протоколе TLS в этих разделах также применяются к протоколам SSL и PCT.

 

## <a name="when-to-use-tls"></a>Когда следует использовать TLS

TLS является единственным вариантом безопасности, доступным, когда серверы должны доказать свою личность анонимным клиентам. Это особенно важно для веб-сайтов, которые хотят участвовать в электронной коммерции, так как помогает защитить передачу конфиденциальной информации, например номеров кредитных карт. TLS гарантирует, что клиенты электронной коммерции могут быть уверены в том, что они выполняют бизнес, так как им предоставляется подтверждение подлинности сервера. Это также дает серверу электронной коммерции эффективность ненужной работы с проверкой подлинности идентификации каждого из клиентов.

TLS требует, чтобы все серверы подтверждают свою личность для клиентов. Кроме того, протокол TLS обеспечивает возможность подтверждения удостоверений клиентов серверами. Такая взаимная проверка подлинности может быть полезна при запрещении доступа к определенным веб-страницам в крупной корпоративной интрасети.

Протокол TLS поддерживает самые строгие уровни проверки подлинности и предлагает открытую архитектуру, которая позволяет увеличить надежность шифрования, чтобы поддерживать технологические инновации. Протокол TLS является лучшим выбором для сред, в которых требуется самый высокий уровень безопасности при передаче данных.

## <a name="brief-overview-of-how-tls-works"></a>Краткий обзор работы протокола TLS

Протокол TLS основан на инфраструктуре открытых ключей (PKI), которая использует пары открытого и закрытого ключей для шифрования данных и установления целостности данных и использует сертификаты X. 509 для проверки подлинности.

Многие протоколы безопасности, такие как протокол Kerberos V5, зависят от одного ключа для шифрования и расшифровки данных. Поэтому такие протоколы зависят от безопасного обмена ключами шифрования. в протоколе Kerberos это делается с помощью билетов, полученных из центр распространения ключей (KDC). Для этого все, кто использует протокол Kerberos, должны быть зарегистрированы в KDC, что является непрактичным ограничением для веб-сервера электронной коммерции, предназначенного для привлечения миллионов клиентов по всему миру. Поэтому протокол TLS основан на PKI, который использует два ключа для данных енкриптионâ € "когда один ключ пары шифрует данные, его можно расшифровать только в другом ключе пары. Преимущество этого подхода заключается в том, что шифрование может быть выполнено без необходимости безопасного обмена ключами шифрования.

PKI использует методику, когда один из ключей хранится в частном состоянии и доступен только участнику, которому он зарегистрирован, а другой ключ становится общедоступным для всех. Если кому-то хочется отправить частное сообщение владельцу пары ключей, сообщение может быть зашифровано с помощью открытого ключа, и только закрытый ключ может быть использован для расшифровки сообщения.

Пары ключей также используются для проверки целостности отправляемых данных. Для этого владелец пары ключей может присоединить цифровую подпись к данным перед их отправкой. Создание цифровой подписи включает в себя вычисление хэша данных и шифрование хэша с помощью закрытого ключа. Любой, кто использует открытый ключ для расшифровки цифровой подписи, гарантирует, что цифровая подпись должна быть только у лица, владеющего закрытым ключом. Кроме того, получатель может вычислить хэш данных с помощью того же алгоритма, что и отправитель, и если вычисленный хэш совпадает с именем, отправленным в цифровой подписи, получатель может быть уверенным в том, что данные не были изменены после подписания цифровой подписью.

Одним из недостатков использования PKI для шифрования данных большого объема является относительно медленная производительность. Из-за большого количества математических операций шифрование и расшифровка данных с помощью асимметричного шифра, который зависит от пары ключей, может быть до 1 000 раз медленнее, чем шифрование и расшифровка с помощью симметричного шифра, который зависит только от одного ключа. Таким образом, протокол TLS использует PKI только для создания цифровых подписей и для согласования единственного ключа сеанса, который будет использоваться как клиентом, так и сервером для полного шифрования и расшифровки данных. Протокол TLS поддерживает широкий спектр симметричных шифров с одним ключом, а в будущем могут добавляться дополнительные шифры.

Дополнительные сведения о протоколе подтверждения TLS см. в разделе [протокол подтверждения TLS](/windows/desktop/SecAuthN/tls-handshake-protocol).

Дополнительные сведения о криптографии за протоколом TLS см. в разделе [Криптография Essentials](/windows/desktop/SecCrypto/cryptography-essentials).

## <a name="x509-certificates"></a>Сертификаты X.509

Критической проблемой, которая должна быть обработана PKI, является возможность доверять подлинности используемого открытого ключа. При использовании открытого ключа, выпущенного для компании, с которой требуется реализовать бизнес, необходимо убедиться, что ключ фактически принадлежит компании, а не к лицу, желающему найти номер кредитной карты.

Чтобы гарантировать удостоверение участника, содержащего пару ключей, участник выдает сертификат X. 509 центром сертификации (ЦС). Этот сертификат содержит сведения, идентифицирующие участника, содержит открытый ключ участника и имеет цифровую подпись ЦС. Эта цифровая подпись означает, что ЦС считает, что открытый ключ, содержащийся в сертификате, действительно принадлежит участнику, определяемому сертификатом.

Как доверять ЦС? Так как сам ЦС содержит сертификат X. 509, подписанный центром сертификации более высокого уровня. Цепочка подписей сертификатов сохраняется до тех пор, пока не достигнет корневого ЦС, который является центром сертификации, который подписывает собственные сертификаты. Если вы доверяете целостности корневого ЦС сертификата, вы должны иметь возможность доверять подлинности самого сертификата. Таким образом, выбор корневых центров сертификации, которым вы готовы доверять, является важной обязанностью для системного администратора.

### <a name="client-certificates"></a>Сертификаты клиента

При первом появлении протоколов транспортного уровня безопасности их основное назначение было гарантией того, что клиент подключается к подлинному серверу и помогает защитить конфиденциальность данных во время передачи. Однако SSL 3,0 и TLS 1,0 также включают поддержку передачи сертификата клиента во время подтверждения протокола. Эта необязательная функция обеспечивает взаимную проверку подлинности клиента и сервера.

Решение о том, следует ли использовать сертификат клиента, должно выполняться в контексте приложения. Сертификаты клиента не требуются, если основным требованием является проверка подлинности сервера. Однако если проверка подлинности клиента является обязательной, можно использовать сертификат клиента вместо пользовательской проверки подлинности в приложении. Использование сертификатов клиентов предпочтительнее, чем пользовательская проверка подлинности, так как предоставляет пользователям сценарий единого входа.

## <a name="using-tls-in-com"></a>Использование TLS в COM

Протокол TLS поддерживает только уровень олицетворения "IMPERSONATE" ( \_ \_ олицетворение на уровне RPC C) олицетворения \_ \_ . Если COM согласовывает протокол TLS в качестве службы проверки подлинности на прокси-сервере, то COM устанавливает олицетворение, независимо от процесса по умолчанию. Для правильной работы олицетворения в TLS клиент должен предоставить серверу сертификат X. 509, а сервер должен иметь сертификат, сопоставленный с определенной учетной записью пользователя на сервере. Дополнительные сведения см. в пошаговом [инструкции по сопоставлению сертификатов с учетными записями пользователей](https://www.microsoft.com/isapi/redir.dll?prd=windows2000&sbp=technicallibrary&ar=security&sba=mappingcertificates).

Протокол TLS не поддерживает [маскировку](cloaking.md). Если флаг маскировки и протокол TLS указаны в вызове [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) или [**Иклиентсекурити:: сетбланкет**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket) , \_ то возвращается E INVALIDARG.

TLS не работает с уровнем проверки подлинности, установленным в значение нет. При подтверждении между клиентом и сервером проверяется уровень проверки подлинности, заданный каждым, и выбирается более высокая настройка безопасности для соединения.

Параметры безопасности для TLS можно задать, вызвав [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) и [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket). В следующих разделах описываются особенности, связанные с выполнением этих вызовов.

### <a name="how-a-server-sets-the-security-blanket"></a>Как сервер устанавливает контракт безопасности

Если сервер хочет использовать TLS, он должен указать Schannel (RPC \_ C \_ AUTHN \_ GSS \_ Schannel) в качестве службы проверки подлинности в  параметре асауссвк [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity). Чтобы предотвратить подключение клиентов к серверу с помощью менее безопасной службы проверки подлинности, сервер должен указать только Schannel в качестве службы проверки подлинности при вызове **CoInitializeSecurity**. Сервер не может изменить общий уровень безопасности после вызова **CoInitializeSecurity**.

Чтобы использовать TLS, необходимо указать следующие параметры при вызове сервером [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity):

-   *pVoid* должен быть либо указателем на объект [**иакцессконтрол**](/windows/desktop/api/IAccess/nn-iaccess-iaccesscontrol) , либо указателем на [**\_ дескриптор безопасности**](/windows/desktop/api/winnt/ns-winnt-security_descriptor). Оно не должно быть **null** или указателем на AppID.
-   *кауссвк* не может иметь значение 0 или-1. Серверы COM никогда не выбирают канал Schannel, если *кауссвк* имеет-1.
-   *асауссвк* должен указывать Schannel в качестве возможной службы проверки подлинности. Для этого необходимо задать следующие параметры [**\_ \_ службы проверки подлинности**](/windows/win32/api/objidlbase/ns-objidlbase-sole_authentication_service) для участника Schannel в [**\_ \_ списке единственной проверки подлинности**](/windows/win32/api/objidlbase/ns-objidlbase-sole_authentication_list):
    -   *двауснсвк* должен быть RPC \_ C \_ AUTHN \_ GSS \_ SChannel.
    -   *дваусзсвк* должен быть RPC \_ C \_ AUTHZ \_ None. В настоящее время он игнорируется.
    -   *ппринЦипалнаме* должен быть указателем на [**\_ контекст сертификата**](/windows/desktop/api/wincrypt/ns-wincrypt-cert_context), приведенным в качестве указателя на Олечар, который представляет сертификат X. 509 сервера.
-   *двауснлевел* указывает минимальный уровень проверки подлинности, который будет приниматься клиентами для успешного подключения. Он не может быть \_ на \_ уровне RPC C AUTHN \_ \_ None.
-   для *двкапабилитиес* не должен быть \_ установлен флаг еоак AppID. \_ \_ Флаг управления доступом еоак должен быть установлен, если *pVoid* указывает на объект [**иакцессконтрол**](/windows/desktop/api/IAccess/nn-iaccess-iaccesscontrol) ; его не следует задавать, если *pVoid* указывает на \_ дескриптор безопасности. Другие флаги, которые можно задать, см. в разделе [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity).

Дополнительные сведения об использовании [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity)см. в разделе [Настройка безопасности Процессвиде с помощью CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).

### <a name="how-a-client-sets-the-security-blanket"></a>Как клиент устанавливает параметр безопасности

Если клиент хочет использовать TLS, он должен указать Schannel (RPC \_ C \_ AUTHN \_ GSS \_ Schannel) в списке служб проверки подлинности в параметре *пауслист* [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity). Если канал Schannel не указан в качестве возможной службы проверки подлинности при вызове **CoInitializeSecurity** , то при последующем вызове метода [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket) (или [**иклиентсекурити:: сетбланкет**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket)) произойдет сбой, если он попытается указать Schannel в качестве службы проверки подлинности.

При вызове [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity)клиентом необходимо указать следующие параметры:

-   *двауснлевел* указывает уровень проверки подлинности по умолчанию, который клиент хочет использовать. Он не может быть \_ на \_ уровне RPC C AUTHN \_ \_ None.
-   *двимплевел* должен быть \_ \_ \_ олицетворением на уровне RPC C \_ .
-   *пауслист* должен иметь следующие параметры [**\_ проверки \_ подлинности**](/windows/win32/api/objidlbase/ns-objidlbase-sole_authentication_info) в качестве члена списка:
    -   *двауснсвк* должен быть RPC \_ C \_ AUTHN \_ GSS \_ SChannel.
    -   *дваусзсвк* должен быть RPC \_ C \_ AUTHZ \_ None.
    -   *паусинфо* — это указатель на [**\_ контекст сертификата**](/windows/desktop/api/wincrypt/ns-wincrypt-cert_context), приведенный в качестве указателя на void, который представляет сертификат X. 509 клиента. Если у клиента нет сертификата или вы не хотите предоставлять его сертификат серверу, *паусинфо* должен иметь **значение NULL** , и будет предпринята попытка использовать анонимное соединение с сервером.
-   *двкапабилитиес* — это набор флагов, которые указывают дополнительные возможности клиента. Сведения о том, какие флаги должны быть установлены, см. в разделе [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) .

Дополнительные сведения об использовании [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity)см. в разделе [Настройка безопасности Процессвиде с помощью CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).

### <a name="how-a-client-changes-the-security-blanket"></a>Изменение клиентом общего доступа

Если клиент хочет использовать TLS, но при этом изменить параметры безопасности после вызова [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity), он должен вызвать метод [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket) или [**иклиентсекурити:: сетбланкет**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket) с параметрами, аналогичными тем, которые использовались в вызове **CoInitializeSecurity**, со следующими отличиями.

-   *псерверпринкнаме* указывает имя участника сервера в формате мсстд или фуллсик. Сведения об этих форматах см. в разделе [имена участников](/windows/desktop/Rpc/principal-names). Если у клиента есть сертификат X. 509 сервера, он может найти имя участника, вызвав [**рпкцертженератепринЦипалнаме**](/windows/desktop/api/rpcssl/nf-rpcssl-rpccertgenerateprincipalname).
-   *паусинфо* — это указатель на [**\_ контекст сертификата**](/windows/desktop/api/wincrypt/ns-wincrypt-cert_context), приведенный в качестве указателя на \_ маркер идентификации RPC auth \_ \_ , который представляет сертификат X. 509 клиента. Если у клиента нет сертификата или вы не хотите предоставлять его сертификат серверу, *паусинфо* должен иметь **значение NULL** , и будет предпринята попытка использовать анонимное соединение с сервером.
-   *двкапабилитиес* состоит из флагов, указывающих дополнительные возможности клиента. Для изменения общих параметров безопасности можно использовать только четыре флага: ЕОАК \_ Default, еоак \_ взаимная \_ Проверка подлинности, еоак \_ любой другой \_ центр (этот флаг является устаревшим), а еоак \_ делает \_ фуллсик. Дополнительные сведения см. в разделе [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket).

Дополнительные сведения об использовании [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)см. в разделе [Настройка безопасности на уровне прокси-сервера интерфейса](setting-security-at-the-interface-proxy-level.md).

### <a name="example-client-changes-the-security-blanket"></a>Пример. клиент изменяет контракт безопасности

В следующем примере показано, как клиент может изменить уровень безопасности, в соответствии с которым клиент должен предоставить сертификат X. 509, чтобы удовлетворить запрос от сервера. Код обработки ошибок не указан для краткости.


```C++
void ClientChangesSecurity ()
{
  HCRYPTPROV                   provider           = 0;
  HCERTSTORE                   cert_store         = NULL;
  PCCERT_CONTEXT               client_cert        = NULL;
  PCCERT_CONTEXT               server_cert        = NULL;
  WCHAR                        *server_princ_name = NULL;
  ISecret                      *pSecret           = NULL;
  MULTI_QI                     server_instance;
  COSERVERINFO                 server_machine;
  SOLE_AUTHENTICATION_LIST     auth_list;
  SOLE_AUTHENTICATION_INFO     auth_info[1];



  // Specify all the authentication info. 
  // The client is willing to connect using SChannel,
  //   with no client certificate.
  auth_list.cAuthInfo     = 1;
  auth_list.aAuthInfo     = auth_info;
  auth_info[0].dwAuthnSvc = RPC_C_AUTHN_GSS_SCHANNEL;
  auth_info[0].dwAuthzSvc = RPC_C_AUTHZ_NONE;
  auth_info[0].pAuthInfo  = NULL;  // No certificate

  // Initialize client security with no client certificate.
  CoInitializeSecurity( NULL, -1, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_PKT,
                        RPC_C_IMP_LEVEL_IMPERSONATE, &auth_list,
                        EOAC_NONE, NULL );
  
  // Specify info for the proxy.
  server_instance = {&IID_ISecret, NULL, S_OK};
  server_machine  = {0, L"ServerMachineName", NULL, 0};
  
  // Create a proxy.
  CoCreateInstanceEx( CLSID_Secret, NULL, CLSCTX_REMOTE_SERVER, 
                      &server_machine, 1, &server_instance);
  pSecret = (ISecret *) server_instance.pItf;

  //** The client obtained the server's certificate during the handshake.
  //** The server requests a certificate from the client.

  // Get the default certificate provider.
  CryptAcquireContext( &provider, NULL, NULL, PROV_RSA_SCHANNEL, 0 );

  // Open the certificate store.
  cert_store = CertOpenSystemStore( provider, L"my" );

  // Find the client's certificate.
  client_cert = 
    CertFindCertificateInStore( cert_store,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                0,
                                CERT_FIND_SUBJECT_STR,
                                L"ClientName",  // Use the principal name
                                NULL );

  // Find the fullsic principal name of the server.
  RpcCertGeneratePrincipalName( server_cert, RPC_C_FULL_CERT_CHAIN, 
                                &server_princ_name );

  // Change the client's security: 
  // Increase the authentication level and attach a certificate.
  CoSetProxyBlanket( pSecret, RPC_C_AUTHN_GSS_SCHANNEL,
                     RPC_C_AUTHZ_NONE,
                     server_princ_name, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                     RPC_C_IMP_LEVEL_IMPERSONATE, 
                     (RPC_AUTH_IDENTITY_HANDLE *) client_cert,
                     EOAC_NONE );

  cleanup:
  if (server_princ_name != NULL)
    RpcStringFree( &server_princ_name );
  if (client_cert != NULL)
    CertFreeCertificateContext(client_cert);
  if (server_cert != NULL)
    CertFreeCertificateContext(server_cert);
  if (cert_store != NULL)
    CertCloseStore( cert_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (provider != 0 )
    CryptReleaseContext( provider, 0 );
  if (pSecret != NULL)
    pSecret->Release();
  CoUninitialize();
}
```



## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Пакеты безопасности и COM](com-and-security-packages.md)
</dt> </dl>

 

 