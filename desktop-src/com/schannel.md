---
title: Schannel
description: 'Пакет безопасности безопасного канала (Schannel), идентификатор службы проверки подлинности которого — RPC \_ C \_ AUTHN \_ GSS \_ , поддерживает следующие протоколы на основе открытых ключей: SSL (SSL) версии 2,0 и 3,0, TLS 1,0 и частная технология связи (PCT) 1,0. TLS 1,0 — это стандартизированная, немного измененная версия SSL 3,0, которая была выпущена IETF в январе 1999 (Internet Engineering Task Force) в документе RFC 2246. Поскольку протокол TLS был стандартизован, разработчикам рекомендуется использовать TLS, а не SSL. Параметр PCT включен только в целях обратной совместимости и не должен использоваться для новой разработки. Если используется пакет безопасности SChannel, DCOM автоматически согласовывает оптимальный протокол в зависимости от возможностей клиента и сервера.'
ms.assetid: 03a5f987-f668-4f19-9b58-d62711f58734
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: eccc9f82a05d1542e7585426128f10cdf452d31d
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104339388"
---
# <a name="schannel"></a><span data-ttu-id="121e5-107">Schannel</span><span class="sxs-lookup"><span data-stu-id="121e5-107">Schannel</span></span>

<span data-ttu-id="121e5-108">Пакет безопасности безопасного канала (Schannel), идентификатор службы проверки подлинности которого — RPC \_ C \_ AUTHN \_ GSS \_ , поддерживает следующие протоколы на основе открытых ключей: SSL (SSL) версии 2,0 и 3,0, TLS 1,0 и частная технология связи (PCT) 1,0.</span><span class="sxs-lookup"><span data-stu-id="121e5-108">The Secure Channel (Schannel) security package, whose authentication service identifier is RPC\_C\_AUTHN\_GSS\_SCHANNEL, supports the following public-key based protocols: SSL (Secure Sockets Layer) versions 2.0 and 3.0, Transport Layer Security (TLS) 1.0, and Private Communication Technology (PCT) 1.0.</span></span> <span data-ttu-id="121e5-109">TLS 1,0 — это стандартизированная, немного измененная версия SSL 3,0, которая была выпущена IETF в январе 1999 (Internet Engineering Task Force) в документе [RFC 2246](https://www.ietf.org/rfc/rfc2246.txt).</span><span class="sxs-lookup"><span data-stu-id="121e5-109">TLS 1.0 is a standardized, slightly modified version of SSL 3.0 that was issued by the Internet Engineering Task Force (IETF) in January 1999, in document [RFC 2246](https://www.ietf.org/rfc/rfc2246.txt).</span></span> <span data-ttu-id="121e5-110">Поскольку протокол TLS был стандартизован, разработчикам рекомендуется использовать TLS, а не SSL.</span><span class="sxs-lookup"><span data-stu-id="121e5-110">Because TLS has been standardized, developers are encouraged to use TLS rather than SSL.</span></span> <span data-ttu-id="121e5-111">Параметр PCT включен только в целях обратной совместимости и не должен использоваться для новой разработки.</span><span class="sxs-lookup"><span data-stu-id="121e5-111">PCT is included for backward compatibility only and should not be used for new development.</span></span> <span data-ttu-id="121e5-112">Если используется пакет безопасности SChannel, DCOM автоматически согласовывает оптимальный протокол в зависимости от возможностей клиента и сервера.</span><span class="sxs-lookup"><span data-stu-id="121e5-112">When the Schannel security package is used, DCOM automatically negotiates the best protocol, depending on the client and server capabilities.</span></span>

<span data-ttu-id="121e5-113">В следующих разделах кратко описывается протокол TLS и принципы его работы с DCOM.</span><span class="sxs-lookup"><span data-stu-id="121e5-113">The following topics briefly describe the TLS protocol and how it works with DCOM.</span></span>

-   [<span data-ttu-id="121e5-114">Когда следует использовать TLS</span><span class="sxs-lookup"><span data-stu-id="121e5-114">When to Use TLS</span></span>](#when-to-use-tls)
-   [<span data-ttu-id="121e5-115">Краткий обзор работы протокола TLS</span><span class="sxs-lookup"><span data-stu-id="121e5-115">Brief Overview of How TLS Works</span></span>](#brief-overview-of-how-tls-works)
-   [<span data-ttu-id="121e5-116">Сертификаты X. 509</span><span class="sxs-lookup"><span data-stu-id="121e5-116">X.509 Certificates</span></span>](#x509-certificates)
    -   [<span data-ttu-id="121e5-117">Сертификаты клиента</span><span class="sxs-lookup"><span data-stu-id="121e5-117">Client Certificates</span></span>](#client-certificates)
-   [<span data-ttu-id="121e5-118">Использование TLS в COM</span><span class="sxs-lookup"><span data-stu-id="121e5-118">Using TLS in COM</span></span>](#using-tls-in-com)
    -   [<span data-ttu-id="121e5-119">Как сервер устанавливает контракт безопасности</span><span class="sxs-lookup"><span data-stu-id="121e5-119">How a Server Sets the Security Blanket</span></span>](#how-a-server-sets-the-security-blanket)
    -   [<span data-ttu-id="121e5-120">Как клиент устанавливает параметр безопасности</span><span class="sxs-lookup"><span data-stu-id="121e5-120">How a Client Sets the Security Blanket</span></span>](#how-a-client-sets-the-security-blanket)
    -   [<span data-ttu-id="121e5-121">Изменение клиентом общего доступа</span><span class="sxs-lookup"><span data-stu-id="121e5-121">How a Client Changes the Security Blanket</span></span>](#how-a-client-changes-the-security-blanket)
    -   [<span data-ttu-id="121e5-122">Пример. клиент изменяет контракт безопасности</span><span class="sxs-lookup"><span data-stu-id="121e5-122">Example: Client Changes the Security Blanket</span></span>](#example-client-changes-the-security-blanket)
-   [<span data-ttu-id="121e5-123">См. также</span><span class="sxs-lookup"><span data-stu-id="121e5-123">Related topics</span></span>](#related-topics)

> [!Note]  
> <span data-ttu-id="121e5-124">Все сведения о протоколе TLS в этих разделах также применяются к протоколам SSL и PCT.</span><span class="sxs-lookup"><span data-stu-id="121e5-124">All the information about the TLS protocol in these sections also applies to the SSL and PCT protocols.</span></span>

 

## <a name="when-to-use-tls"></a><span data-ttu-id="121e5-125">Когда следует использовать TLS</span><span class="sxs-lookup"><span data-stu-id="121e5-125">When to Use TLS</span></span>

<span data-ttu-id="121e5-126">TLS является единственным вариантом безопасности, доступным, когда серверы должны доказать свою личность анонимным клиентам.</span><span class="sxs-lookup"><span data-stu-id="121e5-126">TLS is the only security option available when servers need to prove their identity to anonymous clients.</span></span> <span data-ttu-id="121e5-127">Это особенно важно для веб-сайтов, которые хотят участвовать в электронной коммерции, так как помогает защитить передачу конфиденциальной информации, например номеров кредитных карт.</span><span class="sxs-lookup"><span data-stu-id="121e5-127">This is particularly important for websites that want to participate in e-commerce because it helps protect the transmission of sensitive information such as credit card numbers.</span></span> <span data-ttu-id="121e5-128">TLS гарантирует, что клиенты электронной коммерции могут быть уверены в том, что они выполняют бизнес, так как им предоставляется подтверждение подлинности сервера.</span><span class="sxs-lookup"><span data-stu-id="121e5-128">TLS assures that the e-commerce customers can be certain of whom they are doing business with because they are given proof of the server's identity.</span></span> <span data-ttu-id="121e5-129">Это также дает серверу электронной коммерции эффективность ненужной работы с проверкой подлинности идентификации каждого из клиентов.</span><span class="sxs-lookup"><span data-stu-id="121e5-129">It also gives the e-commerce server the efficiency of not having to concern itself with authenticating the identity of each of its customers.</span></span>

<span data-ttu-id="121e5-130">TLS требует, чтобы все серверы подтверждают свою личность для клиентов.</span><span class="sxs-lookup"><span data-stu-id="121e5-130">TLS requires that all servers prove their identity to clients.</span></span> <span data-ttu-id="121e5-131">Кроме того, протокол TLS обеспечивает возможность подтверждения удостоверений клиентов серверами.</span><span class="sxs-lookup"><span data-stu-id="121e5-131">Additionally, TLS provides the option of having clients prove their identity to servers.</span></span> <span data-ttu-id="121e5-132">Такая взаимная проверка подлинности может быть полезна при запрещении доступа к определенным веб-страницам в крупной корпоративной интрасети.</span><span class="sxs-lookup"><span data-stu-id="121e5-132">This mutual authentication can be useful in restricting the access of certain webpages in a large corporate intranet.</span></span>

<span data-ttu-id="121e5-133">Протокол TLS поддерживает самые строгие уровни проверки подлинности и предлагает открытую архитектуру, которая позволяет увеличить надежность шифрования, чтобы поддерживать технологические инновации.</span><span class="sxs-lookup"><span data-stu-id="121e5-133">TLS supports the strongest authentication levels and offers an open architecture that permits encryption strength to increase over time to keep up with technological innovation.</span></span> <span data-ttu-id="121e5-134">Протокол TLS является лучшим выбором для сред, в которых требуется самый высокий уровень безопасности при передаче данных.</span><span class="sxs-lookup"><span data-stu-id="121e5-134">TLS is the best choice for environments where the highest level of security is desired for the data in transit.</span></span>

## <a name="brief-overview-of-how-tls-works"></a><span data-ttu-id="121e5-135">Краткий обзор работы протокола TLS</span><span class="sxs-lookup"><span data-stu-id="121e5-135">Brief Overview of How TLS Works</span></span>

<span data-ttu-id="121e5-136">Протокол TLS основан на инфраструктуре открытых ключей (PKI), которая использует пары открытого и закрытого ключей для шифрования данных и установления целостности данных и использует сертификаты X. 509 для проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="121e5-136">TLS is built upon a public key infrastructure (PKI), which uses public/private key pairs for enabling data encryption and establishing data integrity, and uses X.509 certificates for authentication.</span></span>

<span data-ttu-id="121e5-137">Многие протоколы безопасности, такие как протокол Kerberos V5, зависят от одного ключа для шифрования и расшифровки данных.</span><span class="sxs-lookup"><span data-stu-id="121e5-137">Many security protocols, such as the Kerberos v5 protocol, depend on a single key to both encrypt and decrypt data.</span></span> <span data-ttu-id="121e5-138">Поэтому такие протоколы зависят от безопасного обмена ключами шифрования. в протоколе Kerberos это делается с помощью билетов, полученных из центр распространения ключей (KDC).</span><span class="sxs-lookup"><span data-stu-id="121e5-138">Such protocols therefore depend on the secure exchange of encryption keys; in the Kerberos protocol, this is done through tickets obtained from the Key Distribution Center (KDC).</span></span> <span data-ttu-id="121e5-139">Для этого все, кто использует протокол Kerberos, должны быть зарегистрированы в KDC, что является непрактичным ограничением для веб-сервера электронной коммерции, предназначенного для привлечения миллионов клиентов по всему миру.</span><span class="sxs-lookup"><span data-stu-id="121e5-139">This requires that everyone using the Kerberos protocol be registered with the KDC, which would be an impractical limitation for an e-commerce web server that is intended to attract millions of customers from around the world.</span></span> <span data-ttu-id="121e5-140">Поэтому протокол TLS основан на PKI, который использует два ключа для данных енкриптионâ € "когда один ключ пары шифрует данные, его можно расшифровать только в другом ключе пары.</span><span class="sxs-lookup"><span data-stu-id="121e5-140">TLS therefore relies upon a PKI, which uses two keys for data encryptionâ€”when one key of the pair encrypts the data, only the other key of the pair can decrypt it.</span></span> <span data-ttu-id="121e5-141">Преимущество этого подхода заключается в том, что шифрование может быть выполнено без необходимости безопасного обмена ключами шифрования.</span><span class="sxs-lookup"><span data-stu-id="121e5-141">The principle benefit of this design is that encryption can be performed without requiring the secure exchange of encryption keys.</span></span>

<span data-ttu-id="121e5-142">PKI использует методику, когда один из ключей хранится в частном состоянии и доступен только участнику, которому он зарегистрирован, а другой ключ становится общедоступным для всех.</span><span class="sxs-lookup"><span data-stu-id="121e5-142">A PKI uses a technique where one of the keys is kept private and is available only to the principal to whom it is registered, while the other key is made public for anyone to access.</span></span> <span data-ttu-id="121e5-143">Если кому-то хочется отправить частное сообщение владельцу пары ключей, сообщение может быть зашифровано с помощью открытого ключа, и только закрытый ключ может быть использован для расшифровки сообщения.</span><span class="sxs-lookup"><span data-stu-id="121e5-143">If someone wants to send a private message to the owner of a key pair, the message can be encrypted with the public key and only the private key can be used to decrypt the message.</span></span>

<span data-ttu-id="121e5-144">Пары ключей также используются для проверки целостности отправляемых данных.</span><span class="sxs-lookup"><span data-stu-id="121e5-144">Key pairs are also used to verify the integrity of the data being sent.</span></span> <span data-ttu-id="121e5-145">Для этого владелец пары ключей может присоединить цифровую подпись к данным перед их отправкой.</span><span class="sxs-lookup"><span data-stu-id="121e5-145">To do this, the owner of the key pair can attach a digital signature to the data before sending it.</span></span> <span data-ttu-id="121e5-146">Создание цифровой подписи включает в себя вычисление хэша данных и шифрование хэша с помощью закрытого ключа.</span><span class="sxs-lookup"><span data-stu-id="121e5-146">Creating a digital signature involves calculating a hash of the data and encrypting the hash with the private key.</span></span> <span data-ttu-id="121e5-147">Любой, кто использует открытый ключ для расшифровки цифровой подписи, гарантирует, что цифровая подпись должна быть только у лица, владеющего закрытым ключом.</span><span class="sxs-lookup"><span data-stu-id="121e5-147">Anyone who uses the public key to decrypt the digital signature is assured that the digital signature must have come only from the person who owns the private key.</span></span> <span data-ttu-id="121e5-148">Кроме того, получатель может вычислить хэш данных с помощью того же алгоритма, что и отправитель, и если вычисленный хэш совпадает с именем, отправленным в цифровой подписи, получатель может быть уверенным в том, что данные не были изменены после подписания цифровой подписью.</span><span class="sxs-lookup"><span data-stu-id="121e5-148">Additionally, the recipient can calculate a hash of the data using the same algorithm as the sender, and if the calculated hash matches the one sent in the digital signature, the recipient can be certain that the data was not modified after it was digitally signed.</span></span>

<span data-ttu-id="121e5-149">Одним из недостатков использования PKI для шифрования данных большого объема является относительно медленная производительность.</span><span class="sxs-lookup"><span data-stu-id="121e5-149">One disadvantage of using a PKI for high-volume data encryption is its relatively slow performance.</span></span> <span data-ttu-id="121e5-150">Из-за большого количества математических операций шифрование и расшифровка данных с помощью асимметричного шифра, который зависит от пары ключей, может быть до 1 000 раз медленнее, чем шифрование и расшифровка с помощью симметричного шифра, который зависит только от одного ключа.</span><span class="sxs-lookup"><span data-stu-id="121e5-150">Because of the intensive mathematics involved, encryption and decryption of data using an asymmetric cipher that depends on a key pair can be up to 1,000 times slower than encryption and decryption using a symmetric cipher that depends only on a single key.</span></span> <span data-ttu-id="121e5-151">Таким образом, протокол TLS использует PKI только для создания цифровых подписей и для согласования единственного ключа сеанса, который будет использоваться как клиентом, так и сервером для полного шифрования и расшифровки данных.</span><span class="sxs-lookup"><span data-stu-id="121e5-151">TLS therefore uses a PKI only for generating digital signatures and for negotiating the session-specific single key that will be used by both the client and the server for bulk data encryption and decryption.</span></span> <span data-ttu-id="121e5-152">Протокол TLS поддерживает широкий спектр симметричных шифров с одним ключом, а в будущем могут добавляться дополнительные шифры.</span><span class="sxs-lookup"><span data-stu-id="121e5-152">TLS supports a wide variety of single-key symmetric ciphers, and additional ciphers may be added in the future.</span></span>

<span data-ttu-id="121e5-153">Дополнительные сведения о протоколе подтверждения TLS см. в разделе [протокол подтверждения TLS](/windows/desktop/SecAuthN/tls-handshake-protocol).</span><span class="sxs-lookup"><span data-stu-id="121e5-153">For more information about the TLS handshake protocol, see [TLS Handshake Protocol](/windows/desktop/SecAuthN/tls-handshake-protocol).</span></span>

<span data-ttu-id="121e5-154">Дополнительные сведения о криптографии за протоколом TLS см. в разделе [Криптография Essentials](/windows/desktop/SecCrypto/cryptography-essentials).</span><span class="sxs-lookup"><span data-stu-id="121e5-154">For more details regarding the cryptography behind the TLS protocol, see [Cryptography Essentials](/windows/desktop/SecCrypto/cryptography-essentials).</span></span>

## <a name="x509-certificates"></a><span data-ttu-id="121e5-155">Сертификаты X.509</span><span class="sxs-lookup"><span data-stu-id="121e5-155">X.509 Certificates</span></span>

<span data-ttu-id="121e5-156">Критической проблемой, которая должна быть обработана PKI, является возможность доверять подлинности используемого открытого ключа.</span><span class="sxs-lookup"><span data-stu-id="121e5-156">A critical issue that must be handled by a PKI is the ability to trust the authenticity of the public key that is being used.</span></span> <span data-ttu-id="121e5-157">При использовании открытого ключа, выпущенного для компании, с которой требуется реализовать бизнес, необходимо убедиться, что ключ фактически принадлежит компании, а не к лицу, желающему найти номер кредитной карты.</span><span class="sxs-lookup"><span data-stu-id="121e5-157">When you use a public key issued to a company that you want to do business with, you want to be certain that the key actually belongs to the company rather than to a thief who wants to discover your credit card number.</span></span>

<span data-ttu-id="121e5-158">Чтобы гарантировать удостоверение участника, содержащего пару ключей, участник выдает сертификат X. 509 центром сертификации (ЦС).</span><span class="sxs-lookup"><span data-stu-id="121e5-158">To guarantee the identity of a principal holding a key pair, the principal is issued an X.509 certificate by a certification authority (CA).</span></span> <span data-ttu-id="121e5-159">Этот сертификат содержит сведения, идентифицирующие участника, содержит открытый ключ участника и имеет цифровую подпись ЦС.</span><span class="sxs-lookup"><span data-stu-id="121e5-159">This certificate contains information that identifies the principal, contains the principal's public key, and is digitally signed by the CA.</span></span> <span data-ttu-id="121e5-160">Эта цифровая подпись означает, что ЦС считает, что открытый ключ, содержащийся в сертификате, действительно принадлежит участнику, определяемому сертификатом.</span><span class="sxs-lookup"><span data-stu-id="121e5-160">This digital signature indicates that the CA believes that the public key contained in the certificate truly belongs to the principal identified by the certificate.</span></span>

<span data-ttu-id="121e5-161">Как доверять ЦС?</span><span class="sxs-lookup"><span data-stu-id="121e5-161">And how do you trust the CA?</span></span> <span data-ttu-id="121e5-162">Так как сам ЦС содержит сертификат X. 509, подписанный центром сертификации более высокого уровня.</span><span class="sxs-lookup"><span data-stu-id="121e5-162">Because the CA itself holds an X.509 certificate that has been signed by a higher-level CA.</span></span> <span data-ttu-id="121e5-163">Цепочка подписей сертификатов сохраняется до тех пор, пока не достигнет корневого ЦС, который является центром сертификации, который подписывает собственные сертификаты.</span><span class="sxs-lookup"><span data-stu-id="121e5-163">This chain of certificate signatures continues until it reaches a root CA, which is a CA that signs its own certificates.</span></span> <span data-ttu-id="121e5-164">Если вы доверяете целостности корневого ЦС сертификата, вы должны иметь возможность доверять подлинности самого сертификата.</span><span class="sxs-lookup"><span data-stu-id="121e5-164">If you trust the integrity of the root CA of a certificate, you should be able to trust the authenticity of the certificate itself.</span></span> <span data-ttu-id="121e5-165">Таким образом, выбор корневых центров сертификации, которым вы готовы доверять, является важной обязанностью для системного администратора.</span><span class="sxs-lookup"><span data-stu-id="121e5-165">Therefore, picking root CAs that you are willing to trust is an important duty for a system administrator.</span></span>

### <a name="client-certificates"></a><span data-ttu-id="121e5-166">Сертификаты клиента</span><span class="sxs-lookup"><span data-stu-id="121e5-166">Client Certificates</span></span>

<span data-ttu-id="121e5-167">При первом появлении протоколов транспортного уровня безопасности их основное назначение было гарантией того, что клиент подключается к подлинному серверу и помогает защитить конфиденциальность данных во время передачи.</span><span class="sxs-lookup"><span data-stu-id="121e5-167">When security transport-layer protocols first emerged, their primary purpose was to guarantee that a client was connecting to an authentic server and help protect the privacy of data while in transit.</span></span> <span data-ttu-id="121e5-168">Однако SSL 3,0 и TLS 1,0 также включают поддержку передачи сертификата клиента во время подтверждения протокола.</span><span class="sxs-lookup"><span data-stu-id="121e5-168">However, SSL 3.0 and TLS 1.0 also include support for the transmission of a client's certificate during the protocol's handshake.</span></span> <span data-ttu-id="121e5-169">Эта необязательная функция обеспечивает взаимную проверку подлинности клиента и сервера.</span><span class="sxs-lookup"><span data-stu-id="121e5-169">This optional feature enables the mutual authentication of the client and server.</span></span>

<span data-ttu-id="121e5-170">Решение о том, следует ли использовать сертификат клиента, должно выполняться в контексте приложения.</span><span class="sxs-lookup"><span data-stu-id="121e5-170">The decision of whether to use a client certificate should be made in the context of the application.</span></span> <span data-ttu-id="121e5-171">Сертификаты клиента не требуются, если основным требованием является проверка подлинности сервера.</span><span class="sxs-lookup"><span data-stu-id="121e5-171">Client certificates are unnecessary if the primary requirement is authenticating the server.</span></span> <span data-ttu-id="121e5-172">Однако если проверка подлинности клиента является обязательной, можно использовать сертификат клиента вместо пользовательской проверки подлинности в приложении.</span><span class="sxs-lookup"><span data-stu-id="121e5-172">However, if client authentication is essential, a client's certificate can be used rather than relying on custom authentication within the application.</span></span> <span data-ttu-id="121e5-173">Использование сертификатов клиентов предпочтительнее, чем пользовательская проверка подлинности, так как предоставляет пользователям сценарий единого входа.</span><span class="sxs-lookup"><span data-stu-id="121e5-173">Using client certificates is preferable over custom authentication because it gives users a single sign-on scenario.</span></span>

## <a name="using-tls-in-com"></a><span data-ttu-id="121e5-174">Использование TLS в COM</span><span class="sxs-lookup"><span data-stu-id="121e5-174">Using TLS in COM</span></span>

<span data-ttu-id="121e5-175">Протокол TLS поддерживает только уровень олицетворения "IMPERSONATE" ( \_ \_ олицетворение на уровне RPC C) олицетворения \_ \_ .</span><span class="sxs-lookup"><span data-stu-id="121e5-175">TLS supports only the impersonate (RPC\_C\_IMP\_LEVEL\_IMPERSONATE) level of impersonation.</span></span> <span data-ttu-id="121e5-176">Если COM согласовывает протокол TLS в качестве службы проверки подлинности на прокси-сервере, то COM устанавливает олицетворение, независимо от процесса по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="121e5-176">If COM negotiates TLS as the authentication service on a proxy, COM will set the impersonation level to impersonate regardless of the process default.</span></span> <span data-ttu-id="121e5-177">Для правильной работы олицетворения в TLS клиент должен предоставить серверу сертификат X. 509, а сервер должен иметь сертификат, сопоставленный с определенной учетной записью пользователя на сервере.</span><span class="sxs-lookup"><span data-stu-id="121e5-177">For impersonation to work properly in TLS, the client must provide an X.509 certificate to the server and the server must have that certificate mapped to a particular user account on the server.</span></span> <span data-ttu-id="121e5-178">Дополнительные сведения см. в пошаговом [инструкции по сопоставлению сертификатов с учетными записями пользователей](https://www.microsoft.com/isapi/redir.dll?prd=windows2000&sbp=technicallibrary&ar=security&sba=mappingcertificates).</span><span class="sxs-lookup"><span data-stu-id="121e5-178">For more information, see the [Step-by-Step Guide to Mapping Certificates to User Accounts](https://www.microsoft.com/isapi/redir.dll?prd=windows2000&sbp=technicallibrary&ar=security&sba=mappingcertificates).</span></span>

<span data-ttu-id="121e5-179">Протокол TLS не поддерживает [маскировку](cloaking.md).</span><span class="sxs-lookup"><span data-stu-id="121e5-179">TLS does not support [cloaking](cloaking.md).</span></span> <span data-ttu-id="121e5-180">Если флаг маскировки и протокол TLS указаны в вызове [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) или [**Иклиентсекурити:: сетбланкет**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket) , \_ то возвращается E INVALIDARG.</span><span class="sxs-lookup"><span data-stu-id="121e5-180">If a cloaking flag and TLS are specified in a [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) or a [**IClientSecurity::SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket) call, E\_INVALIDARG will be returned.</span></span>

<span data-ttu-id="121e5-181">TLS не работает с уровнем проверки подлинности, установленным в значение нет.</span><span class="sxs-lookup"><span data-stu-id="121e5-181">TLS does not work with the authentication level set to None.</span></span> <span data-ttu-id="121e5-182">При подтверждении между клиентом и сервером проверяется уровень проверки подлинности, заданный каждым, и выбирается более высокая настройка безопасности для соединения.</span><span class="sxs-lookup"><span data-stu-id="121e5-182">The handshake between the client and server examines the authentication level set by each and chooses the higher security setting for the connection.</span></span>

<span data-ttu-id="121e5-183">Параметры безопасности для TLS можно задать, вызвав [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) и [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket).</span><span class="sxs-lookup"><span data-stu-id="121e5-183">The security parameters for TLS can be set by calling [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) and [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket).</span></span> <span data-ttu-id="121e5-184">В следующих разделах описываются особенности, связанные с выполнением этих вызовов.</span><span class="sxs-lookup"><span data-stu-id="121e5-184">The following sections describe the nuances involved in making those calls.</span></span>

### <a name="how-a-server-sets-the-security-blanket"></a><span data-ttu-id="121e5-185">Как сервер устанавливает контракт безопасности</span><span class="sxs-lookup"><span data-stu-id="121e5-185">How a Server Sets the Security Blanket</span></span>

<span data-ttu-id="121e5-186">Если сервер хочет использовать TLS, он должен указать Schannel (RPC \_ C \_ AUTHN \_ GSS \_ Schannel) в качестве службы проверки подлинности в  параметре асауссвк [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity).</span><span class="sxs-lookup"><span data-stu-id="121e5-186">If a server wants to use TLS, it must specify Schannel (RPC\_C\_AUTHN\_GSS\_SCHANNEL) as an authentication service in the *asAuthSvc* parameter of [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity).</span></span> <span data-ttu-id="121e5-187">Чтобы предотвратить подключение клиентов к серверу с помощью менее безопасной службы проверки подлинности, сервер должен указать только Schannel в качестве службы проверки подлинности при вызове **CoInitializeSecurity**.</span><span class="sxs-lookup"><span data-stu-id="121e5-187">To prevent clients from connecting to the server by using a less secure authentication service, the server should specify only Schannel as an authentication service when it calls **CoInitializeSecurity**.</span></span> <span data-ttu-id="121e5-188">Сервер не может изменить общий уровень безопасности после вызова **CoInitializeSecurity**.</span><span class="sxs-lookup"><span data-stu-id="121e5-188">The server cannot change the security blanket after it has called **CoInitializeSecurity**.</span></span>

<span data-ttu-id="121e5-189">Чтобы использовать TLS, необходимо указать следующие параметры при вызове сервером [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity):</span><span class="sxs-lookup"><span data-stu-id="121e5-189">To use TLS, the following parameters should be specified when a server calls [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity):</span></span>

-   <span data-ttu-id="121e5-190">*pVoid* должен быть либо указателем на объект [**иакцессконтрол**](/windows/desktop/api/IAccess/nn-iaccess-iaccesscontrol) , либо указателем на [**\_ дескриптор безопасности**](/windows/desktop/api/winnt/ns-winnt-security_descriptor).</span><span class="sxs-lookup"><span data-stu-id="121e5-190">*pVoid* should be either a pointer to an [**IAccessControl**](/windows/desktop/api/IAccess/nn-iaccess-iaccesscontrol) object or a pointer to a [**SECURITY\_DESCRIPTOR**](/windows/desktop/api/winnt/ns-winnt-security_descriptor).</span></span> <span data-ttu-id="121e5-191">Оно не должно быть **null** или указателем на AppID.</span><span class="sxs-lookup"><span data-stu-id="121e5-191">It should not be **NULL** or a pointer to an AppID.</span></span>
-   <span data-ttu-id="121e5-192">*кауссвк* не может иметь значение 0 или-1.</span><span class="sxs-lookup"><span data-stu-id="121e5-192">*cAuthSvc* cannot be 0 or -1.</span></span> <span data-ttu-id="121e5-193">Серверы COM никогда не выбирают канал Schannel, если *кауссвк* имеет-1.</span><span class="sxs-lookup"><span data-stu-id="121e5-193">COM servers never chooses Schannel when *cAuthSvc* is -1.</span></span>
-   <span data-ttu-id="121e5-194">*асауссвк* должен указывать Schannel в качестве возможной службы проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="121e5-194">*asAuthSvc* must specify Schannel as a possible authentication service.</span></span> <span data-ttu-id="121e5-195">Для этого необходимо задать следующие параметры [**\_ \_ службы проверки подлинности**](/windows/win32/api/objidlbase/ns-objidlbase-sole_authentication_service) для участника Schannel в [**\_ \_ списке единственной проверки подлинности**](/windows/win32/api/objidlbase/ns-objidlbase-sole_authentication_list):</span><span class="sxs-lookup"><span data-stu-id="121e5-195">This is done by setting the following [**SOLE\_AUTHENTICATION\_SERVICE**](/windows/win32/api/objidlbase/ns-objidlbase-sole_authentication_service) parameters for the Schannel member of the [**SOLE\_AUTHENTICATION\_LIST**](/windows/win32/api/objidlbase/ns-objidlbase-sole_authentication_list):</span></span>
    -   <span data-ttu-id="121e5-196">*двауснсвк* должен быть RPC \_ C \_ AUTHN \_ GSS \_ SChannel.</span><span class="sxs-lookup"><span data-stu-id="121e5-196">*dwAuthnSvc* must be RPC\_C\_AUTHN\_GSS\_SCHANNEL.</span></span>
    -   <span data-ttu-id="121e5-197">*дваусзсвк* должен быть RPC \_ C \_ AUTHZ \_ None.</span><span class="sxs-lookup"><span data-stu-id="121e5-197">*dwAuthzSvc* should be RPC\_C\_AUTHZ\_NONE.</span></span> <span data-ttu-id="121e5-198">В настоящее время он игнорируется.</span><span class="sxs-lookup"><span data-stu-id="121e5-198">Currently, it is ignored.</span></span>
    -   <span data-ttu-id="121e5-199">*ппринЦипалнаме* должен быть указателем на [**\_ контекст сертификата**](/windows/desktop/api/wincrypt/ns-wincrypt-cert_context), приведенным в качестве указателя на Олечар, который представляет сертификат X. 509 сервера.</span><span class="sxs-lookup"><span data-stu-id="121e5-199">*pPrincipalName* must be a pointer to a [**CERT\_CONTEXT**](/windows/desktop/api/wincrypt/ns-wincrypt-cert_context), cast as a pointer to OLECHAR, which represents the server's X.509 certificate.</span></span>
-   <span data-ttu-id="121e5-200">*двауснлевел* указывает минимальный уровень проверки подлинности, который будет приниматься клиентами для успешного подключения.</span><span class="sxs-lookup"><span data-stu-id="121e5-200">*dwAuthnLevel* indicates the minimum authentication level that will be accepted from clients for a successful connection.</span></span> <span data-ttu-id="121e5-201">Он не может быть \_ на \_ уровне RPC C AUTHN \_ \_ None.</span><span class="sxs-lookup"><span data-stu-id="121e5-201">It cannot be RPC\_C\_AUTHN\_LEVEL\_NONE.</span></span>
-   <span data-ttu-id="121e5-202">для *двкапабилитиес* не должен быть \_ установлен флаг еоак AppID.</span><span class="sxs-lookup"><span data-stu-id="121e5-202">*dwCapabilities* should not have the EOAC\_APPID flag set.</span></span> <span data-ttu-id="121e5-203">\_ \_ Флаг управления доступом еоак должен быть установлен, если *pVoid* указывает на объект [**иакцессконтрол**](/windows/desktop/api/IAccess/nn-iaccess-iaccesscontrol) ; его не следует задавать, если *pVoid* указывает на \_ дескриптор безопасности.</span><span class="sxs-lookup"><span data-stu-id="121e5-203">The EOAC\_ACCESS\_CONTROL flag should be set if *pVoid* points to an [**IAccessControl**](/windows/desktop/api/IAccess/nn-iaccess-iaccesscontrol) object; it should not be set if *pVoid* points to a SECURITY\_DESCRIPTOR.</span></span> <span data-ttu-id="121e5-204">Другие флаги, которые можно задать, см. в разделе [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity).</span><span class="sxs-lookup"><span data-stu-id="121e5-204">For other flags that may be set, see [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity).</span></span>

<span data-ttu-id="121e5-205">Дополнительные сведения об использовании [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity)см. в разделе [Настройка безопасности Процессвиде с помощью CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span><span class="sxs-lookup"><span data-stu-id="121e5-205">For more information about using [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity), see [Setting Processwide Security with CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span></span>

### <a name="how-a-client-sets-the-security-blanket"></a><span data-ttu-id="121e5-206">Как клиент устанавливает параметр безопасности</span><span class="sxs-lookup"><span data-stu-id="121e5-206">How a Client Sets the Security Blanket</span></span>

<span data-ttu-id="121e5-207">Если клиент хочет использовать TLS, он должен указать Schannel (RPC \_ C \_ AUTHN \_ GSS \_ Schannel) в списке служб проверки подлинности в параметре *пауслист* [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity).</span><span class="sxs-lookup"><span data-stu-id="121e5-207">If a client wants to use TLS, it must specify Schannel (RPC\_C\_AUTHN\_GSS\_SCHANNEL) in its list of authentication services in the *pAuthList* parameter of [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity).</span></span> <span data-ttu-id="121e5-208">Если канал Schannel не указан в качестве возможной службы проверки подлинности при вызове **CoInitializeSecurity** , то при последующем вызове метода [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket) (или [**иклиентсекурити:: сетбланкет**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket)) произойдет сбой, если он попытается указать Schannel в качестве службы проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="121e5-208">If Schannel is not specified as a possible authentication service when **CoInitializeSecurity** is called, a later call to [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket) (or [**IClientSecurity::SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket)) will fail if it tries to specify Schannel as the authentication service.</span></span>

<span data-ttu-id="121e5-209">При вызове [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity)клиентом необходимо указать следующие параметры:</span><span class="sxs-lookup"><span data-stu-id="121e5-209">The following parameters should be specified when a client calls [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity):</span></span>

-   <span data-ttu-id="121e5-210">*двауснлевел* указывает уровень проверки подлинности по умолчанию, который клиент хочет использовать.</span><span class="sxs-lookup"><span data-stu-id="121e5-210">*dwAuthnLevel* specifies the default authentication level that the client wants to use.</span></span> <span data-ttu-id="121e5-211">Он не может быть \_ на \_ уровне RPC C AUTHN \_ \_ None.</span><span class="sxs-lookup"><span data-stu-id="121e5-211">It cannot be RPC\_C\_AUTHN\_LEVEL\_NONE.</span></span>
-   <span data-ttu-id="121e5-212">*двимплевел* должен быть \_ \_ \_ олицетворением на уровне RPC C \_ .</span><span class="sxs-lookup"><span data-stu-id="121e5-212">*dwImpLevel* must be RPC\_C\_IMP\_LEVEL\_IMPERSONATE.</span></span>
-   <span data-ttu-id="121e5-213">*пауслист* должен иметь следующие параметры [**\_ проверки \_ подлинности**](/windows/win32/api/objidlbase/ns-objidlbase-sole_authentication_info) в качестве члена списка:</span><span class="sxs-lookup"><span data-stu-id="121e5-213">*pAuthList* must have the following [**SOLE\_AUTHENTICATION\_INFO**](/windows/win32/api/objidlbase/ns-objidlbase-sole_authentication_info) parameters as a member of the list:</span></span>
    -   <span data-ttu-id="121e5-214">*двауснсвк* должен быть RPC \_ C \_ AUTHN \_ GSS \_ SChannel.</span><span class="sxs-lookup"><span data-stu-id="121e5-214">*dwAuthnSvc* must be RPC\_C\_AUTHN\_GSS\_SCHANNEL.</span></span>
    -   <span data-ttu-id="121e5-215">*дваусзсвк* должен быть RPC \_ C \_ AUTHZ \_ None.</span><span class="sxs-lookup"><span data-stu-id="121e5-215">*dwAuthzSvc* must be RPC\_C\_AUTHZ\_NONE.</span></span>
    -   <span data-ttu-id="121e5-216">*паусинфо* — это указатель на [**\_ контекст сертификата**](/windows/desktop/api/wincrypt/ns-wincrypt-cert_context), приведенный в качестве указателя на void, который представляет сертификат X. 509 клиента.</span><span class="sxs-lookup"><span data-stu-id="121e5-216">*pAuthInfo* is a pointer to a [**CERT\_CONTEXT**](/windows/desktop/api/wincrypt/ns-wincrypt-cert_context), cast as a pointer to void, which represents the client's X.509 certificate.</span></span> <span data-ttu-id="121e5-217">Если у клиента нет сертификата или вы не хотите предоставлять его сертификат серверу, *паусинфо* должен иметь **значение NULL** , и будет предпринята попытка использовать анонимное соединение с сервером.</span><span class="sxs-lookup"><span data-stu-id="121e5-217">If the client does not have a certificate or does not wish to present its certificate to the server, *pAuthInfo* must be **NULL** and an anonymous connection will be attempted with the server.</span></span>
-   <span data-ttu-id="121e5-218">*двкапабилитиес* — это набор флагов, которые указывают дополнительные возможности клиента.</span><span class="sxs-lookup"><span data-stu-id="121e5-218">*dwCapabilities* is a set of flags that indicate additional client capabilities.</span></span> <span data-ttu-id="121e5-219">Сведения о том, какие флаги должны быть установлены, см. в разделе [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) .</span><span class="sxs-lookup"><span data-stu-id="121e5-219">See [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) for information about which flags should be set.</span></span>

<span data-ttu-id="121e5-220">Дополнительные сведения об использовании [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity)см. в разделе [Настройка безопасности Процессвиде с помощью CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span><span class="sxs-lookup"><span data-stu-id="121e5-220">For more information about using [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity), see [Setting Processwide Security with CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span></span>

### <a name="how-a-client-changes-the-security-blanket"></a><span data-ttu-id="121e5-221">Изменение клиентом общего доступа</span><span class="sxs-lookup"><span data-stu-id="121e5-221">How a Client Changes the Security Blanket</span></span>

<span data-ttu-id="121e5-222">Если клиент хочет использовать TLS, но при этом изменить параметры безопасности после вызова [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity), он должен вызвать метод [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket) или [**иклиентсекурити:: сетбланкет**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket) с параметрами, аналогичными тем, которые использовались в вызове **CoInitializeSecurity**, со следующими отличиями.</span><span class="sxs-lookup"><span data-stu-id="121e5-222">If a client wants to use TLS but change the security blanket after calling [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity), it must call either [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket) or [**IClientSecurity::SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket) with parameters similar to those used in the call to **CoInitializeSecurity**, with the following differences:</span></span>

-   <span data-ttu-id="121e5-223">*псерверпринкнаме* указывает имя участника сервера в формате мсстд или фуллсик.</span><span class="sxs-lookup"><span data-stu-id="121e5-223">*pServerPrincName* indicates the principal name of the server, in either msstd or fullsic format.</span></span> <span data-ttu-id="121e5-224">Сведения об этих форматах см. в разделе [имена участников](/windows/desktop/Rpc/principal-names).</span><span class="sxs-lookup"><span data-stu-id="121e5-224">For information on these formats, see [Principal Names](/windows/desktop/Rpc/principal-names).</span></span> <span data-ttu-id="121e5-225">Если у клиента есть сертификат X. 509 сервера, он может найти имя участника, вызвав [**рпкцертженератепринЦипалнаме**](/windows/desktop/api/rpcssl/nf-rpcssl-rpccertgenerateprincipalname).</span><span class="sxs-lookup"><span data-stu-id="121e5-225">If the client has the server's X.509 certificate, it can find the principal name by calling [**RpcCertGeneratePrincipalName**](/windows/desktop/api/rpcssl/nf-rpcssl-rpccertgenerateprincipalname).</span></span>
-   <span data-ttu-id="121e5-226">*паусинфо* — это указатель на [**\_ контекст сертификата**](/windows/desktop/api/wincrypt/ns-wincrypt-cert_context), приведенный в качестве указателя на \_ маркер идентификации RPC auth \_ \_ , который представляет сертификат X. 509 клиента.</span><span class="sxs-lookup"><span data-stu-id="121e5-226">*pAuthInfo* is a pointer to a [**CERT\_CONTEXT**](/windows/desktop/api/wincrypt/ns-wincrypt-cert_context), cast as a pointer to RPC\_AUTH\_IDENTITY\_HANDLE, which represents the client's X.509 certificate.</span></span> <span data-ttu-id="121e5-227">Если у клиента нет сертификата или вы не хотите предоставлять его сертификат серверу, *паусинфо* должен иметь **значение NULL** , и будет предпринята попытка использовать анонимное соединение с сервером.</span><span class="sxs-lookup"><span data-stu-id="121e5-227">If the client does not have a certificate or does not wish to present its certificate to the server, *pAuthInfo* must be **NULL** and an anonymous connection will be attempted with the server.</span></span>
-   <span data-ttu-id="121e5-228">*двкапабилитиес* состоит из флагов, указывающих дополнительные возможности клиента.</span><span class="sxs-lookup"><span data-stu-id="121e5-228">*dwCapabilities* consists of flags that indicate additional client capabilities.</span></span> <span data-ttu-id="121e5-229">Для изменения общих параметров безопасности можно использовать только четыре флага: ЕОАК \_ Default, еоак \_ взаимная \_ Проверка подлинности, еоак \_ любой другой \_ центр (этот флаг является устаревшим), а еоак \_ делает \_ фуллсик.</span><span class="sxs-lookup"><span data-stu-id="121e5-229">Only four flags can be used to change security blanket settings: EOAC\_DEFAULT, EOAC\_MUTUAL\_AUTH, EOAC\_ANY\_AUTHORITY (this flag is deprecated), and EOAC\_MAKE\_FULLSIC.</span></span> <span data-ttu-id="121e5-230">Дополнительные сведения см. в разделе [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket).</span><span class="sxs-lookup"><span data-stu-id="121e5-230">For more information, see [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket).</span></span>

<span data-ttu-id="121e5-231">Дополнительные сведения об использовании [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)см. в разделе [Настройка безопасности на уровне прокси-сервера интерфейса](setting-security-at-the-interface-proxy-level.md).</span><span class="sxs-lookup"><span data-stu-id="121e5-231">For more information about using [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket), see [Setting Security at the Interface Proxy Level](setting-security-at-the-interface-proxy-level.md).</span></span>

### <a name="example-client-changes-the-security-blanket"></a><span data-ttu-id="121e5-232">Пример. клиент изменяет контракт безопасности</span><span class="sxs-lookup"><span data-stu-id="121e5-232">Example: Client Changes the Security Blanket</span></span>

<span data-ttu-id="121e5-233">В следующем примере показано, как клиент может изменить уровень безопасности, в соответствии с которым клиент должен предоставить сертификат X. 509, чтобы удовлетворить запрос от сервера.</span><span class="sxs-lookup"><span data-stu-id="121e5-233">The following example demonstrates how a client can change the security blanket to accommodate a request from the server for the client to provide its X.509 certificate.</span></span> <span data-ttu-id="121e5-234">Код обработки ошибок не указан для краткости.</span><span class="sxs-lookup"><span data-stu-id="121e5-234">Error handling code is omitted for brevity.</span></span>


```C++
void ClientChangesSecurity ()
{
  HCRYPTPROV                   provider           = 0;
  HCERTSTORE                   cert_store         = NULL;
  PCCERT_CONTEXT               client_cert        = NULL;
  PCCERT_CONTEXT               server_cert        = NULL;
  WCHAR                        *server_princ_name = NULL;
  ISecret                      *pSecret           = NULL;
  MULTI_QI                     server_instance;
  COSERVERINFO                 server_machine;
  SOLE_AUTHENTICATION_LIST     auth_list;
  SOLE_AUTHENTICATION_INFO     auth_info[1];



  // Specify all the authentication info. 
  // The client is willing to connect using SChannel,
  //   with no client certificate.
  auth_list.cAuthInfo     = 1;
  auth_list.aAuthInfo     = auth_info;
  auth_info[0].dwAuthnSvc = RPC_C_AUTHN_GSS_SCHANNEL;
  auth_info[0].dwAuthzSvc = RPC_C_AUTHZ_NONE;
  auth_info[0].pAuthInfo  = NULL;  // No certificate

  // Initialize client security with no client certificate.
  CoInitializeSecurity( NULL, -1, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_PKT,
                        RPC_C_IMP_LEVEL_IMPERSONATE, &auth_list,
                        EOAC_NONE, NULL );
  
  // Specify info for the proxy.
  server_instance = {&IID_ISecret, NULL, S_OK};
  server_machine  = {0, L"ServerMachineName", NULL, 0};
  
  // Create a proxy.
  CoCreateInstanceEx( CLSID_Secret, NULL, CLSCTX_REMOTE_SERVER, 
                      &server_machine, 1, &server_instance);
  pSecret = (ISecret *) server_instance.pItf;

  //** The client obtained the server's certificate during the handshake.
  //** The server requests a certificate from the client.

  // Get the default certificate provider.
  CryptAcquireContext( &provider, NULL, NULL, PROV_RSA_SCHANNEL, 0 );

  // Open the certificate store.
  cert_store = CertOpenSystemStore( provider, L"my" );

  // Find the client's certificate.
  client_cert = 
    CertFindCertificateInStore( cert_store,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                0,
                                CERT_FIND_SUBJECT_STR,
                                L"ClientName",  // Use the principal name
                                NULL );

  // Find the fullsic principal name of the server.
  RpcCertGeneratePrincipalName( server_cert, RPC_C_FULL_CERT_CHAIN, 
                                &server_princ_name );

  // Change the client's security: 
  // Increase the authentication level and attach a certificate.
  CoSetProxyBlanket( pSecret, RPC_C_AUTHN_GSS_SCHANNEL,
                     RPC_C_AUTHZ_NONE,
                     server_princ_name, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                     RPC_C_IMP_LEVEL_IMPERSONATE, 
                     (RPC_AUTH_IDENTITY_HANDLE *) client_cert,
                     EOAC_NONE );

  cleanup:
  if (server_princ_name != NULL)
    RpcStringFree( &server_princ_name );
  if (client_cert != NULL)
    CertFreeCertificateContext(client_cert);
  if (server_cert != NULL)
    CertFreeCertificateContext(server_cert);
  if (cert_store != NULL)
    CertCloseStore( cert_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (provider != 0 )
    CryptReleaseContext( provider, 0 );
  if (pSecret != NULL)
    pSecret->Release();
  CoUninitialize();
}
```



## <a name="related-topics"></a><span data-ttu-id="121e5-235">См. также</span><span class="sxs-lookup"><span data-stu-id="121e5-235">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="121e5-236">Пакеты безопасности и COM</span><span class="sxs-lookup"><span data-stu-id="121e5-236">COM and Security Packages</span></span>](com-and-security-packages.md)
</dt> </dl>

 

 