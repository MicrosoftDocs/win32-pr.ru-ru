---
title: Проектирование удаленных интерфейсов
description: С появлением объектной модели распределенных компонентов важно, чтобы пользовательский интерфейс был удаленно, даже если вы планируете использовать его только в процессе.
ms.assetid: 2ee4d950-dfd5-4965-bd77-a600e878be59
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3502604d62e6a5129ca3e3538761722909c0198f
ms.sourcegitcommit: 85688bbfbe5b121bc05ddf112d54c23a469dfbc0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2020
ms.locfileid: "103890187"
---
# <a name="designing-remotable-interfaces"></a><span data-ttu-id="2aec0-103">Проектирование удаленных интерфейсов</span><span class="sxs-lookup"><span data-stu-id="2aec0-103">Designing Remotable Interfaces</span></span>

<span data-ttu-id="2aec0-104">С появлением объектной модели распределенных компонентов важно, чтобы пользовательский интерфейс был удаленно, даже если вы планируете использовать его только в процессе.</span><span class="sxs-lookup"><span data-stu-id="2aec0-104">With the advent of the distributed component object model, it is important that your custom interface be remotable, even if you intend to use it in-process only.</span></span>

<span data-ttu-id="2aec0-105">MIDL — это не просто способ создания файлов заголовков для интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="2aec0-105">MIDL is more than just a way to generate header files for your interfaces.</span></span> <span data-ttu-id="2aec0-106">Это язык программирования для удаленного взаимодействия, который позволяет использовать интерфейсы в границах компьютера, процесса и потока.</span><span class="sxs-lookup"><span data-stu-id="2aec0-106">It is a programming language for remoting that allows you to use your interfaces across machine, process, and thread boundaries.</span></span> <span data-ttu-id="2aec0-107">Это означает, что необходимо проверить поведение интерфейсов, определяемых MIDL, в этих условиях до выпуска программы для клиентов.</span><span class="sxs-lookup"><span data-stu-id="2aec0-107">This means that you need to verify the behavior of your MIDL-defined interfaces under those conditions before you release your program to customers.</span></span> <span data-ttu-id="2aec0-108">Если в IDL была допущена ошибка, а интерфейс не удален должным образом, может быть трудно устранить эту ошибку.</span><span class="sxs-lookup"><span data-stu-id="2aec0-108">If you made a mistake in your IDL and the interface is not remoted correctly, it can be difficult to remedy that mistake.</span></span> <span data-ttu-id="2aec0-109">Необходимо изменить интерфейс с помощью нового идентификатора IID и оставить старый в для обеспечения обратной совместимости или преобразовать все клиентские и все серверные компьютеры в одно и то же время.</span><span class="sxs-lookup"><span data-stu-id="2aec0-109">Either you have to revise your interface with a new IID and leave the old one in for backward compatibility or you have to convert every client and every server machine everywhere at the same time.</span></span>

<span data-ttu-id="2aec0-110">Даже если ваш интерфейс никогда не будет использоваться вне процесса, он может использоваться в разных потоках.</span><span class="sxs-lookup"><span data-stu-id="2aec0-110">Even if your interface will never be used out-of-process, it may be used cross-thread.</span></span> <span data-ttu-id="2aec0-111">Наихудшая проблема для непроверенного IDL-файла может возникнуть для внутрипроцессного сервера, которые не поддерживают несколько [однопотоковых подразделения](single-threaded-apartments.md).</span><span class="sxs-lookup"><span data-stu-id="2aec0-111">The worst problem for an unchecked IDL file can arise for in-process servers that do not support multiple [single-threaded apartments](single-threaded-apartments.md)).</span></span> <span data-ttu-id="2aec0-112">Сервер, не указывающий потоковую модель, неявно является однопотоковым.</span><span class="sxs-lookup"><span data-stu-id="2aec0-112">A server that does not specify a threading model is implicitly single-threaded.</span></span> <span data-ttu-id="2aec0-113">Все, что отмечено как однопотоковое, передается в поток, который впервые вызвал [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize) или [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="2aec0-113">Everything marked single-threaded is forced over to the thread that first called [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize) or [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="2aec0-114">Если какой-то другой поток был активирован объектом, все интерфейсы на этом однопотоковом сервере должны быть удаленно возвращены в поток активации, что может привести к возврату РЕГДБ \_ E \_ ииднотрег в ответ на вызов [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))).</span><span class="sxs-lookup"><span data-stu-id="2aec0-114">If some other thread was the one that activated the object, all the interfaces on that single-threaded server must be remoted back to the activating thread, which can result in a return of REGDB\_E\_IIDNOTREG in response to a call to [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))).</span></span> <span data-ttu-id="2aec0-115">Если вы не можете полностью подтвердить, что интерфейс является и в процессе, и всегда будет вызываться в том же потоке, вы будете удаленно работать в течение некоторого времени.</span><span class="sxs-lookup"><span data-stu-id="2aec0-115">Unless you can absolutely assert that your interface is both in-process and always going to be called on the same thread, you will get remoted at some time.</span></span>

<span data-ttu-id="2aec0-116">Наконец, в качестве конструктора интерфейсов необходимо учитывать, как клиентские приложения будут использовать ваш интерфейс.</span><span class="sxs-lookup"><span data-stu-id="2aec0-116">Finally, as an interface designer, you need to consider how client applications will use your interface.</span></span> <span data-ttu-id="2aec0-117">Два вещи вместе определяют, будет ли интерфейс эффективно работать на границах процессов и компьютеров: Частота вызовов методов через границу интерфейса и объем данных, которые будут переданы при указанном вызове метода.</span><span class="sxs-lookup"><span data-stu-id="2aec0-117">Two things, together, determine whether an interface will be efficient across process and machine boundaries: the frequency of method calls across the interface boundary, and the amount of data to be transferred in a given method call.</span></span> <span data-ttu-id="2aec0-118">Хотя COM делает вызовы между процессами и между сетями прозрачными для программ, она не может выполнять высокочастотные вызовы с высокой пропускной способностью в адресных пространствах.</span><span class="sxs-lookup"><span data-stu-id="2aec0-118">Although COM makes cross-process and cross-network calls transparent to programs, it cannot make high-frequency and high-bandwidth calls efficient across address spaces.</span></span> <span data-ttu-id="2aec0-119">В некоторых случаях лучше разработать интерфейсы, которые обычно реализуются только как внутрипроцессный сервер, в то время как другие интерфейсы более подходят для удаленного использования.</span><span class="sxs-lookup"><span data-stu-id="2aec0-119">In some cases, it is more appropriate to design interfaces that will normally be implemented only as in-process servers while other interfaces are more appropriate for remote use.</span></span>

 

 




