---
title: Single-Threaded подразделения
description: Single-Threaded подразделения
ms.assetid: 2f345ae2-8314-4067-a6d6-5a0275941ed4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0f0a8cb1422b6866d9e0d043fdd46c895e6d335b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104413808"
---
# <a name="single-threaded-apartments"></a><span data-ttu-id="80001-103">Single-Threaded подразделения</span><span class="sxs-lookup"><span data-stu-id="80001-103">Single-Threaded Apartments</span></span>

<span data-ttu-id="80001-104">Использование однопотоковых апартаментов (процесс модели апартамента) предоставляет парадигму на основе сообщений для работы с несколькими объектами, выполняющимися одновременно.</span><span class="sxs-lookup"><span data-stu-id="80001-104">Using single-threaded apartments (the apartment model process) offers a message-based paradigm for dealing with multiple objects running concurrently.</span></span> <span data-ttu-id="80001-105">Он позволяет писать более эффективный код, разрешая поток, ожидая выполнения некоторой длительной операции, чтобы разрешить выполнение другого потока.</span><span class="sxs-lookup"><span data-stu-id="80001-105">It enables you to write more efficient code by allowing a thread, while it waits for some time-consuming operation to complete, to allow another thread to be executed.</span></span>

<span data-ttu-id="80001-106">Каждый поток в процессе, который инициализируется как процесс модели апартамента и извлекает и отправляет сообщения окна, является однопотоковым апартаментным потоком.</span><span class="sxs-lookup"><span data-stu-id="80001-106">Each thread in a process that is initialized as an apartment model process, and that retrieves and dispatches window messages, is a single-threaded apartment thread.</span></span> <span data-ttu-id="80001-107">Каждый поток находится в собственном апартаменте.</span><span class="sxs-lookup"><span data-stu-id="80001-107">Each thread lives within its own apartment.</span></span> <span data-ttu-id="80001-108">В подразделении указатели интерфейса могут передаваться без маршалирования, поэтому все объекты в одном потоковом апартаменте взаимодействуют напрямую.</span><span class="sxs-lookup"><span data-stu-id="80001-108">Within an apartment, interface pointers can be passed without marshaling, and therefore, all objects in one single-threaded apartment thread communicate directly.</span></span>

<span data-ttu-id="80001-109">Логическая группировка связанных объектов, которые выполняются в одном и том же потоке и поэтому должны иметь синхронное выполнение, может находиться в одном потоке апартамента с одним потоком.</span><span class="sxs-lookup"><span data-stu-id="80001-109">A logical grouping of related objects that all execute on the same thread, and therefore must have synchronous execution, could live on the same single-threaded apartment thread.</span></span> <span data-ttu-id="80001-110">Однако объект модели подразделения не может находиться в более чем одном потоке.</span><span class="sxs-lookup"><span data-stu-id="80001-110">However, an apartment model object cannot reside on more than one thread.</span></span> <span data-ttu-id="80001-111">Вызовы объектов в других потоках должны выполняться в контексте потока-владельца, поэтому распределенные потоки COM переключаются автоматически при вызове на прокси-сервере.</span><span class="sxs-lookup"><span data-stu-id="80001-111">Calls to objects in other threads must be made within the context of the owning thread, so distributed COM switches threads for you automatically when you call on a proxy.</span></span>

<span data-ttu-id="80001-112">Межпроцессные и многопоточные модели похожи.</span><span class="sxs-lookup"><span data-stu-id="80001-112">The interprocess and interthread models are similar.</span></span> <span data-ttu-id="80001-113">Когда необходимо передать указатель интерфейса в объект в другом контейнере (в другом потоке) в рамках одного процесса, используется та же модель, что и объекты в разных процессах для передачи указателей между границами процесса.</span><span class="sxs-lookup"><span data-stu-id="80001-113">When it is necessary to pass an interface pointer to an object in another apartment (on another thread) within the same process, you use the same marshaling model that objects in different processes use to pass pointers across process boundaries.</span></span> <span data-ttu-id="80001-114">Получив указатель на стандартный объект маршалирования, можно маршалировать указатели на интерфейсы между границами потоков (между апартаментами) точно так же, как и между процессами.</span><span class="sxs-lookup"><span data-stu-id="80001-114">By getting a pointer to the standard marshaling object, you can marshal interface pointers across thread boundaries (between apartments) in the same way you do between processes.</span></span> <span data-ttu-id="80001-115">(При передаче между апартаментами должны быть маршалированы указатели интерфейса.)</span><span class="sxs-lookup"><span data-stu-id="80001-115">(Interface pointers must be marshaled when passed between apartments.)</span></span>

<span data-ttu-id="80001-116">Правила для однопотоковых подразделения просты, но важно тщательно проследить их:</span><span class="sxs-lookup"><span data-stu-id="80001-116">Rules for single-threaded apartments are simple, but it is important to follow them carefully:</span></span>

-   <span data-ttu-id="80001-117">Каждый объект должен находиться в одном потоке (в однопотоковом подразделении).</span><span class="sxs-lookup"><span data-stu-id="80001-117">Every object should live on only one thread (within a single-threaded apartment).</span></span>
-   <span data-ttu-id="80001-118">Инициализируйте библиотеку COM для каждого потока.</span><span class="sxs-lookup"><span data-stu-id="80001-118">Initialize the COM library for each thread.</span></span>
-   <span data-ttu-id="80001-119">Маршалирует все указатели на объекты при передаче их между апартаментами.</span><span class="sxs-lookup"><span data-stu-id="80001-119">Marshal all pointers to objects when passing them between apartments.</span></span>
-   <span data-ttu-id="80001-120">Каждый однопотоковый апартамент должен иметь цикл сообщений для обработки вызовов из других процессов и подразделений в рамках одного процесса.</span><span class="sxs-lookup"><span data-stu-id="80001-120">Each single-threaded apartment must have a message loop to handle calls from other processes and apartments within the same process.</span></span> <span data-ttu-id="80001-121">Для однопотоковых апартаментов без объектов (только для клиента) также необходим цикл обработки сообщений для отправки широковещательных сообщений, используемых некоторыми приложениями.</span><span class="sxs-lookup"><span data-stu-id="80001-121">Single-threaded apartments without objects (client only) also need a message loop to dispatch the broadcast messages that some applications use.</span></span>
-   <span data-ttu-id="80001-122">Основанные на библиотеке DLL или внутрипроцессный объекты не вызывают функции инициализации COM; Вместо этого они регистрируют свою потоковую модель с **ThreadingModel** именованным значением в разделе [InprocServer32](inprocserver32.md) реестра.</span><span class="sxs-lookup"><span data-stu-id="80001-122">DLL-based or in-process objects do not call the COM initialization functions; instead, they register their threading model with the **ThreadingModel** named-value under the [InprocServer32](inprocserver32.md) key in the registry.</span></span> <span data-ttu-id="80001-123">Объекты, поддерживающие подразделение, также должны тщательно записывать точки входа библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="80001-123">Apartment-aware objects must also write DLL entry points carefully.</span></span> <span data-ttu-id="80001-124">Существуют особые соображения, которые применяются к потокам внутрипроцессного сервера.</span><span class="sxs-lookup"><span data-stu-id="80001-124">There are special considerations that apply to threading in-process servers.</span></span> <span data-ttu-id="80001-125">Дополнительные сведения см. [в разделе проблемы потоковой обработки на сервере](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="80001-125">For more information, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="80001-126">Хотя несколько объектов могут находиться в одном потоке, ни один объект модели апартамента не может находиться в нескольких потоках.</span><span class="sxs-lookup"><span data-stu-id="80001-126">While multiple objects can live on a single thread, no apartment model object can live on more than one thread.</span></span>

<span data-ttu-id="80001-127">Каждый поток клиентского процесса или сервера вне процесса должен вызывать [**Соинициализацию**](/windows/desktop/api/Objbase/nf-objbase-coinitialize)или вызывать метод [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) , а также указывать \_ апартментсреадед для параметра *двкоинит* .</span><span class="sxs-lookup"><span data-stu-id="80001-127">Each thread of a client process or out-of-process server must call [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), or call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) and specify COINIT\_APARTMENTTHREADED for the *dwCoInit* parameter.</span></span> <span data-ttu-id="80001-128">Основной апартамент — это поток, который сначала вызывает **CoInitializeEx** .</span><span class="sxs-lookup"><span data-stu-id="80001-128">The main apartment is the thread that calls **CoInitializeEx** first.</span></span> <span data-ttu-id="80001-129">Сведения о внутрипроцессного серверах см. [в статье проблемы потоковой обработки в процессе сервера](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="80001-129">For information on in-process servers, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="80001-130">Все вызовы объекта должны выполняться в своем потоке (в его апартаменте).</span><span class="sxs-lookup"><span data-stu-id="80001-130">All calls to an object must be made on its thread (within its apartment).</span></span> <span data-ttu-id="80001-131">Нельзя вызывать объект непосредственно из другого потока; использование объектов в этом свободно-потоковом режиме может привести к проблемам с приложениями.</span><span class="sxs-lookup"><span data-stu-id="80001-131">It is forbidden to call an object directly from another thread; using objects in this free-threaded manner could cause problems for applications.</span></span> <span data-ttu-id="80001-132">Следствием этого правила является то, что все указатели на объекты должны быть упакованы при передаче между апартаментами.</span><span class="sxs-lookup"><span data-stu-id="80001-132">The implication of this rule is that all pointers to objects must be marshaled when passed between apartments.</span></span> <span data-ttu-id="80001-133">Для этой цели COM предоставляет следующие две функции:</span><span class="sxs-lookup"><span data-stu-id="80001-133">COM provides the following two functions for this purpose:</span></span>

-   <span data-ttu-id="80001-134">[**Комаршалинтерсреадинтерфацеинстреам**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) маршалирует интерфейс в объект потока, который возвращается вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="80001-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) marshals an interface into a stream object that is returned to the caller.</span></span>
-   <span data-ttu-id="80001-135">[**Кожетинтерфацеандрелеасестреам**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) отменяет упаковку указателя интерфейса из объекта потока и освобождает его.</span><span class="sxs-lookup"><span data-stu-id="80001-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) unmarshals an interface pointer from a stream object and releases it.</span></span>

<span data-ttu-id="80001-136">Эти функции заключают вызовы в функции [**комаршалинтерфаце**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) и [**каунмаршалинтерфаце**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) , требующие использования \_ флага мшкткс INPROC.</span><span class="sxs-lookup"><span data-stu-id="80001-136">These functions wrap calls to [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) and [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) functions, which require the use of the MSHCTX\_INPROC flag.</span></span>

<span data-ttu-id="80001-137">Как правило, маршалирование выполняется автоматически с помощью COM.</span><span class="sxs-lookup"><span data-stu-id="80001-137">In general, the marshaling is accomplished automatically by COM.</span></span> <span data-ttu-id="80001-138">Например, при передаче указателя интерфейса в качестве параметра в вызове метода на прокси-сервере в объект в другом апартаменте или при вызове [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), com выполняет упаковку автоматически.</span><span class="sxs-lookup"><span data-stu-id="80001-138">For example, when passing an interface pointer as a parameter in a method call on a proxy to an object in another apartment, or when calling [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), COM does the marshaling automatically.</span></span> <span data-ttu-id="80001-139">Однако в некоторых особых случаях, когда модуль записи приложения передает указатели интерфейса между апартаментами без использования обычных механизмов COM, модуль записи должен обработать упаковку вручную.</span><span class="sxs-lookup"><span data-stu-id="80001-139">However, in some special cases, where the application writer is passing interface pointers between apartments without using the normal COM mechanisms, the writer must handle the marshaling manually.</span></span>

<span data-ttu-id="80001-140">Если одно подразделение (апартамент 1) в процессе имеет указатель интерфейса и другое подразделение (апартамент 2), то Апартамент 1 должен вызвать [**комаршалинтерсреадинтерфацеинстреам**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) для маршалирования интерфейса.</span><span class="sxs-lookup"><span data-stu-id="80001-140">If one apartment (Apartment 1) in a process has an interface pointer and another apartment (Apartment 2) requires its use, Apartment 1 must call [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) to marshal the interface.</span></span> <span data-ttu-id="80001-141">Поток, созданный этой функцией, является потокобезопасным и должен храниться в переменной, доступной для подразделения 2.</span><span class="sxs-lookup"><span data-stu-id="80001-141">The stream that is created by this function is thread-safe and must be stored in a variable that is accessible by Apartment 2.</span></span> <span data-ttu-id="80001-142">Апартамент 2 должен передать этот поток в [**кожетинтерфацеандрелеасестреам**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) для распаковки интерфейса и получить указатель на прокси-сервер, через который он может получить доступ к интерфейсу.</span><span class="sxs-lookup"><span data-stu-id="80001-142">Apartment 2 must pass this stream to [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) to unmarshal the interface and will get back a pointer to a proxy through which it can access the interface.</span></span> <span data-ttu-id="80001-143">Главный апартамент должен оставаться активным до тех пор, пока клиент не завершит все COM-операции (так как некоторые внутрипроцессный объекты загружаются в основном апартаменте, как описано в статье [проблемы с потоковым сервером обработки](in-process-server-threading-issues.md)).</span><span class="sxs-lookup"><span data-stu-id="80001-143">The main apartment must remain alive until the client has completed all COM work (because some in-process objects are loaded in the main apartment, as described in [In-Process Server Threading Issues](in-process-server-threading-issues.md)).</span></span> <span data-ttu-id="80001-144">После того как один объект передается между потоками таким образом, очень просто передавать указатели интерфейса в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="80001-144">After one object has been passed between threads in this manner, it is very easy to pass interface pointers as parameters.</span></span> <span data-ttu-id="80001-145">Таким образом, распределенная модель COM выполняет упаковку и переключение потоков для приложения.</span><span class="sxs-lookup"><span data-stu-id="80001-145">That way, distributed COM does the marshaling and thread switching for the application.</span></span>

<span data-ttu-id="80001-146">Для обработки вызовов из других процессов и подразделений в рамках одного процесса каждый однопотоковый апартамент должен иметь цикл обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="80001-146">To handle calls from other processes and apartments within the same process, each single-threaded apartment must have a message loop.</span></span> <span data-ttu-id="80001-147">Это означает, что Рабочая функция потока должна иметь цикл DispatchMessage/Message.</span><span class="sxs-lookup"><span data-stu-id="80001-147">This means that the thread's work function must have a GetMessage/DispatchMessage loop.</span></span> <span data-ttu-id="80001-148">Если для обмена данными между потоками используются другие примитивы синхронизации, функция [**мсгваитформултиплеобжектс**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) может использоваться для ожидания как для сообщений, так и для событий синхронизации потоков.</span><span class="sxs-lookup"><span data-stu-id="80001-148">If other synchronization primitives are being used to communicate between threads, the [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) function can be used to wait both for messages and for thread synchronization events.</span></span> <span data-ttu-id="80001-149">В документации по этой функции есть пример такого цикла комбинирования.</span><span class="sxs-lookup"><span data-stu-id="80001-149">The documentation for this function has an example of this sort of combination loop.</span></span>

<span data-ttu-id="80001-150">COM создает скрытое окно, используя класс Windows "Олемаинсреадвндкласс" в каждом однопотоковом подразделении.</span><span class="sxs-lookup"><span data-stu-id="80001-150">COM creates a hidden window using the Windows class "OleMainThreadWndClass" in each single-threaded apartment.</span></span> <span data-ttu-id="80001-151">Вызов объекта получается как сообщение окна в скрытое окно.</span><span class="sxs-lookup"><span data-stu-id="80001-151">A call to an object is received as a window message to this hidden window.</span></span> <span data-ttu-id="80001-152">Когда апартамент объекта получает и отправляет сообщение, оно получит скрытое окно.</span><span class="sxs-lookup"><span data-stu-id="80001-152">When the object's apartment retrieves and dispatches the message, the hidden window will receive it.</span></span> <span data-ttu-id="80001-153">Затем процедура окна будет вызывать соответствующий метод интерфейса объекта.</span><span class="sxs-lookup"><span data-stu-id="80001-153">The window procedure will then call the corresponding interface method of the object.</span></span>

<span data-ttu-id="80001-154">Когда несколько клиентов вызывают объект, вызовы помещаются в очередь сообщений, а объект получит вызов каждый раз, когда его апартамент извлекает и отправляет сообщения.</span><span class="sxs-lookup"><span data-stu-id="80001-154">When multiple clients call an object, the calls are queued in the message queue and the object will receive a call each time its apartment retrieves and dispatches messages.</span></span> <span data-ttu-id="80001-155">Поскольку вызовы синхронизированы COM и вызовы всегда доставляются потоком, который принадлежит подразделению объекта, реализации интерфейса объекта не должны обеспечивать синхронизацию.</span><span class="sxs-lookup"><span data-stu-id="80001-155">Because the calls are synchronized by COM and the calls are always delivered by the thread that belongs to the object's apartment, the object's interface implementations need not provide synchronization.</span></span> <span data-ttu-id="80001-156">Однопотоковые подразделения могут реализовать [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) , чтобы позволить им отменять вызовы или принимать сообщения окна при необходимости.</span><span class="sxs-lookup"><span data-stu-id="80001-156">Single-threaded apartments can implement [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) to permit them to cancel calls or receive window messages when necessary.</span></span>

<span data-ttu-id="80001-157">Объект может быть повторно введен, если одна из его реализаций метода интерфейса извлекает и отправляет сообщения или выполняет вызов ОРПК другому потоку, тем самым вызывая другой вызов, который доставляется объекту (в том же апартаменте).</span><span class="sxs-lookup"><span data-stu-id="80001-157">The object can be reentered if one of its interface method implementations retrieves and dispatches messages or makes an ORPC call to another thread, thereby causing another call to be delivered to the object (by the same apartment).</span></span> <span data-ttu-id="80001-158">OLE не препятствует повторному входу в том же потоке, но может способствовать обеспечению безопасности потоков.</span><span class="sxs-lookup"><span data-stu-id="80001-158">OLE does not prevent reentrancy on the same thread, but it can help provide thread safety.</span></span> <span data-ttu-id="80001-159">Это аналогично тому, как процедура окна может быть повторно введена, если она извлекает и отправляет сообщения при обработке сообщения.</span><span class="sxs-lookup"><span data-stu-id="80001-159">This is identical to the way in which a window procedure can be reentered if it retrieves and dispatches messages while processing a message.</span></span> <span data-ttu-id="80001-160">Однако вызов необработанного однопотокового подразделения сервера, который вызывает другой однопотоковый Апартаментный сервер, позволит повторно ввести первый сервер.</span><span class="sxs-lookup"><span data-stu-id="80001-160">However, calling an out-of-process single-threaded apartment server that calls another single-threaded apartment server will allow the first server to be reentered.</span></span>

## <a name="related-topics"></a><span data-ttu-id="80001-161">См. также</span><span class="sxs-lookup"><span data-stu-id="80001-161">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="80001-162">Доступ к интерфейсам в разных апартаментах</span><span class="sxs-lookup"><span data-stu-id="80001-162">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="80001-163">Выбор потоковой модели</span><span class="sxs-lookup"><span data-stu-id="80001-163">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="80001-164">Многопоточные подразделения</span><span class="sxs-lookup"><span data-stu-id="80001-164">Multithreaded Apartments</span></span>](multithreaded-apartments.md)
</dt> <dt>

[<span data-ttu-id="80001-165">Проблемы потоковой обработки в процессе сервера</span><span class="sxs-lookup"><span data-stu-id="80001-165">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="80001-166">Процессы, потоки и подразделения</span><span class="sxs-lookup"><span data-stu-id="80001-166">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="80001-167">Однопотоковое и многопоточное взаимодействие</span><span class="sxs-lookup"><span data-stu-id="80001-167">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> </dl>

 

 