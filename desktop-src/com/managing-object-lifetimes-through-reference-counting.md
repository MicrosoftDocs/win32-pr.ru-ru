---
title: Управление жизненным циклом объектов с помощью подсчета ссылок
description: Управление жизненным циклом объектов с помощью подсчета ссылок
ms.assetid: 7f9da5a9-0435-431c-8f90-56e2e489c431
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7aac184baea9198721e6cdf9c0444a8c6431db08
ms.sourcegitcommit: f0ca63c18dc52c357d3398af7be766d2bdd40be7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/17/2020
ms.locfileid: "105654273"
---
# <a name="managing-object-lifetimes-through-reference-counting"></a>Управление жизненным циклом объектов с помощью подсчета ссылок

В традиционных объектных системах, жизненный цикл объектов, то есть проблемы, связанные с созданием и удалением объектов, — обрабатывается неявно на языке (или времени выполнения языка) или явно программистами приложения.

В развивающейся и децентрализованно построенной системе, состоящую из повторно используемых компонентов, больше нет ничего в том, что любой клиент или даже любой программист всегда «знает», как справиться с жизненным циклом компонента. Для клиента с нужными привилегиями безопасности по-прежнему довольно просто создавать объекты с помощью простого запроса, но удаление объектов — это совсем другое. Не обязательно очищать, когда объект больше не нужен и должен быть удален. (Читатели, знакомые с средами программирования, собранными сборщиком мусора, например Java, могут противолагаться. Однако объекты Java не охватывают границы компьютера или даже процессов, поэтому сборка мусора ограничена объектами, которые находятся в однопроцессном пространстве. Кроме того, Java принудительно использует один язык программирования.) Даже если исходный клиент выполняется с помощью объекта, он не может просто закрыть объект, так как некоторые другие клиенты и клиент по-прежнему могут иметь ссылку на него.

Один из способов убедиться, что объект больше не нужен, — полностью зависеть от базового коммуникационного канала, чтобы уведомить систему о том, что все соединения с межпроцессным или межканальным объектом исчезли. Однако схемы, использующие этот метод, неприемлемы по нескольким причинам. Одна из проблем заключается в том, что она может потребовать значительных различий между межпроцессными и межсетевыми моделями программирования и моделью программирования с одним процессом. В модели межпроцессных и перекрестных сетей система связи предоставит обработчики, необходимые для управления жизненным циклом объектов, а в модели программирования с одним процессом объекты напрямую соединяются без какого-либо промежуточного канала связи. Другая проблема заключается в том, что эта схема также может привести к тому, что уровень предоставляемого системой программного обеспечения будет влиять на производительность компонента в процессе обработки. Кроме того, механизм, основанный на явном мониторинге, не будет увеличивать масштаб для многих тысяч или миллионов объектов.

Модель COM предлагает масштабируемый и распределенный подход к этому набору проблем. Клиенты сообщают объекту, когда они их используют и когда они выполняются, и объекты удаляют себя, когда они больше не нужны. Этот подход требует, чтобы все объекты подсчитаны сами по себе ссылки. Языки программирования, такие как Java, которые изначально имеют собственные схемы управления жизненным циклом, такие как сборка мусора, могут использовать подсчет ссылок COM для внутреннего внедрения и использования COM-объектов, что позволяет программисту избежать работы с ним.

Так же как приложение должно освободить память, выделенную после того, как память больше не используется, клиент объекта несет ответственность за освобождение ссылок на объект, если этот объект больше не нужен. В объектно-ориентированной системе Клиент может сделать это только путем предоставления объекту инструкции для освобождения самого себя.

Важно, чтобы объект был освобожден, когда он больше не используется. Сложность состоит в том, чтобы определить, когда нужно освободить объект. Это легко с помощью автоматических переменных (выделенных в стеке) — они не могут использоваться за пределами блока, в котором они объявляются, поэтому компилятор освобождает их после достижения конца блока. Для объектов COM, которые динамически выделены, для клиентов объекта необходимо решить, когда им больше не нужно использовать объект — особенно локальных или удаленных объектов, которые могут использоваться несколькими клиентами одновременно. Объект должен дождаться завершения работы всех клиентов перед тем, как он освободится. Поскольку COM-объекты обрабатываются через указатели интерфейсов и могут использоваться объектами в различных процессах или на других компьютерах, система не может отследить клиентов объекта.

Метод COM, определяющий, когда подходит для освобождения объекта, — это ручной подсчет ссылок. Каждый объект поддерживает счетчик ссылок, который отслеживает, сколько клиентов подключено к нему, т. е. Сколько указателей существует для любого из своих интерфейсов в любом клиенте.

Дополнительные сведения см. в следующих разделах:

-   [Реализация подсчета ссылок](implementing-reference-counting.md)
-   [Правила управления счетчиками ссылок](rules-for-managing-reference-counts.md)

## <a name="related-topics"></a>См. также

<dl> <dt>

[Использование и реализация IUnknown](using-and-implementing-iunknown.md)
</dt> </dl>

 

 




