---
title: Управление жизненным циклом объектов с помощью подсчета ссылок
description: Управление жизненным циклом объектов с помощью подсчета ссылок
ms.assetid: 7f9da5a9-0435-431c-8f90-56e2e489c431
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7aac184baea9198721e6cdf9c0444a8c6431db08
ms.sourcegitcommit: f0ca63c18dc52c357d3398af7be766d2bdd40be7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/17/2020
ms.locfileid: "105654273"
---
# <a name="managing-object-lifetimes-through-reference-counting"></a><span data-ttu-id="4f0fd-103">Управление жизненным циклом объектов с помощью подсчета ссылок</span><span class="sxs-lookup"><span data-stu-id="4f0fd-103">Managing Object Lifetimes Through Reference Counting</span></span>

<span data-ttu-id="4f0fd-104">В традиционных объектных системах, жизненный цикл объектов, то есть проблемы, связанные с созданием и удалением объектов, — обрабатывается неявно на языке (или времени выполнения языка) или явно программистами приложения.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-104">In traditional object systems, the life cycle of objects—that is, the issues surrounding the creation and deletion of objects—is handled implicitly by the language (or the language run time) or explicitly by application programmers.</span></span>

<span data-ttu-id="4f0fd-105">В развивающейся и децентрализованно построенной системе, состоящую из повторно используемых компонентов, больше нет ничего в том, что любой клиент или даже любой программист всегда «знает», как справиться с жизненным циклом компонента.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-105">In an evolving, decentrally constructed system made up of reused components, it is no longer true that any client, or even any programmer, always "knows" how to deal with a component's lifetime.</span></span> <span data-ttu-id="4f0fd-106">Для клиента с нужными привилегиями безопасности по-прежнему довольно просто создавать объекты с помощью простого запроса, но удаление объектов — это совсем другое.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-106">For a client with the right security privileges, it is still relatively easy to create objects through a simple request, but object deletion is another matter entirely.</span></span> <span data-ttu-id="4f0fd-107">Не обязательно очищать, когда объект больше не нужен и должен быть удален.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-107">It is not necessarily clear when an object is no longer needed and should be deleted.</span></span> <span data-ttu-id="4f0fd-108">(Читатели, знакомые с средами программирования, собранными сборщиком мусора, например Java, могут противолагаться. Однако объекты Java не охватывают границы компьютера или даже процессов, поэтому сборка мусора ограничена объектами, которые находятся в однопроцессном пространстве.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-108">(Readers familiar with garbage-collected programming environments, such as Java, may disagree; however, Java objects do not span machine or even process boundaries, and therefore the garbage collection is restricted to objects living within a single-process space.</span></span> <span data-ttu-id="4f0fd-109">Кроме того, Java принудительно использует один язык программирования.) Даже если исходный клиент выполняется с помощью объекта, он не может просто закрыть объект, так как некоторые другие клиенты и клиент по-прежнему могут иметь ссылку на него.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-109">In addition, Java forces the use of a single programming language.) Even when the original client is done with the object, it cannot simply shut the object down, because some other client or clients might still have a reference to it.</span></span>

<span data-ttu-id="4f0fd-110">Один из способов убедиться, что объект больше не нужен, — полностью зависеть от базового коммуникационного канала, чтобы уведомить систему о том, что все соединения с межпроцессным или межканальным объектом исчезли.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-110">One way to ensure that an object is no longer needed is to depend entirely on an underlying communication channel to inform the system when all connections to a cross-process or cross-channel object have disappeared.</span></span> <span data-ttu-id="4f0fd-111">Однако схемы, использующие этот метод, неприемлемы по нескольким причинам.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-111">However, schemes that use this method are unacceptable for several reasons.</span></span> <span data-ttu-id="4f0fd-112">Одна из проблем заключается в том, что она может потребовать значительных различий между межпроцессными и межсетевыми моделями программирования и моделью программирования с одним процессом.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-112">One problem is that it could require a major difference between the cross-process/cross-network programming model and the single-process programming model.</span></span> <span data-ttu-id="4f0fd-113">В модели межпроцессных и перекрестных сетей система связи предоставит обработчики, необходимые для управления жизненным циклом объектов, а в модели программирования с одним процессом объекты напрямую соединяются без какого-либо промежуточного канала связи.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-113">In the cross-process/cross-network programming model, the communication system would provide the hooks necessary for object lifetime management, while in the single-process programming model, objects are directly connected without any intervening communications channel.</span></span> <span data-ttu-id="4f0fd-114">Другая проблема заключается в том, что эта схема также может привести к тому, что уровень предоставляемого системой программного обеспечения будет влиять на производительность компонента в процессе обработки.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-114">Another problem is that this scheme could also result in a layer of system-provided software that would interfere with component performance in the in-process case.</span></span> <span data-ttu-id="4f0fd-115">Кроме того, механизм, основанный на явном мониторинге, не будет увеличивать масштаб для многих тысяч или миллионов объектов.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-115">Furthermore, a mechanism based on explicit monitoring would not tend to scale toward many thousands or millions of objects.</span></span>

<span data-ttu-id="4f0fd-116">Модель COM предлагает масштабируемый и распределенный подход к этому набору проблем.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-116">COM offers a scalable and distributed approach to this set of problems.</span></span> <span data-ttu-id="4f0fd-117">Клиенты сообщают объекту, когда они их используют и когда они выполняются, и объекты удаляют себя, когда они больше не нужны.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-117">Clients tell an object when they are using it and when they are done, and objects delete themselves when they are no longer needed.</span></span> <span data-ttu-id="4f0fd-118">Этот подход требует, чтобы все объекты подсчитаны сами по себе ссылки.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-118">This approach mandates that all objects count references to themselves.</span></span> <span data-ttu-id="4f0fd-119">Языки программирования, такие как Java, которые изначально имеют собственные схемы управления жизненным циклом, такие как сборка мусора, могут использовать подсчет ссылок COM для внутреннего внедрения и использования COM-объектов, что позволяет программисту избежать работы с ним.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-119">Programming languages such as Java, which inherently have their own lifetime management schemes, such as garbage collection, can use COM's reference counting to implement and use COM objects internally, allowing the programmer to avoid dealing with it.</span></span>

<span data-ttu-id="4f0fd-120">Так же как приложение должно освободить память, выделенную после того, как память больше не используется, клиент объекта несет ответственность за освобождение ссылок на объект, если этот объект больше не нужен.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-120">Just as an application must free memory it has allocated once that memory is no longer in use, a client of an object is responsible for freeing its references to the object when that object is no longer needed.</span></span> <span data-ttu-id="4f0fd-121">В объектно-ориентированной системе Клиент может сделать это только путем предоставления объекту инструкции для освобождения самого себя.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-121">In an object-oriented system, the client can do this only by giving the object an instruction to free itself.</span></span>

<span data-ttu-id="4f0fd-122">Важно, чтобы объект был освобожден, когда он больше не используется.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-122">It is important that an object be deallocated when it is no longer being used.</span></span> <span data-ttu-id="4f0fd-123">Сложность состоит в том, чтобы определить, когда нужно освободить объект.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-123">The difficulty lies in determining when it is appropriate to deallocate an object.</span></span> <span data-ttu-id="4f0fd-124">Это легко с помощью автоматических переменных (выделенных в стеке) — они не могут использоваться за пределами блока, в котором они объявляются, поэтому компилятор освобождает их после достижения конца блока.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-124">This is easy with automatic variables (those allocated on the stack)—they cannot be used outside the block in which they're declared, so the compiler deallocates them when the end of the block is reached.</span></span> <span data-ttu-id="4f0fd-125">Для объектов COM, которые динамически выделены, для клиентов объекта необходимо решить, когда им больше не нужно использовать объект — особенно локальных или удаленных объектов, которые могут использоваться несколькими клиентами одновременно.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-125">For COM objects, which are dynamically allocated, it is up to the clients of an object to decide when they no longer need to use the object—especially local or remote objects that might be in use by multiple clients at the same time.</span></span> <span data-ttu-id="4f0fd-126">Объект должен дождаться завершения работы всех клиентов перед тем, как он освободится.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-126">The object must wait until all clients are finished with it before freeing itself.</span></span> <span data-ttu-id="4f0fd-127">Поскольку COM-объекты обрабатываются через указатели интерфейсов и могут использоваться объектами в различных процессах или на других компьютерах, система не может отследить клиентов объекта.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-127">Because COM objects are manipulated through interface pointers and can be used by objects in different processes or on other machines, the system cannot keep track of an object's clients.</span></span>

<span data-ttu-id="4f0fd-128">Метод COM, определяющий, когда подходит для освобождения объекта, — это ручной подсчет ссылок.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-128">COM's method of determining when it is appropriate to deallocate an object is manual reference counting.</span></span> <span data-ttu-id="4f0fd-129">Каждый объект поддерживает счетчик ссылок, который отслеживает, сколько клиентов подключено к нему, т. е. Сколько указателей существует для любого из своих интерфейсов в любом клиенте.</span><span class="sxs-lookup"><span data-stu-id="4f0fd-129">Each object maintains a reference count that tracks how many clients are connected to it - that is, how many pointers exist to any of its interfaces in any client.</span></span>

<span data-ttu-id="4f0fd-130">Дополнительные сведения см. в следующих разделах:</span><span class="sxs-lookup"><span data-stu-id="4f0fd-130">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="4f0fd-131">Реализация подсчета ссылок</span><span class="sxs-lookup"><span data-stu-id="4f0fd-131">Implementing Reference Counting</span></span>](implementing-reference-counting.md)
-   [<span data-ttu-id="4f0fd-132">Правила управления счетчиками ссылок</span><span class="sxs-lookup"><span data-stu-id="4f0fd-132">Rules for Managing Reference Counts</span></span>](rules-for-managing-reference-counts.md)

## <a name="related-topics"></a><span data-ttu-id="4f0fd-133">См. также</span><span class="sxs-lookup"><span data-stu-id="4f0fd-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="4f0fd-134">Использование и реализация IUnknown</span><span class="sxs-lookup"><span data-stu-id="4f0fd-134">Using and Implementing IUnknown</span></span>](using-and-implementing-iunknown.md)
</dt> </dl>

 

 




