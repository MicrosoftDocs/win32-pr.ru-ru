---
title: Вспомогательные методы реализации сервера
description: Вспомогательные методы реализации сервера
ms.assetid: 18641a84-56f8-4d27-9ddb-fa64011ac8ba
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 264d3f26b179b3ecb659ef93785c8c223b6c524e
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104413845"
---
# <a name="out-of-process-server-implementation-helpers"></a>Вспомогательные методы реализации сервера

Для упрощения процесса написания серверного кода доступны четыре вспомогательные функции, которые могут быть вызваны необработанными серверами. COM-клиенты и серверы обработки COM, как правило, не вызывают их. Эти функции предназначены для предотвращения конкуренции при активации сервера, если серверы имеют несколько подразделения или несколько объектов класса. Однако их также можно использовать для однопотоковых и одноклассовых серверов объектов. Используются следующие функции.

-   [**коаддрефсерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess)
-   [**корелеасесерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)
-   [**косуспендклассобжектс**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects)
-   [**коресумеклассобжектс**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects)

Чтобы правильно завершить работу, сервер COM должен отследить количество экземпляров объектов, на которые он был создан, и сколько раз был вызван метод [**IClassFactory:: локксервер**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) . Завершение работы сервера может быть возможно только в том случае, если оба этих счетчика достигли нуля. В однопотоковых COM-серверах решение о завершении работы было согласовано с входящими запросами на активацию, которые были сериализованы в очереди сообщений. Сервер при получении выпуска на последнем экземпляре объекта и принятии решения о завершении работы может отозвать объекты своего класса до отправки всех запросов на активацию. Если после этого момента запрос на активацию был выполнен, COM распознает, что объекты класса были отозваны, и вернет ошибку диспетчеру управления службами (SCM), что приведет к запуску нового экземпляра локального процесса сервера.

Однако на сервере моделей подразделения, в котором разные объекты класса регистрируются в разных апартаментах, и во всех свободных потоках, это решение должно быть согласовываться с запросами на активацию в нескольких потоках, чтобы один поток сервера не решил завершить работу, пока другой поток сервера занят назначением объектов класса или экземпляров объектов. Одним классическим, но громоздким подходом к решению этой проблемы является наличие сервера после того, как он отзывает объекты класса, проверяет число экземпляров и остается активным до тех пор, пока все экземпляры не будут освобождены.

Чтобы средства записи сервера не обрабатывали такие типы состояний гонки, COM предоставляет две функции подсчета ссылок:

-   [**Коаддрефсерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) увеличивает значение глобального счетчика ссылок на процесс.
-   [**Корелеасесерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) уменьшает общее число ссылок на процесс.

Когда значение глобального счетчика ссылок на процесс достигает нуля, COM автоматически вызывает [**косуспендклассобжектс**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), что предотвращает появление новых запросов на активацию. После этого сервер может отменить регистрацию различных объектов класса из различных потоков в свободное время, не заботясь о том, что может поступать другой запрос на активацию. Все новые запросы на активацию являются исходя этого, обрабатываемыми SCM, запускающим новый экземпляр локального процесса сервера.

Самый простой способ использовать эти функции в локальном серверном приложении заключается в вызове [**коаддрефсерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) в конструкторе для каждого из объектов экземпляров и в каждом из методов [**IClassFactory:: локксервер**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) , если параметр *флокк* имеет **значение true**. Серверное приложение также должно вызывать [**корелеасесерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) в деструкторе каждого из объектов экземпляров и в каждом из его методов IClassFactory::**локксервер** , если параметр *флокк* имеет **значение false**.

Наконец, серверное приложение должно обратить внимание на код возврата из [**корелеасесерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess), и, если он возвращает 0, серверное приложение должно инициировать свою очистку, что для сервера с несколькими потоками обычно означает, что он должен сообщить различным потокам завершить циклы сообщений и вызвать [**коаддрефсерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) и [**корелеасесерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess). Если используются функции управления жизненным циклом серверного процесса, они должны использоваться как в экземплярах объектов, так и в методе [**локксервер**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) . в противном случае серверное приложение может завершить работу преждевременно.

Когда выполняется запрос [**кожетклассобжект**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) , com связывается с сервером, маршалирует интерфейс [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) объекта класса, возвращает в клиентский процесс, демаршалирует интерфейс **IClassFactory** и возвращает его клиенту. На этом этапе клиенты обычно вызывают [**локксервер**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) со значением **true** , чтобы предотвратить завершение работы серверного процесса. Однако существует период времени между упаковкой объекта класса и тем, когда клиент вызывает **локксервер** , в котором другой клиент может подключиться к тому же серверу, получить экземпляр и освободить этот экземпляр, тем самым вызывая завершение работы сервера и оставляя первый клиент высоким и сухой с отключенным указателем **IClassFactory** . Чтобы предотвратить такое состояние гонки, COM добавляет неявный вызов **локксервер** с **true** в объект класса при маршалировании интерфейса **IClassFactory** и неявный вызов **локксервер** со значением **false** , когда клиент освобождает интерфейс **IClassFactory** . Таким образом, удаленные вызовы **локксервер** обратно на сервер, а прокси для **локксервер** просто возвращают " \_ ОК" без фактического удаленного взаимодействия вызова.

При инициализации внешнего процесса сервера существует еще одно состояние гонки, связанное с активацией. COM-сервер, регистрирующий несколько классов, обычно вызывает [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) с регклс \_ Local \_ Server для каждого идентификатора CLSID, который он поддерживает. После того, как это сделано для всех классов, сервер вводит цикл обработки сообщений. Для однопотокового COM-сервера все запросы на активацию блокируются до тех пор, пока сервер не войдет в цикл обработки сообщений. Однако для сервера модели подразделения, который регистрирует различные объекты класса в разных апартаментах и для всех свободных потоков серверов, запросы на активацию могут поступать раньше этого. В случае серверов апартаментных моделей запросы на активацию могут поступать, как только один поток пойдет в цикл обработки сообщений. В случае с свободными потоками серверов запрос на активацию может поступать сразу после регистрации первого объекта класса. Так как активация может быть выполнена раньше, также возможна ситуация, когда окончательный выпуск будет выполняться (и, следовательно, заставить сервер завершить работу) до того, как остальная часть сервера завершит инициализацию.

Чтобы исключить эти состояния гонки и упростить задание модуля записи сервера, любой сервер, желающий зарегистрировать несколько объектов класса с помощью COM, должен вызвать [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) с регклс \_ Local \_ Server \| регклс \_ , который был приостановлен для каждого другого идентификатора CLSID, поддерживаемого сервером. После того как все классы зарегистрированы и серверный процесс готов принять входящие запросы на активацию, сервер должен выполнить один вызов к [**коресумеклассобжектс**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects). Эта функция сообщает SCM о всех зарегистрированных классах и начинает обработку запросов на активацию в серверном процессе. Использование этих функций обеспечивает следующие преимущества.

-   В SCM выполняется только один вызов, независимо от количества зарегистрированных идентификаторов CLSID, что снижает общее время регистрации (и, следовательно, время запуска серверного приложения).
-   Если сервер имеет несколько апартаментов и разные идентификаторы CLSID зарегистрированы в разных подразделениях или если сервер является свободным потоком сервера, то запросы на активацию не будут приходить до тех пор, пока сервер не вызовет [**коресумеклассобжектс**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), предоставляя серверу возможность регистрировать все свои идентификаторы CLSID и правильно настраиваться, прежде чем выполнять запросы на активацию и возобновление работы запросов.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Обязанности сервера COM](com-server-responsibilities.md)
</dt> </dl>

 

 