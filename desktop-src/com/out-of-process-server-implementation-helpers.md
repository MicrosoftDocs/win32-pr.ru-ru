---
title: Вспомогательные методы реализации сервера
description: Вспомогательные методы реализации сервера
ms.assetid: 18641a84-56f8-4d27-9ddb-fa64011ac8ba
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 264d3f26b179b3ecb659ef93785c8c223b6c524e
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104413845"
---
# <a name="out-of-process-server-implementation-helpers"></a><span data-ttu-id="604b2-103">Вспомогательные методы реализации сервера</span><span class="sxs-lookup"><span data-stu-id="604b2-103">Out-of-Process Server Implementation Helpers</span></span>

<span data-ttu-id="604b2-104">Для упрощения процесса написания серверного кода доступны четыре вспомогательные функции, которые могут быть вызваны необработанными серверами.</span><span class="sxs-lookup"><span data-stu-id="604b2-104">Four helper functions that can be called by out-of-process servers are available to simplify the job of writing server code.</span></span> <span data-ttu-id="604b2-105">COM-клиенты и серверы обработки COM, как правило, не вызывают их.</span><span class="sxs-lookup"><span data-stu-id="604b2-105">COM clients and COM in-process servers typically would not call them.</span></span> <span data-ttu-id="604b2-106">Эти функции предназначены для предотвращения конкуренции при активации сервера, если серверы имеют несколько подразделения или несколько объектов класса.</span><span class="sxs-lookup"><span data-stu-id="604b2-106">These functions are designed to help prevent race conditions in server activation when the servers have multiple apartments or multiple class objects.</span></span> <span data-ttu-id="604b2-107">Однако их также можно использовать для однопотоковых и одноклассовых серверов объектов.</span><span class="sxs-lookup"><span data-stu-id="604b2-107">They can also, however, as easily be used for single-threaded and single class object servers.</span></span> <span data-ttu-id="604b2-108">Используются следующие функции.</span><span class="sxs-lookup"><span data-stu-id="604b2-108">The functions are as follows:</span></span>

-   [<span data-ttu-id="604b2-109">**коаддрефсерверпроцесс**</span><span class="sxs-lookup"><span data-stu-id="604b2-109">**CoAddRefServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess)
-   [<span data-ttu-id="604b2-110">**корелеасесерверпроцесс**</span><span class="sxs-lookup"><span data-stu-id="604b2-110">**CoReleaseServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)
-   [<span data-ttu-id="604b2-111">**косуспендклассобжектс**</span><span class="sxs-lookup"><span data-stu-id="604b2-111">**CoSuspendClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects)
-   [<span data-ttu-id="604b2-112">**коресумеклассобжектс**</span><span class="sxs-lookup"><span data-stu-id="604b2-112">**CoResumeClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects)

<span data-ttu-id="604b2-113">Чтобы правильно завершить работу, сервер COM должен отследить количество экземпляров объектов, на которые он был создан, и сколько раз был вызван метод [**IClassFactory:: локксервер**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) .</span><span class="sxs-lookup"><span data-stu-id="604b2-113">To shut down properly, a COM server must keep track of how many object instances it has instantiated and how many times its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method has been called.</span></span> <span data-ttu-id="604b2-114">Завершение работы сервера может быть возможно только в том случае, если оба этих счетчика достигли нуля.</span><span class="sxs-lookup"><span data-stu-id="604b2-114">Only when both of these counts reach zero can a server shut down.</span></span> <span data-ttu-id="604b2-115">В однопотоковых COM-серверах решение о завершении работы было согласовано с входящими запросами на активацию, которые были сериализованы в очереди сообщений.</span><span class="sxs-lookup"><span data-stu-id="604b2-115">In single-threaded COM servers, the decision to shut down was coordinated with incoming activation requests, which were serialized by the message queue.</span></span> <span data-ttu-id="604b2-116">Сервер при получении выпуска на последнем экземпляре объекта и принятии решения о завершении работы может отозвать объекты своего класса до отправки всех запросов на активацию.</span><span class="sxs-lookup"><span data-stu-id="604b2-116">The server, upon receiving a release on its final object instance and deciding to shut down, would revoke its class objects before any more activation requests were dispatched.</span></span> <span data-ttu-id="604b2-117">Если после этого момента запрос на активацию был выполнен, COM распознает, что объекты класса были отозваны, и вернет ошибку диспетчеру управления службами (SCM), что приведет к запуску нового экземпляра локального процесса сервера.</span><span class="sxs-lookup"><span data-stu-id="604b2-117">If an activation request did come in after this point, COM would recognize that the class objects were revoked and would return an error to the Service Control Manager (SCM), which would then cause a new instance of the local server process to be run.</span></span>

<span data-ttu-id="604b2-118">Однако на сервере моделей подразделения, в котором разные объекты класса регистрируются в разных апартаментах, и во всех свободных потоках, это решение должно быть согласовываться с запросами на активацию в нескольких потоках, чтобы один поток сервера не решил завершить работу, пока другой поток сервера занят назначением объектов класса или экземпляров объектов.</span><span class="sxs-lookup"><span data-stu-id="604b2-118">However, in an apartment model server, in which different class objects are registered on different apartments, and in all free-threaded servers, this decision to shut down must be coordinated with activation requests across multiple threads so that one thread of the server does not decide to shut down while another thread of the server is busy handing out class objects or object instances.</span></span> <span data-ttu-id="604b2-119">Одним классическим, но громоздким подходом к решению этой проблемы является наличие сервера после того, как он отзывает объекты класса, проверяет число экземпляров и остается активным до тех пор, пока все экземпляры не будут освобождены.</span><span class="sxs-lookup"><span data-stu-id="604b2-119">One classical but cumbersome approach to solving this is to have the server, after it has revoked its class objects, recheck its instance count and stay alive until all instances have been released.</span></span>

<span data-ttu-id="604b2-120">Чтобы средства записи сервера не обрабатывали такие типы состояний гонки, COM предоставляет две функции подсчета ссылок:</span><span class="sxs-lookup"><span data-stu-id="604b2-120">To make it easier for server writers to handle these types of race conditions, COM provides two reference counting functions:</span></span>

-   <span data-ttu-id="604b2-121">[**Коаддрефсерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) увеличивает значение глобального счетчика ссылок на процесс.</span><span class="sxs-lookup"><span data-stu-id="604b2-121">[**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) increments a global per-process reference count.</span></span>
-   <span data-ttu-id="604b2-122">[**Корелеасесерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) уменьшает общее число ссылок на процесс.</span><span class="sxs-lookup"><span data-stu-id="604b2-122">[**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) decrements the global per-process reference count.</span></span>

<span data-ttu-id="604b2-123">Когда значение глобального счетчика ссылок на процесс достигает нуля, COM автоматически вызывает [**косуспендклассобжектс**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), что предотвращает появление новых запросов на активацию.</span><span class="sxs-lookup"><span data-stu-id="604b2-123">When the global per-process reference count reaches zero, COM automatically calls [**CoSuspendClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), which prevents any new activation requests from coming in.</span></span> <span data-ttu-id="604b2-124">После этого сервер может отменить регистрацию различных объектов класса из различных потоков в свободное время, не заботясь о том, что может поступать другой запрос на активацию.</span><span class="sxs-lookup"><span data-stu-id="604b2-124">The server can then deregister its various class objects from its various threads at leisure without worry that another activation request may come in.</span></span> <span data-ttu-id="604b2-125">Все новые запросы на активацию являются исходя этого, обрабатываемыми SCM, запускающим новый экземпляр локального процесса сервера.</span><span class="sxs-lookup"><span data-stu-id="604b2-125">All new activation requests are henceforth handled by the SCM launching a new instance of the local server process.</span></span>

<span data-ttu-id="604b2-126">Самый простой способ использовать эти функции в локальном серверном приложении заключается в вызове [**коаддрефсерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) в конструкторе для каждого из объектов экземпляров и в каждом из методов [**IClassFactory:: локксервер**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) , если параметр *флокк* имеет **значение true**.</span><span class="sxs-lookup"><span data-stu-id="604b2-126">The simplest way for a local server application to make use of these functions is to call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) in the constructor for each of its instance objects and in each of its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) methods when the *fLock* parameter is **TRUE**.</span></span> <span data-ttu-id="604b2-127">Серверное приложение также должно вызывать [**корелеасесерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) в деструкторе каждого из объектов экземпляров и в каждом из его методов IClassFactory::**локксервер** , если параметр *флокк* имеет **значение false**.</span><span class="sxs-lookup"><span data-stu-id="604b2-127">The server application should also call [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) in the destructor of each of its instance objects and in each of its IClassFactory::**LockServer** methods when the *fLock* parameter is **FALSE**.</span></span>

<span data-ttu-id="604b2-128">Наконец, серверное приложение должно обратить внимание на код возврата из [**корелеасесерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess), и, если он возвращает 0, серверное приложение должно инициировать свою очистку, что для сервера с несколькими потоками обычно означает, что он должен сообщить различным потокам завершить циклы сообщений и вызвать [**коаддрефсерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) и [**корелеасесерверпроцесс**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span><span class="sxs-lookup"><span data-stu-id="604b2-128">Finally, the server application should pay attention to the return code from [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess), and if it returns 0, the server application should initiate its cleanup, which, for a server with multiple threads, typically means that it should signal its various threads to exit their message loops and call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) and [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span></span> <span data-ttu-id="604b2-129">Если используются функции управления жизненным циклом серверного процесса, они должны использоваться как в экземплярах объектов, так и в методе [**локксервер**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) . в противном случае серверное приложение может завершить работу преждевременно.</span><span class="sxs-lookup"><span data-stu-id="604b2-129">If the server process lifetime management functions are used, they must be used in both the object instances and the [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method; otherwise, the server application may be shut down prematurely.</span></span>

<span data-ttu-id="604b2-130">Когда выполняется запрос [**кожетклассобжект**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) , com связывается с сервером, маршалирует интерфейс [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) объекта класса, возвращает в клиентский процесс, демаршалирует интерфейс **IClassFactory** и возвращает его клиенту.</span><span class="sxs-lookup"><span data-stu-id="604b2-130">When a [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) request is made, COM contacts the server, marshals the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface of the class object, returns to the client process, unmarshals the **IClassFactory** interface, and returns this to the client.</span></span> <span data-ttu-id="604b2-131">На этом этапе клиенты обычно вызывают [**локксервер**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) со значением **true** , чтобы предотвратить завершение работы серверного процесса.</span><span class="sxs-lookup"><span data-stu-id="604b2-131">At this point, clients typically call [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) with **TRUE** to prevent the server process from shutting down.</span></span> <span data-ttu-id="604b2-132">Однако существует период времени между упаковкой объекта класса и тем, когда клиент вызывает **локксервер** , в котором другой клиент может подключиться к тому же серверу, получить экземпляр и освободить этот экземпляр, тем самым вызывая завершение работы сервера и оставляя первый клиент высоким и сухой с отключенным указателем **IClassFactory** .</span><span class="sxs-lookup"><span data-stu-id="604b2-132">However, there is a window of time between when the class object is marshaled and when the client calls **LockServer** in which another client could connect to the same server, get an instance, and release that instance, thus causing the server to shut down and leaving the first client high and dry with a disconnected **IClassFactory** pointer.</span></span> <span data-ttu-id="604b2-133">Чтобы предотвратить такое состояние гонки, COM добавляет неявный вызов **локксервер** с **true** в объект класса при маршалировании интерфейса **IClassFactory** и неявный вызов **локксервер** со значением **false** , когда клиент освобождает интерфейс **IClassFactory** .</span><span class="sxs-lookup"><span data-stu-id="604b2-133">To prevent this race condition, COM adds an implicit call to **LockServer** with **TRUE** to the class object when it marshals the **IClassFactory** interface and an implicit call to **LockServer** with **FALSE** when the client releases the **IClassFactory** interface.</span></span> <span data-ttu-id="604b2-134">Таким образом, удаленные вызовы **локксервер** обратно на сервер, а прокси для **локксервер** просто возвращают " \_ ОК" без фактического удаленного взаимодействия вызова.</span><span class="sxs-lookup"><span data-stu-id="604b2-134">Therefore, it is not necessary to remote **LockServer** calls back to the server, and the proxy for **LockServer** simply returns S\_OK without actually remoting the call.</span></span>

<span data-ttu-id="604b2-135">При инициализации внешнего процесса сервера существует еще одно состояние гонки, связанное с активацией.</span><span class="sxs-lookup"><span data-stu-id="604b2-135">There is another activation-related race condition during initialization of an out-of-process server process.</span></span> <span data-ttu-id="604b2-136">COM-сервер, регистрирующий несколько классов, обычно вызывает [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) с регклс \_ Local \_ Server для каждого идентификатора CLSID, который он поддерживает.</span><span class="sxs-lookup"><span data-stu-id="604b2-136">A COM server that registers multiple classes typically calls [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER for each CLSID it supports.</span></span> <span data-ttu-id="604b2-137">После того, как это сделано для всех классов, сервер вводит цикл обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="604b2-137">After it has done this for all classes, the server enters its message loop.</span></span> <span data-ttu-id="604b2-138">Для однопотокового COM-сервера все запросы на активацию блокируются до тех пор, пока сервер не войдет в цикл обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="604b2-138">For a single-threaded COM server, all activation requests are blocked until the server enters the message loop.</span></span> <span data-ttu-id="604b2-139">Однако для сервера модели подразделения, который регистрирует различные объекты класса в разных апартаментах и для всех свободных потоков серверов, запросы на активацию могут поступать раньше этого.</span><span class="sxs-lookup"><span data-stu-id="604b2-139">However, for an apartment model server that registers different class objects in different apartments and for all free-threaded servers, activation requests can arrive earlier than this.</span></span> <span data-ttu-id="604b2-140">В случае серверов апартаментных моделей запросы на активацию могут поступать, как только один поток пойдет в цикл обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="604b2-140">In the case of apartment model servers, activation requests could arrive as soon as any one thread has entered its message loop.</span></span> <span data-ttu-id="604b2-141">В случае с свободными потоками серверов запрос на активацию может поступать сразу после регистрации первого объекта класса.</span><span class="sxs-lookup"><span data-stu-id="604b2-141">In the case of free-threaded servers, an activation request could arrive as soon as the first class object is registered.</span></span> <span data-ttu-id="604b2-142">Так как активация может быть выполнена раньше, также возможна ситуация, когда окончательный выпуск будет выполняться (и, следовательно, заставить сервер завершить работу) до того, как остальная часть сервера завершит инициализацию.</span><span class="sxs-lookup"><span data-stu-id="604b2-142">Since an activation can happen this early, it is also possible for the final release to occur (and therefore cause the server to begin shutting down) before the rest of the server has had a chance to finish initializing.</span></span>

<span data-ttu-id="604b2-143">Чтобы исключить эти состояния гонки и упростить задание модуля записи сервера, любой сервер, желающий зарегистрировать несколько объектов класса с помощью COM, должен вызвать [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) с регклс \_ Local \_ Server \| регклс \_ , который был приостановлен для каждого другого идентификатора CLSID, поддерживаемого сервером.</span><span class="sxs-lookup"><span data-stu-id="604b2-143">To eliminate these race conditions and simplify the job of the server writer, any server that wants to register multiple class objects with COM should call [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER \| REGCLS\_SUSPENDED for each different CLSID the server supports.</span></span> <span data-ttu-id="604b2-144">После того как все классы зарегистрированы и серверный процесс готов принять входящие запросы на активацию, сервер должен выполнить один вызов к [**коресумеклассобжектс**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span><span class="sxs-lookup"><span data-stu-id="604b2-144">After all classes have been registered and the server process is ready to accept incoming activation requests, the server should make one call to [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span></span> <span data-ttu-id="604b2-145">Эта функция сообщает SCM о всех зарегистрированных классах и начинает обработку запросов на активацию в серверном процессе.</span><span class="sxs-lookup"><span data-stu-id="604b2-145">This function tells COM to inform the SCM about all the registered classes, and it begins letting activation requests into the server process.</span></span> <span data-ttu-id="604b2-146">Использование этих функций обеспечивает следующие преимущества.</span><span class="sxs-lookup"><span data-stu-id="604b2-146">Using these functions provides the following advantages:</span></span>

-   <span data-ttu-id="604b2-147">В SCM выполняется только один вызов, независимо от количества зарегистрированных идентификаторов CLSID, что снижает общее время регистрации (и, следовательно, время запуска серверного приложения).</span><span class="sxs-lookup"><span data-stu-id="604b2-147">Only one call is made to the SCM, regardless of how many CLSIDs are registered, thus reducing the overall registration time (and hence startup time of the server application).</span></span>
-   <span data-ttu-id="604b2-148">Если сервер имеет несколько апартаментов и разные идентификаторы CLSID зарегистрированы в разных подразделениях или если сервер является свободным потоком сервера, то запросы на активацию не будут приходить до тех пор, пока сервер не вызовет [**коресумеклассобжектс**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), предоставляя серверу возможность регистрировать все свои идентификаторы CLSID и правильно настраиваться, прежде чем выполнять запросы на активацию и возобновление работы запросов.</span><span class="sxs-lookup"><span data-stu-id="604b2-148">If the server has multiple apartments and different CLSIDs are registered in different apartments, or if the server is a free-threaded server, no activation requests will come in until the server calls [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), giving the server a chance to register all of its CLSIDs and get properly set up before having to deal with activation requests and possible shut down requests.</span></span>

## <a name="related-topics"></a><span data-ttu-id="604b2-149">См. также</span><span class="sxs-lookup"><span data-stu-id="604b2-149">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="604b2-150">Обязанности сервера COM</span><span class="sxs-lookup"><span data-stu-id="604b2-150">COM Server Responsibilities</span></span>](com-server-responsibilities.md)
</dt> </dl>

 

 