---
title: Технический обзор COM
ms.assetid: 519c87cc-b442-4187-af2a-124a1e4e8b49
description: 'Дополнительные сведения: технический обзор COM'
keywords:
- COM технического обзора com
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: be5dc95ffae5166d86cd8110cab1a6b90e6ffa5c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104141390"
---
# <a name="com-technical-overview"></a><span data-ttu-id="67617-104">Технический обзор COM</span><span class="sxs-lookup"><span data-stu-id="67617-104">COM Technical Overview</span></span>

<span data-ttu-id="67617-105">В этом разделе приводятся общие сведения об объектной модели компонентов (COM) Microsoft.</span><span class="sxs-lookup"><span data-stu-id="67617-105">This topic provides an overview of the Microsoft Component Object Model (COM):</span></span>

-   [<span data-ttu-id="67617-106">Введение в модель COM</span><span class="sxs-lookup"><span data-stu-id="67617-106">Introduction to COM</span></span>](#introduction-to-com)
-   [<span data-ttu-id="67617-107">Объекты и интерфейсы</span><span class="sxs-lookup"><span data-stu-id="67617-107">Objects and Interfaces</span></span>](#objects-and-interfaces)
-   [<span data-ttu-id="67617-108">Реализация интерфейса</span><span class="sxs-lookup"><span data-stu-id="67617-108">Interface implementation</span></span>](#interface-implementation)
-   [<span data-ttu-id="67617-109">Интерфейс IUnknown</span><span class="sxs-lookup"><span data-stu-id="67617-109">The IUnknown Interface</span></span>](#the-iunknown-interface)
-   [<span data-ttu-id="67617-110">Модель "клиент-сервер"</span><span class="sxs-lookup"><span data-stu-id="67617-110">The Client/Server Model</span></span>](#the-clientserver-model)
-   [<span data-ttu-id="67617-111">Диспетчер служб</span><span class="sxs-lookup"><span data-stu-id="67617-111">Service Control Manager</span></span>](#service-control-manager)
-   [<span data-ttu-id="67617-112">Возможность многократного использования</span><span class="sxs-lookup"><span data-stu-id="67617-112">Reusability</span></span>](#reusability)
-   [<span data-ttu-id="67617-113">Объекты хранилища и потока</span><span class="sxs-lookup"><span data-stu-id="67617-113">Storage and Stream Objects</span></span>](#storage-and-stream-objects)
-   [<span data-ttu-id="67617-114">Передача данных</span><span class="sxs-lookup"><span data-stu-id="67617-114">Data Transfer</span></span>](#data-transfer)
-   [<span data-ttu-id="67617-115">Удаленное взаимодействие</span><span class="sxs-lookup"><span data-stu-id="67617-115">Remoting</span></span>](#remoting)
-   [<span data-ttu-id="67617-116">Безопасность</span><span class="sxs-lookup"><span data-stu-id="67617-116">Security</span></span>](#security)
-   [<span data-ttu-id="67617-117">См. также</span><span class="sxs-lookup"><span data-stu-id="67617-117">Related topics</span></span>](#related-topics)

## <a name="introduction-to-com"></a><span data-ttu-id="67617-118">Введение в модель COM</span><span class="sxs-lookup"><span data-stu-id="67617-118">Introduction to COM</span></span>

<span data-ttu-id="67617-119">Модель COM определяет двоичный стандарт взаимодействия для создания многократно используемых библиотек программного обеспечения, взаимодействующих во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="67617-119">The Microsoft Component Object Model (COM) defines a binary interoperability standard for creating reusable software libraries that interact at run time.</span></span> <span data-ttu-id="67617-120">Вы можете использовать библиотеки COM без необходимости их компиляции в приложение.</span><span class="sxs-lookup"><span data-stu-id="67617-120">You can use COM libraries without the requirement of compiling them into your application.</span></span> <span data-ttu-id="67617-121">COM — это основа для ряда продуктов и технологий Майкрософт, таких как проигрыватель Windows Media и Windows Server.</span><span class="sxs-lookup"><span data-stu-id="67617-121">COM is the foundation for a number of Microsoft products and technologies, such as Windows Media Player and Windows Server.</span></span>

<span data-ttu-id="67617-122">Модель COM определяет двоичный стандарт, который применяется ко многим операционным системам и аппаратным платформам.</span><span class="sxs-lookup"><span data-stu-id="67617-122">COM defines a binary standard that applies to many operating systems and hardware platforms.</span></span> <span data-ttu-id="67617-123">Для сетевых вычислений COM определяет стандартный формат подключения и протокол для взаимодействия между объектами, которые выполняются на разных аппаратных платформах.</span><span class="sxs-lookup"><span data-stu-id="67617-123">For network computing, COM defines a standard wire format and protocol for interaction among objects that run on different hardware platforms.</span></span> <span data-ttu-id="67617-124">COM не зависит от языка реализации. Это означает, что вы можете создавать библиотеки COM с помощью различных языков программирования, таких как C++ и платформа .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="67617-124">COM is independent of implementation language, which means that you can create COM libraries by using different programming languages, such as C++ and those in the .NET Framework.</span></span>

<span data-ttu-id="67617-125">Спецификация COM предоставляет все фундаментальные концепции, обеспечивающие многократное использование межплатформенного программного обеспечения.</span><span class="sxs-lookup"><span data-stu-id="67617-125">The COM specification provides all of the fundamental concepts that enable cross-platform software reuse:</span></span>

-   <span data-ttu-id="67617-126">Двоичный стандарт для вызовов функций между компонентами.</span><span class="sxs-lookup"><span data-stu-id="67617-126">A binary standard for function calls between components.</span></span>
-   <span data-ttu-id="67617-127">Предоставление строго типизированных группирований функций в интерфейсах.</span><span class="sxs-lookup"><span data-stu-id="67617-127">A provision for strongly-typed groupings of functions into interfaces.</span></span>
-   <span data-ttu-id="67617-128">Базовый интерфейс, обеспечивающий полиморфизм, обнаружение компонентов и отслеживание времени существования объектов.</span><span class="sxs-lookup"><span data-stu-id="67617-128">A base interface that provides polymorphism, feature discovery, and object lifetime tracking.</span></span>
-   <span data-ttu-id="67617-129">Механизм, однозначно определяющий компоненты и их интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="67617-129">A mechanism that uniquely identifies components and their interfaces.</span></span>
-   <span data-ttu-id="67617-130">Загрузчик компонента, который создает экземпляры компонентов из развертывания.</span><span class="sxs-lookup"><span data-stu-id="67617-130">A component loader that creates component instances from a deployment.</span></span>

<span data-ttu-id="67617-131">Модель COM состоит из нескольких частей, которые совместно позволяют создавать приложения, основанные на повторно используемых компонентах:</span><span class="sxs-lookup"><span data-stu-id="67617-131">COM has a number of parts that work together to enable the creation of applications that are built from reusable components:</span></span>

-   <span data-ttu-id="67617-132">*Система узла* , предоставляющая среду выполнения, которая соответствует спецификации COM.</span><span class="sxs-lookup"><span data-stu-id="67617-132">A *host system* that provides a run-time environment that conforms to the COM specification.</span></span>
-   <span data-ttu-id="67617-133">*Интерфейсы* , определяющие контракты функций и *компоненты* , реализующие интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="67617-133">*Interfaces* that define feature contracts, and *components* that implement interfaces.</span></span>
-   <span data-ttu-id="67617-134">*Серверы* , предоставляющие компоненты системе, и *Клиенты* , использующие функции, предоставляемые компонентами.</span><span class="sxs-lookup"><span data-stu-id="67617-134">*Servers* that provide components to the system, and *clients* that use the features provided by components.</span></span>
-   <span data-ttu-id="67617-135">*Реестр* , который отслеживает, где разворачиваются компоненты на локальном и удаленном узлах.</span><span class="sxs-lookup"><span data-stu-id="67617-135">A *registry* that tracks where components are deployed on local and remote hosts.</span></span>
-   <span data-ttu-id="67617-136">*Диспетчер управления службами* , который находит компоненты на локальных и удаленных узлах и подключает серверы к клиентам.</span><span class="sxs-lookup"><span data-stu-id="67617-136">A *Service Control Manager* that locates components on local and remote hosts and connects servers to clients.</span></span>
-   <span data-ttu-id="67617-137">Протокол *структурированного хранилища* , определяющий способ перемещения по содержимому файлов в файловой системе узла.</span><span class="sxs-lookup"><span data-stu-id="67617-137">A *structured storage* protocol that defines how to navigate the contents of files on the host's file system.</span></span>

<span data-ttu-id="67617-138">Включение повторного использования кода на разных узлах и платформах является центральным для COM.</span><span class="sxs-lookup"><span data-stu-id="67617-138">Enabling code re-use across hosts and platforms is central to COM.</span></span> <span data-ttu-id="67617-139">Реализация интерфейса с возможностью повторного использования называется *компонентом*, *объектом компонента* или *COM-объектом*.</span><span class="sxs-lookup"><span data-stu-id="67617-139">A reusable interface implementation is named a *component*, a *component object*, or a *COM object*.</span></span> <span data-ttu-id="67617-140">Компонент реализует один или несколько интерфейсов COM.</span><span class="sxs-lookup"><span data-stu-id="67617-140">A component implements one or more COM interfaces.</span></span>

<span data-ttu-id="67617-141">Пользовательская библиотека COM определяется путем проектирования интерфейсов, реализуемых библиотекой.</span><span class="sxs-lookup"><span data-stu-id="67617-141">You define a custom COM library by designing the interfaces that your library implements.</span></span> <span data-ttu-id="67617-142">Потребители библиотеки могут обнаруживать и использовать ее функции, не зная сведений о развертывании и реализации вашей библиотеки.</span><span class="sxs-lookup"><span data-stu-id="67617-142">Consumers of your library can discover and use its features without any knowledge of your library's deployment and implementation details.</span></span>

## <a name="objects-and-interfaces"></a><span data-ttu-id="67617-143">Объекты и интерфейсы</span><span class="sxs-lookup"><span data-stu-id="67617-143">Objects and Interfaces</span></span>

<span data-ttu-id="67617-144">COM-объект предоставляет свои возможности через *интерфейс*, который представляет собой коллекцию функций-членов.</span><span class="sxs-lookup"><span data-stu-id="67617-144">A COM object exposes its features through an *interface*, which is a collection of member functions.</span></span> <span data-ttu-id="67617-145">COM-интерфейс определяет ожидаемое поведение и обязанности компонента, а также указывает строго типизированный контракт, предоставляющий небольшой набор связанных операций.</span><span class="sxs-lookup"><span data-stu-id="67617-145">A COM interface defines the expected behavior and responsibilities of a component, and it specifies a strongly-typed contract that provides a small set of related operations.</span></span> <span data-ttu-id="67617-146">Все взаимодействие между компонентами COM осуществляется через интерфейсы, а все службы, предлагаемые компонентом, предоставляются через его интерфейс.</span><span class="sxs-lookup"><span data-stu-id="67617-146">All communication among COM components occurs through interfaces, and all services offered by a component are exposed through its interface.</span></span> <span data-ttu-id="67617-147">Вызывающий объект может обращаться только к функциям-членам интерфейса.</span><span class="sxs-lookup"><span data-stu-id="67617-147">A caller can access only the interface member functions.</span></span> <span data-ttu-id="67617-148">Внутреннее состояние недоступно для вызывающего объекта, если оно не представлено в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="67617-148">Internal state is unavailable to a caller unless it is exposed in the interface.</span></span>

<span data-ttu-id="67617-149">Интерфейсы строго типизированы.</span><span class="sxs-lookup"><span data-stu-id="67617-149">Interfaces are strongly typed.</span></span> <span data-ttu-id="67617-150">Каждый интерфейс имеет собственный уникальный идентификатор интерфейса с именем IID, который устраняет конфликты, которые могут возникнуть при работе с понятными для человека именами.</span><span class="sxs-lookup"><span data-stu-id="67617-150">Every interface has its own unique interface identifier, named an IID, which eliminates collisions that could occur with human-readable names.</span></span> <span data-ttu-id="67617-151">IID — это глобальный уникальный идентификатор (GUID), который совпадает с универсальным уникальным ИДЕНТИФИКАТОРом (UUID), определенным в распределенной вычислительной среде (использование) Open Software Foundation (DCE).</span><span class="sxs-lookup"><span data-stu-id="67617-151">The IID is a globally unique identifier (GUID), which is the same as the Universally Unique ID (UUID) defined by the Open Software Foundation (OSF) Distributed Computing Environment (DCE).</span></span> <span data-ttu-id="67617-152">При создании нового интерфейса необходимо создать новый идентификатор для этого интерфейса.</span><span class="sxs-lookup"><span data-stu-id="67617-152">When you create a new interface, you must create a new identifier for that interface.</span></span> <span data-ttu-id="67617-153">Когда вызывающий объект использует интерфейс, он должен использовать уникальный идентификатор.</span><span class="sxs-lookup"><span data-stu-id="67617-153">When a caller uses an interface, it must use the unique identifier.</span></span> <span data-ttu-id="67617-154">Эта явная идентификация повышает надежность, устраняя конфликты имен, которые могут привести к сбою во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="67617-154">This explicit identification improves robustness by eliminating naming conflicts that would result in run-time failure.</span></span>

<span data-ttu-id="67617-155">При определении нового интерфейса можно создать определение интерфейса с помощью языка определения интерфейса (IDL).</span><span class="sxs-lookup"><span data-stu-id="67617-155">When you define a new interface, you can create an interface definition by using the interface definition language (IDL).</span></span> <span data-ttu-id="67617-156">Из этого определения интерфейса компилятор Microsoft IDL создает файлы заголовков для использования приложениями, использующими интерфейс, и исходный код для обработки удаленных вызовов процедур.</span><span class="sxs-lookup"><span data-stu-id="67617-156">From this interface definition, the Microsoft IDL compiler generates header files for use by applications using the interface, and source code to handle remote procedure calls.</span></span> <span data-ttu-id="67617-157">IDL, предоставляемый корпорацией Майкрософт, основан на простых расширениях для DCE IDL, промышленном стандарте для распределенных вычислений на основе удаленного вызова процедур (RPC).</span><span class="sxs-lookup"><span data-stu-id="67617-157">The IDL supplied by Microsoft is based on simple extensions to DCE IDL, an industry standard for Remote Procedure Call (RPC)-based distributed computing.</span></span> <span data-ttu-id="67617-158">IDL является средством для удобства работы с конструктором интерфейсов и не является центральным для COM-взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="67617-158">IDL is a tool for the convenience of the interface designer and is not central to COM interoperability.</span></span> <span data-ttu-id="67617-159">При использовании IDL не требуется создавать файлы заголовков вручную для каждой среды программирования.</span><span class="sxs-lookup"><span data-stu-id="67617-159">With IDL, you do not need to create header files manually for each programming environment.</span></span> <span data-ttu-id="67617-160">Дополнительные сведения см. в разделе [Определение COM-интерфейсов](defining-com-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="67617-160">For more information, see [Defining COM Interfaces](defining-com-interfaces.md).</span></span>

<span data-ttu-id="67617-161">Наследование используется реже в COM-интерфейсах.</span><span class="sxs-lookup"><span data-stu-id="67617-161">Inheritance is used sparingly in COM interfaces.</span></span> <span data-ttu-id="67617-162">Модель COM поддерживает наследование интерфейса только для повторного использования контракта, связанного с базовым интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="67617-162">COM supports interface inheritance only to reuse a contract associated with a base interface.</span></span> <span data-ttu-id="67617-163">COM не поддерживает выборочное наследование; Таким образом, если один интерфейс наследуется от другого, он включает все функции, определяемые базовым интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="67617-163">COM does not support selective inheritance; therefore, if one interface inherits from another, it includes all of the functions that the base interface defines.</span></span> <span data-ttu-id="67617-164">Кроме того, интерфейсы используют только одиночное наследование, а не множественное наследование для получения функций из базового интерфейса.</span><span class="sxs-lookup"><span data-stu-id="67617-164">In addition, interfaces use only single inheritance, instead of multiple inheritance, to obtain functions from a base interface.</span></span>

## <a name="interface-implementation"></a><span data-ttu-id="67617-165">Реализация интерфейса</span><span class="sxs-lookup"><span data-stu-id="67617-165">Interface implementation</span></span>

<span data-ttu-id="67617-166">Невозможно самостоятельно создать экземпляр COM-интерфейса.</span><span class="sxs-lookup"><span data-stu-id="67617-166">You cannot create an instance of a COM interface by itself.</span></span> <span data-ttu-id="67617-167">Вместо этого создается экземпляр класса, который реализует интерфейс.</span><span class="sxs-lookup"><span data-stu-id="67617-167">Instead, you create an instance of a class that implements the interface.</span></span> <span data-ttu-id="67617-168">В C++ COM-интерфейс моделируется как *абстрактный базовый класс*, что означает, что интерфейс является классом C++, который содержит только чистые виртуальные функции-члены.</span><span class="sxs-lookup"><span data-stu-id="67617-168">In C++, a COM interface is modeled as an *abstract base class*, which means that the interface is a C++ class that contains only pure virtual member functions.</span></span> <span data-ttu-id="67617-169">Библиотека C++ реализует COM-объекты, наследуя сигнатуры функций членов из одного или нескольких интерфейсов, переопределяя каждую функцию-член и предоставляя реализацию для каждой функции.</span><span class="sxs-lookup"><span data-stu-id="67617-169">A C++ library implements COM objects by inheriting the member function signatures from one or more interfaces, overriding each member function, and providing an implementation for each function.</span></span>

<span data-ttu-id="67617-170">Для реализации COM-интерфейса можно использовать любой язык программирования, поддерживающий концепцию указателей на функции.</span><span class="sxs-lookup"><span data-stu-id="67617-170">You can use any programming language that supports the concept of function pointers to implement a COM interface.</span></span> <span data-ttu-id="67617-171">Например, в языке C интерфейсом является структура, содержащая указатель на таблицу указателей на функцию, по одному для каждого метода в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="67617-171">For example, in C, an interface is a structure containing a pointer to a table of function pointers, one for each method in the interface.</span></span>

<span data-ttu-id="67617-172">При реализации интерфейса класс должен предоставлять реализацию для каждой функции в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="67617-172">When you implement an interface, your class must provide an implementation for every function in the interface.</span></span> <span data-ttu-id="67617-173">Если класс не работает в функции интерфейса, реализация может быть единственной инструкцией return.</span><span class="sxs-lookup"><span data-stu-id="67617-173">If the class has no work to do in an interface function, the implementation may be a single return statement.</span></span>

<span data-ttu-id="67617-174">Класс COM определяется с помощью уникального 128-разрядного класса (CLSID), связывающего класс с определенным развертыванием в файловой системе, для Windows — DLL или EXE.</span><span class="sxs-lookup"><span data-stu-id="67617-174">A COM class is identified by using a unique 128-bit Class ID (CLSID) that associates a class with a particular deployment in the file system, which for Windows is a DLL or EXE.</span></span> <span data-ttu-id="67617-175">CLSID — это идентификатор GUID, который означает, что ни один из других классов не имеет такого же идентификатора CLSID.</span><span class="sxs-lookup"><span data-stu-id="67617-175">A CLSID is a GUID, which means that no other class has the same CLSID.</span></span> <span data-ttu-id="67617-176">Использование уникальных идентификаторов классов предотвращает конфликты имен между классами.</span><span class="sxs-lookup"><span data-stu-id="67617-176">The use of unique class identifiers prevents name collisions among classes.</span></span> <span data-ttu-id="67617-177">Например, два разных поставщика могут написать класс с именем Кстакк, но оба класса имеют уникальный идентификатор CLSID, что позволяет избежать возникновения конфликта.</span><span class="sxs-lookup"><span data-stu-id="67617-177">For example, two different vendors can write a class named CStack, but both classes have a unique CLSID, so any possibility of a collision is avoided.</span></span>

<span data-ttu-id="67617-178">Получить новый идентификатор CLSID можно с помощью функции [**CoCreateGuid**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateguid) или средства разработки COM, такого как Visual Studio, которое вызывает эту функцию внутренним образом.</span><span class="sxs-lookup"><span data-stu-id="67617-178">You obtain a new CLSID by using the [**CoCreateGuid**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateguid) function or by using a COM authoring tool, such as Visual Studio, that calls this function internally.</span></span>

## <a name="the-iunknown-interface"></a><span data-ttu-id="67617-179">Интерфейс IUnknown</span><span class="sxs-lookup"><span data-stu-id="67617-179">The IUnknown Interface</span></span>

<span data-ttu-id="67617-180">Все COM-интерфейсы наследуют от интерфейса [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) .</span><span class="sxs-lookup"><span data-stu-id="67617-180">All COM interfaces inherit from the [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) interface.</span></span> <span data-ttu-id="67617-181">Интерфейс **IUnknown** содержит фундаментальные операции com для управления полиморфизмом и временем существования экземпляра.</span><span class="sxs-lookup"><span data-stu-id="67617-181">The **IUnknown** interface contains the fundamental COM operations for polymorphism and instance lifetime management.</span></span> <span data-ttu-id="67617-182">Интерфейс **IUnknown** имеет три функции члена с именами [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span><span class="sxs-lookup"><span data-stu-id="67617-182">The **IUnknown** interface has three member functions, named [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref), and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span></span> <span data-ttu-id="67617-183">Все COM-объекты необходимы для реализации интерфейса **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="67617-183">All COM objects are required to implement the **IUnknown** interface.</span></span>

<span data-ttu-id="67617-184">Функция-член [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) предоставляет полиморфизм для com.</span><span class="sxs-lookup"><span data-stu-id="67617-184">The [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) member function provides polymorphism for COM.</span></span> <span data-ttu-id="67617-185">Вызовите метод **QueryInterface** , чтобы определить во время выполнения, поддерживает ли COM-объект определенный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="67617-185">Call **QueryInterface** to determine at run time whether a COM object supports a particular interface.</span></span> <span data-ttu-id="67617-186">COM-объект возвращает указатель интерфейса в `ppvObject` параметре, если он реализует запрошенный интерфейс, в противном случае возвращает `NULL` .</span><span class="sxs-lookup"><span data-stu-id="67617-186">The COM object returns an interface pointer in the `ppvObject` parameter if it implements the requested interface, otherwise it returns `NULL`.</span></span> <span data-ttu-id="67617-187">Функция-член **QueryInterface** позволяет осуществлять навигацию по всем интерфейсам, которые поддерживает объект COM.</span><span class="sxs-lookup"><span data-stu-id="67617-187">The **QueryInterface** member function enables navigation among all of the interfaces that a COM object supports.</span></span>

<span data-ttu-id="67617-188">Время существования экземпляра COM-объекта определяется по *счетчику ссылок*.</span><span class="sxs-lookup"><span data-stu-id="67617-188">The lifetime of a COM object instance is controlled by its *reference count*.</span></span> <span data-ttu-id="67617-189">Элемент [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) функции [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) контролируют счетчик.</span><span class="sxs-lookup"><span data-stu-id="67617-189">The [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) member functions [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) control the count.</span></span> <span data-ttu-id="67617-190">**AddRef** увеличивает значение счетчика и **выпуска** уменьшает число.</span><span class="sxs-lookup"><span data-stu-id="67617-190">**AddRef** increments the count and **Release** decrements the count.</span></span> <span data-ttu-id="67617-191">Если счетчик ссылок достигает нуля, функция-член **выпуска** может освободить экземпляр, так как он не использует вызывающие объекты.</span><span class="sxs-lookup"><span data-stu-id="67617-191">When the reference count reaches zero, the **Release** member function may free the instance, because no callers are using it.</span></span>

## <a name="the-clientserver-model"></a><span data-ttu-id="67617-192">Модель "клиент-сервер"</span><span class="sxs-lookup"><span data-stu-id="67617-192">The Client/Server Model</span></span>

<span data-ttu-id="67617-193">COM-класс реализует ряд COM-интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="67617-193">A COM class implements a number of COM interfaces.</span></span> <span data-ttu-id="67617-194">Реализация состоит из двоичных файлов, которые выполняются, когда вызывающий объект взаимодействует с экземпляром класса COM.</span><span class="sxs-lookup"><span data-stu-id="67617-194">The implementation consists of binaries that run when a caller interacts with an instance of the COM class.</span></span> <span data-ttu-id="67617-195">COM позволяет использовать класс в различных приложениях, включая приложения, написанные без знания конкретного класса.</span><span class="sxs-lookup"><span data-stu-id="67617-195">COM enables using a class in different applications, including applications written without knowledge of a particular class.</span></span> <span data-ttu-id="67617-196">На платформе Windows классы существуют либо в динамической библиотеке (DLL), либо в другом приложении (EXE).</span><span class="sxs-lookup"><span data-stu-id="67617-196">On a Windows platform, classes exist either in a dynamic-linked library (DLL) or in another application (EXE).</span></span>

<span data-ttu-id="67617-197">В своей системе размещения COM поддерживает базу данных регистрации всех идентификаторов CLSID для COM-объектов, установленных в системе.</span><span class="sxs-lookup"><span data-stu-id="67617-197">On its host system, COM maintains a registration database of all the CLSIDs for the COM objects installed on the system.</span></span> <span data-ttu-id="67617-198">База данных регистрации — это сопоставление между каждым идентификатором CLSID и расположением библиотеки DLL или EXE, в котором находится соответствующий класс.</span><span class="sxs-lookup"><span data-stu-id="67617-198">The registration database is a mapping between each CLSID and the location of the DLL or EXE that houses the corresponding class.</span></span> <span data-ttu-id="67617-199">COM запрашивает эту базу данных каждый раз, когда вызывающий объект хочет создать экземпляр класса COM.</span><span class="sxs-lookup"><span data-stu-id="67617-199">COM queries this database whenever a caller wants to create an instance of a COM class.</span></span> <span data-ttu-id="67617-200">Вызывающему объекту необходимо получить сведения только об идентификаторе CLSID, чтобы запросить новый экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="67617-200">The caller needs to know only the CLSID to request a new instance of the class.</span></span>

<span data-ttu-id="67617-201">Взаимодействие между COM-объектом и его вызывающими объектами моделируется как отношение "клиент-сервер".</span><span class="sxs-lookup"><span data-stu-id="67617-201">The interaction between a COM object and its callers is modeled as a client/server relationship.</span></span> <span data-ttu-id="67617-202">Клиент является вызывающим объектом, который запрашивает COM-объект из системы, а сервер является модулем, предоставляющим COM-объекты, которые предоставляют службы клиентам.</span><span class="sxs-lookup"><span data-stu-id="67617-202">The client is the caller that requests a COM object from the system, and the server is the module that houses COM objects that provides services to clients.</span></span>

<span data-ttu-id="67617-203">Клиент COM — это любой вызывающий объект, передающий в систему идентификатор CLSID для запроса экземпляра COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="67617-203">A COM client is any caller that passes a CLSID to the system to request an instance of a COM object.</span></span> <span data-ttu-id="67617-204">Самый простой способ создать экземпляр — вызвать функцию COM, [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="67617-204">The simplest way to create an instance is to call the COM function, [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span>

<span data-ttu-id="67617-205">Функция [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) создает один экземпляр указанного идентификатора CLSID и возвращает указатель интерфейса типа, запрошенного клиентом.</span><span class="sxs-lookup"><span data-stu-id="67617-205">The [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) function creates one instance of the specified CLSID and returns an interface pointer of the type requested by the client.</span></span> <span data-ttu-id="67617-206">Клиент несет ответственность за управление временем существования экземпляра путем вызова его функции [**выпуска**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) , когда клиент завершит его использование.</span><span class="sxs-lookup"><span data-stu-id="67617-206">The client is responsible for managing the lifetime of the instance by calling its [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) function when the client has finished using it.</span></span> <span data-ttu-id="67617-207">Чтобы создать несколько объектов на основе одного идентификатора CLSID, вызовите функцию [**кожетклассобжект**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) .</span><span class="sxs-lookup"><span data-stu-id="67617-207">To create multiple objects based on a single CLSID, call the [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) function.</span></span> <span data-ttu-id="67617-208">Чтобы подключиться к объекту, который уже создан и запущен, вызовите функцию [**жетактивеобжект**](/previous-versions/windows/desktop/api/oleauto/nf-oleauto-getactiveobject) .</span><span class="sxs-lookup"><span data-stu-id="67617-208">To connect to an object that is already created and running, call the [**GetActiveObject**](/previous-versions/windows/desktop/api/oleauto/nf-oleauto-getactiveobject) function.</span></span>

<span data-ttu-id="67617-209">COM-сервер предоставляет системе реализацию COM.</span><span class="sxs-lookup"><span data-stu-id="67617-209">A COM server provides a COM implementation to the system.</span></span> <span data-ttu-id="67617-210">Сервер связывает CLSID с классом COM, внедряет реализацию класса, реализует фабрику класса для создания экземпляров класса и предоставляет для выгрузки сервера.</span><span class="sxs-lookup"><span data-stu-id="67617-210">A server associates a CLSID with a COM class, houses the implementation of the class, implements a class factory for creating instances of the class, and provides for unloading the server.</span></span>

> [!Note]  
> <span data-ttu-id="67617-211">Сервер COM не совпадает с COM-объектом, который он предоставляет системе.</span><span class="sxs-lookup"><span data-stu-id="67617-211">A COM server is not the same as the COM object that it provides to the system.</span></span>

 

<span data-ttu-id="67617-212">Чтобы включить создание COM-объекта, сервер COM должен предоставить реализацию интерфейса [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) .</span><span class="sxs-lookup"><span data-stu-id="67617-212">To enable creating a COM object, a COM server must provide an implementation of the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface.</span></span> <span data-ttu-id="67617-213">Клиенты могут вызывать метод [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) для запроса нового экземпляра COM-объекта, но обычно такие запросы инкапсулируются в функции [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) .</span><span class="sxs-lookup"><span data-stu-id="67617-213">Clients can call the [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) method to request a new instance of a COM object, but usually such requests are encapsulated in the [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) function.</span></span>

<span data-ttu-id="67617-214">Сервер COM можно развернуть как общую библиотеку, которая загружается в процесс клиента во время выполнения (DLL на платформах Windows) или как исполняемый модуль (EXE на платформах Windows).</span><span class="sxs-lookup"><span data-stu-id="67617-214">You can deploy a COM server either as a shared library that is loaded into the client's process at run time (DLL on Windows platforms) or as an executable module (EXE on Windows platforms).</span></span> <span data-ttu-id="67617-215">Дополнительные сведения см. в разделе [Регистрация приложений COM](registering-com-applications.md).</span><span class="sxs-lookup"><span data-stu-id="67617-215">For more information, see [Registering COM Applications](registering-com-applications.md).</span></span>

## <a name="service-control-manager"></a><span data-ttu-id="67617-216">Диспетчер служб</span><span class="sxs-lookup"><span data-stu-id="67617-216">Service Control Manager</span></span>

<span data-ttu-id="67617-217">Диспетчер управления службами (SCM) обрабатывает клиентский запрос для экземпляра COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="67617-217">The Service Control Manager (SCM) handles the client request for an instance of a COM object.</span></span> <span data-ttu-id="67617-218">В следующем списке показана последовательность событий.</span><span class="sxs-lookup"><span data-stu-id="67617-218">The following list shows the sequence of events:</span></span>

-   <span data-ttu-id="67617-219">Клиент запрашивает указатель интерфейса на COM-объект из библиотеки COM, вызывая функцию, например [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) , с идентификатором CLSID COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="67617-219">A client requests an interface pointer to a COM object from the COM Library by calling a function such as [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) with the CLSID of the COM object.</span></span>
-   <span data-ttu-id="67617-220">Библиотека COM отправляет службе SCM запрос на поиск сервера, соответствующего запрошенному идентификатору CLSID.</span><span class="sxs-lookup"><span data-stu-id="67617-220">The COM Library queries the SCM to find the server that corresponds with the requested CLSID.</span></span>
-   <span data-ttu-id="67617-221">SCM находит сервер и запрашивает создание объекта COM из фабрики класса, предоставляемой сервером.</span><span class="sxs-lookup"><span data-stu-id="67617-221">The SCM locates the server and requests the creation of the COM object from the class factory that is provided by the server.</span></span>
-   <span data-ttu-id="67617-222">В случае успеха библиотека COM возвращает клиенту указатель на интерфейс.</span><span class="sxs-lookup"><span data-stu-id="67617-222">If successful, the COM Library returns an interface pointer to the client.</span></span>

<span data-ttu-id="67617-223">После того как система COM подключает серверный объект к клиенту, клиент и объект обмениваются данными напрямую.</span><span class="sxs-lookup"><span data-stu-id="67617-223">After the COM system connects a server object to a client, the client and object communicate directly.</span></span> <span data-ttu-id="67617-224">Нет дополнительных издержек при вызове через промежуточное время выполнения.</span><span class="sxs-lookup"><span data-stu-id="67617-224">There is no added overhead from calling through an intermediary run time.</span></span>

<span data-ttu-id="67617-225">При регистрации сервера COM в системе размещения можно указать различные способы активации сервера.</span><span class="sxs-lookup"><span data-stu-id="67617-225">When you register a COM server with the host system, you can specify different ways for the server to be activated.</span></span> <span data-ttu-id="67617-226">В следующем списке показаны три способа активации сервера COM с помощью SCM:</span><span class="sxs-lookup"><span data-stu-id="67617-226">The following list shows the three ways that the SCM can activate a COM server:</span></span>

-   <span data-ttu-id="67617-227">Внутрипроцессный: SCM Возвращает путь к файлу библиотеки DLL, содержащей реализацию сервера объектов.</span><span class="sxs-lookup"><span data-stu-id="67617-227">In-process: The SCM returns the file path of the DLL that contains the object server implementation.</span></span> <span data-ttu-id="67617-228">Библиотека COM загружает библиотеку DLL и запрашивает ее указатель интерфейса фабрики класса.</span><span class="sxs-lookup"><span data-stu-id="67617-228">The COM Library loads the DLL and queries it for its class factory interface pointer.</span></span>
-   <span data-ttu-id="67617-229">Локальный: SCM запускает локальный исполняемый файл, который регистрирует фабрику класса при запуске, и его указатель интерфейса доступен для системы и клиентов.</span><span class="sxs-lookup"><span data-stu-id="67617-229">Local: The SCM starts the local executable which registers a class factory on startup, and its interface pointer is available to the system and clients.</span></span>
-   <span data-ttu-id="67617-230">Удаленный: локальный SCM получает указатель интерфейса фабрики классов от SCM, который работает на удаленном компьютере.</span><span class="sxs-lookup"><span data-stu-id="67617-230">Remote: The local SCM acquires a class factory interface pointer from the SCM that is running on a remote computer.</span></span>

<span data-ttu-id="67617-231">Когда клиент запрашивает COM-объект, Библиотека COM обращается к SCM на локальном узле.</span><span class="sxs-lookup"><span data-stu-id="67617-231">When a client requests a COM object, the COM Library contacts the SCM on the local host.</span></span> <span data-ttu-id="67617-232">SCM находит соответствующий COM-сервер, который может быть локальным или удаленным, и сервер возвращает указатель интерфейса на фабрику класса сервера.</span><span class="sxs-lookup"><span data-stu-id="67617-232">The SCM locates the appropriate COM server, which may be local or remote, and the server returns an interface pointer to the server's class factory.</span></span> <span data-ttu-id="67617-233">Когда фабрика класса доступна, Библиотека COM или клиент может использовать фабрику классов для создания запрошенного объекта.</span><span class="sxs-lookup"><span data-stu-id="67617-233">When the class factory is available, the COM Library or the client can use the class factory to create the requested object.</span></span> <span data-ttu-id="67617-234">Дополнительные сведения см. в разделе [Реализация IClassFactory](implementing-iclassfactory.md).</span><span class="sxs-lookup"><span data-stu-id="67617-234">For more information, see [Implementing IClassFactory](implementing-iclassfactory.md).</span></span>

## <a name="reusability"></a><span data-ttu-id="67617-235">Повторное использование</span><span class="sxs-lookup"><span data-stu-id="67617-235">Reusability</span></span>

<span data-ttu-id="67617-236">COM поддерживает возможность повторного *использования*, что означает, что сведения о реализации повторно используемого компонента не предоставляются клиентам.</span><span class="sxs-lookup"><span data-stu-id="67617-236">COM supports *black-box reusability*, which means that the implementation details of a reusable component are not exposed to clients.</span></span> <span data-ttu-id="67617-237">Чтобы обеспечить возможность повторного использования черного ящика, COM поддерживает два механизма, с помощью которых один объект может использовать другой.</span><span class="sxs-lookup"><span data-stu-id="67617-237">To achieve black-box reusability, COM supports two mechanisms through which one object may reuse another.</span></span> <span data-ttu-id="67617-238">Две формы многократного использования называются *вложенностью* и *агрегированием*.</span><span class="sxs-lookup"><span data-stu-id="67617-238">The two forms of reuse are named *containment* and *aggregation*.</span></span> <span data-ttu-id="67617-239">По соглашению используемый объект называется *внутренним объектом*, а объект, который используется для внутреннего объекта, называется *внешним объектом*.</span><span class="sxs-lookup"><span data-stu-id="67617-239">By convention, the object being reused is named the *inner object*, and the object that is making use of the inner object is named the *outer object*.</span></span>

<span data-ttu-id="67617-240">Во вложении внешний объект ведет себя как клиент внутреннего объекта.</span><span class="sxs-lookup"><span data-stu-id="67617-240">In containment, the outer object behaves as a client of the inner object.</span></span> <span data-ttu-id="67617-241">Внешний объект является логическим контейнером для внутреннего объекта, а когда внешний объект использует службы внутреннего объекта, внешний объект делегирует реализацию интерфейсам внутреннего объекта.</span><span class="sxs-lookup"><span data-stu-id="67617-241">The outer object is a logical container for the inner object, and when the outer object uses the services of the inner object, the outer object delegates implementation to the inner object's interfaces.</span></span> <span data-ttu-id="67617-242">Это означает, что внешний объект реализуется с точки зрения служб внутреннего объекта.</span><span class="sxs-lookup"><span data-stu-id="67617-242">This means that the outer object is implemented in terms of the inner object's services.</span></span> <span data-ttu-id="67617-243">Внешний объект может не поддерживать те же интерфейсы, что и внутренний объект, а внешний объект может использовать интерфейс внутреннего объекта для реализации частей другого интерфейса внешнего объекта.</span><span class="sxs-lookup"><span data-stu-id="67617-243">The outer object may not support the same interfaces as the inner object, and the outer object may use an inner object's interface to help with implementing parts of a different interface on the outer object.</span></span>

<span data-ttu-id="67617-244">В агрегате внешний объект предоставляет интерфейсы из внутреннего объекта, как если бы они были реализованы во внешнем объекте.</span><span class="sxs-lookup"><span data-stu-id="67617-244">In aggregation, the outer object exposes interfaces from the inner object as if they were implemented on the outer object.</span></span> <span data-ttu-id="67617-245">Это полезно, когда внешний объект всегда будет делегировать каждый вызов одного из его интерфейсов в тот же интерфейс внутреннего объекта.</span><span class="sxs-lookup"><span data-stu-id="67617-245">This is useful when the outer object would always delegate every call on one of its interfaces to the same interface of the inner object.</span></span> <span data-ttu-id="67617-246">Агрегирование — это удобство, позволяющее внешнему объекту избежать дополнительных затрат на реализацию.</span><span class="sxs-lookup"><span data-stu-id="67617-246">Aggregation is a convenience that enables the outer object to avoid extra implementation overhead.</span></span>

<span data-ttu-id="67617-247">Дополнительные сведения см. в разделе [повторное использование объектов](reusing-objects.md).</span><span class="sxs-lookup"><span data-stu-id="67617-247">For more information, see [Reusing Objects](reusing-objects.md).</span></span>

## <a name="storage-and-stream-objects"></a><span data-ttu-id="67617-248">Объекты хранилища и потока</span><span class="sxs-lookup"><span data-stu-id="67617-248">Storage and Stream Objects</span></span>

<span data-ttu-id="67617-249">Объекты COM сохраняют состояние в файле с помощью *структурированного хранилища*, которое представляет собой форму постоянного хранилища, позволяющего переходить по содержимому файла с помощью семантики файловой системы.</span><span class="sxs-lookup"><span data-stu-id="67617-249">COM objects save state to a file by using *structured storage*, which is a form of persistent storage that enables navigation of a file's contents by using file system semantics.</span></span> <span data-ttu-id="67617-250">Подобная обработка содержимого файла позволяет выполнять такие функции, как добавочный доступ, транзакции и совместное использование между процессами.</span><span class="sxs-lookup"><span data-stu-id="67617-250">Treating a file's contents in this manner enables features such as incremental access, transactions, and sharing among processes.</span></span>

<span data-ttu-id="67617-251">Спецификация постоянного хранилища COM предоставляет два типа элементов хранения: объекты хранилища и объекты потока.</span><span class="sxs-lookup"><span data-stu-id="67617-251">The COM persistent storage specification provides for two types of storage elements: storage objects and stream objects.</span></span> <span data-ttu-id="67617-252">Эти объекты реализуются библиотекой COM, а пользовательские приложения редко реализуют эти элементы хранения.</span><span class="sxs-lookup"><span data-stu-id="67617-252">These objects are implemented by the COM Library, and user applications rarely implement these storage elements.</span></span> <span data-ttu-id="67617-253">Объекты хранилища реализуют интерфейс [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) , а объекты потока реализуют интерфейс [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) .</span><span class="sxs-lookup"><span data-stu-id="67617-253">Storage objects implement the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface, and stream objects implement the [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) interface.</span></span>

<span data-ttu-id="67617-254">Объект потока содержит данные и концептуально напоминает отдельный файл в файловой системе.</span><span class="sxs-lookup"><span data-stu-id="67617-254">A stream object contains data and is conceptually similar to a single file in a file system.</span></span> <span data-ttu-id="67617-255">У каждого потока есть права доступа и один указатель поиска.</span><span class="sxs-lookup"><span data-stu-id="67617-255">Each stream has access rights and a single seek pointer.</span></span> <span data-ttu-id="67617-256">С помощью интерфейса [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) можно читать, записывать, искать и выполнять другие операции с базовыми данными потока.</span><span class="sxs-lookup"><span data-stu-id="67617-256">Through the [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) interface, you can read, write, seek, and perform other operations on the stream's underlying data.</span></span> <span data-ttu-id="67617-257">Потоку присваивается имя с помощью текстовой строки.</span><span class="sxs-lookup"><span data-stu-id="67617-257">A stream is named by using a text string.</span></span> <span data-ttu-id="67617-258">Он может содержать любую внутреннюю структуру, так как это плоский поток байтов.</span><span class="sxs-lookup"><span data-stu-id="67617-258">It can contain any internal structure, because it is a flat stream of bytes.</span></span> <span data-ttu-id="67617-259">Кроме того, функции в интерфейсе **IStream** похожи на стандартные функции, основанные на обработке файлов, например, в библиотеке времени выполнения C ANSI.</span><span class="sxs-lookup"><span data-stu-id="67617-259">In addition, the functions in the **IStream** interface are similar to standard file-handle based functions, such as those in the ANSI C run-time library.</span></span>

<span data-ttu-id="67617-260">Объект хранилища концептуально напоминает каталог в файловой системе.</span><span class="sxs-lookup"><span data-stu-id="67617-260">A storage object is conceptually similar to a directory in a file system.</span></span> <span data-ttu-id="67617-261">Каждое хранилище может содержать любое количество объектов вложенного хранилища и любое количество потоков.</span><span class="sxs-lookup"><span data-stu-id="67617-261">Each storage can contain any number of sub-storage objects and any number of streams.</span></span> <span data-ttu-id="67617-262">У каждого хранилища есть свои права доступа.</span><span class="sxs-lookup"><span data-stu-id="67617-262">Each storage has its own access rights.</span></span> <span data-ttu-id="67617-263">С помощью интерфейса [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) можно выполнять такие операции, как перечисление, перемещение, копирование, переименование, создание и удаление элементов.</span><span class="sxs-lookup"><span data-stu-id="67617-263">Through the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface, you can perform operations such as enumerating, moving, copying, renaming, creating, and deleting elements.</span></span> <span data-ttu-id="67617-264">Объект хранилища не хранит определяемые приложением данные, но сохраняет неявные имена элементов (хранилищ и потоков), которые он содержит.</span><span class="sxs-lookup"><span data-stu-id="67617-264">A storage object does not store application-defined data, but it stores implicitly the names of the elements (storages and streams) that it contains.</span></span>

<span data-ttu-id="67617-265">Объекты хранилища и потока могут совместно обрабатываться между процессами, когда они реализуются в соответствии со спецификацией COM на хост-платформе.</span><span class="sxs-lookup"><span data-stu-id="67617-265">Storage and stream objects are sharable among processes when they are implemented according to the COM specification on a host platform.</span></span> <span data-ttu-id="67617-266">Это позволяет объектам, которые выполняются внутри процесса или вне процесса, иметь одинаковый добавочный доступ к их хранилищу файлов.</span><span class="sxs-lookup"><span data-stu-id="67617-266">This enables objects that are running in-process or out-of-process to have equal incremental access to their file storage.</span></span> <span data-ttu-id="67617-267">Так как COM загружается в каждый процесс отдельно, он использует поддерживаемые механизмы общей памяти для передачи состояния открытых элементов и их режимов доступа между процессами.</span><span class="sxs-lookup"><span data-stu-id="67617-267">Because COM is loaded into each process separately, it uses operating-system supported shared memory mechanisms to communicate the state of opened elements and their access modes between processes.</span></span>

<span data-ttu-id="67617-268">Каждый объект хранения и потоковой передачи в структурированном файле имеет имя для его обнаружения.</span><span class="sxs-lookup"><span data-stu-id="67617-268">Every storage and stream object in a structured file has a name to identify it.</span></span> <span data-ttu-id="67617-269">Имя — это строка, которая соответствует определенному соглашению.</span><span class="sxs-lookup"><span data-stu-id="67617-269">The name is a string that follows a particular convention.</span></span> <span data-ttu-id="67617-270">Дополнительные сведения см. в разделе [соглашения об именовании объектов хранилища](/windows/desktop/Stg/storage-object-naming-conventions).</span><span class="sxs-lookup"><span data-stu-id="67617-270">For more information, see [Storage Object Naming Conventions](/windows/desktop/Stg/storage-object-naming-conventions).</span></span> <span data-ttu-id="67617-271">Имя передается в функции [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) , чтобы указать, в каком элементе хранилища следует работать.</span><span class="sxs-lookup"><span data-stu-id="67617-271">The name is passed to [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) functions to specify which element in the storage to operate on.</span></span> <span data-ttu-id="67617-272">Имена объектов корневого хранилища совпадают с именами файлов в базовой файловой системе, и эти имена должны соответствовать соглашениям файловой системы и ограничениям.</span><span class="sxs-lookup"><span data-stu-id="67617-272">Names of root storage objects are the same as file names in the underlying file system, and these names must follow the file system's conventions and restrictions.</span></span> <span data-ttu-id="67617-273">Строки, передаваемые в функции, связанные с хранилищем, имена файлов которых передаются в файловую систему без интерпретации или изменения.</span><span class="sxs-lookup"><span data-stu-id="67617-273">Strings passed to storage-related functions which name files are passed through to the file system without interpretation or changes.</span></span>

<span data-ttu-id="67617-274">Имена элементов, содержащихся в объектах хранилища, управляются реализацией определенного объекта хранилища.</span><span class="sxs-lookup"><span data-stu-id="67617-274">Names of elements that are contained within storage objects are managed by the implementation of the particular storage object in question.</span></span> <span data-ttu-id="67617-275">Все реализации объектов хранилища должны поддерживать имена элементов длиной 32 символов, а некоторые реализации могут поддерживать более длинные имена.</span><span class="sxs-lookup"><span data-stu-id="67617-275">All implementations of storage objects must support element names that are 32 characters in length, and some implementations may support longer names.</span></span> <span data-ttu-id="67617-276">Имена сохраняются с сохранением регистра, но сравниваются без учета регистра.</span><span class="sxs-lookup"><span data-stu-id="67617-276">Names are stored with case preserved, but they are compared as case-insensitive.</span></span> <span data-ttu-id="67617-277">Приложения, определяющие имена элементов хранилища, должны выбирать имена, которые работают в любой ситуации.</span><span class="sxs-lookup"><span data-stu-id="67617-277">Applications that define storage element names must choose names that work in either situation.</span></span>

<span data-ttu-id="67617-278">Доступ к каждому элементу в структурированном файле хранилища осуществляется с помощью функций и интерфейсов, реализованных в COM.</span><span class="sxs-lookup"><span data-stu-id="67617-278">You access every element in a structured storage file by using functions and interfaces that are implemented by COM.</span></span> <span data-ttu-id="67617-279">Это означает, что другие приложения могут просматривать файл, перейдя к функциям интерфейса [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) , которые предоставляют службы, аналогичные каталогам.</span><span class="sxs-lookup"><span data-stu-id="67617-279">This means that other applications can browse the file by navigating with the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface functions that provide directory-like services.</span></span> <span data-ttu-id="67617-280">Кроме того, другие приложения могут использовать данные этого файла без необходимости запуска приложения, записывающего файл.</span><span class="sxs-lookup"><span data-stu-id="67617-280">Also, other applications can use the file's data, without having to run the application that wrote the file.</span></span> <span data-ttu-id="67617-281">Когда COM-приложение обращается к структурированным файлам хранилища другого приложения, применяются стандартные права доступа Windows, и приложение должно иметь достаточные привилегии.</span><span class="sxs-lookup"><span data-stu-id="67617-281">When a COM application accesses the structured storage files of another application, standard Windows access rights apply, and the application must have sufficient privileges.</span></span>

<span data-ttu-id="67617-282">COM-объект может выполнять чтение и запись в постоянное хранилище.</span><span class="sxs-lookup"><span data-stu-id="67617-282">A COM object can read and write itself to persistent storage.</span></span> <span data-ttu-id="67617-283">Клиент запрашивает один из интерфейсов, связанных с сохраняемостью, для COM-объекта в зависимости от контекста операции.</span><span class="sxs-lookup"><span data-stu-id="67617-283">A client queries for one of the persistence-related interfaces on the COM object, depending on the context of the operation.</span></span> <span data-ttu-id="67617-284">COM-объекты могут реализовывать любое сочетание следующих интерфейсов:</span><span class="sxs-lookup"><span data-stu-id="67617-284">COM objects can implement any combination of the following interfaces:</span></span>

-   <span data-ttu-id="67617-285">[**Иперсистстораже**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststorage): объект COM считывает и записывает свое постоянное состояние в объект хранилища.</span><span class="sxs-lookup"><span data-stu-id="67617-285">[**IPersistStorage**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststorage): The COM object reads and writes its persistent state to a storage object.</span></span> <span data-ttu-id="67617-286">Клиент предоставляет объект с указателем [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) через этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="67617-286">The client provides the object with an [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) pointer through this interface.</span></span> <span data-ttu-id="67617-287">Это единственный интерфейс сохраняемости, который включает семантику для добавочного доступа.</span><span class="sxs-lookup"><span data-stu-id="67617-287">This is the only persistence interface that includes semantics for incremental access.</span></span>
-   <span data-ttu-id="67617-288">[**IPersistStream**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststream): объект COM считывает и записывает свое постоянное состояние в объект потока.</span><span class="sxs-lookup"><span data-stu-id="67617-288">[**IPersistStream**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststream): The COM object reads and writes its persistent state to a stream object.</span></span> <span data-ttu-id="67617-289">Клиент предоставляет объект с помощью указателя [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) через этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="67617-289">The client provides the object with an [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) pointer through this interface.</span></span>
-   <span data-ttu-id="67617-290">[**IPersistFile**](/windows/desktop/api/ObjIdl/nn-objidl-ipersistfile): объект COM считывает и записывает свое постоянное состояние непосредственно в файл в базовой системе.</span><span class="sxs-lookup"><span data-stu-id="67617-290">[**IPersistFile**](/windows/desktop/api/ObjIdl/nn-objidl-ipersistfile): The COM object reads and writes its persistent state directly to a file on the underlying system.</span></span> <span data-ttu-id="67617-291">Этот интерфейс не включает [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) или [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) , если доступ к базовому файлу через эти интерфейсы отсутствует, но интерфейс **IPersistFile** не имеет семантики для хранения и потоков.</span><span class="sxs-lookup"><span data-stu-id="67617-291">This interface does not involve [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) or [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) unless the underlying file is accessed through these interfaces, but the **IPersistFile** interface has no semantics for storages and streams.</span></span> <span data-ttu-id="67617-292">Клиент предоставляет объект с именем файла и вызывает функции [**Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-save) или [**Load**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-load) .</span><span class="sxs-lookup"><span data-stu-id="67617-292">The client provides the object with a file name and calls the [**Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-save) or [**Load**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-load) functions.</span></span>

## <a name="data-transfer"></a><span data-ttu-id="67617-293">Передача данных</span><span class="sxs-lookup"><span data-stu-id="67617-293">Data Transfer</span></span>

<span data-ttu-id="67617-294">Структурированное хранилище предоставляет базу обмена данными между COM-объектами и процессами, которая называется *однородным обменом данными*.</span><span class="sxs-lookup"><span data-stu-id="67617-294">Structured storage provides the basis for data exchange between COM objects and processes, which is named *uniform data transfer*.</span></span> <span data-ttu-id="67617-295">До реализации модели COM в OLE 2, при передаче данных в Windows были указаны *протоколы переноса*, такие как буфер обмена и протоколы перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="67617-295">Before COM was implemented in OLE 2, data transfer on Windows was specified by *transfer protocols*, such as the clipboard and drag-drop protocols.</span></span> <span data-ttu-id="67617-296">Каждый протокол передает собственный набор функций, которые применяют протокол к запросу, а конкретный код был необходим для обработки каждого отдельного протокола и процедуры Exchange.</span><span class="sxs-lookup"><span data-stu-id="67617-296">Each transfer protocol had its own set of functions that bound the protocol to the query, and specific code was required to handle each different protocol and exchange procedure.</span></span> <span data-ttu-id="67617-297">Единая передача данных представляет все передачи данных с помощью интерфейса [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) , который отделяет общие операции обмена данными от протокола передачи.</span><span class="sxs-lookup"><span data-stu-id="67617-297">Uniform data transfer represents all data transfers by using the [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface, which separates common data exchange operations from the transfer protocol.</span></span>

<span data-ttu-id="67617-298">Интерфейс [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) инкапсулирует стандартные операции получения и задания данных, запросов и перечислений, а также уведомления, которые обнаруживают, когда изменяются данные в объекте.</span><span class="sxs-lookup"><span data-stu-id="67617-298">The [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface encapsulates the standard get and set operations on data, queries and enumerations, and notifications that detect when data changes in an object.</span></span> <span data-ttu-id="67617-299">Однородные передачи данных позволяют использовать подробные описания форматов данных, а также разные носители для передачи данных.</span><span class="sxs-lookup"><span data-stu-id="67617-299">Uniform data transfer enables rich descriptions of data formats, as well as the use of different storage media for the data transfer.</span></span>

<span data-ttu-id="67617-300">Во время равномерной пересылки данных все протоколы обмениваются указателем на интерфейс [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) .</span><span class="sxs-lookup"><span data-stu-id="67617-300">During uniform data transfer, all protocols exchange a pointer to an [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="67617-301">Сервер является источником данных и реализует один объект данных, который можно использовать в любом протоколе обмена данными.</span><span class="sxs-lookup"><span data-stu-id="67617-301">The server is the source of the data and implements one data object, which is usable in any data exchange protocol.</span></span> <span data-ttu-id="67617-302">Клиент использует данные и запрашивает данные из объекта данных при получении указателя **IDataObject** от любого протокола.</span><span class="sxs-lookup"><span data-stu-id="67617-302">The client consumes the data and requests data from a data object when it receives an **IDataObject** pointer from any protocol.</span></span> <span data-ttu-id="67617-303">После обмена указателями обе стороны обрабатывали обмен данными единообразно через интерфейс **IDataObject** .</span><span class="sxs-lookup"><span data-stu-id="67617-303">After the pointer exchange has occurred, both sides handle data exchange in a uniform fashion, through the **IDataObject** interface.</span></span>

<span data-ttu-id="67617-304">Модель COM определяет две структуры данных, которые обеспечивают единообразную пересылку данных.</span><span class="sxs-lookup"><span data-stu-id="67617-304">COM defines two data structures that enable uniform data transfer.</span></span> <span data-ttu-id="67617-305">Структура [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) представляет обобщенный формат буфера обмена, а структура [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) представляет собой носитель передачи в виде маркера памяти.</span><span class="sxs-lookup"><span data-stu-id="67617-305">The [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure represents a generalized clipboard format, and the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure represents the transfer medium as a memory handle.</span></span>

<span data-ttu-id="67617-306">Клиент создает структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) для указания типа данных, запрашиваемых из источника данных, и используется источником данных для описания форматов, которые он предоставляет.</span><span class="sxs-lookup"><span data-stu-id="67617-306">The client creates a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to indicate the type of data that it requests from a data source, and it is used by the data source to describe what formats it provides.</span></span> <span data-ttu-id="67617-307">Клиент запрашивает у источника данных доступные форматы, запрашивая интерфейс [**иенумформатетк**](/windows/desktop/api/ObjIdl/nn-objidl-ienumformatetc) .</span><span class="sxs-lookup"><span data-stu-id="67617-307">The client queries a data source for its available formats by requesting its [**IEnumFORMATETC**](/windows/desktop/api/ObjIdl/nn-objidl-ienumformatetc) interface.</span></span> <span data-ttu-id="67617-308">Дополнительные сведения см. [в разделе Структура форматетк](the-formatetc-structure.md).</span><span class="sxs-lookup"><span data-stu-id="67617-308">For more information, see [The FORMATETC Structure](the-formatetc-structure.md).</span></span>

<span data-ttu-id="67617-309">Клиент создает структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) и передает ее методу [**GetData**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-getdata) , а объект данных возвращает данные в предоставленной структуре **стгмедиум** .</span><span class="sxs-lookup"><span data-stu-id="67617-309">The client creates a [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure and passes it to the [**GetData**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-getdata) method, and the data object returns the data in the provided **STGMEDIUM** structure.</span></span>

<span data-ttu-id="67617-310">Структура [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) позволяет клиентам и источникам данных выбирать наиболее эффективный носитель Exchange.</span><span class="sxs-lookup"><span data-stu-id="67617-310">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure enables both clients and data sources to choose the most efficient exchange medium.</span></span> <span data-ttu-id="67617-311">Например, если данные для обмена имеют очень большой размер, источник данных может указывать дисковый носитель в качестве предпочтительного формата вместо основной памяти.</span><span class="sxs-lookup"><span data-stu-id="67617-311">For example, if the data to be exchanged is very large, the data source can indicate a disk-based medium as its preferred format, instead of main memory.</span></span> <span data-ttu-id="67617-312">Такая гибкость обеспечивает эффективный обмен данными, который может быть таким же быстрым, как и передача указателя на [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) или [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream).</span><span class="sxs-lookup"><span data-stu-id="67617-312">This flexibility enables efficient data exchanges that can be as fast as passing a pointer to an [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) or an [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream).</span></span> <span data-ttu-id="67617-313">Дополнительные сведения см. [в разделе Структура стгмедиум](the-stgmedium-structure.md).</span><span class="sxs-lookup"><span data-stu-id="67617-313">For more information, see [The STGMEDIUM Structure](the-stgmedium-structure.md).</span></span>

<span data-ttu-id="67617-314">Клиент источника данных может потребовать уведомления при изменении данных.</span><span class="sxs-lookup"><span data-stu-id="67617-314">A client of a data source may require notification when the data changes.</span></span> <span data-ttu-id="67617-315">COM обрабатывает уведомления об изменении данных с помощью объекта *приемника уведомлений* , который реализует интерфейс [**иадвисесинк**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink) .</span><span class="sxs-lookup"><span data-stu-id="67617-315">COM handles data-change notifications by using an *advise sink* object, which implements the [**IAdviseSink**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink) interface.</span></span> <span data-ttu-id="67617-316">Объект приемника уведомлений и интерфейс **иадвисесинк** реализуются клиентом, который передает указатель **иадвисесинк** в источник данных.</span><span class="sxs-lookup"><span data-stu-id="67617-316">The advise sink object and the **IAdviseSink** interface are implemented by the client, which passes an **IAdviseSink** pointer to the data source.</span></span> <span data-ttu-id="67617-317">Когда источник данных обнаруживает изменение в базовых данных, он вызывает метод **иадвисесинк** для уведомления клиента.</span><span class="sxs-lookup"><span data-stu-id="67617-317">When the data source detects a change in the underlying data, it calls an **IAdviseSink** method to notify the client.</span></span> <span data-ttu-id="67617-318">Дополнительные сведения см. в разделе [уведомление об изменении данных](data-notification.md).</span><span class="sxs-lookup"><span data-stu-id="67617-318">For more information, see [Data Notification](data-notification.md).</span></span>

## <a name="remoting"></a><span data-ttu-id="67617-319">Удаленное взаимодействие</span><span class="sxs-lookup"><span data-stu-id="67617-319">Remoting</span></span>

<span data-ttu-id="67617-320">Модель COM позволяет выполнять удаленное и распределенное вычисление.</span><span class="sxs-lookup"><span data-stu-id="67617-320">COM enables remote and distributed computation.</span></span> <span data-ttu-id="67617-321">*Удаленное взаимодействие интерфейсов* позволяет функции-члену возвращать указатель интерфейса на объект COM, который находится в другом процессе или на другом главном компьютере.</span><span class="sxs-lookup"><span data-stu-id="67617-321">*Interface remoting* enables a member function to return an interface pointer to a COM object that is in a different process or on a different host computer.</span></span> <span data-ttu-id="67617-322">Инфраструктура, которая выполняет удаленное взаимодействие интерфейсов, прозрачна как для клиента, так и для сервера объектов.</span><span class="sxs-lookup"><span data-stu-id="67617-322">The infrastructure that performs the interface remoting is transparent to both the client and the object server.</span></span> <span data-ttu-id="67617-323">Ни клиент, ни сервер не нуждаются в сведениях о развертывании другого, чтобы взаимодействовать через удаленный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="67617-323">Neither the client nor the server need one another's deployment details to communicate through a remoted interface.</span></span> <span data-ttu-id="67617-324">Клиент вызывает функции-члены для того же интерфейса, чтобы взаимодействовать с COM-объектом, который находится в процессе, вне процесса на локальном узле или на удаленном компьютере.</span><span class="sxs-lookup"><span data-stu-id="67617-324">A client calls member functions on the same interface to communicate with a COM object that is in-process, out-of-process on the local host, or on a remote computer.</span></span> <span data-ttu-id="67617-325">Локальные и удаленные вызовы на одном интерфейсе неразличимы для клиента.</span><span class="sxs-lookup"><span data-stu-id="67617-325">Local and remote calls on the same interface are indistinguishable to the client.</span></span>

<span data-ttu-id="67617-326">Для взаимодействия с COM-объектом клиент всегда вызывает внутрипроцессный метод.</span><span class="sxs-lookup"><span data-stu-id="67617-326">To communicate with a COM object, a client always calls an in-process implementation.</span></span> <span data-ttu-id="67617-327">Если COM-объект находится в процессе, вызов осуществляется напрямую.</span><span class="sxs-lookup"><span data-stu-id="67617-327">If the COM object is in-process, the call is direct.</span></span> <span data-ttu-id="67617-328">Если COM-объект находится вне процесса или удаленно, COM предоставляет реализацию *прокси-сервера* , которая перенаправляет вызов объекта с помощью протокола удаленного вызова процедур (RPC).</span><span class="sxs-lookup"><span data-stu-id="67617-328">If the COM object is out-of-process or remote, COM provides a *proxy* implementation that forwards the call to the object by using the Remote Procedure Call (RPC) protocol.</span></span>

<span data-ttu-id="67617-329">COM-объект всегда получает вызовы от клиента с помощью внутрипроцессного метода.</span><span class="sxs-lookup"><span data-stu-id="67617-329">A COM object always receives calls from a client through an in-process implementation.</span></span> <span data-ttu-id="67617-330">Если вызывающий объект находится в процессе, вызов осуществляется напрямую.</span><span class="sxs-lookup"><span data-stu-id="67617-330">If the caller is in-process, the call is direct.</span></span> <span data-ttu-id="67617-331">Если вызывающий объект находится вне процесса или удаленно, COM предоставляет реализацию *заглушки* , которая получает удаленный вызов процедуры от прокси-сервера в клиентском процессе.</span><span class="sxs-lookup"><span data-stu-id="67617-331">If the caller is out-of-process or remote, COM provides a *stub* implementation that receives the remote procedure call from the proxy in the client process.</span></span>

<span data-ttu-id="67617-332">*Маршалирование* — это процедура упаковки стека вызовов для передачи из прокси-сервера в заглушку.</span><span class="sxs-lookup"><span data-stu-id="67617-332">*Marshaling* is the procedure for packaging the call stack for transmission from proxy to stub.</span></span> <span data-ttu-id="67617-333">*Распаковка* — это распаковка, которая происходит в принимающей стороне.</span><span class="sxs-lookup"><span data-stu-id="67617-333">*Unmarshaling* is the unpackaging that occurs at the receiving end.</span></span> <span data-ttu-id="67617-334">Возвращаемые значения маршалируются и расмаршалируются из заглушки в прокси-сервер.</span><span class="sxs-lookup"><span data-stu-id="67617-334">Return values are marshaled and unmarshaled from the stub to the proxy.</span></span> <span data-ttu-id="67617-335">Такой тип взаимодействия также называется отправкой вызова *по каналу* передачи.</span><span class="sxs-lookup"><span data-stu-id="67617-335">This kind of communication is also referred to as sending a call *over the wire*.</span></span>

<span data-ttu-id="67617-336">Каждый тип данных имеет правила для маршалирования.</span><span class="sxs-lookup"><span data-stu-id="67617-336">Each different data type has rules for marshaling.</span></span> <span data-ttu-id="67617-337">Указатели интерфейса также имеют протокол маршалирования, который инкапсулируется в функцию [**комаршалинтерфаце**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) .</span><span class="sxs-lookup"><span data-stu-id="67617-337">Interface pointers also have a marshaling protocol, which is encapsulated in the [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) function.</span></span> <span data-ttu-id="67617-338">В большинстве случаев достаточно реализовать *стандартную упаковку интерфейса*, предоставляемую системой, но COM-объект может реализовывать *настраиваемый пользовательский интерфейс* , чтобы управлять созданием удаленных прокси объектов.</span><span class="sxs-lookup"><span data-stu-id="67617-338">In most cases, *standard interface marshaling*, which is provided by the system, is sufficient, but a COM object optionally may implement *custom interface marshaling* to control the creation of remote object proxies to itself.</span></span> <span data-ttu-id="67617-339">Дополнительные сведения см. в разделе [Обмен данными между объектами](inter-object-communication.md).</span><span class="sxs-lookup"><span data-stu-id="67617-339">For more information, see [Inter-Object Communication](inter-object-communication.md).</span></span>

## <a name="security"></a><span data-ttu-id="67617-340">Безопасность</span><span class="sxs-lookup"><span data-stu-id="67617-340">Security</span></span>

<span data-ttu-id="67617-341">Модель COM предоставляет две формы безопасности приложений.</span><span class="sxs-lookup"><span data-stu-id="67617-341">COM provides two forms of application security.</span></span> <span data-ttu-id="67617-342">Одна из них — *Безопасность активации*, которая указывает, как создаются новые объекты, как клиенты подключаются к новым и существующим объектам и каким образом защищаются определенные общедоступные службы, такие как таблица классов и выполняемая таблица объектов.</span><span class="sxs-lookup"><span data-stu-id="67617-342">One is *activation security*, which specifies how new objects are created, how clients connect to new and existing objects, and how certain public services, such as the Class Table and the Running Object Table are secured.</span></span> <span data-ttu-id="67617-343">Другой — *вызов безопасности*, который указывает, как безопасность работает в установленном соединении между клиентом и COM-объектом.</span><span class="sxs-lookup"><span data-stu-id="67617-343">The other is *call security*, which specifies how security operates in an established connection between a client to a COM object.</span></span>

<span data-ttu-id="67617-344">Безопасность активации автоматически применяется диспетчером управления службами (SCM).</span><span class="sxs-lookup"><span data-stu-id="67617-344">Activation security is applied automatically by the Service Control Manager (SCM).</span></span> <span data-ttu-id="67617-345">Когда SCM получает запрос на получение COM-объекта, он проверяет запрос на соответствие сведениям о безопасности, хранящимся в реестре.</span><span class="sxs-lookup"><span data-stu-id="67617-345">When the SCM receives a request to retrieve a COM object, it checks the request against security information that is stored in the registry.</span></span>

<span data-ttu-id="67617-346">Реализации SCM обычно предлагают управляемую реестром конфигурацию для администрирования развернутых классов и для конкретных учетных записей пользователей на узле.</span><span class="sxs-lookup"><span data-stu-id="67617-346">SCM implementations usually offer registry-driven configuration for administering deployed classes and for specific user accounts on the host.</span></span> <span data-ttu-id="67617-347">Дополнительные сведения см. в разделе [Безопасность активации](activation-security.md).</span><span class="sxs-lookup"><span data-stu-id="67617-347">For more information, see [Activation Security](activation-security.md).</span></span>

<span data-ttu-id="67617-348">Безопасность вызовов применяется автоматически или обеспечивается приложением.</span><span class="sxs-lookup"><span data-stu-id="67617-348">Call security is applied automatically or is enforced by the application.</span></span> <span data-ttu-id="67617-349">Если приложение предоставляет сведения о настройке, COM выполняет необходимые проверки для защиты приложения.</span><span class="sxs-lookup"><span data-stu-id="67617-349">If the application provides setup information, COM performs the necessary checks to secure the application.</span></span>

<span data-ttu-id="67617-350">Механизм автоматического выполнения проверяет безопасность процесса, но не для отдельных объектов или методов.</span><span class="sxs-lookup"><span data-stu-id="67617-350">The automatic mechanism checks security for the process, but not for individual objects or methods.</span></span> <span data-ttu-id="67617-351">Если приложению требуется более детализированная безопасность, COM предоставляет функции, которые могут использоваться приложениями для собственной проверки безопасности.</span><span class="sxs-lookup"><span data-stu-id="67617-351">If an application requires more fine-grained security, COM provides functions that applications may use do their own security checking.</span></span>

<span data-ttu-id="67617-352">Автоматические и настраиваемые механизмы можно использовать совместно, поэтому приложение может попросить COM выполнить автоматическую проверку безопасности, а затем выполнить собственную.</span><span class="sxs-lookup"><span data-stu-id="67617-352">The automatic and custom mechanisms can be used together, so an application may ask COM to perform automatic security checking and then perform its own.</span></span>

<span data-ttu-id="67617-353">Службы безопасности вызовов COM делятся на следующие категории:</span><span class="sxs-lookup"><span data-stu-id="67617-353">COM call security services are divided into the following categories:</span></span>

-   <span data-ttu-id="67617-354">Общие функции, вызываемые как клиентами, так и серверами, которые позволяют регистрировать автоматический механизм безопасности и службы автоматической проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="67617-354">General functions that are called by both clients and servers, which enable the automatic security mechanism to be initialized and automatic authentication services to be registered.</span></span> <span data-ttu-id="67617-355">Общие интерфейсы API безопасности вызовов — это функции [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) и [**кокуеряусентикатионсервицес**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryauthenticationservices) .</span><span class="sxs-lookup"><span data-stu-id="67617-355">The general call security APIs are the [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) and [**CoQueryAuthenticationServices**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryauthenticationservices) functions.</span></span>
-   <span data-ttu-id="67617-356">Интерфейсы на клиентских прокси, которые позволяют клиенту управлять безопасностью при вызовах отдельных интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="67617-356">Interfaces on client proxies, which enable the client to control the security on calls to individual interfaces.</span></span> <span data-ttu-id="67617-357">Интерфейсы [**иклиентсекурити**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) и функции [**кокуерипроксибланкет**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryproxyblanket), [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)и [**кокопипрокси**](/windows/desktop/api/combaseapi/nf-combaseapi-cocopyproxy) обеспечивают безопасность вызовов удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="67617-357">The [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) interface and the [**CoQueryProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryproxyblanket), [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket), and [**CoCopyProxy**](/windows/desktop/api/combaseapi/nf-combaseapi-cocopyproxy) functions provide call security on a remote object.</span></span>
-   <span data-ttu-id="67617-358">Функции на стороне сервера и интерфейсы контекста вызова, которые позволяют серверу получать сведения о безопасности вызова и олицетворять вызывающего.</span><span class="sxs-lookup"><span data-stu-id="67617-358">Server-side functions and call-context interfaces, which enable the server to retrieve security information about a call and to impersonate the caller.</span></span> <span data-ttu-id="67617-359">Интерфейс [**исерверсекурити**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) и функции [**кожеткаллконтекст**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext), [**коимперсонатеклиент**](/windows/desktop/api/combaseapi/nf-combaseapi-coimpersonateclient)и [**кореверттоселф**](/windows/desktop/api/combaseapi/nf-combaseapi-coreverttoself) обеспечивают безопасность вызовов на стороне сервера.</span><span class="sxs-lookup"><span data-stu-id="67617-359">The [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) interface and the [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext), [**CoImpersonateClient**](/windows/desktop/api/combaseapi/nf-combaseapi-coimpersonateclient), and [**CoRevertToSelf**](/windows/desktop/api/combaseapi/nf-combaseapi-coreverttoself) functions provide server-side call security.</span></span>

<span data-ttu-id="67617-360">Часто клиент запрашивает COM-объект для интерфейса [**иклиентсекурити**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) , который реализуется локально на уровне удаленного взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="67617-360">Often, the client queries the COM object for the [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) interface, which is implemented locally by the remoting layer.</span></span> <span data-ttu-id="67617-361">Клиент использует этот интерфейс для управления безопасностью отдельных прокси-серверов интерфейса объекта COM перед выполнением вызова в одном из интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="67617-361">The client uses this interface to control the security of individual interface proxies on the COM object before making a call on one of the interfaces.</span></span>

<span data-ttu-id="67617-362">При поступлении вызова на сервер сервер может вызвать функцию [**кожеткаллконтекст**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext) для получения интерфейса [**исерверсекурити**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) , который позволяет серверу проверять проверку подлинности клиента и олицетворять клиента при необходимости.</span><span class="sxs-lookup"><span data-stu-id="67617-362">When a call arrives at the server, the server may call the [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext) function to retrieve an [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) interface, which allows the server to check the client's authentication and to impersonate the client, if necessary.</span></span> <span data-ttu-id="67617-363">Объект **исерверсекурити** действителен на время вызова.</span><span class="sxs-lookup"><span data-stu-id="67617-363">The **IServerSecurity** object is valid for the duration of the call.</span></span>

<span data-ttu-id="67617-364">Вызовите функцию [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) , чтобы инициализировать уровень безопасности и задать указанные значения по умолчанию для безопасности.</span><span class="sxs-lookup"><span data-stu-id="67617-364">Call the [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) function to initialize the security layer and set the specified values as the security default.</span></span> <span data-ttu-id="67617-365">Если процесс не вызывает **CoInitializeSecurity**, COM вызывает его автоматически при первом маршалировании или распаковке интерфейса, регистрируя системную безопасность по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="67617-365">If a process does not call **CoInitializeSecurity**, COM calls it automatically the first time an interface is marshaled or unmarshaled, registering the system default security.</span></span> <span data-ttu-id="67617-366">Функция **CoInitializeSecurity** позволяет клиенту установить безопасность вызова по умолчанию для процесса, что позволяет избежать использования [**иклиентсекурити**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) для отдельных прокси-серверов.</span><span class="sxs-lookup"><span data-stu-id="67617-366">The **CoInitializeSecurity** function allows the client to establish default call security for the process, which avoids the use of [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) on individual proxies.</span></span> <span data-ttu-id="67617-367">Функция **CoInitializeSecurity** позволяет серверу регистрировать автоматические службы проверки подлинности для процесса.</span><span class="sxs-lookup"><span data-stu-id="67617-367">The **CoInitializeSecurity** function enables a server to register automatic authentication services for the process.</span></span> <span data-ttu-id="67617-368">Дополнительные сведения см. в разделе [Настройка безопасности Process-Wide с помощью CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span><span class="sxs-lookup"><span data-stu-id="67617-368">For more information, see [Setting Process-Wide Security with CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="67617-369">См. также</span><span class="sxs-lookup"><span data-stu-id="67617-369">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="67617-370">COM-клиенты и серверы</span><span class="sxs-lookup"><span data-stu-id="67617-370">COM Clients and Servers</span></span>](com-clients-and-servers.md)
</dt> <dt>

[<span data-ttu-id="67617-371">Определение COM-интерфейсов</span><span class="sxs-lookup"><span data-stu-id="67617-371">Defining COM Interfaces</span></span>](defining-com-interfaces.md)
</dt> <dt>

[<span data-ttu-id="67617-372">Регистрация приложений COM</span><span class="sxs-lookup"><span data-stu-id="67617-372">Registering COM Applications</span></span>](registering-com-applications.md)
</dt> <dt>

[<span data-ttu-id="67617-373">Безопасность в COM</span><span class="sxs-lookup"><span data-stu-id="67617-373">Security in COM</span></span>](security-in-com.md)
</dt> <dt>

[<span data-ttu-id="67617-374">Процессы, потоки и подразделения</span><span class="sxs-lookup"><span data-stu-id="67617-374">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> </dl>

 

 
