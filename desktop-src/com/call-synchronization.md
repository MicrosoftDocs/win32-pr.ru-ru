---
title: Синхронизация вызовов
description: Синхронизация вызовов
ms.assetid: e74407ef-f500-4d13-aef4-ca6bb37d5858
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ec9254aceaaa8a6fa26d56d4a86987cc955b90dc
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104070687"
---
# <a name="call-synchronization"></a><span data-ttu-id="287e2-103">Синхронизация вызовов</span><span class="sxs-lookup"><span data-stu-id="287e2-103">Call Synchronization</span></span>

<span data-ttu-id="287e2-104">Приложения COM должны уметь правильно работать с вводом данных при обработке одного или нескольких вызовов из COM или операционной системы.</span><span class="sxs-lookup"><span data-stu-id="287e2-104">COM applications must be able to deal correctly with user input while processing one or more calls from COM or the operating system.</span></span> <span data-ttu-id="287e2-105">COM обеспечивает синхронизацию вызовов только для однопотоковых апартаментов.</span><span class="sxs-lookup"><span data-stu-id="287e2-105">COM provides call synchronization for single-threaded apartments only.</span></span> <span data-ttu-id="287e2-106">Многопоточные подразделения (содержащие свободные потоки) не получают вызовы при выполнении вызовов (в одном потоке).</span><span class="sxs-lookup"><span data-stu-id="287e2-106">Multithreaded apartments (containing free-threaded threads) do not receive calls while making calls (on the same thread).</span></span> <span data-ttu-id="287e2-107">Многопоточные подразделения не могут выполнять входные синхронизированные вызовы.</span><span class="sxs-lookup"><span data-stu-id="287e2-107">Multithreaded apartments cannot make input synchronized calls.</span></span> <span data-ttu-id="287e2-108">Асинхронные вызовы преобразуются в синхронные вызовы в многопоточных апартаментах.</span><span class="sxs-lookup"><span data-stu-id="287e2-108">Asynchronous calls are converted to synchronous calls in multithreaded apartments.</span></span> <span data-ttu-id="287e2-109">Фильтр сообщений не вызывается ни для одного потока в многопоточном апартаменте.</span><span class="sxs-lookup"><span data-stu-id="287e2-109">The message filter is not called for any thread in a multithreaded apartment.</span></span> <span data-ttu-id="287e2-110">Дополнительные сведения о проблемах с потоками см. в разделе [процессы, потоки и подразделения](processes--threads--and-apartments.md).</span><span class="sxs-lookup"><span data-stu-id="287e2-110">For more information about threading issues, see [Processes, Threads, and Apartments](processes--threads--and-apartments.md).</span></span>

<span data-ttu-id="287e2-111">Вызовы COM между процессами делятся на три категории следующим образом:</span><span class="sxs-lookup"><span data-stu-id="287e2-111">COM calls between processes fall into three categories, as follows:</span></span>

<dl> <dt>

<span data-ttu-id="287e2-112"><span id="Synchronous_calls"></span><span id="synchronous_calls"></span><span id="SYNCHRONOUS_CALLS"></span>*Синхронные вызовы*</span><span class="sxs-lookup"><span data-stu-id="287e2-112"><span id="Synchronous_calls"></span><span id="synchronous_calls"></span><span id="SYNCHRONOUS_CALLS"></span>*Synchronous calls*</span></span>
</dt> <dd>

<span data-ttu-id="287e2-113">Большая часть взаимодействия, выполняемого в модели COM, является синхронной.</span><span class="sxs-lookup"><span data-stu-id="287e2-113">Most of the communication that takes place within COM is synchronous.</span></span> <span data-ttu-id="287e2-114">При выполнении синхронных вызовов вызывающий объект ждет ответа перед продолжением и сможет принимать входящие сообщения в ожидании.</span><span class="sxs-lookup"><span data-stu-id="287e2-114">When making synchronous calls, the caller waits for the reply before continuing and can receive incoming messages while waiting.</span></span> <span data-ttu-id="287e2-115">COM входит в модальный цикл для ожидания ответа, получения и отправки других сообщений управляемым способом.</span><span class="sxs-lookup"><span data-stu-id="287e2-115">COM enters a modal loop to wait for the reply, receiving and dispatching other messages in a controlled manner.</span></span>

</dd> <dt>

<span data-ttu-id="287e2-116"><span id="Asynchronous_notifications"></span><span id="asynchronous_notifications"></span><span id="ASYNCHRONOUS_NOTIFICATIONS"></span>*Асинхронные уведомления*</span><span class="sxs-lookup"><span data-stu-id="287e2-116"><span id="Asynchronous_notifications"></span><span id="asynchronous_notifications"></span><span id="ASYNCHRONOUS_NOTIFICATIONS"></span>*Asynchronous notifications*</span></span>
</dt> <dd>

<span data-ttu-id="287e2-117">При отправке асинхронных уведомлений вызывающий объект не ждет ответа.</span><span class="sxs-lookup"><span data-stu-id="287e2-117">When sending asynchronous notifications, the caller does not wait for the reply.</span></span> <span data-ttu-id="287e2-118">COM использует события на основе [**сообщений**](/windows/win32/api/winuser/nf-winuser-postmessagea) или высокого уровня для отправки асинхронных уведомлений в зависимости от платформы.</span><span class="sxs-lookup"><span data-stu-id="287e2-118">COM uses [**PostMessage**](/windows/win32/api/winuser/nf-winuser-postmessagea) or high-level events to send asynchronous notifications, depending on the platform.</span></span> <span data-ttu-id="287e2-119">COM определяет пять асинхронных методов [**иадвисесинк**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink):</span><span class="sxs-lookup"><span data-stu-id="287e2-119">COM defines five asynchronous methods of [**IAdviseSink**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink):</span></span>

-   [<span data-ttu-id="287e2-120">**ондатачанже**</span><span class="sxs-lookup"><span data-stu-id="287e2-120">**OnDataChange**</span></span>](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-ondatachange)
-   [<span data-ttu-id="287e2-121">**онвиевчанже**</span><span class="sxs-lookup"><span data-stu-id="287e2-121">**OnViewChange**</span></span>](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onviewchange)
-   [<span data-ttu-id="287e2-122">**Onrename**</span><span class="sxs-lookup"><span data-stu-id="287e2-122">**OnRename**</span></span>](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onrename)
-   [<span data-ttu-id="287e2-123">**OnSave**</span><span class="sxs-lookup"><span data-stu-id="287e2-123">**OnSave**</span></span>](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onsave)
-   [<span data-ttu-id="287e2-124">**OnClose**</span><span class="sxs-lookup"><span data-stu-id="287e2-124">**OnClose**</span></span>](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onclose)

> [!Note]  
> <span data-ttu-id="287e2-125">Хотя COM обрабатывает асинхронный вызов, синхронные вызовы не могут быть выполнены.</span><span class="sxs-lookup"><span data-stu-id="287e2-125">While COM is processing an asynchronous call, synchronous calls cannot be made.</span></span> <span data-ttu-id="287e2-126">Например, реализация [**ондатачанже**](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-ondatachange) приложения-контейнера не может содержать вызов [**Иперсистстораже:: Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersiststorage-save).</span><span class="sxs-lookup"><span data-stu-id="287e2-126">For example, a container application's implementation of [**OnDataChange**](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-ondatachange) cannot contain a call to [**IPersistStorage::Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersiststorage-save).</span></span> <span data-ttu-id="287e2-127">Эти вызовы являются единственными асинхронными вызовами, поддерживаемыми COM.</span><span class="sxs-lookup"><span data-stu-id="287e2-127">These calls are the only asynchronous calls supported by COM.</span></span> <span data-ttu-id="287e2-128">В настоящее время невозможно создать настраиваемый интерфейс, который является асинхронным.</span><span class="sxs-lookup"><span data-stu-id="287e2-128">There is no way to create a custom interface that is asynchronous at this time.</span></span>

 

</dd> <dt>

<span data-ttu-id="287e2-129"><span id="Input-synchronized_calls"></span><span id="input-synchronized_calls"></span><span id="INPUT-SYNCHRONIZED_CALLS"></span>*Синхронные вызовы входных данных*</span><span class="sxs-lookup"><span data-stu-id="287e2-129"><span id="Input-synchronized_calls"></span><span id="input-synchronized_calls"></span><span id="INPUT-SYNCHRONIZED_CALLS"></span>*Input-synchronized calls*</span></span>
</dt> <dd>

<span data-ttu-id="287e2-130">При выполнении вызовов, синхронизированных с входом, объект, вызываемый, должен завершить вызов до получения элемента управления.</span><span class="sxs-lookup"><span data-stu-id="287e2-130">When making input-synchronized calls, the object called must complete the call before yielding control.</span></span> <span data-ttu-id="287e2-131">Это гарантирует, что управление фокусом работает правильно и данные, введенные пользователем, обрабатываются соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="287e2-131">This helps ensure that focus management works correctly and that data entered by the user is processed appropriately.</span></span> <span data-ttu-id="287e2-132">Эти вызовы делаются COM через функцию [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) без входа в модальный цикл.</span><span class="sxs-lookup"><span data-stu-id="287e2-132">These calls are made by COM through the [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) function, without entering a modal loop.</span></span> <span data-ttu-id="287e2-133">При обработке синхронизированного вызова объект не должен вызывать ни одну функцию или метод (включая синхронные методы), которые могут привести к управлению.</span><span class="sxs-lookup"><span data-stu-id="287e2-133">While processing an input-synchronized call, the object called must not call any function or method (including synchronous methods) that might yield control.</span></span> <span data-ttu-id="287e2-134">Следующие методы являются синхронизированными входными данными</span><span class="sxs-lookup"><span data-stu-id="287e2-134">The following methods are input synchronized</span></span>

-   [<span data-ttu-id="287e2-135">**Иолевиндов::/Window**</span><span class="sxs-lookup"><span data-stu-id="287e2-135">**IOleWindow::GetWindow**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-iolewindow-getwindow)
-   [<span data-ttu-id="287e2-136">**Метода IOleInPlaceActiveObject:: OnFrameWindowActivate**</span><span class="sxs-lookup"><span data-stu-id="287e2-136">**IOleInPlaceActiveObject::OnFrameWindowActivate**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceactiveobject-onframewindowactivate)
-   [<span data-ttu-id="287e2-137">**Метода IOleInPlaceActiveObject:: OnDocWindowActivate**</span><span class="sxs-lookup"><span data-stu-id="287e2-137">**IOleInPlaceActiveObject::OnDocWindowActivate**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceactiveobject-ondocwindowactivate)
-   [<span data-ttu-id="287e2-138">**Метода IOleInPlaceActiveObject:: ResizeBorder**</span><span class="sxs-lookup"><span data-stu-id="287e2-138">**IOleInPlaceActiveObject::ResizeBorder**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceactiveobject-resizeborder)
-   [<span data-ttu-id="287e2-139">**Иолеинплацеуивиндов:: награница**</span><span class="sxs-lookup"><span data-stu-id="287e2-139">**IOleInPlaceUIWindow::GetBorder**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceuiwindow-getborder)
-   [<span data-ttu-id="287e2-140">**Иолеинплацеуивиндов:: Рекуестбордерспаце**</span><span class="sxs-lookup"><span data-stu-id="287e2-140">**IOleInPlaceUIWindow::RequestBorderSpace**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceuiwindow-requestborderspace)
-   [<span data-ttu-id="287e2-141">**Иолеинплацеуивиндов:: Сетбордерспаце**</span><span class="sxs-lookup"><span data-stu-id="287e2-141">**IOleInPlaceUIWindow::SetBorderSpace**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceuiwindow-setborderspace)
-   [<span data-ttu-id="287e2-142">**Иолеинплацефраме:: Сетмену**</span><span class="sxs-lookup"><span data-stu-id="287e2-142">**IOleInPlaceFrame::SetMenu**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceframe-setmenu)
-   [<span data-ttu-id="287e2-143">**Иолеинплацефраме:: Сетстатустекст**</span><span class="sxs-lookup"><span data-stu-id="287e2-143">**IOleInPlaceFrame::SetStatusText**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceframe-setstatustext)
-   [<span data-ttu-id="287e2-144">**Иолеинплацеобжект:: Сетобжектректс**</span><span class="sxs-lookup"><span data-stu-id="287e2-144">**IOleInPlaceObject::SetObjectRects**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceobject-setobjectrects)

</dd> </dl>

<span data-ttu-id="287e2-145">Чтобы избежать проблем, которые могут возникнуть при асинхронной обработке сообщений, большинство вызовов COM-методов являются синхронными.</span><span class="sxs-lookup"><span data-stu-id="287e2-145">To minimize problems that can arise from asynchronous message processing, the majority of COM method calls are synchronous.</span></span> <span data-ttu-id="287e2-146">При синхронном обмене не требуется специальный код для отправки и обработки входящих сообщений.</span><span class="sxs-lookup"><span data-stu-id="287e2-146">With synchronous communication, there is no need for special code to dispatch and handle incoming messages.</span></span> <span data-ttu-id="287e2-147">Когда приложение выполняет синхронный вызов метода, COM входит в модальный цикл ожидания, который обрабатывает необходимые ответы и отправляет входящие сообщения приложениям, которые способны их обрабатывать.</span><span class="sxs-lookup"><span data-stu-id="287e2-147">When an application makes a synchronous method call, COM enters a modal wait loop that handles the required replies and dispatches incoming messages to applications capable of processing them.</span></span>

<span data-ttu-id="287e2-148">COM управляет вызовами методов путем присвоения идентификатора, называемого *идентификатором логического потока*.</span><span class="sxs-lookup"><span data-stu-id="287e2-148">COM manages method calls by assigning an identifier called a *logical thread ID*.</span></span> <span data-ttu-id="287e2-149">Новый назначается, когда пользователь выбирает команду меню или когда приложение инициирует новую операцию COM.</span><span class="sxs-lookup"><span data-stu-id="287e2-149">A new one is assigned when a user selects a menu command or when the application initiates a new COM operation.</span></span> <span data-ttu-id="287e2-150">Последующие вызовы, связанные с первоначальным вызовом COM, присваиваются тому же ИДЕНТИФИКАТОРу логического потока, что и начальный вызов.</span><span class="sxs-lookup"><span data-stu-id="287e2-150">Subsequent calls that relate to the initial COM call are assigned the same logical thread ID as the initial call.</span></span>

 

 