---
title: Многопоточные подразделения
description: Многопоточные подразделения
ms.assetid: d3e6acd9-cd5c-4a2c-8526-4f43db3b606b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dc2594f9341fc662b068fb7e007e538282a31273
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "105681704"
---
# <a name="multithreaded-apartments"></a><span data-ttu-id="1d2c5-103">Многопоточные подразделения</span><span class="sxs-lookup"><span data-stu-id="1d2c5-103">Multithreaded Apartments</span></span>

<span data-ttu-id="1d2c5-104">В многопоточной модели апартамента все потоки в процессе, которые были инициализированы как свободные, находятся в одном апартаменте.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-104">In a multithreaded apartment model, all the threads in the process that have been initialized as free-threaded reside in a single apartment.</span></span> <span data-ttu-id="1d2c5-105">Поэтому нет необходимости выполнять маршалирование между потоками.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-105">Therefore, there is no need to marshal between threads.</span></span> <span data-ttu-id="1d2c5-106">Потокам не требуется получать и отправлять сообщения, так как COM не использует сообщения окна в этой модели.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-106">The threads need not retrieve and dispatch messages because COM does not use window messages in this model.</span></span>

<span data-ttu-id="1d2c5-107">Вызовы методов объектов в многопоточном апартаменте могут выполняться в любом потоке в апартаменте.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-107">Calls to methods of objects in the multithreaded apartment can be run on any thread in the apartment.</span></span> <span data-ttu-id="1d2c5-108">Сериализация вызовов отсутствует; многие вызовы могут происходить с одним и тем же методом или с одним и тем же объектом одновременно.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-108">There is no serialization of calls; many calls may occur to the same method or to the same object simultaneously.</span></span> <span data-ttu-id="1d2c5-109">Объекты, созданные в многопоточном апартаменте, должны иметь возможность обрабатывать вызовы методов из других потоков в любое время.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-109">Objects created in the multithreaded apartment must be able to handle calls on their methods from other threads at any time.</span></span>

<span data-ttu-id="1d2c5-110">Поскольку вызовы объектов не сериализуются каким-либо образом, параллельный параллелизм объектов обеспечивает наивысшую производительность и использует лучшее преимущество многопроцессорного оборудования для перекрестных потоков, кросс-процессов и вызовов между компьютерами.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-110">Because calls to objects are not serialized in any way, multithreaded object concurrency offers the highest performance and takes the best advantage of multiprocessor hardware for cross-thread, cross-process, and cross-machine calling.</span></span> <span data-ttu-id="1d2c5-111">Это означает, однако, что код объектов должен обеспечивать синхронизацию в своих реализациях интерфейса, как правило, с помощью примитивов синхронизации, таких как объекты событий, критические разделы, мьютексы или семафоры, которые описаны далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-111">This means, however, that the code for objects must provide synchronization in their interface implementations, typically through the use of synchronization primitives such as event objects, critical sections, mutexes, or semaphores, which are described later in this section.</span></span> <span data-ttu-id="1d2c5-112">Кроме того, поскольку объект не управляет временем существования потоков, обращающихся к нему, в объекте (локальное хранилище потока) не может храниться состояние конкретного потока.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-112">In addition, because the object doesn't control the lifetime of the threads that are accessing it, no thread-specific state may be stored in the object (in thread local storage).</span></span>

<span data-ttu-id="1d2c5-113">Ниже приведены некоторые важные соображения, касающиеся синхронизации многопоточных подразделения.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-113">Following are some important considerations regarding synchronization for multithreaded apartments:</span></span>

-   <span data-ttu-id="1d2c5-114">COM обеспечивает синхронизацию вызовов только для однопотоковых апартаментов.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-114">COM provides call synchronization for single-threaded apartments only.</span></span>
-   <span data-ttu-id="1d2c5-115">Многопоточные подразделения не получают вызовы при выполнении вызовов (в одном потоке).</span><span class="sxs-lookup"><span data-stu-id="1d2c5-115">Multithreaded apartments do not receive calls while making calls (on the same thread).</span></span>
-   <span data-ttu-id="1d2c5-116">Многопоточные подразделения не могут выполнять синхронизированные входные вызовы.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-116">Multithreaded apartments cannot make input-synchronized calls.</span></span>
-   <span data-ttu-id="1d2c5-117">Асинхронные вызовы преобразуются в синхронные вызовы в многопоточных апартаментах.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-117">Asynchronous calls are converted to synchronous calls in multithreaded apartments.</span></span>
-   <span data-ttu-id="1d2c5-118">Фильтр сообщений не вызывается ни для одного потока в многопоточном апартаменте.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-118">The message filter is not called for any thread in a multithreaded apartment.</span></span>

<span data-ttu-id="1d2c5-119">Чтобы инициализировать поток как свободный поток, вызовите [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), указав \_ многопоточность.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-119">To initialize a thread as free-threaded, call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), specifying COINIT\_MULTITHREADED.</span></span> <span data-ttu-id="1d2c5-120">Сведения о потоковой работе сервера в процессе см. [в разделе проблемы потоковой](in-process-server-threading-issues.md)обработки на сервере.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-120">For information on in-process server threading, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="1d2c5-121">Несколько клиентов могут одновременно вызывать, из разных потоков, объект, поддерживающий свободную потоковую связь.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-121">Multiple clients can simultaneously call, from different threads, an object that supports free-threading.</span></span> <span data-ttu-id="1d2c5-122">В свободных потоках внешние серверы, COM, через подсистему RPC создает пул потоков в серверном процессе и клиентский вызов (или несколько клиентских вызовов) может быть доставлен любым из этих потоков в любое время.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-122">In free-threaded out-of-process servers, COM, through the RPC subsystem, creates a pool of threads in the server process and a client call (or multiple client calls) can be delivered by any of these threads at any time.</span></span> <span data-ttu-id="1d2c5-123">Сервер вне процесса должен также реализовать синхронизацию в своей фабрике классов.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-123">An out-of-process server must also implement synchronization in its class factory.</span></span> <span data-ttu-id="1d2c5-124">В свободных потоках внутрипроцессный объект может принимать прямые вызовы из нескольких потоков клиента.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-124">Free-threaded, in-process objects can receive direct calls from multiple threads of the client.</span></span>

<span data-ttu-id="1d2c5-125">Клиент может работать с COM в нескольких потоках.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-125">The client can do COM work in multiple threads.</span></span> <span data-ttu-id="1d2c5-126">Все потоки принадлежат одному и тому же многопоточному подразделению.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-126">All threads belong to the same multithreaded apartment.</span></span> <span data-ttu-id="1d2c5-127">Указатели интерфейса передаются непосредственно из потока в поток в многопоточном апартаменте, поэтому указатели интерфейса не маршалируются между своими потоками.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-127">Interface pointers are passed directly from thread to thread within a multithreaded apartment, so interface pointers are not marshaled between its threads.</span></span> <span data-ttu-id="1d2c5-128">Фильтры сообщений (реализации [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) не используются в многопоточных подразделениях.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-128">Message filters (implementations of [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) are not used in multithreaded apartments.</span></span> <span data-ttu-id="1d2c5-129">Клиентский поток будет приостановлен при вызове COM-вызова объектов, находящихся вне апартамента, и возобновляться при возврате вызова.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-129">The client thread will suspend when it makes a COM call to out-of-apartment objects and will resume when the call returns.</span></span> <span data-ttu-id="1d2c5-130">Вызовы между процессами по-прежнему обрабатываются RPC.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-130">Calls between processes are still handled by RPC.</span></span>

<span data-ttu-id="1d2c5-131">Потоки, инициализированные с моделью в свободной потоковой модели, должны реализовывать собственную синхронизацию.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-131">Threads initialized with the free-threaded model must implement their own synchronization.</span></span> <span data-ttu-id="1d2c5-132">Как упоминалось ранее в этом разделе, Windows включает эту реализацию с помощью следующих примитивов синхронизации:</span><span class="sxs-lookup"><span data-stu-id="1d2c5-132">As mentioned earlier in this section, Windows enables this implementation through the following synchronization primitives:</span></span>

-   <span data-ttu-id="1d2c5-133">Объекты событий предоставляют способ сигнализации одного или нескольких потоков о произошедшем событии.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-133">Event objects provide a way of signaling one or more threads that an event has occurred.</span></span> <span data-ttu-id="1d2c5-134">Любой поток в процессе может создать объект события.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-134">Any thread within a process can create an event object.</span></span> <span data-ttu-id="1d2c5-135">Маркер события возвращается функцией создания события [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span><span class="sxs-lookup"><span data-stu-id="1d2c5-135">A handle to the event is returned by the event-creating function, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span></span> <span data-ttu-id="1d2c5-136">После создания объекта события потоки с маркером объекта могут ожидать его до продолжения выполнения.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-136">Once an event object has been created, threads with a handle to the object can wait on it before continuing execution.</span></span>
-   <span data-ttu-id="1d2c5-137">Критические разделы используются для раздела кода, который требует эксклюзивного доступа к определенному набору общих данных, прежде чем его можно будет выполнить и использовать только в потоках одного процесса.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-137">Critical sections are used for a section of code that requires exclusive access to some set of shared data before it can be executed and that is used only by the threads within a single process.</span></span> <span data-ttu-id="1d2c5-138">Критическая секция похожа на пересчет, через который может пройти только один поток за раз. он работает следующим образом:</span><span class="sxs-lookup"><span data-stu-id="1d2c5-138">A critical section is like a turnstile through which only one thread at a time may pass, working as follows:</span></span>
    -   <span data-ttu-id="1d2c5-139">Чтобы гарантировать, что ни один поток за раз обращается к общим данным, основной поток процесса выделяет глобальную КРИТическую \_ структуру данных секции и инициализирует ее члены.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-139">To ensure that no more than one thread at a time accesses shared data, a process's primary thread allocates a global CRITICAL\_SECTION data structure and initializes its members.</span></span> <span data-ttu-id="1d2c5-140">Поток, поступающий в критическую секцию, вызывает функцию [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) и изменяет элементы структуры данных.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-140">A thread entering a critical section calls the [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) function and modifies the data structure's members.</span></span>
    -   <span data-ttu-id="1d2c5-141">Поток, пытающийся войти в критическую секцию, вызывает [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) , который проверяет, была ли \_ изменена структура данных критической секции.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-141">A thread attempting to enter a critical section calls [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) which checks to see whether the CRITICAL\_SECTION data structure has been modified.</span></span> <span data-ttu-id="1d2c5-142">В этом случае другой поток находится в критическом разделе, а следующий поток помещается в спящий режим.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-142">If so, another thread is currently in the critical section and the subsequent thread is put to sleep.</span></span> <span data-ttu-id="1d2c5-143">Поток, который выходит из критической секции, вызывает [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), который сбрасывает структуру данных.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-143">A thread leaving a critical section calls [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), which resets the data structure.</span></span> <span data-ttu-id="1d2c5-144">Когда поток покидает критическую секцию, система пробуждает один из спящих потоков, который затем входит в критическую секцию.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-144">When a thread leaves a critical section, the system wakes one of the sleeping threads, which then enters the critical section.</span></span>
-   <span data-ttu-id="1d2c5-145">Мьютексы выполняют ту же функцию, что и критическая секция, за исключением того, что мьютекс доступен для потоков, выполняющихся в разных процессах.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-145">Mutexes performs the same function as a critical section, except that the mutex is accessible to threads running in different processes.</span></span> <span data-ttu-id="1d2c5-146">Владелец объекта Mutex похож на пол в споре.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-146">Owning a mutex object is like having the floor in a debate.</span></span> <span data-ttu-id="1d2c5-147">Процесс создает объект мьютекса, вызывая функцию [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) , которая возвращает маркер.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-147">A process creates a mutex object by calling the [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) function, which returns a handle.</span></span> <span data-ttu-id="1d2c5-148">Первый поток, запрашивающий объект Mutex, получает его владение.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-148">The first thread requesting a mutex object obtains ownership of it.</span></span> <span data-ttu-id="1d2c5-149">Когда поток завершился с мьютексом, владение передается другим потокам на основе первого поступления.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-149">When the thread has finished with the mutex, ownership passes to other threads on a first-come, first-served basis.</span></span>
-   <span data-ttu-id="1d2c5-150">Семафоры используются для поддержания счетчика ссылок на некоторый доступный ресурс.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-150">Semaphores are used to maintain a reference count on some available resource.</span></span> <span data-ttu-id="1d2c5-151">Поток создает семафор для ресурса, вызывая функцию [**createsemaphore-**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) и передавая указатель на ресурс, начальное число ресурсов и максимальное число ресурсов.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-151">A thread creates a semaphore for a resource by calling the [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) function and passing a pointer to the resource, an initial resource count, and the maximum resource count.</span></span> <span data-ttu-id="1d2c5-152">Эта функция возвращает маркер.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-152">This function returns a handle.</span></span> <span data-ttu-id="1d2c5-153">Поток, запрашивающий ресурс, передает его обработчик семафора в вызове функции [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) .</span><span class="sxs-lookup"><span data-stu-id="1d2c5-153">A thread requesting a resource passes its semaphore handle in a call to the [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) function.</span></span> <span data-ttu-id="1d2c5-154">Объект семафора опрашивает ресурс, чтобы определить, доступен ли он.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-154">The semaphore object polls the resource to determine whether it is available.</span></span> <span data-ttu-id="1d2c5-155">В этом случае семафор уменьшает число ресурсов и пробуждает ожидающий поток.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-155">If so, the semaphore decrements the resource count and wakes the waiting thread.</span></span> <span data-ttu-id="1d2c5-156">Если значение счетчика равно нулю, поток остается в спящем режиме до тех пор, пока другой поток не освободит ресурс, в результате чего семафор увеличит число до одного.</span><span class="sxs-lookup"><span data-stu-id="1d2c5-156">If the count is zero, the thread remains asleep until another thread releases a resource, causing the semaphore to increment the count to one.</span></span>

## <a name="related-topics"></a><span data-ttu-id="1d2c5-157">См. также</span><span class="sxs-lookup"><span data-stu-id="1d2c5-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="1d2c5-158">Доступ к интерфейсам в разных апартаментах</span><span class="sxs-lookup"><span data-stu-id="1d2c5-158">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="1d2c5-159">Выбор потоковой модели</span><span class="sxs-lookup"><span data-stu-id="1d2c5-159">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="1d2c5-160">Проблемы потоковой обработки в процессе сервера</span><span class="sxs-lookup"><span data-stu-id="1d2c5-160">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="1d2c5-161">Процессы, потоки и подразделения</span><span class="sxs-lookup"><span data-stu-id="1d2c5-161">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="1d2c5-162">Однопотоковое и многопоточное взаимодействие</span><span class="sxs-lookup"><span data-stu-id="1d2c5-162">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[<span data-ttu-id="1d2c5-163">Подразделения с одним потоком</span><span class="sxs-lookup"><span data-stu-id="1d2c5-163">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
</dt> </dl>

 

 