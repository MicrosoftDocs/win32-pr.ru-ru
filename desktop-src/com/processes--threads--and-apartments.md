---
title: Процессы, потоки и подразделения
description: Процесс — это коллекция пространства виртуальной памяти, кода, данных и системных ресурсов.
ms.assetid: cb62412a-d079-40f9-89dc-cce0bf3889af
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d598fc9d7dd39ab070b58aa7ba45a6e2fcae90db
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "104413801"
---
# <a name="processes-threads-and-apartments"></a><span data-ttu-id="754fd-103">Процессы, потоки и подразделения</span><span class="sxs-lookup"><span data-stu-id="754fd-103">Processes, Threads, and Apartments</span></span>

<span data-ttu-id="754fd-104">*Процесс* — это коллекция пространства виртуальной памяти, кода, данных и системных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="754fd-104">A *process* is a collection of virtual memory space, code, data, and system resources.</span></span> <span data-ttu-id="754fd-105">*Поток* — это код, который должен быть последовательно выполнен внутри процесса.</span><span class="sxs-lookup"><span data-stu-id="754fd-105">A *thread* is code that is to be serially executed within a process.</span></span> <span data-ttu-id="754fd-106">Процессор выполняет потоки, а не процессы, поэтому каждое приложение имеет по крайней мере один процесс, и процесс всегда имеет по крайней мере один поток выполнения, известный как основной поток.</span><span class="sxs-lookup"><span data-stu-id="754fd-106">A processor executes threads, not processes, so each application has at least one process, and a process always has at least one thread of execution, known as the primary thread.</span></span> <span data-ttu-id="754fd-107">В дополнение к основному потоку в процессе может быть несколько потоков.</span><span class="sxs-lookup"><span data-stu-id="754fd-107">A process can have multiple threads in addition to the primary thread.</span></span>

<span data-ttu-id="754fd-108">Процессы взаимодействуют друг с другом через сообщения, используя технологию удаленного вызова процедур (RPC) корпорации Майкрософт для передачи информации друг другу.</span><span class="sxs-lookup"><span data-stu-id="754fd-108">Processes communicate with one another through messages, using Microsoft's Remote Procedure Call (RPC) technology to pass information to one another.</span></span> <span data-ttu-id="754fd-109">Между вызовом, поступающим от процесса на удаленном компьютере, и вызовом, поступающим от другого процесса на том же компьютере, не существует различий.</span><span class="sxs-lookup"><span data-stu-id="754fd-109">There is no difference to the caller between a call coming from a process on a remote machine and a call coming from another process on the same machine.</span></span>

<span data-ttu-id="754fd-110">Когда поток начинает выполняться, он продолжается до тех пор, пока он не будет завершен или пока не будет прерван потоком с более высоким приоритетом (действие пользователя или планировщик потоков ядра).</span><span class="sxs-lookup"><span data-stu-id="754fd-110">When a thread begins to execute, it continues until it is killed or until it is interrupted by a thread with higher priority (by a user action or the kernel's thread scheduler).</span></span> <span data-ttu-id="754fd-111">Каждый поток может выполнять отдельные разделы кода, или несколько потоков могут выполнять один и тот же раздел кода.</span><span class="sxs-lookup"><span data-stu-id="754fd-111">Each thread can run separate sections of code, or multiple threads can execute the same section of code.</span></span> <span data-ttu-id="754fd-112">Потоки, выполняющие один и тот же блок кода, поддерживают отдельные стеки.</span><span class="sxs-lookup"><span data-stu-id="754fd-112">Threads executing the same block of code maintain separate stacks.</span></span> <span data-ttu-id="754fd-113">Каждый поток в процессе совместно использует глобальные переменные и ресурсы этого процесса.</span><span class="sxs-lookup"><span data-stu-id="754fd-113">Each thread in a process shares that process's global variables and resources.</span></span>

<span data-ttu-id="754fd-114">Планировщик потоков определяет, когда и как часто следует выполнять поток, в соответствии с сочетанием атрибута класса приоритета процесса и базового приоритета потока.</span><span class="sxs-lookup"><span data-stu-id="754fd-114">The thread scheduler determines when and how often to execute a thread, according to a combination of the process's priority class attribute and the thread's base priority.</span></span> <span data-ttu-id="754fd-115">Атрибут класса приоритета процесса задается путем вызова функции [**сетприоритикласс**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setpriorityclass) , а базовый приоритет потока задается вызовом [**сетсреадприорити**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreadpriority).</span><span class="sxs-lookup"><span data-stu-id="754fd-115">You set a process's priority class attribute by calling the [**SetPriorityClass**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setpriorityclass) function , and you set a thread's base priority with a call to [**SetThreadPriority**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreadpriority).</span></span>

<span data-ttu-id="754fd-116">Многопоточные приложения должны избегать двух проблем с потоками: *взаимоблокировки* и *состязания*.</span><span class="sxs-lookup"><span data-stu-id="754fd-116">Multithreaded applications must avoid two threading problems: *deadlocks* and *races*.</span></span> <span data-ttu-id="754fd-117">Взаимоблокировка возникает, когда каждый поток ожидает выполнения какого-либо другого потока.</span><span class="sxs-lookup"><span data-stu-id="754fd-117">A deadlock occurs when each thread is waiting for the other to do something.</span></span> <span data-ttu-id="754fd-118">Управление вызовами COM помогает предотвратить взаимоблокировки вызовов между объектами.</span><span class="sxs-lookup"><span data-stu-id="754fd-118">The COM call control helps prevent deadlocks in calls between objects.</span></span> <span data-ttu-id="754fd-119">Состояние гонки возникает, когда один поток завершается до другого, от которого он зависит, что приводит к тому, что в бывшем экземпляре используется неинициализированное значение, поскольку второй еще не предоставил допустимого значения.</span><span class="sxs-lookup"><span data-stu-id="754fd-119">A race condition occurs when one thread finishes before another on which it depends, causing the former to use an uninitialized value because the latter has not yet supplied a valid one.</span></span> <span data-ttu-id="754fd-120">COM предоставляет некоторые функции, специально разработанные для того, чтобы избежать конкуренции в необработанных серверах.</span><span class="sxs-lookup"><span data-stu-id="754fd-120">COM supplies some functions specifically designed to help avoid race conditions in out-of-process servers.</span></span> <span data-ttu-id="754fd-121">(См. раздел [вспомогательные методы реализации сервера](out-of-process-server-implementation-helpers.md).)</span><span class="sxs-lookup"><span data-stu-id="754fd-121">(See [Out-of-Process Server Implementation Helpers](out-of-process-server-implementation-helpers.md).)</span></span>

## <a name="the-apartment-and-the-com-threading-architecture"></a><span data-ttu-id="754fd-122">Подразделение и архитектура потоков COM</span><span class="sxs-lookup"><span data-stu-id="754fd-122">The Apartment and the COM Threading Architecture</span></span>

<span data-ttu-id="754fd-123">Хотя COM поддерживает модель с одним потоком, которая наследуется перед введением нескольких потоков выполнения, можно написать код для использования преимуществ нескольких потоков, что приведет к более эффективным приложениям, допуская выполнение одного потока, в то время как другой поток ожидает завершения некоторой длительной операции.</span><span class="sxs-lookup"><span data-stu-id="754fd-123">While COM supports the single-thread-per-process model prevalent before the introduction of multiple threads of execution, you can write code to take advantage of multiple threads, resulting in more efficient applications, by allowing one thread to be executed while another thread waits for some time-consuming operation to complete.</span></span>

> [!Note]  
> <span data-ttu-id="754fd-124">Использование нескольких потоков не гарантирует лучшую производительность.</span><span class="sxs-lookup"><span data-stu-id="754fd-124">Using multiple threads is not a guarantee of better performance.</span></span> <span data-ttu-id="754fd-125">На самом деле, поскольку многопоточность является сложной задачей, использование нескольких потоков часто приводит к проблемам с производительностью.</span><span class="sxs-lookup"><span data-stu-id="754fd-125">In fact, because thread factoring is a difficult problem, using multiple threads often causes performance problems.</span></span> <span data-ttu-id="754fd-126">Ключ состоит в использовании нескольких потоков, только если вы точно уверены, что вы делаете.</span><span class="sxs-lookup"><span data-stu-id="754fd-126">The key is to use multiple threads only if you are very sure of what you are doing.</span></span>

 

<span data-ttu-id="754fd-127">Как правило, самый простой способ просмотреть архитектуру потоковой обработки COM — считать все COM-объекты в процессе, разделенные на группы, называемые *апартаментами*.</span><span class="sxs-lookup"><span data-stu-id="754fd-127">In general, the simplest way to view the COM threading architecture is to think of all the COM objects in the process as divided into groups called *apartments*.</span></span> <span data-ttu-id="754fd-128">COM-объект находится в одном апартаменте, в том смысле, что его методы могут быть непосредственно вызваны только потоком, принадлежащим этому подразделению.</span><span class="sxs-lookup"><span data-stu-id="754fd-128">A COM object lives in exactly one apartment, in the sense that its methods can legally be directly called only by a thread that belongs to that apartment.</span></span> <span data-ttu-id="754fd-129">Любой другой поток, которому требуется вызвать объект, должен пройти через прокси-сервер.</span><span class="sxs-lookup"><span data-stu-id="754fd-129">Any other thread that wants to call the object must go through a proxy.</span></span>

<span data-ttu-id="754fd-130">Существует два типа апартаментов: [Однопотоковые подразделения](single-threaded-apartments.md)и [многопоточные подразделения](multithreaded-apartments.md).</span><span class="sxs-lookup"><span data-stu-id="754fd-130">There are two types of apartments: [single-threaded apartments](single-threaded-apartments.md), and [multithreaded apartments](multithreaded-apartments.md).</span></span>

-   <span data-ttu-id="754fd-131">Однопотоковые подразделения состоят из ровно одного потока, поэтому все COM-объекты, которые находятся в однопотоковом подразделении, могут принимать вызовы методов только из одного потока, который принадлежит этому подразделению.</span><span class="sxs-lookup"><span data-stu-id="754fd-131">Single-threaded apartments consist of exactly one thread, so all COM objects that live in a single-threaded apartment can receive method calls only from the one thread that belongs to that apartment.</span></span> <span data-ttu-id="754fd-132">Все вызовы методов к COM-объекту в однопотоковом апартаменте синхронизируются с очередью сообщений Windows для потока однопотокового подразделения.</span><span class="sxs-lookup"><span data-stu-id="754fd-132">All method calls to a COM object in a single-threaded apartment are synchronized with the windows message queue for the single-threaded apartment's thread.</span></span> <span data-ttu-id="754fd-133">Процесс с одним потоком выполнения — это просто особый случай этой модели.</span><span class="sxs-lookup"><span data-stu-id="754fd-133">A process with a single thread of execution is simply a special case of this model.</span></span>
-   <span data-ttu-id="754fd-134">Многопоточные подразделения состоят из одного или нескольких потоков, поэтому все COM-объекты, которые находятся в многопоточном апартаменте, могут получить вызовы методов непосредственно из любого потока, принадлежащего многопоточному подразделению.</span><span class="sxs-lookup"><span data-stu-id="754fd-134">Multithreaded apartments consist of one or more threads, so all COM objects that live in an multithreaded apartment can receive method calls directly from any of the threads that belong to the multithreaded apartment.</span></span> <span data-ttu-id="754fd-135">Потоки в многопоточном апартаменте используют модель, называемую *бесплатным потоком*.</span><span class="sxs-lookup"><span data-stu-id="754fd-135">Threads in a multithreaded apartment use a model called *free-threading*.</span></span> <span data-ttu-id="754fd-136">Вызовы COM-объектов в многопоточном апартаменте синхронизируются самими объектами.</span><span class="sxs-lookup"><span data-stu-id="754fd-136">Calls to COM objects in a multithreaded apartment are synchronized by the objects themselves.</span></span>

> [!Note]  
> <span data-ttu-id="754fd-137">Описание обмена данными между однопотоковыми и многопоточными апартаментами в рамках одного процесса см. в разделе [однопотоковое и](single-threaded-and-multithreaded-communication.md)многопоточное взаимодействие.</span><span class="sxs-lookup"><span data-stu-id="754fd-137">For a description of communication between single-threaded apartments and multithreaded apartments within the same process, see [Single-Threaded and Multithreaded Communication](single-threaded-and-multithreaded-communication.md).</span></span>

 

<span data-ttu-id="754fd-138">Процесс может содержать ноль или более однопотоковых подразделений и ноль или один многопоточный апартамент.</span><span class="sxs-lookup"><span data-stu-id="754fd-138">A process can have zero or more single-threaded apartments and zero or one multithreaded apartment.</span></span>

<span data-ttu-id="754fd-139">В процессе сначала инициализируется главный апартамент.</span><span class="sxs-lookup"><span data-stu-id="754fd-139">In a process, the main apartment is the first to be initialized.</span></span> <span data-ttu-id="754fd-140">В однопотоковом процессе это единственный апартамент.</span><span class="sxs-lookup"><span data-stu-id="754fd-140">In a single-threaded process, this is the only apartment.</span></span> <span data-ttu-id="754fd-141">Параметры вызова маршалируются между апартаментами, а COM обрабатывает синхронизацию посредством обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="754fd-141">Call parameters are marshaled between apartments, and COM handles the synchronization through messaging.</span></span> <span data-ttu-id="754fd-142">Если назначить несколько потоков в процессе свободными потоками, все свободные потоки находятся в одном апартаменте, параметры передаются непосредственно в любой поток в подразделении, и необходимо обрабатывать всю синхронизацию.</span><span class="sxs-lookup"><span data-stu-id="754fd-142">If you designate multiple threads in a process to be free-threaded, all free threads reside in a single apartment, parameters are passed directly to any thread in the apartment, and you must handle all synchronization.</span></span> <span data-ttu-id="754fd-143">В процессе с произвольной многопоточностью и потоковыми потоками все свободные потоки находятся в одном апартаменте, а все остальные подразделения являются однопотоковыми апартаментами.</span><span class="sxs-lookup"><span data-stu-id="754fd-143">In a process with both free-threading and apartment threading, all free threads reside in a single apartment and all other apartments are single-threaded apartments.</span></span> <span data-ttu-id="754fd-144">Процесс, выполняющий работу COM, — это коллекция подразделений с (не более одного многопоточного подразделения), но с любым числом однопотоковых апартаментов.</span><span class="sxs-lookup"><span data-stu-id="754fd-144">A process that does COM work is a collection of apartments with, at most, one multithreaded apartment but any number of single-threaded apartments.</span></span>

<span data-ttu-id="754fd-145">Модели потоков в COM предоставляют механизм для клиентов и серверов, использующих различные архитектурные потоки для совместной работы.</span><span class="sxs-lookup"><span data-stu-id="754fd-145">The threading models in COM provide the mechanism for clients and servers that use different threading architectures to work together.</span></span> <span data-ttu-id="754fd-146">Естественным образом поддерживаются вызовы между объектами с различными моделями потоков в разных процессах.</span><span class="sxs-lookup"><span data-stu-id="754fd-146">Calls among objects with different threading models in different processes are naturally supported.</span></span> <span data-ttu-id="754fd-147">С точки зрения вызывающего объекта все вызовы объектов, находящиеся вне процесса, ведут себя одинаково, независимо от того, как вызывается поток.</span><span class="sxs-lookup"><span data-stu-id="754fd-147">From the perspective of the calling object, all calls to objects outside a process behave identically, no matter how the object being called is threaded.</span></span> <span data-ttu-id="754fd-148">Аналогично, с точки зрения вызываемого объекта, поступающие вызовы ведут себя одинаково, независимо от модели потоков вызывающего.</span><span class="sxs-lookup"><span data-stu-id="754fd-148">Likewise, from the perspective of the object being called, arriving calls behave identically, regardless of the threading model of the caller.</span></span>

<span data-ttu-id="754fd-149">Взаимодействие между клиентом и необработанным объектом осуществляется просто, даже если они используют различные модели потоков, поскольку клиент и объект находятся в разных процессах.</span><span class="sxs-lookup"><span data-stu-id="754fd-149">Interaction between a client and an out-of-process object is straightforward, even when they use different threading models because the client and object are in different processes.</span></span> <span data-ttu-id="754fd-150">COM-взаимодействие между клиентом и сервером может предоставить код для потоковой модели, который будет взаимодействовать с помощью стандартного маршалирования и RPC.</span><span class="sxs-lookup"><span data-stu-id="754fd-150">COM, interposed between the client and the server, can provide the code for the threading models to interoperate, using standard marshaling and RPC.</span></span> <span data-ttu-id="754fd-151">Например, если однопотоковый объект вызывается несколькими клиентами, работающими в многопоточном процессе, вызовы будут синхронизированы COM путем размещения соответствующих сообщений в очереди сообщений сервера.</span><span class="sxs-lookup"><span data-stu-id="754fd-151">For example, if a single-threaded object is called simultaneously by multiple free-threaded clients, the calls will be synchronized by COM by placing corresponding window messages in the server's message queue.</span></span> <span data-ttu-id="754fd-152">Апартамент объекта будет получать один вызов каждый раз, когда он извлекает и отправляет сообщения.</span><span class="sxs-lookup"><span data-stu-id="754fd-152">The object's apartment will receive one call each time it retrieves and dispatches messages.</span></span> <span data-ttu-id="754fd-153">Тем не менее необходимо соблюдать некоторые меры, чтобы убедиться, что внутрипроцессный сервер правильно взаимодействует с клиентами.</span><span class="sxs-lookup"><span data-stu-id="754fd-153">However, some care must be taken to ensure that in-process servers interact properly with their clients.</span></span> <span data-ttu-id="754fd-154">(См. статью [проблемы потоковой обработки на сервере](in-process-server-threading-issues.md).)</span><span class="sxs-lookup"><span data-stu-id="754fd-154">(See [In-Process Server Threading Issues](in-process-server-threading-issues.md).)</span></span>

<span data-ttu-id="754fd-155">Наиболее важной проблемой при программировании с использованием многопоточной модели является обеспечение безопасности потока кода таким образом, чтобы сообщения, предназначенные для конкретного потока, передавались только этому потоку, а доступ к потокам был защищен.</span><span class="sxs-lookup"><span data-stu-id="754fd-155">The most important issue in programming with a multithreaded model is to make your code thread-safe so that messages intended for a particular thread go only to that thread and access to threads is protected.</span></span>

<span data-ttu-id="754fd-156">Дополнительные сведения см. в следующих разделах:</span><span class="sxs-lookup"><span data-stu-id="754fd-156">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="754fd-157">Выбор потоковой модели</span><span class="sxs-lookup"><span data-stu-id="754fd-157">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
-   [<span data-ttu-id="754fd-158">Подразделения с одним потоком</span><span class="sxs-lookup"><span data-stu-id="754fd-158">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
-   [<span data-ttu-id="754fd-159">Многопоточные подразделения</span><span class="sxs-lookup"><span data-stu-id="754fd-159">Multithreaded Apartments</span></span>](multithreaded-apartments.md)
-   [<span data-ttu-id="754fd-160">Однопотоковое и многопоточное взаимодействие</span><span class="sxs-lookup"><span data-stu-id="754fd-160">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
-   [<span data-ttu-id="754fd-161">Проблемы потоковой обработки в процессе сервера</span><span class="sxs-lookup"><span data-stu-id="754fd-161">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
-   [<span data-ttu-id="754fd-162">Доступ к интерфейсам в разных апартаментах</span><span class="sxs-lookup"><span data-stu-id="754fd-162">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)

 

 