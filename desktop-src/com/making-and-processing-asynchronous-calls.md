---
title: Создание и обработка асинхронных вызовов
description: COM-объекты могут поддерживать асинхронный вызов.
ms.assetid: bf7f9f8e-66ce-41a4-854c-62dbe840a89e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 059f55cc64a70f130e7fb654426803edbe8b7209
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "105691672"
---
# <a name="making-and-processing-asynchronous-calls"></a><span data-ttu-id="5605b-103">Создание и обработка асинхронных вызовов</span><span class="sxs-lookup"><span data-stu-id="5605b-103">Making and Processing Asynchronous Calls</span></span>

<span data-ttu-id="5605b-104">COM-объекты могут поддерживать асинхронный вызов.</span><span class="sxs-lookup"><span data-stu-id="5605b-104">COM objects can support asynchronous calling.</span></span> <span data-ttu-id="5605b-105">Когда клиент выполняет асинхронный вызов, управление немедленно возвращается клиенту.</span><span class="sxs-lookup"><span data-stu-id="5605b-105">When a client makes an asynchronous call, control returns to the client immediately.</span></span> <span data-ttu-id="5605b-106">Пока сервер обрабатывает вызов, клиент может выполнять другие действия.</span><span class="sxs-lookup"><span data-stu-id="5605b-106">While the server processes the call, the client is free to do other work.</span></span> <span data-ttu-id="5605b-107">Если клиент больше не может продолжать работу без результатов вызова, он может получить результаты вызова в это время.</span><span class="sxs-lookup"><span data-stu-id="5605b-107">When the client can no longer proceed without the results of the call, it can get the results of the call at that time.</span></span>

<span data-ttu-id="5605b-108">Например, запрос на большой или сложный набор записей может занять много времени.</span><span class="sxs-lookup"><span data-stu-id="5605b-108">For example, a request for a large or complex recordset can be time-consuming.</span></span> <span data-ttu-id="5605b-109">Клиент может запросить набор записей с помощью асинхронного вызова, а затем выполнить другие действия.</span><span class="sxs-lookup"><span data-stu-id="5605b-109">A client can request the recordset by an asynchronous call and then do other work.</span></span> <span data-ttu-id="5605b-110">Если набор записей доступен, клиент может быстро получить его без блокировки.</span><span class="sxs-lookup"><span data-stu-id="5605b-110">When the recordset is available, the client can obtain it quickly without blocking.</span></span>

<span data-ttu-id="5605b-111">Клиенты не выполняют асинхронные вызовы непосредственно на серверный объект.</span><span class="sxs-lookup"><span data-stu-id="5605b-111">Clients do not make asynchronous calls directly on the server object.</span></span> <span data-ttu-id="5605b-112">Вместо этого они получают объект вызова, который реализует асинхронную версию синхронного интерфейса для серверного объекта.</span><span class="sxs-lookup"><span data-stu-id="5605b-112">Instead, they obtain a call object that implements an asynchronous version of a synchronous interface on the server object.</span></span> <span data-ttu-id="5605b-113">Асинхронный интерфейс для объекта вызова имеет имя в виде асинхронного *interfacename*.</span><span class="sxs-lookup"><span data-stu-id="5605b-113">The asynchronous interface on the call object has a name of the form Async *InterfaceName*.</span></span> <span data-ttu-id="5605b-114">Например, если объект сервера реализует синхронный интерфейс с именем IMyInterface, то будет существовать объект call, реализующий асинхронный интерфейс с именем АсинЦиминтерфаце.</span><span class="sxs-lookup"><span data-stu-id="5605b-114">For example, if a server object implements a synchronous interface named IMyInterface, there will be a call object that implements an asynchronous interface named AsyncIMyInterface.</span></span>

> [!Note]  
> <span data-ttu-id="5605b-115">Асинхронная поддержка недоступна для **IDispatch** или для интерфейсов, которые наследуют **IDispatch**.</span><span class="sxs-lookup"><span data-stu-id="5605b-115">Asynchronous support is not available for **IDispatch** or for interfaces that inherit **IDispatch**.</span></span>

 

<span data-ttu-id="5605b-116">Объекты сервера, поддерживающие асинхронные вызовы, реализуют интерфейс [**икаллфактори**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory) .</span><span class="sxs-lookup"><span data-stu-id="5605b-116">Server objects that support asynchronous calls implement the [**ICallFactory**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory) interface.</span></span> <span data-ttu-id="5605b-117">Этот интерфейс предоставляет единственный метод [**креатекалл**](/windows/win32/api/objidlbase/nf-objidlbase-icallfactory-createcall), который создает экземпляр указанного объекта вызова.</span><span class="sxs-lookup"><span data-stu-id="5605b-117">This interface exposes a single method, [**CreateCall**](/windows/win32/api/objidlbase/nf-objidlbase-icallfactory-createcall), which creates an instance of a specified call object.</span></span> <span data-ttu-id="5605b-118">Клиенты могут запрашивать **икаллфактори** , чтобы определить, поддерживает ли объект асинхронный вызов.</span><span class="sxs-lookup"><span data-stu-id="5605b-118">Clients can query for **ICallFactory** to determine whether an object supports asynchronous calling.</span></span>

<span data-ttu-id="5605b-119">Для каждого метода в синхронном интерфейсе соответствующий асинхронный интерфейс реализует два метода.</span><span class="sxs-lookup"><span data-stu-id="5605b-119">For each method on a synchronous interface, the corresponding asynchronous interface implements two methods.</span></span> <span data-ttu-id="5605b-120">Эти методы присоединяют префиксы Begin \_ и Finish \_ к имени синхронного метода.</span><span class="sxs-lookup"><span data-stu-id="5605b-120">These methods attach the prefixes Begin\_ and Finish\_ to the name of the synchronous method.</span></span> <span data-ttu-id="5605b-121">Например, если интерфейс с именем Исимплестреам имеет метод Read, то интерфейс АсинЦисимплестреам будет иметь \_ метод Begin Read и готово \_ Read.</span><span class="sxs-lookup"><span data-stu-id="5605b-121">For example, if an interface named ISimpleStream has a Read method, the AsyncISimpleStream interface will have a Begin\_Read and a Finish\_Read method.</span></span> <span data-ttu-id="5605b-122">Чтобы начать асинхронный вызов, клиент вызывает \_ метод Begin.</span><span class="sxs-lookup"><span data-stu-id="5605b-122">To begin an asynchronous call, the client calls the Begin\_ method.</span></span>

<span data-ttu-id="5605b-123">При реализации серверного объекта нет необходимости предоставлять объект вызова для каждого интерфейса, реализуемого объектом.</span><span class="sxs-lookup"><span data-stu-id="5605b-123">When you implement a server object, you do not have to provide a call object for every interface the object implements.</span></span> <span data-ttu-id="5605b-124">Если серверный объект реализует интерфейс [**икаллфактори**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory) и использует стандартную упаковку, то упакованный клиент всегда может получить объект вызова прокси-сервера, даже если на стороне сервера нет объекта Call.</span><span class="sxs-lookup"><span data-stu-id="5605b-124">If the server object implements the [**ICallFactory**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory) interface and uses standard marshaling, a marshaled client can always obtain a proxy call object, even if there is no call object on the server side.</span></span> <span data-ttu-id="5605b-125">Этот прокси-сервер маршалирует \_ метод Begin как синхронный вызов, сервер будет обрабатывать вызов синхронно, а клиент может получить выходные параметры, вызвав \_ метод Finish.</span><span class="sxs-lookup"><span data-stu-id="5605b-125">This proxy will marshal the Begin\_ method as a synchronous call, the server will process the call synchronously, and the client can obtain the out parameters by calling the Finish\_ method.</span></span>

<span data-ttu-id="5605b-126">И наоборот, если клиент выполняет упакованный синхронный вызов в интерфейсе, для которого имеется объект вызова на стороне сервера, сервер всегда будет обрабатывать вызов асинхронно.</span><span class="sxs-lookup"><span data-stu-id="5605b-126">Conversely, if a client makes a marshaled synchronous call on an interface for which there is a call object on the server side, the server will always process the call asynchronously.</span></span> <span data-ttu-id="5605b-127">Это поведение не будет очевидным для клиента, так как клиент будет получать те же выходные параметры и то же возвращаемое значение, что было бы получено от синхронного метода.</span><span class="sxs-lookup"><span data-stu-id="5605b-127">This behavior will not be apparent to the client, because the client will receive the same out parameters and the same return value it would have received from the synchronous method.</span></span>

<span data-ttu-id="5605b-128">В любом случае взаимодействие между клиентом и сервером маршалируется, как если бы вызов был синхронным: выходные данные синхронных и асинхронных прокси-серверов неразличимы, как и выходные данные соответствующих заглушек.</span><span class="sxs-lookup"><span data-stu-id="5605b-128">In either case, the interaction between client and server is marshaled as if the call were synchronous: The output of synchronous and asynchronous proxies is indistinguishable, as is the output of the corresponding stubs.</span></span> <span data-ttu-id="5605b-129">Такое поведение значительно упрощает модель программирования как клиентов, так и серверов.</span><span class="sxs-lookup"><span data-stu-id="5605b-129">This behavior greatly simplifies the programming model both of clients and of servers.</span></span> <span data-ttu-id="5605b-130">Если серверный объект реализует [**икаллфактори**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory), упакованному клиенту не нужно пытаться создать объект вызова, который может быть недоступен клиенту, объект вызова всегда доступен.</span><span class="sxs-lookup"><span data-stu-id="5605b-130">If a server object implements [**ICallFactory**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory), a marshaled client does not have to attempt to create a call object that may not be available — to the client, a call object is always available.</span></span>

<span data-ttu-id="5605b-131">Если клиент и сервер находятся в одном апартаменте, объект сервера будет обрабатывать любой вызов, который делает клиент.</span><span class="sxs-lookup"><span data-stu-id="5605b-131">When client and server are in the same apartment, the server object will process whichever call the client makes.</span></span> <span data-ttu-id="5605b-132">Если объект вызова недоступен, клиент должен явно получить синхронный интерфейс и выполнить синхронный вызов.</span><span class="sxs-lookup"><span data-stu-id="5605b-132">If a call object is not available, the client must explicitly obtain the synchronous interface and make a synchronous call.</span></span>

<span data-ttu-id="5605b-133">Дополнительные сведения см. в следующих разделах:</span><span class="sxs-lookup"><span data-stu-id="5605b-133">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="5605b-134">Выполнение асинхронного вызова</span><span class="sxs-lookup"><span data-stu-id="5605b-134">Making an Asynchronous Call</span></span>](making-an-asynchronous-call.md)
-   [<span data-ttu-id="5605b-135">Отмена асинхронного вызова</span><span class="sxs-lookup"><span data-stu-id="5605b-135">Canceling an Asynchronous Call</span></span>](canceling-an-asynchronous-call.md)
-   [<span data-ttu-id="5605b-136">Отмена вызовов метода</span><span class="sxs-lookup"><span data-stu-id="5605b-136">Canceling Method Calls</span></span>](canceling-method-calls.md)
-   [<span data-ttu-id="5605b-137">Синхронизация вызовов</span><span class="sxs-lookup"><span data-stu-id="5605b-137">Call Synchronization</span></span>](call-synchronization.md)

 

 