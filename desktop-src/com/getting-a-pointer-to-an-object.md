---
title: Получение указателя на объект
description: Получение указателя на объект
ms.assetid: 4af9d356-402b-4e69-9f6e-8589057d3ac4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0476d36390e7077e7fdd75eef8d95e8173683891
ms.sourcegitcommit: 307b14e9847ced354a52a1ac12d7f659722d99bb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2020
ms.locfileid: "105710249"
---
# <a name="getting-a-pointer-to-an-object"></a><span data-ttu-id="44ede-103">Получение указателя на объект</span><span class="sxs-lookup"><span data-stu-id="44ede-103">Getting a Pointer to an Object</span></span>

<span data-ttu-id="44ede-104">Поскольку модель COM не имеет классической модели, существует четыре способа создания экземпляра или получения указателя на интерфейс объекта.</span><span class="sxs-lookup"><span data-stu-id="44ede-104">Because COM does not have a strict class model, there are four ways that a client can instantiate or get a pointer to an interface on an object:</span></span>

-   <span data-ttu-id="44ede-105">Вызов функции библиотеки COM, которая создает объект предопределенного типа; то есть функция возвращает указатель на только один конкретный интерфейс для конкретного класса объектов.</span><span class="sxs-lookup"><span data-stu-id="44ede-105">Call a COM library function that creates an object of a predetermined type; that is, the function will return a pointer to only one specific interface for a specific object class.</span></span>
-   <span data-ttu-id="44ede-106">Вызов функции библиотеки COM, которая может создать объект на основе идентификатора класса (CLSID) и возвращать любой тип запрошенного указателя интерфейса.</span><span class="sxs-lookup"><span data-stu-id="44ede-106">Call a COM library function that can create an object based on a class identifier (CLSID) and that returns any type of interface pointer requested.</span></span>
-   <span data-ttu-id="44ede-107">Вызовите метод некоторого интерфейса, который создает другой объект (или соединяется с существующим) и возвращает указатель интерфейса на этот отдельный объект.</span><span class="sxs-lookup"><span data-stu-id="44ede-107">Call a method of some interface that creates another object (or connects to an existing one) and returns an interface pointer on that separate object.</span></span>
-   <span data-ttu-id="44ede-108">Реализуйте объект с интерфейсом, через который другие объекты передают указатель интерфейса непосредственно клиенту.</span><span class="sxs-lookup"><span data-stu-id="44ede-108">Implement an object with an interface through which other objects pass their interface pointer to the client directly.</span></span>

<span data-ttu-id="44ede-109">Сведения о получении указателей на другие интерфейсы объекта после получения первого из них см. [в разделе QueryInterface: Навигация в объекте](queryinterface--navigating-in-an-object.md).</span><span class="sxs-lookup"><span data-stu-id="44ede-109">For information on getting pointers to other interfaces on an object after you have the first one, see [QueryInterface: Navigating in an Object](queryinterface--navigating-in-an-object.md).</span></span>

## <a name="creating-an-object-of-a-predetermined-type"></a><span data-ttu-id="44ede-110">Создание объекта предопределенного типа</span><span class="sxs-lookup"><span data-stu-id="44ede-110">Creating an Object of a Predetermined Type</span></span>

<span data-ttu-id="44ede-111">Существует множество функций COM, таких как [**кожетмаллок**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetmalloc), которые возвращают указатели на определенные реализации интерфейса.</span><span class="sxs-lookup"><span data-stu-id="44ede-111">There are numerous COM functions, such as [**CoGetMalloc**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetmalloc), that return pointers to specific interface implementations.</span></span> <span data-ttu-id="44ede-112">(**Кожетмаллок** получает указатель на стандартный распределитель памяти com.) Большинство из них являются вспомогательными функциями, и большинство этих функций описаны в разделах справки этой документации в определенной области, с которой они связаны, например в хранилище или при переносе данных.</span><span class="sxs-lookup"><span data-stu-id="44ede-112">(**CoGetMalloc** retrieves a pointer to the standard COM memory allocator.) Most of these are helper functions, and most of these functions are described in the reference sections of this documentation, under the specific area they are related to, such as storage or data transfer.</span></span>

## <a name="creating-an-object-based-on-a-clsid"></a><span data-ttu-id="44ede-113">Создание объекта на основе идентификатора CLSID</span><span class="sxs-lookup"><span data-stu-id="44ede-113">Creating an Object Based on a CLSID</span></span>

<span data-ttu-id="44ede-114">Существует несколько функций, которые могут вызываться клиентом для создания экземпляра объекта и получения указателя на него.</span><span class="sxs-lookup"><span data-stu-id="44ede-114">There are several functions that, given a CLSID, a client can call to create an object instance and get a pointer to it.</span></span> <span data-ttu-id="44ede-115">Все эти функции основаны на функции [**кожетклассобжект**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject), которая создает объект класса и предоставляет указатель на интерфейс, который позволяет создавать экземпляры этого класса.</span><span class="sxs-lookup"><span data-stu-id="44ede-115">All of these functions are based on the function [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject), which creates a class object and supplies a pointer to an interface that allows you to create instances of that class.</span></span> <span data-ttu-id="44ede-116">Хотя должны быть сведения, указывающие, в какой системе находится сервер, не требуется, чтобы эта информация содержалась в клиенте.</span><span class="sxs-lookup"><span data-stu-id="44ede-116">While there must be information that says which system the server resides on, there is no need for that information to be contained in the client.</span></span> <span data-ttu-id="44ede-117">Клиент должен быть в курсе только идентификатора CLSID и никогда не является абсолютным путем к серверному коду.</span><span class="sxs-lookup"><span data-stu-id="44ede-117">The client needs to know only the CLSID and never the absolute path of the server code.</span></span> <span data-ttu-id="44ede-118">Дополнительные сведения см. в разделе [Создание объекта с помощью объекта класса](creating-an-object-through-a-class-object.md).</span><span class="sxs-lookup"><span data-stu-id="44ede-118">For more information, see [Creating an Object Through a Class Object](creating-an-object-through-a-class-object.md).</span></span>

## <a name="returning-a-pointer-to-a-separate-object"></a><span data-ttu-id="44ede-119">Возвращение указателя на отдельный объект</span><span class="sxs-lookup"><span data-stu-id="44ede-119">Returning a Pointer to a Separate Object</span></span>

<span data-ttu-id="44ede-120">Между многими методами интерфейса, которые возвращают указатель на отдельный объект, относятся несколько, которые создают и возвращают указатель на *объект перечислителя*, который позволяет определить, сколько элементов данного типа поддерживается объектом.</span><span class="sxs-lookup"><span data-stu-id="44ede-120">Among the many interface methods that return a pointer to a separate object are several that create and return a pointer to an *enumerator object*, which allows you to determine how many items of a given type an object maintains.</span></span> <span data-ttu-id="44ede-121">COM определяет интерфейсы для перечисления широкого спектра элементов, таких как строки, важные структуры, моникеры и указатели интерфейса [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) .</span><span class="sxs-lookup"><span data-stu-id="44ede-121">COM defines interfaces for enumerating a wide variety of items, such as strings, important structures, monikers, and [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) interface pointers.</span></span> <span data-ttu-id="44ede-122">Типичным способом создания экземпляра перечислителя и получения указателя на его интерфейс является вызов метода из другого интерфейса.</span><span class="sxs-lookup"><span data-stu-id="44ede-122">The typical way to create an enumerator instance and get a pointer to its interface is to call a method from another interface.</span></span> <span data-ttu-id="44ede-123">Например, интерфейс [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) определяет два метода, [**енумдадвисе**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-enumdadvise) и [**енумформатетк**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-enumformatetc), которые возвращают указатели на интерфейсы двух различных объектов перечисления.</span><span class="sxs-lookup"><span data-stu-id="44ede-123">For example, the [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface defines two methods, [**EnumDAdvise**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-enumdadvise) and [**EnumFormatEtc**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-enumformatetc), that return pointers to interfaces on two different enumeration objects.</span></span> <span data-ttu-id="44ede-124">Существует множество других примеров в COM методов, которые возвращают указатели на объекты, например интерфейс составного документа OLE [**иолеобжект:: жетклиентсите**](/windows/desktop/api/OleIdl/nf-oleidl-ioleobject-getclientsite), который при вызове для внедренного или связанного объекта возвращает указатель на реализацию [**иолеклиентсите**](/windows/desktop/api/OleIdl/nn-oleidl-ioleclientsite)объекта контейнера.</span><span class="sxs-lookup"><span data-stu-id="44ede-124">There are many other examples in COM of methods that return pointers to objects, such as the OLE compound document interface [**IOleObject::GetClientSite**](/windows/desktop/api/OleIdl/nf-oleidl-ioleobject-getclientsite), which, when called on the embedded or linked object, returns a pointer to the container object's implementation of [**IOleClientSite**](/windows/desktop/api/OleIdl/nn-oleidl-ioleclientsite).</span></span>

## <a name="implementing-an-object-through-which-to-pass-an-interface-pointer-directly-to-the-client"></a><span data-ttu-id="44ede-125">Реализация объекта, через который передается указатель интерфейса непосредственно клиенту</span><span class="sxs-lookup"><span data-stu-id="44ede-125">Implementing an Object Through Which to Pass an Interface Pointer Directly to the Client</span></span>

<span data-ttu-id="44ede-126">Когда двум объектам, например контейнеру составного документа OLE и серверу, требуется двунаправленная связь, каждый из них реализует объект, содержащий метод интерфейса, с помощью которого он может передать указатель интерфейса другому объекту.</span><span class="sxs-lookup"><span data-stu-id="44ede-126">When two objects, such as an OLE compound document container and server, need bidirectional communication, each implements an object containing an interface method through which it can pass an interface pointer to the other object.</span></span> <span data-ttu-id="44ede-127">Реализующий объект, который также является клиентом созданного объекта, может затем вызвать метод и получить переданный указатель.</span><span class="sxs-lookup"><span data-stu-id="44ede-127">The implementing object, which is also the client of the created object, can then call the method and get the pointer that was passed.</span></span>

## <a name="related-topics"></a><span data-ttu-id="44ede-128">См. также</span><span class="sxs-lookup"><span data-stu-id="44ede-128">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="44ede-129">COM-клиенты и серверы</span><span class="sxs-lookup"><span data-stu-id="44ede-129">COM Clients and Servers</span></span>](com-clients-and-servers.md)
</dt> <dt>

[<span data-ttu-id="44ede-130">Обязанности сервера COM</span><span class="sxs-lookup"><span data-stu-id="44ede-130">COM Server Responsibilities</span></span>](com-server-responsibilities.md)
</dt> </dl>

 

 




