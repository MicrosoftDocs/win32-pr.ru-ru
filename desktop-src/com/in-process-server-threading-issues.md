---
title: Проблемы с потоком In-Process Server
description: Проблемы с потоком In-Process Server
ms.assetid: 7bd6f62f-8c91-44bd-9a7f-d47988180eed
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8a9d02af739eac11a6adae62de76be9078ee8e32
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2020
ms.locfileid: "104414124"
---
# <a name="in-process-server-threading-issues"></a>Проблемы с потоком In-Process Server

Внутрипроцессный сервер не вызывает [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex)или [**олеинитиализе**](/windows/desktop/api/Ole2/nf-ole2-oleinitialize) для пометки своей потоковой модели. Для основанных на потоках объектов DLL или процессов, поддерживающих потоки, необходимо задать модель потоков в реестре. Модель по умолчанию, если не задана потоковая модель, состоит из одного потока на процесс. Чтобы указать модель, добавьте значение **ThreadingModel** в ключ [InprocServer32](inprocserver32.md) в реестре.

Библиотеки DLL, поддерживающие создание экземпляров объекта класса, должны реализовывать и экспортировать функции [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) и [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow). Когда клиенту требуется экземпляр класса, поддерживаемый библиотекой DLL, вызов [**кожетклассобжект**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) (напрямую или через вызов [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)) вызывает **DllGetClassObject** , чтобы получить указатель на его объект Class, когда объект реализован в библиотеке DLL. Таким образом, **DllGetClassObject** должен иметь возможность отказаться от нескольких объектов класса или одного потокобезопасного объекта (по сути, просто используя [**интерлоккединкремент**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) / [**интерлоккеддекремент**](/windows/desktop/api/winbase/nf-winbase-interlockeddecrement) на внутренних счетчиках ссылок).

Как следует из названия, вызывается [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow) , чтобы определить, используется ли библиотека DLL, которая ее реализует, что позволяет вызывающей стороне безопасно выгрузить ее, если это не так. Вызовы [**кофриунуседлибрариес**](/windows/desktop/api/combaseapi/nf-combaseapi-cofreeunusedlibraries) из любого потока всегда проходят через поток основного апартамента для вызова **DllCanUnloadNow**.

Как и другие серверы, внутрипроцессный сервер может быть многопоточным, потоковым или свободным потоком. Эти серверы могут использоваться любым клиентом OLE независимо от модели потоков, используемой этим клиентом.

Все комбинации взаимодействия модели потоков разрешены между клиентами и внутрипроцессный объект. Взаимодействие между клиентом и внутрипроцессный объект, которые используют различные модели потоков, в точности аналогичен взаимодействию между клиентами и серверами вне процесса. Для внутрипроцессного сервера, когда потоковая модель клиента и внутрипроцессного сервера различаются, COM должен интерпосе себя между клиентом и объектом.

Если внутрипроцессный объект, поддерживающий однопотоковую модель, вызывается одновременно несколькими потоками клиента, COM не может разрешить клиентским потокам напрямую обращаться к интерфацеâу объекта "объект не был разработан для такого доступа. Вместо этого COM должен гарантировать, что вызовы синхронизированы и сделаны только клиентским потоком, создавшим объект. Таким образом, COM создает объект в главном апартаменте клиента и требует, чтобы все другие клиентские подразделения обращаются к объекту через прокси-серверы.

Когда в клиенте создается поток подразделений в свободной потоковой модели (модель с несколькими потоками), COM выполняет потоковую модель однопотокового подразделения "узел" в клиенте. Этот ведущий поток создаст объект, и указатель интерфейса будет упакован обратно в свободный поток клиента. Аналогичным образом, когда однопотоковое подразделение в клиенте модели подразделения создает бесплатный внутрипроцессный сервер, COM выполняет поток на стороне свободных потоков (многопоточное подразделение, в котором будет создан объект, а затем обратно в однопотоковое подразделение клиента).

> [!Note]  
> Как правило, при проектировании пользовательского интерфейса на внутрипроцессного сервере необходимо также предоставить код маршалирования для него, чтобы модель COM могла маршалировать интерфейс между клиентскими апартаментами.

 

COM помогает защитить доступ к объектам, предоставляемым с помощью однопотоковой библиотеки DLL, запрашивая доступ из того же подразделения клиента, в котором они были созданы. Кроме того, все точки входа библиотеки DLL (например, [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) и [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)) и глобальные данные всегда должны быть доступны в одном и том же апартаменте. COM создает такие объекты в основном апартаменте клиента, предоставляя основному апартаменту прямой доступ к указателям объекта. Вызовы из других подразделений используют межпотоковый маршалирование для перехода от прокси к заглушке в главном апартаменте, а затем к объекту. Это позволяет COM синхронизировать вызовы к объекту. Вызовы между потоками выполняются очень долго, поэтому рекомендуется переписывать эти серверы для поддержки нескольких апартаментов.

Как и в случае с однопотоковым внутрипроцессного сервером, объект, предоставленный БИБЛИОТЕКой модели апартамента, должен иметь тот же клиентский контейнер клиента, из которого он был создан. Однако объекты, предоставляемые этим сервером, могут быть созданы в нескольких апартаментах клиента, поэтому сервер должен реализовать свои точки входа (например, [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) и [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)) для многопоточного использования. Например, если два подразделения клиента пытаются одновременно создать два экземпляра внутрипроцессного объекта, **DllGetClassObject** можно вызывать одновременно обоими апартаментами. **DllCanUnloadNow** должен быть написан таким образом, чтобы библиотека DLL не выгружается, пока код все еще выполняется в библиотеке DLL.

Если библиотека DLL предоставляет только один экземпляр фабрики классов для создания всех объектов, реализация фабрики класса также должна быть разработана для многопоточного использования, так как к ней будут обращаться несколько апартаментов клиента. Если библиотека DLL создает новый экземпляр фабрики класса каждый раз, когда вызывается [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) , фабрика класса не должна быть потокобезопасной.

Объекты, созданные фабрикой класса, не должны быть потокобезопасными. После создания потоком доступ к объекту всегда осуществляется через этот поток, а все вызовы объекта синхронизируются с помощью COM. Контейнер апартаментной модели клиента, который создает этот объект, получит прямой указатель на объект. Клиентские подразделения, отличные от подразделений, в которых был создан объект, должны обращаться к объекту через прокси-серверы. Эти прокси-серверы создаются, когда клиент маршалирует интерфейс между его апартаментами.

Если для внутрипроцессного DLL **ThreadingModel** задано значение "both", объект, предоставленный этой библиотекой DLL, можно создать и использовать напрямую (без прокси-сервера) в однопотоковых или многопоточных клиентские подразделения. Однако его можно использовать непосредственно в пределах апартамента, в котором он был создан. Чтобы передать объект в любой другой апартамент, объект должен быть маршалирован. Объект DLL должен реализовывать собственную синхронизацию, и к нему можно обращаться несколькими клиентскими апартаментами одновременно.

Для повышения производительности доступа в реальном потоке к внутрипроцессного объектам DLL COM предоставляет функцию [**кокреатефрисреадедмаршалер**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreatefreethreadedmarshaler) . Эта функция создает объект маршалирования с произвольным потоком, который можно объединить с объектом внутрипроцессного сервера. Если потоку-контейнеру клиента в том же процессе требуется доступ к объекту в другом апартаменте, то при статистической обработке свободного потокового маршалером он предоставляет клиенту прямой указатель на объект сервера, а не на прокси-сервер, когда клиент маршалирует интерфейс объекта в другое подразделение. Клиенту не требуется выполнять синхронизацию. Это работает только в том же процессе; Стандартная упаковка используется для ссылки на объект, который отправляется в другой процесс.

Объект, предоставляемый внутрипроцессный библиотекой DLL, поддерживающей только свободную потоковую обработку, — это свободный потоковый объект. Он реализует собственную синхронизацию и может быть доступен нескольким клиентским потокам одновременно. Этот сервер не маршалирует интерфейсы между потоками, поэтому этот сервер можно создать и использовать напрямую (без прокси) только в многопоточных подразделениях клиента. Однопотоковые подразделения, которые их создают, будут обращаться к нему через прокси-сервер.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Доступ к интерфейсам в разных апартаментах](accessing-interfaces-across-apartments.md)
</dt> <dt>

[Выбор потоковой модели](choosing-the-threading-model.md)
</dt> <dt>

[Многопоточные подразделения](multithreaded-apartments.md)
</dt> <dt>

[Процессы, потоки и подразделения](processes--threads--and-apartments.md)
</dt> <dt>

[Однопотоковое и многопоточное взаимодействие](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[Подразделения с одним потоком](single-threaded-apartments.md)
</dt> </dl>

 

 