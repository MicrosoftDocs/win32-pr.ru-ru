---
title: Проблемы с потоком In-Process Server
description: Проблемы с потоком In-Process Server
ms.assetid: 7bd6f62f-8c91-44bd-9a7f-d47988180eed
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8a9d02af739eac11a6adae62de76be9078ee8e32
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2020
ms.locfileid: "104414124"
---
# <a name="in-process-server-threading-issues"></a><span data-ttu-id="1a58a-103">Проблемы с потоком In-Process Server</span><span class="sxs-lookup"><span data-stu-id="1a58a-103">In-Process Server Threading Issues</span></span>

<span data-ttu-id="1a58a-104">Внутрипроцессный сервер не вызывает [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex)или [**олеинитиализе**](/windows/desktop/api/Ole2/nf-ole2-oleinitialize) для пометки своей потоковой модели.</span><span class="sxs-lookup"><span data-stu-id="1a58a-104">An in-process server does not call [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), or [**OleInitialize**](/windows/desktop/api/Ole2/nf-ole2-oleinitialize) to mark its threading model.</span></span> <span data-ttu-id="1a58a-105">Для основанных на потоках объектов DLL или процессов, поддерживающих потоки, необходимо задать модель потоков в реестре.</span><span class="sxs-lookup"><span data-stu-id="1a58a-105">For thread-aware DLL-based or in-process objects, you need to set the threading model in the registry.</span></span> <span data-ttu-id="1a58a-106">Модель по умолчанию, если не задана потоковая модель, состоит из одного потока на процесс.</span><span class="sxs-lookup"><span data-stu-id="1a58a-106">The default model when you do not specify a threading model is single-thread-per-process.</span></span> <span data-ttu-id="1a58a-107">Чтобы указать модель, добавьте значение **ThreadingModel** в ключ [InprocServer32](inprocserver32.md) в реестре.</span><span class="sxs-lookup"><span data-stu-id="1a58a-107">To specify a model, you add the **ThreadingModel** value to the [InprocServer32](inprocserver32.md) key in the registry.</span></span>

<span data-ttu-id="1a58a-108">Библиотеки DLL, поддерживающие создание экземпляров объекта класса, должны реализовывать и экспортировать функции [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) и [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow).</span><span class="sxs-lookup"><span data-stu-id="1a58a-108">DLLs that support instantiation of a class object must implement and export the functions [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) and [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow).</span></span> <span data-ttu-id="1a58a-109">Когда клиенту требуется экземпляр класса, поддерживаемый библиотекой DLL, вызов [**кожетклассобжект**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) (напрямую или через вызов [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)) вызывает **DllGetClassObject** , чтобы получить указатель на его объект Class, когда объект реализован в библиотеке DLL.</span><span class="sxs-lookup"><span data-stu-id="1a58a-109">When a client wants an instance of the class the DLL supports, a call to [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) (either directly or through a call to [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)) calls **DllGetClassObject** to get a pointer to its class object when the object is implemented in a DLL.</span></span> <span data-ttu-id="1a58a-110">Таким образом, **DllGetClassObject** должен иметь возможность отказаться от нескольких объектов класса или одного потокобезопасного объекта (по сути, просто используя [**интерлоккединкремент**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) / [**интерлоккеддекремент**](/windows/desktop/api/winbase/nf-winbase-interlockeddecrement) на внутренних счетчиках ссылок).</span><span class="sxs-lookup"><span data-stu-id="1a58a-110">**DllGetClassObject** should therefore be able to give away multiple class objects or a single thread-safe object (essentially just using [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement)/[**InterlockedDecrement**](/windows/desktop/api/winbase/nf-winbase-interlockeddecrement) on their internal reference counts).</span></span>

<span data-ttu-id="1a58a-111">Как следует из названия, вызывается [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow) , чтобы определить, используется ли библиотека DLL, которая ее реализует, что позволяет вызывающей стороне безопасно выгрузить ее, если это не так.</span><span class="sxs-lookup"><span data-stu-id="1a58a-111">As its name implies, [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow) is called to determine whether the DLL that implements it is in use, enabling the caller to safely unload it if it is not.</span></span> <span data-ttu-id="1a58a-112">Вызовы [**кофриунуседлибрариес**](/windows/desktop/api/combaseapi/nf-combaseapi-cofreeunusedlibraries) из любого потока всегда проходят через поток основного апартамента для вызова **DllCanUnloadNow**.</span><span class="sxs-lookup"><span data-stu-id="1a58a-112">Calls to [**CoFreeUnusedLibraries**](/windows/desktop/api/combaseapi/nf-combaseapi-cofreeunusedlibraries) from any thread always route through the main apartment's thread to call **DllCanUnloadNow**.</span></span>

<span data-ttu-id="1a58a-113">Как и другие серверы, внутрипроцессный сервер может быть многопоточным, потоковым или свободным потоком.</span><span class="sxs-lookup"><span data-stu-id="1a58a-113">Like other servers, in-process servers can be single-threaded, apartment-threaded, or free-threaded.</span></span> <span data-ttu-id="1a58a-114">Эти серверы могут использоваться любым клиентом OLE независимо от модели потоков, используемой этим клиентом.</span><span class="sxs-lookup"><span data-stu-id="1a58a-114">These servers can be used by any OLE client, regardless of the threading model used by that client.</span></span>

<span data-ttu-id="1a58a-115">Все комбинации взаимодействия модели потоков разрешены между клиентами и внутрипроцессный объект.</span><span class="sxs-lookup"><span data-stu-id="1a58a-115">All combinations of threading model interoperability are allowed between clients and in-process objects.</span></span> <span data-ttu-id="1a58a-116">Взаимодействие между клиентом и внутрипроцессный объект, которые используют различные модели потоков, в точности аналогичен взаимодействию между клиентами и серверами вне процесса.</span><span class="sxs-lookup"><span data-stu-id="1a58a-116">Interaction between a client and an in-process object that use different threading models is exactly like the interaction between clients and out-of-process servers.</span></span> <span data-ttu-id="1a58a-117">Для внутрипроцессного сервера, когда потоковая модель клиента и внутрипроцессного сервера различаются, COM должен интерпосе себя между клиентом и объектом.</span><span class="sxs-lookup"><span data-stu-id="1a58a-117">For an in-process server, when the threading model of the client and in-process server differ, COM must interpose itself between the client and the object.</span></span>

<span data-ttu-id="1a58a-118">Если внутрипроцессный объект, поддерживающий однопотоковую модель, вызывается одновременно несколькими потоками клиента, COM не может разрешить клиентским потокам напрямую обращаться к интерфацеâу объекта "объект не был разработан для такого доступа.</span><span class="sxs-lookup"><span data-stu-id="1a58a-118">When an in-process object that supports the single-threaded model is called simultaneously by multiple threads of a client, COM cannot allow the client threads to directly access the object's interfaceâ€”the object was not designed for such access.</span></span> <span data-ttu-id="1a58a-119">Вместо этого COM должен гарантировать, что вызовы синхронизированы и сделаны только клиентским потоком, создавшим объект.</span><span class="sxs-lookup"><span data-stu-id="1a58a-119">Instead, COM must ensure that calls are synchronized and are made only by the client thread that created the object.</span></span> <span data-ttu-id="1a58a-120">Таким образом, COM создает объект в главном апартаменте клиента и требует, чтобы все другие клиентские подразделения обращаются к объекту через прокси-серверы.</span><span class="sxs-lookup"><span data-stu-id="1a58a-120">Therefore, COM creates the object in the client's main apartment and requires all the other client apartments to access the object by using proxies.</span></span>

<span data-ttu-id="1a58a-121">Когда в клиенте создается поток подразделений в свободной потоковой модели (модель с несколькими потоками), COM выполняет потоковую модель однопотокового подразделения "узел" в клиенте.</span><span class="sxs-lookup"><span data-stu-id="1a58a-121">When a free-threaded apartment (multithreaded apartment model) in a client creates an apartment-threaded in-process server, COM spins up a single-threaded apartment model "host" thread in the client.</span></span> <span data-ttu-id="1a58a-122">Этот ведущий поток создаст объект, и указатель интерфейса будет упакован обратно в свободный поток клиента.</span><span class="sxs-lookup"><span data-stu-id="1a58a-122">This host thread will create the object, and the interface pointer will be marshaled back to the client's free-threaded apartment.</span></span> <span data-ttu-id="1a58a-123">Аналогичным образом, когда однопотоковое подразделение в клиенте модели подразделения создает бесплатный внутрипроцессный сервер, COM выполняет поток на стороне свободных потоков (многопоточное подразделение, в котором будет создан объект, а затем обратно в однопотоковое подразделение клиента).</span><span class="sxs-lookup"><span data-stu-id="1a58a-123">Similarly, when a single-threaded apartment in an apartment-model client creates a free-threaded in-process server, COM spins up a free-threaded host thread (multithreaded apartment on which the object will be created and then marshaled back to the client single-threaded apartment).</span></span>

> [!Note]  
> <span data-ttu-id="1a58a-124">Как правило, при проектировании пользовательского интерфейса на внутрипроцессного сервере необходимо также предоставить код маршалирования для него, чтобы модель COM могла маршалировать интерфейс между клиентскими апартаментами.</span><span class="sxs-lookup"><span data-stu-id="1a58a-124">In general, if you design a custom interface on an in-process server, you should also provide the marshaling code for it so that COM can marshal the interface between client apartments.</span></span>

 

<span data-ttu-id="1a58a-125">COM помогает защитить доступ к объектам, предоставляемым с помощью однопотоковой библиотеки DLL, запрашивая доступ из того же подразделения клиента, в котором они были созданы.</span><span class="sxs-lookup"><span data-stu-id="1a58a-125">COM helps protect access to objects provided by a single-threaded DLL by requiring access from the same client apartment in which they were created.</span></span> <span data-ttu-id="1a58a-126">Кроме того, все точки входа библиотеки DLL (например, [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) и [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)) и глобальные данные всегда должны быть доступны в одном и том же апартаменте.</span><span class="sxs-lookup"><span data-stu-id="1a58a-126">In addition, all of the DLL entry points (like [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) and [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)) and global data should always be accessed by the same apartment.</span></span> <span data-ttu-id="1a58a-127">COM создает такие объекты в основном апартаменте клиента, предоставляя основному апартаменту прямой доступ к указателям объекта.</span><span class="sxs-lookup"><span data-stu-id="1a58a-127">COM creates such objects in the main apartment of the client, giving the main apartment direct access to the object's pointers.</span></span> <span data-ttu-id="1a58a-128">Вызовы из других подразделений используют межпотоковый маршалирование для перехода от прокси к заглушке в главном апартаменте, а затем к объекту.</span><span class="sxs-lookup"><span data-stu-id="1a58a-128">Calls from the other apartments use interthread marshaling to go from the proxy to the stub in the main apartment and then to the object.</span></span> <span data-ttu-id="1a58a-129">Это позволяет COM синхронизировать вызовы к объекту.</span><span class="sxs-lookup"><span data-stu-id="1a58a-129">This allows COM to synchronize calls to the object.</span></span> <span data-ttu-id="1a58a-130">Вызовы между потоками выполняются очень долго, поэтому рекомендуется переписывать эти серверы для поддержки нескольких апартаментов.</span><span class="sxs-lookup"><span data-stu-id="1a58a-130">Interthread calls are slow, so it is recommended that these servers be rewritten to support multiple apartments.</span></span>

<span data-ttu-id="1a58a-131">Как и в случае с однопотоковым внутрипроцессного сервером, объект, предоставленный БИБЛИОТЕКой модели апартамента, должен иметь тот же клиентский контейнер клиента, из которого он был создан.</span><span class="sxs-lookup"><span data-stu-id="1a58a-131">Like a single-threaded in-process server, an object provided by an apartment model DLL must be accessed by the same client apartment from which it was created.</span></span> <span data-ttu-id="1a58a-132">Однако объекты, предоставляемые этим сервером, могут быть созданы в нескольких апартаментах клиента, поэтому сервер должен реализовать свои точки входа (например, [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) и [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)) для многопоточного использования.</span><span class="sxs-lookup"><span data-stu-id="1a58a-132">However, objects provided by this server can be created in multiple apartments of the client, so the server must implement its entry points (like [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) and [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)) for multithreaded use.</span></span> <span data-ttu-id="1a58a-133">Например, если два подразделения клиента пытаются одновременно создать два экземпляра внутрипроцессного объекта, **DllGetClassObject** можно вызывать одновременно обоими апартаментами.</span><span class="sxs-lookup"><span data-stu-id="1a58a-133">For example, if two apartments of a client try to create two instances of the in-process object simultaneously, **DllGetClassObject** can be called simultaneously by both apartments.</span></span> <span data-ttu-id="1a58a-134">**DllCanUnloadNow** должен быть написан таким образом, чтобы библиотека DLL не выгружается, пока код все еще выполняется в библиотеке DLL.</span><span class="sxs-lookup"><span data-stu-id="1a58a-134">**DllCanUnloadNow** must be written so that the DLL does not unload while code is still executing in the DLL.</span></span>

<span data-ttu-id="1a58a-135">Если библиотека DLL предоставляет только один экземпляр фабрики классов для создания всех объектов, реализация фабрики класса также должна быть разработана для многопоточного использования, так как к ней будут обращаться несколько апартаментов клиента.</span><span class="sxs-lookup"><span data-stu-id="1a58a-135">If the DLL provides only one instance of the class factory to create all the objects, the class factory implementation must also be designed for multithreaded use, because it will be accessed by multiple client apartments.</span></span> <span data-ttu-id="1a58a-136">Если библиотека DLL создает новый экземпляр фабрики класса каждый раз, когда вызывается [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) , фабрика класса не должна быть потокобезопасной.</span><span class="sxs-lookup"><span data-stu-id="1a58a-136">If the DLL creates a new instance of the class factory each time [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) is called, the class factory need not be thread-safe.</span></span>

<span data-ttu-id="1a58a-137">Объекты, созданные фабрикой класса, не должны быть потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="1a58a-137">Objects created by the class factory need not be thread-safe.</span></span> <span data-ttu-id="1a58a-138">После создания потоком доступ к объекту всегда осуществляется через этот поток, а все вызовы объекта синхронизируются с помощью COM.</span><span class="sxs-lookup"><span data-stu-id="1a58a-138">Once created by a thread, the object is always accessed through that thread and all calls to the object are synchronized by COM.</span></span> <span data-ttu-id="1a58a-139">Контейнер апартаментной модели клиента, который создает этот объект, получит прямой указатель на объект.</span><span class="sxs-lookup"><span data-stu-id="1a58a-139">The apartment model apartment of a client that creates this object will get a direct pointer to the object.</span></span> <span data-ttu-id="1a58a-140">Клиентские подразделения, отличные от подразделений, в которых был создан объект, должны обращаться к объекту через прокси-серверы.</span><span class="sxs-lookup"><span data-stu-id="1a58a-140">Client apartments that are different from the apartment in which the object was created must access the object through proxies.</span></span> <span data-ttu-id="1a58a-141">Эти прокси-серверы создаются, когда клиент маршалирует интерфейс между его апартаментами.</span><span class="sxs-lookup"><span data-stu-id="1a58a-141">These proxies are created when the client marshals the interface between its apartments.</span></span>

<span data-ttu-id="1a58a-142">Если для внутрипроцессного DLL **ThreadingModel** задано значение "both", объект, предоставленный этой библиотекой DLL, можно создать и использовать напрямую (без прокси-сервера) в однопотоковых или многопоточных клиентские подразделения.</span><span class="sxs-lookup"><span data-stu-id="1a58a-142">When an in-process DLL **ThreadingModel** value is set to "Both", an object provided by this DLL can be created and used directly (without a proxy) in single-threaded or multithreaded client apartments.</span></span> <span data-ttu-id="1a58a-143">Однако его можно использовать непосредственно в пределах апартамента, в котором он был создан.</span><span class="sxs-lookup"><span data-stu-id="1a58a-143">However, it can be used directly only within the apartment in which it was created.</span></span> <span data-ttu-id="1a58a-144">Чтобы передать объект в любой другой апартамент, объект должен быть маршалирован.</span><span class="sxs-lookup"><span data-stu-id="1a58a-144">To give the object to any other apartment, the object must be marshaled.</span></span> <span data-ttu-id="1a58a-145">Объект DLL должен реализовывать собственную синхронизацию, и к нему можно обращаться несколькими клиентскими апартаментами одновременно.</span><span class="sxs-lookup"><span data-stu-id="1a58a-145">The DLL object must implement its own synchronization and can be accessed by multiple client apartments at the same time.</span></span>

<span data-ttu-id="1a58a-146">Для повышения производительности доступа в реальном потоке к внутрипроцессного объектам DLL COM предоставляет функцию [**кокреатефрисреадедмаршалер**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreatefreethreadedmarshaler) .</span><span class="sxs-lookup"><span data-stu-id="1a58a-146">To speed performance for free-threaded access to in-process DLL objects, COM provides the [**CoCreateFreeThreadedMarshaler**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreatefreethreadedmarshaler) function.</span></span> <span data-ttu-id="1a58a-147">Эта функция создает объект маршалирования с произвольным потоком, который можно объединить с объектом внутрипроцессного сервера.</span><span class="sxs-lookup"><span data-stu-id="1a58a-147">This function creates a free-threaded marshaling object that can be aggregated with an in-process server object.</span></span> <span data-ttu-id="1a58a-148">Если потоку-контейнеру клиента в том же процессе требуется доступ к объекту в другом апартаменте, то при статистической обработке свободного потокового маршалером он предоставляет клиенту прямой указатель на объект сервера, а не на прокси-сервер, когда клиент маршалирует интерфейс объекта в другое подразделение.</span><span class="sxs-lookup"><span data-stu-id="1a58a-148">When a client apartment in the same process needs access to an object in another apartment, aggregating the free-threaded marshaler provides the client with a direct pointer to the server object, rather than to a proxy, when the client marshals the object's interface to a different apartment.</span></span> <span data-ttu-id="1a58a-149">Клиенту не требуется выполнять синхронизацию.</span><span class="sxs-lookup"><span data-stu-id="1a58a-149">The client does not need to do any synchronization.</span></span> <span data-ttu-id="1a58a-150">Это работает только в том же процессе; Стандартная упаковка используется для ссылки на объект, который отправляется в другой процесс.</span><span class="sxs-lookup"><span data-stu-id="1a58a-150">This works only within the same process; standard marshaling is used for a reference to the object that is sent to another process.</span></span>

<span data-ttu-id="1a58a-151">Объект, предоставляемый внутрипроцессный библиотекой DLL, поддерживающей только свободную потоковую обработку, — это свободный потоковый объект.</span><span class="sxs-lookup"><span data-stu-id="1a58a-151">An object provided by an in-process DLL that supports only free threading is a free-threaded object.</span></span> <span data-ttu-id="1a58a-152">Он реализует собственную синхронизацию и может быть доступен нескольким клиентским потокам одновременно.</span><span class="sxs-lookup"><span data-stu-id="1a58a-152">It implements its own synchronization and can be accessed by multiple client threads at the same time.</span></span> <span data-ttu-id="1a58a-153">Этот сервер не маршалирует интерфейсы между потоками, поэтому этот сервер можно создать и использовать напрямую (без прокси) только в многопоточных подразделениях клиента.</span><span class="sxs-lookup"><span data-stu-id="1a58a-153">This server does not marshal interfaces between threads, so this server can be created and used directly (without a proxy) only by multithreaded apartments in a client.</span></span> <span data-ttu-id="1a58a-154">Однопотоковые подразделения, которые их создают, будут обращаться к нему через прокси-сервер.</span><span class="sxs-lookup"><span data-stu-id="1a58a-154">Single-threaded apartments that create it will access it through a proxy.</span></span>

## <a name="related-topics"></a><span data-ttu-id="1a58a-155">См. также</span><span class="sxs-lookup"><span data-stu-id="1a58a-155">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="1a58a-156">Доступ к интерфейсам в разных апартаментах</span><span class="sxs-lookup"><span data-stu-id="1a58a-156">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="1a58a-157">Выбор потоковой модели</span><span class="sxs-lookup"><span data-stu-id="1a58a-157">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="1a58a-158">Многопоточные подразделения</span><span class="sxs-lookup"><span data-stu-id="1a58a-158">Multithreaded Apartments</span></span>](multithreaded-apartments.md)
</dt> <dt>

[<span data-ttu-id="1a58a-159">Процессы, потоки и подразделения</span><span class="sxs-lookup"><span data-stu-id="1a58a-159">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="1a58a-160">Однопотоковое и многопоточное взаимодействие</span><span class="sxs-lookup"><span data-stu-id="1a58a-160">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[<span data-ttu-id="1a58a-161">Подразделения с одним потоком</span><span class="sxs-lookup"><span data-stu-id="1a58a-161">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
</dt> </dl>

 

 