---
title: Соображения по поводу программирования без использования блокировок для Xbox 360 и Microsoft Windows
description: В этой статье приводятся общие сведения о некоторых проблемах, которые следует учитывать при попытке использования методов программирования, не связанных с блокировкой.
ms.assetid: 44700352-a791-7ef7-0858-146214b0e3da
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 23bf8d66cada8aff00735fe6d6ac2d4f1369bc32
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2020
ms.locfileid: "103987983"
---
# <a name="lockless-programming-considerations-for-xbox-360-and-microsoft-windows"></a><span data-ttu-id="962ce-103">Соображения по поводу программирования без использования блокировок для Xbox 360 и Microsoft Windows</span><span class="sxs-lookup"><span data-stu-id="962ce-103">Lockless Programming Considerations for Xbox 360 and Microsoft Windows</span></span>

<span data-ttu-id="962ce-104">Программирование без блокировок — это способ безопасного обмена данными между несколькими потоками, не требуя затрат на получение и освобождение блокировок.</span><span class="sxs-lookup"><span data-stu-id="962ce-104">Lockless programming is a way to safely share changing data between multiple threads without the cost of acquiring and releasing locks.</span></span> <span data-ttu-id="962ce-105">Это звучит, как панацея, но программирование без блокировки является сложным и незаметным, и иногда не дает никаких преимуществ, которые он обещает.</span><span class="sxs-lookup"><span data-stu-id="962ce-105">This sounds like a panacea, but lockless programming is complex and subtle, and sometimes doesn't give the benefits that it promises.</span></span> <span data-ttu-id="962ce-106">Программирование с неблокировкой особенно сложно на Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="962ce-106">Lockless programming is particularly complex on Xbox 360.</span></span>

<span data-ttu-id="962ce-107">Программирование без блокировок является допустимым методом для многопоточного программирования, но его не следует использовать в качестве источника.</span><span class="sxs-lookup"><span data-stu-id="962ce-107">Lockless programming is a valid technique for multithreaded programming, but it should not be used lightly.</span></span> <span data-ttu-id="962ce-108">Прежде чем использовать его, необходимо понимать сложность, и необходимо тщательно оценить, чтобы убедиться в том, что на самом деле это дает вам желаемый выигрыш.</span><span class="sxs-lookup"><span data-stu-id="962ce-108">Before using it you must understand the complexities, and you should measure carefully to make sure that it is actually giving you the gains that you expect.</span></span> <span data-ttu-id="962ce-109">Во многих случаях существуют простые и быстрые решения, такие как обмен данными реже, которые следует использовать вместо них.</span><span class="sxs-lookup"><span data-stu-id="962ce-109">In many cases, there are simpler and faster solutions, such as sharing data less frequently, which should be used instead.</span></span>

<span data-ttu-id="962ce-110">Неправильное использование программирования без блокировки требует значительных знаний о вашем оборудовании и компиляторе.</span><span class="sxs-lookup"><span data-stu-id="962ce-110">Using lockless programming correctly and safely requires significant knowledge of both your hardware and your compiler.</span></span> <span data-ttu-id="962ce-111">В этой статье приводятся общие сведения о некоторых проблемах, которые следует учитывать при попытке использования методов программирования, не связанных с блокировкой.</span><span class="sxs-lookup"><span data-stu-id="962ce-111">This article gives an overview of some of the issues to consider when trying to use lockless programming techniques.</span></span>

## <a name="programming-with-locks"></a><span data-ttu-id="962ce-112">Программирование с помощью блокировок</span><span class="sxs-lookup"><span data-stu-id="962ce-112">Programming with Locks</span></span>

<span data-ttu-id="962ce-113">При написании многопоточного кода часто бывает необходимо обмениваться данными между потоками.</span><span class="sxs-lookup"><span data-stu-id="962ce-113">When writing multi-threaded code it is often necessary to share data between threads.</span></span> <span data-ttu-id="962ce-114">Если несколько потоков одновременно считывают и записывают общие структуры данных, может произойти повреждение памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-114">If multiple threads are simultaneously reading and writing the shared data structures, memory corruption can occur.</span></span> <span data-ttu-id="962ce-115">Самый простой способ решения этой проблемы — использовать блокировки.</span><span class="sxs-lookup"><span data-stu-id="962ce-115">The simplest way of solving this problem is to use locks.</span></span> <span data-ttu-id="962ce-116">Например, если Манипулатешареддата должен выполняться только одним потоком за раз, \_ для этого можно использовать критическую секцию, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="962ce-116">For instance, if ManipulateSharedData should only be executed by one thread at a time, a CRITICAL\_SECTION can be used to guarantee this, as in the following code:</span></span>

``` syntax
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection(&cs);

// Use
void ManipulateSharedData()
{
    EnterCriticalSection(&cs);
    // Manipulate stuff...
    LeaveCriticalSection(&cs);
}

// Destroy
DeleteCriticalSection(&cs);
```

<span data-ttu-id="962ce-117">Этот код довольно прост и прост, и легко понять, что он правильно.</span><span class="sxs-lookup"><span data-stu-id="962ce-117">This code is fairly simple and straightforward, and it is easy to tell that it is correct.</span></span> <span data-ttu-id="962ce-118">Однако программирование с блокировкой имеет несколько потенциальных недостатков.</span><span class="sxs-lookup"><span data-stu-id="962ce-118">However, programming with locks comes with several potential disadvantages.</span></span> <span data-ttu-id="962ce-119">Например, если два потока пытаются получить те же две блокировки, но запрашивают их в другом порядке, можно получить взаимоблокировку.</span><span class="sxs-lookup"><span data-stu-id="962ce-119">For example, if two threads try to acquire the same two locks but acquire them in a different order, you may get a deadlock.</span></span> <span data-ttu-id="962ce-120">Если программа удерживает блокировку слишком долго, из-за плохого проектирования или из-за того, что поток был переключен в поток более высокого приоритета, другие потоки могут быть заблокированы в течение длительного времени.</span><span class="sxs-lookup"><span data-stu-id="962ce-120">If a program holds a lock for too long—because of poor design or because the thread has been swapped out by a higher priority thread—other threads may be blocked for a long time.</span></span> <span data-ttu-id="962ce-121">Этот риск особенно хорош на Xbox 360, так как программным потокам назначен аппаратный поток, который разработчик, и операционная система не переместит их в другой аппаратный поток, даже если он бездействует.</span><span class="sxs-lookup"><span data-stu-id="962ce-121">This risk is particularly great on Xbox 360 because the software threads are assigned a hardware thread by the developer, and the operating system won't move them to another hardware thread, even if one is idle.</span></span> <span data-ttu-id="962ce-122">Xbox 360 также не имеет защиты от инверсии приоритета, где поток с высоким приоритетом циклически вращается в цикле, ожидая освобождения потока потоком с низким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="962ce-122">The Xbox 360 also has no protection against priority inversion, where a high-priority thread spins in a loop while waiting for a low-priority thread to release a lock.</span></span> <span data-ttu-id="962ce-123">Наконец, если вызов отложенной процедуры или процедура службы прерываний пытается получить блокировку, то может возникнуть взаимоблокировка.</span><span class="sxs-lookup"><span data-stu-id="962ce-123">Finally, if a deferred procedure call or interrupt service routine tries to acquire a lock, you may get a deadlock.</span></span>

<span data-ttu-id="962ce-124">Несмотря на эти проблемы, примитивы синхронизации, такие как критические разделы, обычно являются лучшим способом координирования нескольких потоков.</span><span class="sxs-lookup"><span data-stu-id="962ce-124">Despite these problems, synchronization primitives, such as critical sections, are generally the best way of coordinating multiple threads.</span></span> <span data-ttu-id="962ce-125">Если примитивы синхронизации слишком медленные, лучшее решение обычно использует их реже.</span><span class="sxs-lookup"><span data-stu-id="962ce-125">If the synchronization primitives are too slow, the best solution is usually to use them less frequently.</span></span> <span data-ttu-id="962ce-126">Однако для тех, кто может предоставить дополнительную сложность, другой вариант — это программирование с блокировкой.</span><span class="sxs-lookup"><span data-stu-id="962ce-126">However, for those who can afford the extra complexity, another option is lockless programming.</span></span>

## <a name="lockless-programming"></a><span data-ttu-id="962ce-127">Программирование с неблокировкой</span><span class="sxs-lookup"><span data-stu-id="962ce-127">Lockless Programming</span></span>

<span data-ttu-id="962ce-128">Незаблокированное программирование, как и предполагает название, является семейством методик для безопасного управления общими данными без использования блокировок.</span><span class="sxs-lookup"><span data-stu-id="962ce-128">Lockless programming, as the name suggests, is a family of techniques for safely manipulating shared data without using locks.</span></span> <span data-ttu-id="962ce-129">Существуют бесблокировки алгоритмы, доступные для передачи сообщений, совместного использования списков и очередей данных и других задач.</span><span class="sxs-lookup"><span data-stu-id="962ce-129">There are lockless algorithms available for passing messages, sharing lists and queues of data, and other tasks.</span></span>

<span data-ttu-id="962ce-130">При программировании без блокировки существует две проблемы, с которыми необходимо работать: неатомарные операции и переупорядочение.</span><span class="sxs-lookup"><span data-stu-id="962ce-130">When doing lockless programming, there are two challenges that you must deal with: non-atomic operations and reordering.</span></span>

## <a name="non-atomic-operations"></a><span data-ttu-id="962ce-131">Операции, не являющиеся атомарными</span><span class="sxs-lookup"><span data-stu-id="962ce-131">Non-Atomic Operations</span></span>

<span data-ttu-id="962ce-132">Атомарная операция — это одна из неделимых — одна, где другие потоки гарантированно не видят операцию, когда она выполняется.</span><span class="sxs-lookup"><span data-stu-id="962ce-132">An atomic operation is one that is indivisible—one where other threads are guaranteed to never see the operation when it is half done.</span></span> <span data-ttu-id="962ce-133">Атомарные операции важны для программирования без блокировки, так как в противном случае другие потоки могут видеть полуширинные значения или непротиворечивое состояние.</span><span class="sxs-lookup"><span data-stu-id="962ce-133">Atomic operations are important for lockless programming, because without them, other threads might see half-written values, or otherwise inconsistent state.</span></span>

<span data-ttu-id="962ce-134">На всех современных процессорах можно предположить, что операции чтения и записи для естественного согласованного машинного типа являются атомарными.</span><span class="sxs-lookup"><span data-stu-id="962ce-134">On all modern processors, you can assume that reads and writes of naturally aligned native types are atomic.</span></span> <span data-ttu-id="962ce-135">Пока размер шины памяти не меньше, чем тип, который считывается или записывается, ЦП считывает и записывает эти типы в одну транзакцию шины, делая так, что другие потоки не смогут видеть их в состоянии "половина завершено".</span><span class="sxs-lookup"><span data-stu-id="962ce-135">As long as the memory bus is at least as wide as the type being read or written, the CPU reads and writes these types in a single bus transaction, making it impossible for other threads to see them in a half-completed state.</span></span> <span data-ttu-id="962ce-136">В архитектуре x86 и x64 нет гарантии, что операции чтения и записи размером более восьми байт являются атомарными.</span><span class="sxs-lookup"><span data-stu-id="962ce-136">On x86 and x64 there, is no guarantee that reads and writes larger than eight bytes are atomic.</span></span> <span data-ttu-id="962ce-137">Это означает, что 16-байтовые операции чтения и записи регистров расширения Streaming SIMD (SSE) и строковых операций могут быть не атомарными.</span><span class="sxs-lookup"><span data-stu-id="962ce-137">This means that 16-byte reads and writes of streaming SIMD extension (SSE) registers, and string operations, might not be atomic.</span></span>

<span data-ttu-id="962ce-138">Операции чтения и записи типов, которые не выровнены естественным образом (например, написание DWORD, которые пересекают границы из четырех байтов), не гарантированно будут атомарными.</span><span class="sxs-lookup"><span data-stu-id="962ce-138">Reads and writes of types that are not naturally aligned—for instance, writing DWORDs that cross four-byte boundaries—are not guaranteed to be atomic.</span></span> <span data-ttu-id="962ce-139">ПРОЦЕССОР может выполнять эти операции чтения и записи как несколько транзакций шины, что позволяет другому потоку изменять или просматривать данные в середине чтения или записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-139">The CPU may have to do these reads and writes as multiple bus transactions, which could allow another thread to modify or see the data in the middle of the read or write.</span></span>

<span data-ttu-id="962ce-140">Составные операции, такие как чтение и изменение — запись, выполняемая при увеличении общей переменной, не являются атомарными.</span><span class="sxs-lookup"><span data-stu-id="962ce-140">Composite operations, such as the read-modify-write sequence that occurs when you increment a shared variable, are not atomic.</span></span> <span data-ttu-id="962ce-141">На Xbox 360 эти операции реализуются в виде нескольких инструкций (ЛВЗ, Адди и СТВ), и поток можно переключать попадете с помощью последовательности.</span><span class="sxs-lookup"><span data-stu-id="962ce-141">On Xbox 360, these operations are implemented as multiple instructions (lwz, addi, and stw), and the thread could be swapped out partway through the sequence.</span></span> <span data-ttu-id="962ce-142">На платформах x86 и x64 имеется одна инструкция (Inc.), которую можно использовать для увеличения переменной в памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-142">On x86 and x64, there is a single instruction (inc) that can be used to increment a variable in memory.</span></span> <span data-ttu-id="962ce-143">При использовании этой инструкции увеличение переменной происходит атомарно на однопроцессорных системах, но по-прежнему не является атомарным для многопроцессорных систем.</span><span class="sxs-lookup"><span data-stu-id="962ce-143">If you use this instruction, incrementing a variable is atomic on single-processor systems, but it is still not atomic on multi-processor systems.</span></span> <span data-ttu-id="962ce-144">Чтобы сделать Inc атомарным многопроцессорным системам на базе x86 и x64, необходимо использовать префикс блокировки, который не позволяет другому процессору выполнить собственную последовательность чтения-изменения и записи между чтением и записью инструкции Inc.</span><span class="sxs-lookup"><span data-stu-id="962ce-144">Making inc atomic on x86- and x64-based multi-processor systems requires using the lock prefix, which prevents another processor from doing its own read-modify-write sequence between the read and the write of the inc instruction.</span></span>

<span data-ttu-id="962ce-145">В коде ниже приведено несколько примеров:</span><span class="sxs-lookup"><span data-stu-id="962ce-145">The following code shows some examples:</span></span>

``` syntax
// This write is not atomic because it is not natively aligned.
DWORD* pData = (DWORD*)(pChar + 1);
*pData = 0;

// This is not atomic because it is three separate operations.
++g_globalCounter;

// This write is atomic.
g_alignedGlobal = 0;

// This read is atomic.
DWORD local = g_alignedGlobal;
```

## <a name="guaranteeing-atomicity"></a><span data-ttu-id="962ce-146">Обеспечение атомарности</span><span class="sxs-lookup"><span data-stu-id="962ce-146">Guaranteeing Atomicity</span></span>

<span data-ttu-id="962ce-147">Вы можете убедиться, что вы используете атомарные операции, используя сочетание следующих параметров:</span><span class="sxs-lookup"><span data-stu-id="962ce-147">You can be sure you are using atomic operations by a combination of the following:</span></span>

-   <span data-ttu-id="962ce-148">Естественным образом атомарные операции</span><span class="sxs-lookup"><span data-stu-id="962ce-148">Naturally atomic operations</span></span>
-   <span data-ttu-id="962ce-149">Блокировки для составных операций</span><span class="sxs-lookup"><span data-stu-id="962ce-149">Locks to wrap composite operations</span></span>
-   <span data-ttu-id="962ce-150">Функции операционной системы, реализующие атомарные версии популярных составных операций</span><span class="sxs-lookup"><span data-stu-id="962ce-150">Operating system functions that implement atomic versions of popular composite operations</span></span>

<span data-ttu-id="962ce-151">Увеличение переменной не является атомарной операцией, а увеличение может привести к повреждению данных, если оно выполняется в нескольких потоках.</span><span class="sxs-lookup"><span data-stu-id="962ce-151">Incrementing a variable is not an atomic operation, and incrementing may lead to data corruption if executed on multiple threads.</span></span>

``` syntax
// This will be atomic.
g_globalCounter = 0;

// This is not atomic and gives undefined behavior
// if executed on multiple threads
++g_globalCounter;
```

<span data-ttu-id="962ce-152">Win32 поставляется с семейством функций, которые обеспечивают атомарные операции чтения и изменения для записи нескольких распространенных операций.</span><span class="sxs-lookup"><span data-stu-id="962ce-152">Win32 comes with a family of functions that offer atomic read-modify-write versions of several common operations.</span></span> <span data-ttu-id="962ce-153">Это семейство функций Интерлоккедкскскс.</span><span class="sxs-lookup"><span data-stu-id="962ce-153">These are the InterlockedXxx family of functions.</span></span> <span data-ttu-id="962ce-154">Если все изменения в общей переменной используют эти функции, изменения будут потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="962ce-154">If all modifications of the shared variable use these functions, the modifications will be thread safe.</span></span>

``` syntax
// Incrementing our variable in a safe lockless way.
InterlockedIncrement(&g_globalCounter);
```

## <a name="reordering"></a><span data-ttu-id="962ce-155">Переупорядочение</span><span class="sxs-lookup"><span data-stu-id="962ce-155">Reordering</span></span>

<span data-ttu-id="962ce-156">Более сложная проблема заключается в переупорядочении.</span><span class="sxs-lookup"><span data-stu-id="962ce-156">A more subtle problem is reordering.</span></span> <span data-ttu-id="962ce-157">Операции чтения и записи не всегда происходят в том порядке, в котором они были написаны в коде, и это может привести к очень запутанным проблемам.</span><span class="sxs-lookup"><span data-stu-id="962ce-157">Reads and writes do not always happen in the order that you have written them in your code, and this can lead to very confusing problems.</span></span> <span data-ttu-id="962ce-158">Во многих многопоточных алгоритмах поток записывает некоторые данные, а затем записывает их в флаг, сообщающий другим потокам, что данные готовы.</span><span class="sxs-lookup"><span data-stu-id="962ce-158">In many multi-threaded algorithms, a thread writes some data and then writes to a flag that tells other threads that the data is ready.</span></span> <span data-ttu-id="962ce-159">Это называется записью выпуска.</span><span class="sxs-lookup"><span data-stu-id="962ce-159">This is known as a write-release.</span></span> <span data-ttu-id="962ce-160">Если операции записи переупорядочиваются, другие потоки могут увидеть, что флаг установлен, прежде чем они смогут увидеть записанные данные.</span><span class="sxs-lookup"><span data-stu-id="962ce-160">If the writes are reordered, other threads may see that the flag is set before they can see the written data.</span></span>

<span data-ttu-id="962ce-161">Аналогичным образом, во многих случаях поток считывает данные из флага, а затем считывает часть общих данных, если флаг говорит, что поток получил доступ к общим данным.</span><span class="sxs-lookup"><span data-stu-id="962ce-161">Similarly, in many cases, a thread reads from a flag and then reads some shared data if the flag says that the thread has acquired access to the shared data.</span></span> <span data-ttu-id="962ce-162">Это называется получением для чтения.</span><span class="sxs-lookup"><span data-stu-id="962ce-162">This is known as a read-acquire.</span></span> <span data-ttu-id="962ce-163">Если операции чтения переупорядочиваются, то данные могут быть считаны из общего хранилища до флага, и отображаемые значения могут оказаться неактуальными.</span><span class="sxs-lookup"><span data-stu-id="962ce-163">If reads are reordered, then the data may be read from shared storage before the flag, and the values seen might not be up to date.</span></span>

<span data-ttu-id="962ce-164">Изменение порядка операций чтения и записи может выполняться компилятором и процессором.</span><span class="sxs-lookup"><span data-stu-id="962ce-164">Reordering of reads and writes can be done both by the compiler and by the processor.</span></span> <span data-ttu-id="962ce-165">Компиляторы и процессоры выполнили это изменение порядка в течение нескольких лет, но на однопроцессорных компьютерах это было меньше.</span><span class="sxs-lookup"><span data-stu-id="962ce-165">Compilers and processors have done this reordering for years, but on single-processor machines it was less of an issue.</span></span> <span data-ttu-id="962ce-166">Это связано с тем, что изменение количества операций чтения и записи ЦП на однопроцессорных компьютерах невидимо (для кода драйвера не устройства, который не является частью драйвера устройства), и изменение порядка операций чтения и записи в компиляторе снижает вероятность возникновения проблем на компьютерах с одним процессором.</span><span class="sxs-lookup"><span data-stu-id="962ce-166">This is because CPU rearrangement of reads and writes is invisible on single-processor machines (for non-device driver code that is not part of a device driver), and compiler rearrangement of reads and writes is less likely to cause problems on single-processor machines.</span></span>

<span data-ttu-id="962ce-167">Если компилятор или ЦП переупорядочивает записи, показанные в следующем коде, другой поток может увидеть, что флаг Alive установлен, а старые значения для x или y не видны.</span><span class="sxs-lookup"><span data-stu-id="962ce-167">If the compiler or the CPU rearranges the writes shown in the following code, another thread may see that the alive flag is set while still seeing the old values for x or y.</span></span> <span data-ttu-id="962ce-168">Аналогичное изменение может произойти при чтении.</span><span class="sxs-lookup"><span data-stu-id="962ce-168">Similar rearrangement can happen when reading.</span></span>

<span data-ttu-id="962ce-169">В этом коде один поток добавляет новую запись в массив Sprite:</span><span class="sxs-lookup"><span data-stu-id="962ce-169">In this code, one thread adds a new entry to the sprite array:</span></span>

``` syntax
// Create a new sprite by writing its position into an empty
// entry and then setting the ‘alive' flag. If ‘alive' is
// written before x or y then errors may occur.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="962ce-170">В следующем блоке кода другой поток считывает из массива спрайта:</span><span class="sxs-lookup"><span data-stu-id="962ce-170">In this next code block, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites. If the reads of x and y are moved ahead of
// the read of ‘alive' then errors may occur.
for( int i = 0; i < numSprites; ++i )
{
    if( g_sprites[nextSprite].alive )
    {
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="962ce-171">Чтобы обеспечить безопасность системы спрайта, необходимо предотвратить Переупорядочение операций чтения и записи для компилятора и ЦП.</span><span class="sxs-lookup"><span data-stu-id="962ce-171">To make this sprite system safe, we need to prevent both compiler and CPU reordering of reads and writes.</span></span>

### <a name="understanding-cpu-rearrangement-of-writes"></a><span data-ttu-id="962ce-172">Основные сведения о перекомпоновке операций записи ЦП</span><span class="sxs-lookup"><span data-stu-id="962ce-172">Understanding CPU Rearrangement of Writes</span></span>

<span data-ttu-id="962ce-173">Некоторые ЦП переупорядочивают записи, чтобы они были видны другим процессорам или устройствам в порядке, отличном от программы.</span><span class="sxs-lookup"><span data-stu-id="962ce-173">Some CPUs rearrange writes so that they are externally visible to other processors or devices in non-program order.</span></span> <span data-ttu-id="962ce-174">Это изменение никогда не является видимым для однопотокового кода, не относящегося к драйверу, но может вызвать проблемы в многопоточном коде.</span><span class="sxs-lookup"><span data-stu-id="962ce-174">This rearranging is never visible to single-threaded non-driver code, but it can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="962ce-175">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="962ce-175">Xbox 360</span></span>

<span data-ttu-id="962ce-176">Хотя процессор Xbox 360 не упорядочивает инструкции, он переупорядочивает операции записи, что завершается после выполнения инструкций.</span><span class="sxs-lookup"><span data-stu-id="962ce-176">While the Xbox 360 CPU does not reorder instructions, it does rearrange write operations, which complete after the instructions themselves.</span></span> <span data-ttu-id="962ce-177">Такое изменение порядка операций записи осуществляется специально для модели памяти PowerPC.</span><span class="sxs-lookup"><span data-stu-id="962ce-177">This rearranging of writes is specifically allowed by the PowerPC memory model.</span></span>

<span data-ttu-id="962ce-178">Операции записи на Xbox 360 не переходят непосредственно в кэш L2.</span><span class="sxs-lookup"><span data-stu-id="962ce-178">Writes on Xbox 360 do not go directly to the L2 cache.</span></span> <span data-ttu-id="962ce-179">Вместо этого, чтобы улучшить пропускную способность записи в кэш L2, они проходят через очереди хранилища, а затем — для хранения буферов.</span><span class="sxs-lookup"><span data-stu-id="962ce-179">Instead, in order to improve L2 cache write bandwidth, they go through store queues and then to store-gather buffers.</span></span> <span data-ttu-id="962ce-180">Буферы сбора данных хранилища позволяют записывать блоки 64 байт в кэш L2 за одну операцию.</span><span class="sxs-lookup"><span data-stu-id="962ce-180">The store-gather buffers allow 64-byte blocks to be written to the L2 cache in one operation.</span></span> <span data-ttu-id="962ce-181">Существует восемь буферов для сбора данных о хранении, которые обеспечивают эффективную запись в несколько различных областей памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-181">There are eight store-gather buffers, which allow efficient writing to several different areas of memory.</span></span>

<span data-ttu-id="962ce-182">Буферы сбора данных хранения обычно записываются в кэш L2 в порядке "первым вошел — первым обслужен" (FIFO).</span><span class="sxs-lookup"><span data-stu-id="962ce-182">The store-gather buffers are normally written to the L2 cache in first-in-first-out (FIFO) order.</span></span> <span data-ttu-id="962ce-183">Однако если целевой кэш-адрес записи не находится в кэше L2, запись может быть отложена, пока строка кэша извлекается из памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-183">However, if the target cache-line of a write is not in the L2 cache, that write may be delayed while the cache-line is fetched from memory.</span></span>

<span data-ttu-id="962ce-184">Даже если буферы сбора данных хранилища записываются в кэш L2 в определенном порядке FIFO, это не гарантирует, что отдельные операции записи записываются в кэш L2 по порядку.</span><span class="sxs-lookup"><span data-stu-id="962ce-184">Even when the store-gather buffers are written to the L2 cache in strict FIFO order, this does not guarantee that individual writes are written to the L2 cache in order.</span></span> <span data-ttu-id="962ce-185">Например, представьте, что ЦП записывает в расположение 0x1000, затем на Location 0x2000, а затем в Location 0x1004.</span><span class="sxs-lookup"><span data-stu-id="962ce-185">For instance, imagine that the CPU writes to location 0x1000, then to location 0x2000, and then to location 0x1004.</span></span> <span data-ttu-id="962ce-186">Первая запись выделяет буфер сбора данных о хранилище и помещает его в начало очереди.</span><span class="sxs-lookup"><span data-stu-id="962ce-186">The first write allocates a store-gather buffer and puts it at the front of the queue.</span></span> <span data-ttu-id="962ce-187">Вторая запись выделяет другой буфер сбора данных о хранении и помещает его в очередь далее.</span><span class="sxs-lookup"><span data-stu-id="962ce-187">The second write allocates another store-gather buffer and puts it next in the queue.</span></span> <span data-ttu-id="962ce-188">Третья запись добавляет свои данные в первый буфер хранилища данных, который остается в начале очереди.</span><span class="sxs-lookup"><span data-stu-id="962ce-188">The third write adds its data to the first store-gather buffer, which remains at the front of the queue.</span></span> <span data-ttu-id="962ce-189">Таким же третью запись будет находиться в кэше L2 до второй записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-189">Thus, the third write ends up going to the L2 cache before the second write.</span></span>

<span data-ttu-id="962ce-190">Переупорядочение, вызванное буферами сбора данных о хранении, является фундаментальным непредсказуемым, особенно потому, что оба потока в ядре совместно используют буферы для сбора данных хранилища, что делает выделение и очистку буферов с высокой степенью переменными.</span><span class="sxs-lookup"><span data-stu-id="962ce-190">Reordering caused by store-gather buffers is fundamentally unpredictable, especially because both threads on a core share the store-gather buffers, making the allocation and emptying of the store-gather buffers highly variable.</span></span>

<span data-ttu-id="962ce-191">Это один из примеров того, как можно изменить порядок записей.</span><span class="sxs-lookup"><span data-stu-id="962ce-191">This is one example of how writes can be reordered.</span></span> <span data-ttu-id="962ce-192">Возможны и другие возможности.</span><span class="sxs-lookup"><span data-stu-id="962ce-192">There may be other possibilities.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="962ce-193">x86 и x64</span><span class="sxs-lookup"><span data-stu-id="962ce-193">x86 and x64</span></span>

<span data-ttu-id="962ce-194">Несмотря на то, что процессоры x86 и x64 выполняют инструкции по изменению порядка, они обычно не переупорядочивают операции записи относительно других операций записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-194">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder write operations relative to other writes.</span></span> <span data-ttu-id="962ce-195">Существуют некоторые исключения для общей памяти с записью.</span><span class="sxs-lookup"><span data-stu-id="962ce-195">There are some exceptions for write-combined memory.</span></span> <span data-ttu-id="962ce-196">Кроме того, операции со строковыми операциями (МОВС и СТОС) и 16-байтовые записи SSE могут быть упорядочены внутри, но в противном случае операции записи не переупорядочиваются по отношению друг к другу.</span><span class="sxs-lookup"><span data-stu-id="962ce-196">Additionally, string operations (MOVS and STOS) and 16-byte SSE writes can be internally reordered, but otherwise, writes are not reordered relative to each other.</span></span>

### <a name="understanding-cpu-rearrangement-of-reads"></a><span data-ttu-id="962ce-197">Общие сведения о перестановке операций чтения ЦП</span><span class="sxs-lookup"><span data-stu-id="962ce-197">Understanding CPU Rearrangement of Reads</span></span>

<span data-ttu-id="962ce-198">Некоторые ЦП переупорядочивают операции чтения, чтобы они эффективно поступали из общего хранилища в порядке, отличном от программы.</span><span class="sxs-lookup"><span data-stu-id="962ce-198">Some CPUs rearrange reads so that they effectively come from shared storage in non-program order.</span></span> <span data-ttu-id="962ce-199">Это изменение никогда не является видимым для однопотокового кода, не относящегося к драйверу, но может вызвать проблемы в многопоточном коде.</span><span class="sxs-lookup"><span data-stu-id="962ce-199">This rearranging is never visible to single-threaded non-driver code, but can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="962ce-200">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="962ce-200">Xbox 360</span></span>

<span data-ttu-id="962ce-201">Промахи в кэше могут привести к задержке операций чтения, что эффективно приводит к тому, что операции чтения поступают из общей памяти в неправильном порядке, а время этих промахов кэша является фундаментальным непредсказуемым.</span><span class="sxs-lookup"><span data-stu-id="962ce-201">Cache misses can cause some reads to be delayed, which effectively causes reads to come from shared memory out of order, and the timing of these cache misses is fundamentally unpredictable.</span></span> <span data-ttu-id="962ce-202">Предварительная выборка и прогнозирование ветвей также могут привести к неупорядоченному получению данных из общей памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-202">Prefetching and branch prediction can also cause data to come from shared memory out of order.</span></span> <span data-ttu-id="962ce-203">Это лишь несколько примеров того, как можно изменить порядок операций чтения.</span><span class="sxs-lookup"><span data-stu-id="962ce-203">These are just a few examples of how reads can be reordered.</span></span> <span data-ttu-id="962ce-204">Возможны и другие возможности.</span><span class="sxs-lookup"><span data-stu-id="962ce-204">There may be other possibilities.</span></span> <span data-ttu-id="962ce-205">Такое изменение порядка операций чтения выполняется специально для модели памяти PowerPC.</span><span class="sxs-lookup"><span data-stu-id="962ce-205">This rearranging of reads is specifically allowed by the PowerPC memory model.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="962ce-206">x86 и x64</span><span class="sxs-lookup"><span data-stu-id="962ce-206">x86 and x64</span></span>

<span data-ttu-id="962ce-207">Несмотря на то, что процессоры x86 и x64 выполняют инструкции по изменению порядка, они обычно не переупорядочивают операции чтения относительно других операций чтения.</span><span class="sxs-lookup"><span data-stu-id="962ce-207">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder read operations relative to other reads.</span></span> <span data-ttu-id="962ce-208">Операции со строковыми операциями (МОВС и СТОС) и 16-битные операции чтения SSE могут быть упорядочены по внутреннему индексу, но в противном случае операции чтения не переупорядочиваются по отношению друг к другу.</span><span class="sxs-lookup"><span data-stu-id="962ce-208">String operations (MOVS and STOS) and 16-byte SSE reads can be internally reordered, but otherwise, reads are not reordered relative to each other.</span></span>

### <a name="other-reordering"></a><span data-ttu-id="962ce-209">Другие изменения порядка</span><span class="sxs-lookup"><span data-stu-id="962ce-209">Other Reordering</span></span>

<span data-ttu-id="962ce-210">Хотя процессоры x86 и x64 не переупорядочивают операции записи относительно других операций записи или переупорядочивают операции чтения относительно других операций чтения, они могут переупорядочивать операции чтения относительно операций записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-210">Even though x86 and x64 CPUs do not reorder writes relative to other writes, or reorder reads relative to other reads, they can reorder reads relative to writes.</span></span> <span data-ttu-id="962ce-211">В частности, если программа выполняет запись в одно расположение, а затем считывает из другого расположения, то данные для чтения могут поступать из общей памяти, прежде чем записанные данные станут там.</span><span class="sxs-lookup"><span data-stu-id="962ce-211">Specifically, if a program writes to one location followed by reading from a different location, the read data may come from shared memory before the written data makes it there.</span></span> <span data-ttu-id="962ce-212">Изменение порядка может привести к нарушению работы некоторых алгоритмов, таких как алгоритмы взаимного исключения Деккер.</span><span class="sxs-lookup"><span data-stu-id="962ce-212">This reordering can break some algorithms, such as Dekker’s mutual exclusion algorithms.</span></span> <span data-ttu-id="962ce-213">В алгоритме Деккер каждый поток задает флаг, указывающий, что требуется ввести критическую область, а затем проверяет флаг другого потока, чтобы определить, находится ли другой поток в критическом регионе или пытаетесь его ввести.</span><span class="sxs-lookup"><span data-stu-id="962ce-213">In Dekker's algorithm, each thread sets a flag to indicate that it wants to enter the critical region, and then checks the other thread’s flag to see if the other thread is in the critical region or trying to enter it.</span></span> <span data-ttu-id="962ce-214">Исходный код приведен ниже.</span><span class="sxs-lookup"><span data-stu-id="962ce-214">The initial code follows.</span></span>

``` syntax
volatile bool f0 = false;
volatile bool f1 = false;

void P0Acquire()
{
    // Indicate intention to enter critical region
    f0 = true;
    // Check for other thread in or entering critical region
    while (f1)
    {
        // Handle contention.
    }
    // critical region
    ...
}


void P1Acquire()
{
    // Indicate intention to enter critical region
    f1 = true;
    // Check for other thread in or entering critical region
    while (f0)
    {
        // Handle contention.
    }
    // critical region
    ...
}
```

<span data-ttu-id="962ce-215">Проблема заключается в том, что чтение данных F1 в P0Acquire может считаться из общего хранилища, прежде чем запись в F0 сделает его общим хранилищем.</span><span class="sxs-lookup"><span data-stu-id="962ce-215">The problem is that the read of f1 in P0Acquire can read from shared storage before the write to f0 makes it to shared storage.</span></span> <span data-ttu-id="962ce-216">В то же время чтение F0 в P1Acquire может считаться из общего хранилища, прежде чем запись в F1 сделает его общим хранилищем.</span><span class="sxs-lookup"><span data-stu-id="962ce-216">Meanwhile, the read of f0 in P1Acquire can read from shared storage before the write to f1 makes it to shared storage.</span></span> <span data-ttu-id="962ce-217">Результатом является то, что оба потока устанавливают флаги равными TRUE, и оба потока видят флаг другого потока как FALSE, поэтому они одновременно указывают на критическую область.</span><span class="sxs-lookup"><span data-stu-id="962ce-217">The net effect is that both threads set their flags to TRUE, and both threads see the other thread's flag as being FALSE, so they both enter the critical region.</span></span> <span data-ttu-id="962ce-218">Поэтому, хотя проблемы с изменением порядка в системах на базе x86 и x64 менее распространены, чем в Xbox 360, они, конечно же, могут по-прежнему выполняться.</span><span class="sxs-lookup"><span data-stu-id="962ce-218">Therefore, while problems with reordering on x86- and x64-based systems are less common than on Xbox 360, they definitely can still happen.</span></span> <span data-ttu-id="962ce-219">Алгоритм Деккер не будет работать без барьеров аппаратной памяти на любой из этих платформ.</span><span class="sxs-lookup"><span data-stu-id="962ce-219">Dekker’s algorithm will not work without hardware memory barriers on any of these platforms.</span></span>

<span data-ttu-id="962ce-220">Процессоры x86 и x64 не будут переупорядочивать записи перед предыдущим чтением.</span><span class="sxs-lookup"><span data-stu-id="962ce-220">x86 and x64 CPUs will not reorder a write ahead of a previous read.</span></span> <span data-ttu-id="962ce-221">Процессоры x86 и x64 переупорядочивают только операции чтения перед предыдущими операциями записи, если они предназначены для разных расположений.</span><span class="sxs-lookup"><span data-stu-id="962ce-221">x86 and x64 CPUs only reorder reads ahead of previous writes if they target different locations.</span></span>

<span data-ttu-id="962ce-222">Процессоры PowerPC могут переупорядочивать операции чтения перед операциями записи, а также переупорядочивать записи перед чтением, если они относятся к разным адресам.</span><span class="sxs-lookup"><span data-stu-id="962ce-222">PowerPC CPUs can reorder reads ahead of writes, and can reorder writes ahead of reads, as long as they are to different addresses.</span></span>

### <a name="reordering-summary"></a><span data-ttu-id="962ce-223">Сводка по переупорядочиванию</span><span class="sxs-lookup"><span data-stu-id="962ce-223">Reordering Summary</span></span>

<span data-ttu-id="962ce-224">ЦП Xbox 360 переупорядочивает операции с памятью гораздо более агрессивно, чем процессоры x86 и x64, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="962ce-224">The Xbox 360 CPU reorders memory operations much more aggressively than do x86 and x64 CPUs, as shown in the following table.</span></span> <span data-ttu-id="962ce-225">Дополнительные сведения см. в документации к процессору.</span><span class="sxs-lookup"><span data-stu-id="962ce-225">For more details, consult the processor documentation.</span></span>



| <span data-ttu-id="962ce-226">Действие изменения порядка</span><span class="sxs-lookup"><span data-stu-id="962ce-226">Reordering Activity</span></span>           | <span data-ttu-id="962ce-227">x86 и x64</span><span class="sxs-lookup"><span data-stu-id="962ce-227">x86 and x64</span></span> | <span data-ttu-id="962ce-228">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="962ce-228">Xbox 360</span></span> |
|-------------------------------|-------------|----------|
| <span data-ttu-id="962ce-229">Чтение с опережением чтения</span><span class="sxs-lookup"><span data-stu-id="962ce-229">Reads moving ahead of reads</span></span>   | <span data-ttu-id="962ce-230">Нет</span><span class="sxs-lookup"><span data-stu-id="962ce-230">No</span></span>          | <span data-ttu-id="962ce-231">Да</span><span class="sxs-lookup"><span data-stu-id="962ce-231">Yes</span></span>      |
| <span data-ttu-id="962ce-232">Операций записи, предшествующих записи</span><span class="sxs-lookup"><span data-stu-id="962ce-232">Writes moving ahead of writes</span></span> | <span data-ttu-id="962ce-233">Нет</span><span class="sxs-lookup"><span data-stu-id="962ce-233">No</span></span>          | <span data-ttu-id="962ce-234">Да</span><span class="sxs-lookup"><span data-stu-id="962ce-234">Yes</span></span>      |
| <span data-ttu-id="962ce-235">Операций записи, перемещенных вперед</span><span class="sxs-lookup"><span data-stu-id="962ce-235">Writes moving ahead of reads</span></span>  | <span data-ttu-id="962ce-236">Нет</span><span class="sxs-lookup"><span data-stu-id="962ce-236">No</span></span>          | <span data-ttu-id="962ce-237">Да</span><span class="sxs-lookup"><span data-stu-id="962ce-237">Yes</span></span>      |
| <span data-ttu-id="962ce-238">Считывания за преупреждающим числом операций записи</span><span class="sxs-lookup"><span data-stu-id="962ce-238">Reads moving ahead of writes</span></span>  | <span data-ttu-id="962ce-239">Да</span><span class="sxs-lookup"><span data-stu-id="962ce-239">Yes</span></span>         | <span data-ttu-id="962ce-240">Да</span><span class="sxs-lookup"><span data-stu-id="962ce-240">Yes</span></span>      |



 

## <a name="read-acquire-and-write-release-barriers"></a><span data-ttu-id="962ce-241">Барьеры Read-Acquire и Write-Release</span><span class="sxs-lookup"><span data-stu-id="962ce-241">Read-Acquire and Write-Release Barriers</span></span>

<span data-ttu-id="962ce-242">Основные конструкции, используемые для предотвращения переупорядочения операций чтения и записи, называются барьерами чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-242">The main constructs used to prevent reordering of reads and writes are called read-acquire and write-release barriers.</span></span> <span data-ttu-id="962ce-243">Запрос на чтение — это чтение флага или другой переменной для получения владения ресурсом в сочетании с барьером в переупорядочении.</span><span class="sxs-lookup"><span data-stu-id="962ce-243">A read-acquire is a read of a flag or other variable to gain ownership of a resource, coupled with a barrier against reordering.</span></span> <span data-ttu-id="962ce-244">Аналогичным образом, запись в эксплуатацию — это запись флага или другой переменной для предоставления владения ресурсом в сочетании с барьером для переупорядочения.</span><span class="sxs-lookup"><span data-stu-id="962ce-244">Similarly, a write-release is a write of a flag or other variable to give away ownership of a resource, coupled with a barrier against reordering.</span></span>

<span data-ttu-id="962ce-245">Формальные определения с помощью Герб Саттер:</span><span class="sxs-lookup"><span data-stu-id="962ce-245">The formal definitions, courtesy of Herb Sutter, are:</span></span>

-   <span data-ttu-id="962ce-246">Чтение и запись выполняется до всех операций чтения и записи в том же потоке, который находится за ним в порядке программ.</span><span class="sxs-lookup"><span data-stu-id="962ce-246">A read-acquire executes before all reads and writes by the same thread that follow it in program order.</span></span>
-   <span data-ttu-id="962ce-247">Запись-выпуск выполняется после всех операций чтения и записи в том же потоке, который предшествует ему в порядке программ.</span><span class="sxs-lookup"><span data-stu-id="962ce-247">A write-release executes after all reads and writes by the same thread that precede it in program order.</span></span>

<span data-ttu-id="962ce-248">Когда код получает владение некоторой памятью либо путем получения блокировки, либо путем извлечения элемента из общего связанного списка (без блокировки), используется постоянное чтение — тестирование флага или указателя, чтобы проверить, была ли получена принадлежность к памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-248">When your code acquires ownership of some memory, either by acquiring a lock or by pulling an item off of a shared linked list (without a lock), there is always a read involved—testing a flag or pointer to see if ownership of the memory has been acquired.</span></span> <span data-ttu-id="962ce-249">Эта операция чтения может быть частью операции **интерлоккедкскскс** . в этом случае она включает как чтение, так и запись, но является чтением, указывающим, получен ли владелец.</span><span class="sxs-lookup"><span data-stu-id="962ce-249">This read may be part of an **InterlockedXxx** operation, in which case it involves both a read and a write, but it is the read that indicates whether ownership has been gained.</span></span> <span data-ttu-id="962ce-250">После получения владения памятью значения обычно считываются из этой памяти или записываются в нее, и очень важно, чтобы эти операции чтения и записи выполнялись после получения владения.</span><span class="sxs-lookup"><span data-stu-id="962ce-250">After ownership of the memory is acquired, values are typically read from or written to that memory, and it is very important that these reads and writes execute after acquiring ownership.</span></span> <span data-ttu-id="962ce-251">Это гарантирует барьер для чтения и получения.</span><span class="sxs-lookup"><span data-stu-id="962ce-251">A read-acquire barrier guarantees this.</span></span>

<span data-ttu-id="962ce-252">Когда освобождается владение какой-либо памятью путем снятия блокировки или путем отправки элемента в общий связанный список, всегда существует запись, которая сообщает другим потокам о том, что память теперь доступна для них.</span><span class="sxs-lookup"><span data-stu-id="962ce-252">When ownership of some memory is released, either by releasing a lock or by pushing an item on to a shared linked list, there is always a write involved which notifies other threads that the memory is now available to them.</span></span> <span data-ttu-id="962ce-253">Несмотря на то, что код владеет памятью, он, вероятно, считывает данные из нее или пишет его, и очень важно, чтобы эти операции чтения и записи выполнялись до освобождения владения.</span><span class="sxs-lookup"><span data-stu-id="962ce-253">While your code had ownership of the memory, it probably read from or wrote to it, and it is very important that these reads and writes execute before releasing ownership.</span></span> <span data-ttu-id="962ce-254">Это гарантируется с помощью барьера выпуска для записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-254">A write-release barrier guarantees this.</span></span>

<span data-ttu-id="962ce-255">Проще всего подумать о барьерах чтения и записи в качестве отдельных операций.</span><span class="sxs-lookup"><span data-stu-id="962ce-255">It is simplest to think of read-acquire and write-release barriers as single operations.</span></span> <span data-ttu-id="962ce-256">Однако иногда их необходимо создавать из двух частей: чтение или запись, а также барьер, который не допускает операции чтения или записи для перемещения по нему.</span><span class="sxs-lookup"><span data-stu-id="962ce-256">However, they sometimes have to be constructed from two parts: a read or write and a barrier that does not allow reads or writes to move across it.</span></span> <span data-ttu-id="962ce-257">В этом случае размещение барьера является критически важным.</span><span class="sxs-lookup"><span data-stu-id="962ce-257">In this case, the placement of the barrier is critical.</span></span> <span data-ttu-id="962ce-258">Для барьера, читающего запросы на чтение, сначала выполняется чтение флага, затем барьер, а затем считываются и записываются общие данные.</span><span class="sxs-lookup"><span data-stu-id="962ce-258">For a read-acquire barrier, the read of the flag comes first, then the barrier, and then the reads and writes of the shared data.</span></span> <span data-ttu-id="962ce-259">Для барьера выпуска с возможностью записи сначала поступают операции чтения и записи общих данных, затем барьер, а затем запись флага.</span><span class="sxs-lookup"><span data-stu-id="962ce-259">For a write-release barrier the reads and writes of the shared data come first, then the barrier, and then the write of the flag.</span></span>

``` syntax
// Read that acquires the data.
if( g_flag )
{
    // Guarantee that the read of the flag executes before
    // all reads and writes that follow in program order.
    BarrierOfSomeSort();

    // Now we can read and write the shared data.
    int localVariable = sharedData.y;
    sharedData.x = 0;

    // Guarantee that the write to the flag executes after all
    // reads and writes that precede it in program order.
    BarrierOfSomeSort();
    
    // Write that releases the data.
    g_flag = false;
}
```

<span data-ttu-id="962ce-260">Единственное различие между чтением и записью в эксплуатацию заключается в расположении барьера памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-260">The only difference between a read-acquire and a write-release is the location of the memory barrier.</span></span> <span data-ttu-id="962ce-261">При получении запроса на чтение закладывается барьер после операции блокировки, а у записи выпуска есть барьер.</span><span class="sxs-lookup"><span data-stu-id="962ce-261">A read-acquire has the barrier after the lock operation, and a write-release has the barrier before.</span></span> <span data-ttu-id="962ce-262">В обоих случаях барьер находится между ссылками на Заблокированную память и ссылками на блокировку.</span><span class="sxs-lookup"><span data-stu-id="962ce-262">In both cases the barrier is in-between the references to the locked memory and the references to the lock.</span></span>

<span data-ttu-id="962ce-263">Чтобы понять, почему барьеры необходимы как при получении, так и при освобождении данных, лучше всего (и наиболее точным) считать эти барьеры как гарантируют синхронизацию с общей памятью, а не с другими процессорами.</span><span class="sxs-lookup"><span data-stu-id="962ce-263">To understand why barriers are needed both when acquiring and when releasing data, it is best (and most accurate) to think of these barriers as guaranteeing synchronization with shared memory, not with other processors.</span></span> <span data-ttu-id="962ce-264">Если один процессор использует запись-выпуск для освобождения структуры данных в общей памяти, а другой процессор использует для получения доступа к этой структуре данных из общей памяти, то этот код будет работать правильно.</span><span class="sxs-lookup"><span data-stu-id="962ce-264">If one processor uses a write-release to release a data structure to shared memory, and another processor uses a read-acquire to gain access to that data structure from shared memory, the code will then work properly.</span></span> <span data-ttu-id="962ce-265">Если какой либо процессор не использует соответствующее препятствие, совместное использование данных может завершиться ошибкой.</span><span class="sxs-lookup"><span data-stu-id="962ce-265">If either processor doesn't use the appropriate barrier, the data sharing may fail.</span></span>

<span data-ttu-id="962ce-266">Использование правильного барьера для предотвращения переупорядочивания компилятора и ЦП для вашей платформы является критически важным.</span><span class="sxs-lookup"><span data-stu-id="962ce-266">Using the right barrier to prevent compiler and CPU reordering for your platform is critical.</span></span>

<span data-ttu-id="962ce-267">Одним из преимуществ использования примитивов синхронизации, предоставляемых операционной системой, является то, что все они включают соответствующие барьеры памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-267">One of the advantages of using the synchronization primitives provided by the operating system is that all of them include the appropriate memory barriers.</span></span>

## <a name="preventing-compiler-reordering"></a><span data-ttu-id="962ce-268">Запрет переупорядочения компилятора</span><span class="sxs-lookup"><span data-stu-id="962ce-268">Preventing Compiler Reordering</span></span>

<span data-ttu-id="962ce-269">Задание компилятора — агрессивно оптимизировать код для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="962ce-269">A compiler's job is to aggressively optimize your code in order to improve performance.</span></span> <span data-ttu-id="962ce-270">Сюда входит изменение порядка инструкций везде, где это полезно, и в любом месте, где она не изменит поведение.</span><span class="sxs-lookup"><span data-stu-id="962ce-270">This includes rearranging instructions wherever it is helpful and wherever it will not change behavior.</span></span> <span data-ttu-id="962ce-271">Поскольку стандарт C++ никогда не упоминает многопоточность, и, поскольку компилятор не знает, какой код должен быть потокобезопасным, компилятор предполагает, что код является однопотоковым при принятии решения о том, какие именно изменения можно безопасно выполнить.</span><span class="sxs-lookup"><span data-stu-id="962ce-271">Because the C++ Standard never mentions multithreading, and because the compiler doesn't know what code needs to be thread-safe, the compiler assumes that your code is single-threaded when deciding what rearrangements it can safely do.</span></span> <span data-ttu-id="962ce-272">Поэтому необходимо сообщить компилятору, что он не может переупорядочивать операции чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-272">Therefore, you need to tell the compiler when it is not allowed to reorder reads and writes.</span></span>

<span data-ttu-id="962ce-273">С Visual C++ можно запретить Переупорядочение компилятора с помощью встроенных [**\_ реадвритебарриер**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx)компилятора.</span><span class="sxs-lookup"><span data-stu-id="962ce-273">With Visual C++ you can prevent compiler reordering by using the compiler intrinsic [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx).</span></span> <span data-ttu-id="962ce-274">Когда вы вставляете **\_ реадвритебарриер** в код, компилятор не будет перемещать операции чтения и записи по нему.</span><span class="sxs-lookup"><span data-stu-id="962ce-274">Where you insert **\_ReadWriteBarrier** into your code, the compiler will not move reads and writes across it.</span></span>

``` syntax
#if _MSC_VER < 1400
    // With VC++ 2003 you need to declare _ReadWriteBarrier
    extern "C" void _ReadWriteBarrier();
#else
    // With VC++ 2005 you can get the declaration from intrin.h
#include <intrin.h>
#endif
// Tell the compiler that this is an intrinsic, not a function.
#pragma intrinsic(_ReadWriteBarrier)

// Create a new sprite by filling in a previously empty entry.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
// Write-release, barrier followed by write.
// Guarantee that the compiler leaves the write to the flag
// after all reads and writes that precede it in program order.
_ReadWriteBarrier();
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="962ce-275">В следующем коде другой поток считывает из массива спрайта:</span><span class="sxs-lookup"><span data-stu-id="962ce-275">In the following code, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites.
for( int i = 0; i < numSprites; ++i )
{

    // Read-acquire, read followed by barrier.
    if( g_sprites[nextSprite].alive )
    {
    
        // Guarantee that the compiler leaves the read of the flag
        // before all reads and writes that follow in program order.
        _ReadWriteBarrier();
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="962ce-276">Важно понимать, что [**\_ реадвритебарриер**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) не вставляет никаких дополнительных инструкций и не мешает процессору переупорядочить операции чтения и записи — он только не позволяет компилятору переупорядочить их.</span><span class="sxs-lookup"><span data-stu-id="962ce-276">It is important to understand that [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) does not insert any additional instructions, and it does not prevent the CPU from rearranging reads and writes—it only prevents the compiler from rearranging them.</span></span> <span data-ttu-id="962ce-277">Таким словами, **\_ реадвритебарриер** достаточно при реализации барьера для записи на платформах x86 и x64 (поскольку x86 и x64 не переупорядочивают записи, а обычная запись достаточна для освобождения блокировки), но в большинстве других случаев также необходимо предотвратить Переупорядочение операций чтения и записи ЦП.</span><span class="sxs-lookup"><span data-stu-id="962ce-277">Thus, **\_ReadWriteBarrier** is sufficient when you implement a write-release barrier on x86 and x64 (because x86 and x64 do not reorder writes, and a normal write is sufficient for releasing a lock), but in most other cases, it is also necessary to prevent the CPU from reordering reads and writes.</span></span>

<span data-ttu-id="962ce-278">[**\_ Реадвритебарриер**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) также можно использовать при записи в память, не поддерживающую кэширование, для предотвращения изменения порядка операций записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-278">You can also use [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) when you write to non-cacheable write-combined memory to prevent reordering of writes.</span></span> <span data-ttu-id="962ce-279">В этом случае **\_ реадвритебарриер** помогает повысить производительность, гарантируя, что операции записи происходят в предпочтительном линейном порядке процессора.</span><span class="sxs-lookup"><span data-stu-id="962ce-279">In this case **\_ReadWriteBarrier** helps to improve performance, by guaranteeing that the writes happen in the processor's preferred linear order.</span></span>

<span data-ttu-id="962ce-280">Также можно использовать встроенные функции [**\_ реадбарриер**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) и [**\_ вритебарриер**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) для более точного управления переупорядочением компилятора.</span><span class="sxs-lookup"><span data-stu-id="962ce-280">It is also possible to use the [**\_ReadBarrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) and [**\_WriteBarrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) intrinsics for more precise control of compiler reordering.</span></span> <span data-ttu-id="962ce-281">Компилятор не будет перемещать операции чтения в **\_ реадбарриер** и не будет перемещать операции записи по **\_ вритебарриер**.</span><span class="sxs-lookup"><span data-stu-id="962ce-281">The compiler will not move reads across a **\_ReadBarrier**, and it will not move writes across a **\_WriteBarrier**.</span></span>

## <a name="preventing-cpu-reordering"></a><span data-ttu-id="962ce-282">Предотвращение изменения порядка ЦП</span><span class="sxs-lookup"><span data-stu-id="962ce-282">Preventing CPU Reordering</span></span>

<span data-ttu-id="962ce-283">Изменение порядка ЦП является более незаметным, чем Переупорядочение компилятора.</span><span class="sxs-lookup"><span data-stu-id="962ce-283">CPU reordering is more subtle than compiler reordering.</span></span> <span data-ttu-id="962ce-284">Пока вы не видите его напрямую, вы просто видите ошибки инекспликабле.</span><span class="sxs-lookup"><span data-stu-id="962ce-284">You can't ever see it happen directly, you just see inexplicable bugs.</span></span> <span data-ttu-id="962ce-285">Чтобы предотвратить изменение порядка операций чтения и записи ЦП, необходимо использовать инструкции по барьеру памяти на некоторых процессорах.</span><span class="sxs-lookup"><span data-stu-id="962ce-285">In order to prevent CPU reordering of reads and writes you need to use memory barrier instructions, on some processors.</span></span> <span data-ttu-id="962ce-286">Универсальное имя для инструкции барьера памяти на Xbox 360 и в Windows — [**меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span><span class="sxs-lookup"><span data-stu-id="962ce-286">The all-purpose name for a memory barrier instruction, on Xbox 360 and on Windows, is [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span></span> <span data-ttu-id="962ce-287">Этот макрос реализуется соответствующим образом для каждой платформы.</span><span class="sxs-lookup"><span data-stu-id="962ce-287">This macro is implemented appropriately for each platform.</span></span>

<span data-ttu-id="962ce-288">В Xbox 360 [**меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier) определен как **лвсинк** (облегченная синхронизация), также доступный через встроенную **\_ \_ лвсинк** , которая определена в ппЦинтринсикс. h.</span><span class="sxs-lookup"><span data-stu-id="962ce-288">On Xbox 360, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined as **lwsync** (lightweight sync), also available through the **\_\_lwsync** intrinsic, which is defined in ppcintrinsics.h.</span></span> <span data-ttu-id="962ce-289">**\_ \_ лвсинк** также выступает в качестве барьера памяти компилятора, предотвращая перераспределение операций чтения и записи компилятором.</span><span class="sxs-lookup"><span data-stu-id="962ce-289">**\_\_lwsync** also serves as a compiler memory barrier, preventing rearranging of reads and writes by the compiler.</span></span>

<span data-ttu-id="962ce-290">Инструкция **лвсинк** — это барьер памяти на Xbox 360, который синхронизирует одно ядро процессора с кэшем L2.</span><span class="sxs-lookup"><span data-stu-id="962ce-290">The **lwsync** instruction is a memory barrier on Xbox 360 that synchronizes one processor core with the L2 cache.</span></span> <span data-ttu-id="962ce-291">Он гарантирует, что все операции записи перед **лвсинк** передают его в кэш L2, прежде чем выполнять операции записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-291">It guarantees that all writes before **lwsync** make it to the L2 cache before any writes that follow.</span></span> <span data-ttu-id="962ce-292">Также гарантируется, что все операции чтения, следующие за **лвсинк** , не будут получать более старые данные из L2, чем предыдущие операции чтения.</span><span class="sxs-lookup"><span data-stu-id="962ce-292">It also guarantees that any reads that follow **lwsync** don't get older data from L2 than previous reads.</span></span> <span data-ttu-id="962ce-293">Один из типов переупорядочения, который он не препятствует, — это чтение с переносом на другой адрес.</span><span class="sxs-lookup"><span data-stu-id="962ce-293">The one type of reordering that it does not prevent is a read moving ahead of a write to a different address.</span></span> <span data-ttu-id="962ce-294">Таким же **лвсинк** обеспечивает упорядочение памяти, совпадающее с порядком памяти процессоров x86 и x64 по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="962ce-294">Thus, **lwsync** enforces memory ordering that matches the default memory ordering on x86 and x64 processors.</span></span> <span data-ttu-id="962ce-295">Для получения полного порядка памяти требуется более дорогостоящая Инструкция по синхронизации (также известная как бумага высокой плотности), но в большинстве случаев это не является обязательным.</span><span class="sxs-lookup"><span data-stu-id="962ce-295">To get full memory ordering requires the more expensive sync instruction (also known as heavyweight sync), but in most cases, this is not required.</span></span> <span data-ttu-id="962ce-296">Параметры изменения порядка памяти в Xbox 360 показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="962ce-296">The memory reordering options on Xbox 360 are shown in the following table.</span></span>



| <span data-ttu-id="962ce-297">Переупорядочение Xbox 360</span><span class="sxs-lookup"><span data-stu-id="962ce-297">Xbox 360 Reordering</span></span>           | <span data-ttu-id="962ce-298">Без синхронизации</span><span class="sxs-lookup"><span data-stu-id="962ce-298">No sync</span></span> | <span data-ttu-id="962ce-299">лвсинк</span><span class="sxs-lookup"><span data-stu-id="962ce-299">lwsync</span></span> | <span data-ttu-id="962ce-300">sync</span><span class="sxs-lookup"><span data-stu-id="962ce-300">sync</span></span> |
|-------------------------------|---------|--------|------|
| <span data-ttu-id="962ce-301">Чтение с опережением чтения</span><span class="sxs-lookup"><span data-stu-id="962ce-301">Reads moving ahead of reads</span></span>   | <span data-ttu-id="962ce-302">Да</span><span class="sxs-lookup"><span data-stu-id="962ce-302">Yes</span></span>     | <span data-ttu-id="962ce-303">Нет</span><span class="sxs-lookup"><span data-stu-id="962ce-303">No</span></span>     | <span data-ttu-id="962ce-304">Нет</span><span class="sxs-lookup"><span data-stu-id="962ce-304">No</span></span>   |
| <span data-ttu-id="962ce-305">Операций записи, предшествующих записи</span><span class="sxs-lookup"><span data-stu-id="962ce-305">Writes moving ahead of writes</span></span> | <span data-ttu-id="962ce-306">Да</span><span class="sxs-lookup"><span data-stu-id="962ce-306">Yes</span></span>     | <span data-ttu-id="962ce-307">Нет</span><span class="sxs-lookup"><span data-stu-id="962ce-307">No</span></span>     | <span data-ttu-id="962ce-308">Нет</span><span class="sxs-lookup"><span data-stu-id="962ce-308">No</span></span>   |
| <span data-ttu-id="962ce-309">Операций записи, перемещенных вперед</span><span class="sxs-lookup"><span data-stu-id="962ce-309">Writes moving ahead of reads</span></span>  | <span data-ttu-id="962ce-310">Да</span><span class="sxs-lookup"><span data-stu-id="962ce-310">Yes</span></span>     | <span data-ttu-id="962ce-311">Нет</span><span class="sxs-lookup"><span data-stu-id="962ce-311">No</span></span>     | <span data-ttu-id="962ce-312">Нет</span><span class="sxs-lookup"><span data-stu-id="962ce-312">No</span></span>   |
| <span data-ttu-id="962ce-313">Считывания за преупреждающим числом операций записи</span><span class="sxs-lookup"><span data-stu-id="962ce-313">Reads moving ahead of writes</span></span>  | <span data-ttu-id="962ce-314">Да</span><span class="sxs-lookup"><span data-stu-id="962ce-314">Yes</span></span>     | <span data-ttu-id="962ce-315">Да</span><span class="sxs-lookup"><span data-stu-id="962ce-315">Yes</span></span>    | <span data-ttu-id="962ce-316">Нет</span><span class="sxs-lookup"><span data-stu-id="962ce-316">No</span></span>   |



 

<span data-ttu-id="962ce-317">PowerPC также содержит инструкции по синхронизации **исинк** и **еиеио** (которые используются для управления переупорядочением памяти, запрещенной для кэширования).</span><span class="sxs-lookup"><span data-stu-id="962ce-317">PowerPC also has the synchronization instructions **isync** and **eieio** (which is used to control reordering to caching-inhibited memory).</span></span> <span data-ttu-id="962ce-318">Эти инструкции по синхронизации не требуются для нормальной синхронизации.</span><span class="sxs-lookup"><span data-stu-id="962ce-318">These synchronization instructions should not be needed for normal synchronization purposes.</span></span>

<span data-ttu-id="962ce-319">В Windows [**меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier) определяется в Winnt. h и предоставляет другую инструкцию барьера памяти в зависимости от того, выполняется ли компиляция для x86 или x64.</span><span class="sxs-lookup"><span data-stu-id="962ce-319">On Windows, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined in Winnt.h and gives you a different memory barrier instruction depending on whether you are compiling for x86 or x64.</span></span> <span data-ttu-id="962ce-320">Инструкция барьера памяти служит полным барьером, предотвращая Переупорядочение операций чтения и записи в барьере.</span><span class="sxs-lookup"><span data-stu-id="962ce-320">The memory barrier instruction serves as a full barrier, preventing all reordering of reads and writes across the barrier.</span></span> <span data-ttu-id="962ce-321">Таким образом, **меморибарриер** в Windows обеспечивает более надежную гарантию, чем на Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="962ce-321">Thus, **MemoryBarrier** on Windows gives a stronger reordering guarantee than it does on Xbox 360.</span></span>

<span data-ttu-id="962ce-322">На Xbox 360 и во многих других ЦП существует еще один дополнительный способ, который может быть предотвращен на чтение и изменение порядка ЦП.</span><span class="sxs-lookup"><span data-stu-id="962ce-322">On Xbox 360, and on many other CPUs, there is one additional way that read-reordering by the CPU can be prevented.</span></span> <span data-ttu-id="962ce-323">Если вы прочитаете указатель и затем используете этот указатель для загрузки других данных, ЦП гарантирует, что считывания с указателя не старше, чем чтение указателя.</span><span class="sxs-lookup"><span data-stu-id="962ce-323">If you read a pointer and then use that pointer to load other data, the CPU guarantees that the reads off of the pointer are not older than the read of the pointer.</span></span> <span data-ttu-id="962ce-324">Если флаг блокировки является указателем, и если все операции чтения общих данных находятся за пределами указателя, [**меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier) можно опустить, чтобы снизить экономию производительности.</span><span class="sxs-lookup"><span data-stu-id="962ce-324">If your lock flag is a pointer and if all reads of shared data are off of the pointer, the [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) can be omitted, for a modest performance savings.</span></span>

``` syntax
Data* localPointer = g_sharedPointer;
if( localPointer )
{
    // No import barrier is needed--all reads off of localPointer
    // are guaranteed to not be reordered past the read of
    // localPointer.
    int localVariable = localPointer->y;
    // A memory barrier is needed to stop the read of g_global
    // from being speculatively moved ahead of the read of
    // g_sharedPointer.
    int localVariable2 = g_global;
}
```

<span data-ttu-id="962ce-325">Инструкция [**меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier) предотвращает изменение порядка операций чтения и записи в кэшированную память.</span><span class="sxs-lookup"><span data-stu-id="962ce-325">The [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) instruction only prevents reordering of reads and writes to cacheable memory.</span></span> <span data-ttu-id="962ce-326">Если выделить память в качестве нестраничного \_ кэша страницы или \_ вритекомбине страницы, Общий прием для авторов драйверов устройств и для разработчиков игр на Xbox 360, **меморибарриер** не влияет на доступ к этой памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-326">If you allocate memory as PAGE\_NOCACHE or PAGE\_WRITECOMBINE, a common technique for device driver authors and for game developers on Xbox 360, **MemoryBarrier** has no effect on accesses to this memory.</span></span> <span data-ttu-id="962ce-327">Большинству разработчиков не требуется синхронизация некэшированной памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-327">Most developers don't need synchronization of non-cacheable memory.</span></span> <span data-ttu-id="962ce-328">Это выходит за рамки данной статьи.</span><span class="sxs-lookup"><span data-stu-id="962ce-328">That is beyond the scope of this article.</span></span>

## <a name="interlocked-functions-and-cpu-reordering"></a><span data-ttu-id="962ce-329">Блокируемые функции и изменение порядка ЦП</span><span class="sxs-lookup"><span data-stu-id="962ce-329">Interlocked Functions and CPU Reordering</span></span>

<span data-ttu-id="962ce-330">Иногда операции чтения или записи, которые запрашивают или освобождают ресурс, выполняются с помощью одной из функций **интерлоккедкскскс** .</span><span class="sxs-lookup"><span data-stu-id="962ce-330">Sometimes the read or write that acquires or releases a resource is done using one of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="962ce-331">В Windows это упрощает работу. Поскольку в Windows функции **интерлоккедкскскс** — это все барьеры для полной памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-331">On Windows, this simplifies things; because on Windows, the **InterlockedXxx** functions are all full-memory barriers.</span></span> <span data-ttu-id="962ce-332">Они эффективно используют барьер памяти ЦП как до, так и после них. Это означает, что они являются полным барьером для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-332">They effectively have a CPU memory barrier both before and after them, which means that they are a full read-acquire or write-release barrier all by themselves.</span></span>

<span data-ttu-id="962ce-333">В Xbox 360 функции **интерлоккедкскскс** не содержат барьеров памяти ЦП.</span><span class="sxs-lookup"><span data-stu-id="962ce-333">On Xbox 360, the **InterlockedXxx** functions do not contain CPU memory barriers.</span></span> <span data-ttu-id="962ce-334">Они предотвращают изменение порядка операций чтения и записи в компиляторе, но не переупорядочивают ЦП.</span><span class="sxs-lookup"><span data-stu-id="962ce-334">They prevent compiler reordering of reads and writes but not CPU reordering.</span></span> <span data-ttu-id="962ce-335">Таким образом, в большинстве случаев при использовании функций **интерлоккедкскскс** на Xbox 360 необходимо перед ними или следовать ему с помощью **\_ \_ лвсинк**, чтобы сделать их барьером для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="962ce-335">Therefore, in most cases when using **InterlockedXxx** functions on Xbox 360, you should precede or follow them with an **\_\_lwsync**, to make them a read-acquire or write-release barrier.</span></span> <span data-ttu-id="962ce-336">Для удобства и **более удобного** читаемости доступны и **выпуски** версий многих функций **интерлоккедкскскс** .</span><span class="sxs-lookup"><span data-stu-id="962ce-336">For convenience and for easier readability, there are **Acquire** and **Release** versions of many of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="962ce-337">Они поставляются с встроенным барьером памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-337">These come with a built-in memory barrier.</span></span> <span data-ttu-id="962ce-338">Например, [**интерлоккединкрементаккуире**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) выполняет блокируемое приращение, за которым следует барьер памяти **\_ \_ лвсинк** , чтобы обеспечить полную функциональность чтения и считывания.</span><span class="sxs-lookup"><span data-stu-id="962ce-338">For instance, [**InterlockedIncrementAcquire**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) does an interlocked increment followed by an **\_\_lwsync** memory barrier to give the full read-acquire functionality.</span></span>

<span data-ttu-id="962ce-339">Рекомендуется использовать версии для **получения** и **выпуска** функций **интерлоккедкскскс** (большинство из которых доступны в Windows, без снижения производительности), чтобы сделать цель более очевидной и упростить получение инструкций по барьеру памяти в нужном месте.</span><span class="sxs-lookup"><span data-stu-id="962ce-339">It is recommended that you use the **Acquire** and **Release** versions of the **InterlockedXxx** functions (most of which are available on Windows as well, with no performance penalty) to make your intent more obvious and to make it easier to get the memory barrier instructions in the correct place.</span></span> <span data-ttu-id="962ce-340">Любое использование **интерлоккедкскскс** на Xbox 360 без барьера памяти должно быть тщательно проверено, так как часто это ошибка.</span><span class="sxs-lookup"><span data-stu-id="962ce-340">Any use of **InterlockedXxx** on Xbox 360 without a memory barrier should be examined very carefully, because it is often a bug.</span></span>

<span data-ttu-id="962ce-341">В этом примере показано, как один поток может передавать задачи или другие данные в другой поток, используя версии **получения** и **выпуска** функций **интерлоккедксксксслист** .</span><span class="sxs-lookup"><span data-stu-id="962ce-341">This sample demonstrates how one thread can pass tasks or other data to another thread using the **Acquire** and **Release** versions of the **InterlockedXxxSList** functions.</span></span> <span data-ttu-id="962ce-342">Функции **интерлоккедксксксслист** — это семейство функций для поддержания общего однонаправленного списка без блокировки.</span><span class="sxs-lookup"><span data-stu-id="962ce-342">The **InterlockedXxxSList** functions are a family of functions for maintaining a shared singly linked list without a lock.</span></span> <span data-ttu-id="962ce-343">Обратите внимание, что варианты **получения** и **освобождения** этих функций недоступны в Windows, но обычные версии этих функций являются полным барьером памяти в Windows.</span><span class="sxs-lookup"><span data-stu-id="962ce-343">Note that **Acquire** and **Release** variants of these functions are not available on Windows, but the regular versions of these functions are a full memory barrier on Windows.</span></span>

``` syntax
// Declarations for the Task class go here.

// Add a new task to the list using lockless programming.
void AddTask( DWORD ID, DWORD data )
{
    Task* newItem = new Task( ID, data );
    InterlockedPushEntrySListRelease( g_taskList, newItem );
}

// Remove a task from the list, using lockless programming.
// This will return NULL if there are no items in the list.
Task* GetTask()
{
    Task* result = (Task*)
        InterlockedPopEntrySListAcquire( g_taskList );
    return result;
}
```

## <a name="volatile-variables-and-reordering"></a><span data-ttu-id="962ce-344">Переменные переменных и изменение порядка</span><span class="sxs-lookup"><span data-stu-id="962ce-344">Volatile Variables and Reordering</span></span>

<span data-ttu-id="962ce-345">Стандарт C++ говорит, что чтение переменных с переменными переменными не может быть кэшировано, временные операции записи не могут быть отложены, а временные операции чтения и записи нельзя перемещать друг за другом.</span><span class="sxs-lookup"><span data-stu-id="962ce-345">The C++ Standard says that reads of volatile variables cannot be cached, volatile writes cannot be delayed, and volatile reads and writes cannot be moved past each other.</span></span> <span data-ttu-id="962ce-346">Это достаточно для связи с аппаратными устройствами, что является назначением ключевого слова volatile в стандарте C++.</span><span class="sxs-lookup"><span data-stu-id="962ce-346">This is sufficient for communicating with hardware devices, which is the purpose of the volatile keyword in the C++ Standard.</span></span>

<span data-ttu-id="962ce-347">Однако гарантии уровня "Стандартный" недостаточно для использования переменных для многопоточности.</span><span class="sxs-lookup"><span data-stu-id="962ce-347">However, the guarantees of the standard are not sufficient for using volatile for multi-threading.</span></span> <span data-ttu-id="962ce-348">Стандарт C++ не останавливает Переупорядочение неизменяемых операций чтения и записи относительно временных операций чтения и записи, и ничего не говорит о предотвращении переупорядочения ЦП.</span><span class="sxs-lookup"><span data-stu-id="962ce-348">The C++ Standard does not stop the compiler from reordering non-volatile reads and writes relative to volatile reads and writes, and it says nothing about preventing CPU reordering.</span></span>

<span data-ttu-id="962ce-349">Visual C++ 2005 выходит за пределы стандартного языка C++, чтобы определить понятную многопотоковую семантику для временного доступа к переменным.</span><span class="sxs-lookup"><span data-stu-id="962ce-349">Visual C++ 2005 goes beyond standard C++ to define multi-threading-friendly semantics for volatile variable access.</span></span> <span data-ttu-id="962ce-350">Начиная с Visual C++ 2005, операции чтения из переменных volatile определяют семантику чтения и записи в переменные переменных, для которых определена семантика записи в эксплуатацию.</span><span class="sxs-lookup"><span data-stu-id="962ce-350">Starting with Visual C++ 2005, reads from volatile variables are defined to have read-acquire semantics, and writes to volatile variables are defined to have write-release semantics.</span></span> <span data-ttu-id="962ce-351">Это означает, что компилятор не будет изменять порядок операций чтения и записи после их последующего использования, и в Windows это гарантирует, что процессор не будет делать это.</span><span class="sxs-lookup"><span data-stu-id="962ce-351">This means that the compiler will not rearrange any reads and writes past them, and on Windows it will ensure that the CPU does not do so either.</span></span>

<span data-ttu-id="962ce-352">Важно понимать, что эти новые гарантии применимы только к Visual C++ 2005 и будущим версиям Visual C++.</span><span class="sxs-lookup"><span data-stu-id="962ce-352">It is important to understand that these new guarantees only apply to Visual C++ 2005 and future versions of Visual C++.</span></span> <span data-ttu-id="962ce-353">Компиляторы от других поставщиков обычно реализуют другую семантику без дополнительных гарантий Visual C++ 2005.</span><span class="sxs-lookup"><span data-stu-id="962ce-353">Compilers from other vendors will generally implement different semantics, without the extra guarantees of Visual C++ 2005.</span></span> <span data-ttu-id="962ce-354">Кроме того, в Xbox 360 компилятор не вставляет никаких инструкций для предотвращения переупорядочения операций чтения и записи ЦП.</span><span class="sxs-lookup"><span data-stu-id="962ce-354">Also, on Xbox 360, the compiler does not insert any instructions to prevent the CPU from reordering reads and writes.</span></span>

## <a name="example-of-a-lock-free-data-pipe"></a><span data-ttu-id="962ce-355">Пример канала данных Lock-Free</span><span class="sxs-lookup"><span data-stu-id="962ce-355">Example of a Lock-Free Data Pipe</span></span>

<span data-ttu-id="962ce-356">Канал — это конструкция, которая позволяет одному или нескольким потокам записывать данные, которые затем считываются другими потоками.</span><span class="sxs-lookup"><span data-stu-id="962ce-356">A pipe is a construct that lets one or more threads write data that is then read by other threads.</span></span> <span data-ttu-id="962ce-357">Незаблокированная версия канала может быть элегантным и эффективным способом передачи работы от потоков к потоку.</span><span class="sxs-lookup"><span data-stu-id="962ce-357">A lockless version of a pipe can be an elegant and efficient way to pass work from thread to thread.</span></span> <span data-ttu-id="962ce-358">Пакет SDK для DirectX предоставляет **локкфрипипе**, одномодульный и однозаписывающий канал безблокировок, доступный в дксутлоккфрипипе. h.</span><span class="sxs-lookup"><span data-stu-id="962ce-358">The DirectX SDK supplies **LockFreePipe**, a single-reader, single-writer lockless pipe that is available in DXUTLockFreePipe.h.</span></span> <span data-ttu-id="962ce-359">Один и тот же **локкфрипипе** доступен в пакете SDK для Xbox 360 в атглоккфрипипе. h.</span><span class="sxs-lookup"><span data-stu-id="962ce-359">The same **LockFreePipe** is available in the Xbox 360 SDK in AtgLockFreePipe.h.</span></span>

<span data-ttu-id="962ce-360">**Локкфрипипе** можно использовать, когда у двух потоков есть связь "производитель-получатель".</span><span class="sxs-lookup"><span data-stu-id="962ce-360">**LockFreePipe** can be used when two threads have a producer/consumer relationship.</span></span> <span data-ttu-id="962ce-361">Поток-производитель может записывать данные в канал, чтобы поток-потребитель мог обработать его позже, без каких-либо блокировок.</span><span class="sxs-lookup"><span data-stu-id="962ce-361">The producer thread can write data to the pipe for the consumer thread to process at a later date, without ever blocking.</span></span> <span data-ttu-id="962ce-362">Если канал заполняется, происходит сбой записи, и потоку-производителю придется повторить попытку позже, но это произойдет только в случае, если поток-производитель впереди.</span><span class="sxs-lookup"><span data-stu-id="962ce-362">If the pipe fills up, writes fail, and the producer thread will have to try again later, but this would only happen if the producer thread is ahead.</span></span> <span data-ttu-id="962ce-363">Если канал очищается, происходит сбой операций чтения, и потребительский поток придется повторить попытку позже, но это произойдет, только если нет никакой работы для выполнения потока-потребителя.</span><span class="sxs-lookup"><span data-stu-id="962ce-363">If the pipe empties, reads fail, and the consumer thread will have to try again later, but this would only happen if there is no work for the consumer thread to do.</span></span> <span data-ttu-id="962ce-364">Если два потока хорошо сбалансированы, и канал достаточно велик, канал позволит им без проблем передавать данные без задержек или блоков.</span><span class="sxs-lookup"><span data-stu-id="962ce-364">If the two threads are well-balanced, and the pipe is big enough, the pipe lets them smoothly pass data along with no delays or blocks.</span></span>

## <a name="xbox-360-performance"></a><span data-ttu-id="962ce-365">Производительность Xbox 360</span><span class="sxs-lookup"><span data-stu-id="962ce-365">Xbox 360 Performance</span></span>

<span data-ttu-id="962ce-366">Производительность инструкций по синхронизации и функций в Xbox 360 будет зависеть от того, какой код работает.</span><span class="sxs-lookup"><span data-stu-id="962ce-366">The performance of synchronization instructions and functions on Xbox 360 will vary depending on what other code is running.</span></span> <span data-ttu-id="962ce-367">Получение блокировок займет больше времени, если другой поток в настоящее время владеет блокировкой.</span><span class="sxs-lookup"><span data-stu-id="962ce-367">Acquiring locks will take much longer if another thread currently owns the lock.</span></span> <span data-ttu-id="962ce-368">Операции [**интерлоккединкремент**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) и критического раздела будут выполняться намного дольше, если другие потоки записываются в одну строку кэша.</span><span class="sxs-lookup"><span data-stu-id="962ce-368">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) and critical section operations will take much longer if other threads are writing to the same cache line.</span></span> <span data-ttu-id="962ce-369">Содержимое очередей хранилища также может негативно сказаться на производительности.</span><span class="sxs-lookup"><span data-stu-id="962ce-369">The contents of the store queues can also affect performance.</span></span> <span data-ttu-id="962ce-370">Таким образом, все эти числа являются приблизительными, что формируется из очень простых тестов:</span><span class="sxs-lookup"><span data-stu-id="962ce-370">Therefore, all of these numbers are just approximations, generated from very simple tests:</span></span>

-   <span data-ttu-id="962ce-371">**лвсинк** измеряется в 33-48 циклов.</span><span class="sxs-lookup"><span data-stu-id="962ce-371">**lwsync** was measured as taking 33-48 cycles.</span></span>
-   <span data-ttu-id="962ce-372">[**Интерлоккединкремент**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) измеряется в 225-260 циклов.</span><span class="sxs-lookup"><span data-stu-id="962ce-372">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 225-260 cycles.</span></span>
-   <span data-ttu-id="962ce-373">Получение или освобождение критической секции измеряется примерно 345 циклов.</span><span class="sxs-lookup"><span data-stu-id="962ce-373">Acquiring or releasing a critical section was measured as taking about 345 cycles.</span></span>
-   <span data-ttu-id="962ce-374">Получение или освобождение мьютекса заняло примерно 2350 циклов.</span><span class="sxs-lookup"><span data-stu-id="962ce-374">Acquiring or releasing a mutex was measured as taking about 2350 cycles.</span></span>

## <a name="windows-performance"></a><span data-ttu-id="962ce-375">Производительность Windows</span><span class="sxs-lookup"><span data-stu-id="962ce-375">Windows Performance</span></span>

<span data-ttu-id="962ce-376">Производительность инструкций по синхронизации и функций в Windows в значительной степени зависит от типа и конфигурации процессора, а также от того, какой код работает.</span><span class="sxs-lookup"><span data-stu-id="962ce-376">The performance of synchronization instructions and functions on Windows vary widely depending on the processor type and configuration, and on what other code is running.</span></span> <span data-ttu-id="962ce-377">Многоядерные и многосокетные системы часто занимают больше времени для выполнения инструкций по синхронизации, и получение блокировок занимает больше времени, если другой поток в настоящее время владеет блокировкой.</span><span class="sxs-lookup"><span data-stu-id="962ce-377">Multi-core and multi-socket systems often take longer to execute synchronizing instructions, and acquiring locks take much longer if another thread currently owns the lock.</span></span>

<span data-ttu-id="962ce-378">Тем не менее, даже некоторые измерения, созданные на основе очень простых тестов, полезны:</span><span class="sxs-lookup"><span data-stu-id="962ce-378">However, even some measurements generated from very simple tests are helpful:</span></span>

-   <span data-ttu-id="962ce-379">[**Меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier) измеряется в 20-90 циклов.</span><span class="sxs-lookup"><span data-stu-id="962ce-379">[**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) was measured as taking 20-90 cycles.</span></span>
-   <span data-ttu-id="962ce-380">[**Интерлоккединкремент**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) измеряется в 36-90 циклов.</span><span class="sxs-lookup"><span data-stu-id="962ce-380">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 36-90 cycles.</span></span>
-   <span data-ttu-id="962ce-381">Получение или освобождение критической секции измеряется в 40-100 циклов.</span><span class="sxs-lookup"><span data-stu-id="962ce-381">Acquiring or releasing a critical section was measured as taking 40-100 cycles.</span></span>
-   <span data-ttu-id="962ce-382">Получение или освобождение мьютекса заняло примерно 750-2500 циклов.</span><span class="sxs-lookup"><span data-stu-id="962ce-382">Acquiring or releasing a mutex was measured as taking about 750-2500 cycles.</span></span>

<span data-ttu-id="962ce-383">Эти тесты выполнялись в Windows XP на различных процессорах.</span><span class="sxs-lookup"><span data-stu-id="962ce-383">These tests were done on Windows XP on a range of different processors.</span></span> <span data-ttu-id="962ce-384">Короткие времена находились на однопроцессорном компьютере, и более длительные времена находились на многопроцессорном компьютере.</span><span class="sxs-lookup"><span data-stu-id="962ce-384">The short times were on a single-processor machine, and the longer times were on a multi-processor machine.</span></span>

<span data-ttu-id="962ce-385">Хотя получение и освобождение блокировок является более дорогим, чем использование программирования без блокировки, лучше обмениваться данными реже, тем самым избегая затрат.</span><span class="sxs-lookup"><span data-stu-id="962ce-385">While acquiring and releasing locks is more expensive than using lockless programming, it is even better to share data less frequently, thus avoiding the cost altogether.</span></span>

## <a name="performance-thoughts"></a><span data-ttu-id="962ce-386">Соображения по производительности</span><span class="sxs-lookup"><span data-stu-id="962ce-386">Performance Thoughts</span></span>

<span data-ttu-id="962ce-387">Получение или освобождение критической секции состоит из барьера памяти, операции **интерлоккедкскскс** и некоторой дополнительной проверки на обработку рекурсии и возвращения к мьютексу при необходимости.</span><span class="sxs-lookup"><span data-stu-id="962ce-387">Acquiring or releasing a critical section consists of a memory barrier, an **InterlockedXxx** operation, and some extra checking to handle recursion and to fall back to a mutex, if necessary.</span></span> <span data-ttu-id="962ce-388">Вы должны быть осторожными при реализации собственного критического раздела, так как цикличный цикл, ожидающий снятия блокировки, не прибегает к мьютексу, может извлекать значительный объем производительности.</span><span class="sxs-lookup"><span data-stu-id="962ce-388">You should be wary of implementing your own critical section, because spinning in a loop waiting for a lock to be free, without falling back to a mutex, can waste considerable performance.</span></span> <span data-ttu-id="962ce-389">Для критически важных разделов, которые сильно обрабатываются, но не удерживаются в течение длительного времени, следует рассмотреть возможность использования [**инитиализекритикалсектионандспинкаунт**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) , чтобы операционная система проходила на некоторое время, ожидая доступности критического раздела, а не сразу же откладывая на мьютекс, если при попытке получить критический раздел вы являетесь владельцем критической секции.</span><span class="sxs-lookup"><span data-stu-id="962ce-389">For critical sections that are heavily contended but not held for long, you should consider using [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) so that the operating system will spin for a while waiting for the critical section to be available rather than immediately deferring to a mutex if the critical section is owned when you try to acquire it.</span></span> <span data-ttu-id="962ce-390">Для определения критических секций, которые могут использовать преимущества счетчика, необходимо измерять длину типичного ожидания для определенной блокировки.</span><span class="sxs-lookup"><span data-stu-id="962ce-390">In order to identify critical sections that can benefit from a spin count, it is necessary to measure the length of the typical wait for a particular lock.</span></span>

<span data-ttu-id="962ce-391">Если для выделения памяти используется общая куча, поведение по умолчанию — каждое выделение памяти и освобождение ресурсов требуют блокировки.</span><span class="sxs-lookup"><span data-stu-id="962ce-391">If a shared heap is used for memory allocations—the default behavior—every memory allocation and free involves acquiring a lock.</span></span> <span data-ttu-id="962ce-392">По мере увеличения числа потоков и числа выделений, уровни производительности отключаются, а в конечном итоге начинает уменьшаться.</span><span class="sxs-lookup"><span data-stu-id="962ce-392">As the number of threads and the number of allocations increases, performance levels off, and eventually starts to decrease.</span></span> <span data-ttu-id="962ce-393">Использование куч для каждого потока или уменьшение числа выделений может избежать возникновения узкого места блокировки.</span><span class="sxs-lookup"><span data-stu-id="962ce-393">Using per-thread heaps, or reducing the number of allocations, can avoid this locking bottleneck.</span></span>

<span data-ttu-id="962ce-394">Если один поток создает данные, а другой поток использует данные, они могут часто предоставлять общий доступ к данным.</span><span class="sxs-lookup"><span data-stu-id="962ce-394">If one thread is generating data and another thread is consuming data, they may end up sharing data frequently.</span></span> <span data-ttu-id="962ce-395">Это может произойти, если один поток загружает ресурсы, а другой поток — визуализацию сцены.</span><span class="sxs-lookup"><span data-stu-id="962ce-395">This can happen if one thread is loading resources and another thread is rendering the scene.</span></span> <span data-ttu-id="962ce-396">Если поток отрисовки ссылается на общие данные при каждом вызове Draw, затраты на блокировку будут высокими.</span><span class="sxs-lookup"><span data-stu-id="962ce-396">If the rendering thread references the shared data on every draw call, the locking overhead will be high.</span></span> <span data-ttu-id="962ce-397">Гораздо более высокая производительность может быть реализована, если каждый поток имеет закрытые структуры данных, которые затем синхронизируются один раз для каждого кадра или меньше.</span><span class="sxs-lookup"><span data-stu-id="962ce-397">Much better performance can be realized if each thread has private data structures which are then synchronized once per frame or less.</span></span>

<span data-ttu-id="962ce-398">Не гарантируется, что алгоритмы без блокировки будут работать быстрее, чем алгоритмы, использующие блокировки.</span><span class="sxs-lookup"><span data-stu-id="962ce-398">Lockless algorithms are not guaranteed to be faster than algorithms that use locks.</span></span> <span data-ttu-id="962ce-399">Следует проверить, действительно ли блокировки вызывают проблемы, прежде чем пытаться избежать их, и следует оценить, чтобы узнать, действительно ли код без блокировки повышает производительность.</span><span class="sxs-lookup"><span data-stu-id="962ce-399">You should check to see if locks are actually causing you problems before trying to avoid them, and you should measure to see if your lockless code actually improves performance.</span></span>

## <a name="platform-differences-summary"></a><span data-ttu-id="962ce-400">Обзор различий платформы</span><span class="sxs-lookup"><span data-stu-id="962ce-400">Platform Differences Summary</span></span>

-   <span data-ttu-id="962ce-401">Функции **интерлоккедкскскс** предотвращают упорядочение ресурсов ЦП на чтение и запись в Windows, но не на Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="962ce-401">**InterlockedXxx** functions prevent CPU read/write reordering on Windows, but not on Xbox 360.</span></span>
-   <span data-ttu-id="962ce-402">Чтение и запись переменных с временными переменными с помощью Visual Studio C++ 2005 предотвращает изменение порядка чтения и записи ЦП в Windows, но на Xbox 360 она только не допускают переупорядочения чтения и записи компилятора.</span><span class="sxs-lookup"><span data-stu-id="962ce-402">Reading and writing of volatile variables using Visual Studio C++ 2005 prevents CPU read/write reordering on Windows, but on Xbox 360, it only prevents compiler read/write reordering.</span></span>
-   <span data-ttu-id="962ce-403">Операции записи переупорядочиваются на Xbox 360, но не на x86 или x64.</span><span class="sxs-lookup"><span data-stu-id="962ce-403">Writes are reordered on Xbox 360, but not on x86 or x64.</span></span>
-   <span data-ttu-id="962ce-404">Операции чтения переупорядочиваются на Xbox 360, но на x86 или x64 они переупорядочиваются только относительно операций записи и только в том случае, если операции чтения и записи предназначены для разных расположений.</span><span class="sxs-lookup"><span data-stu-id="962ce-404">Reads are reordered on Xbox 360, but on x86 or x64 they are only reordered relative to writes, and only if the reads and writes target different locations.</span></span>

## <a name="recommendations"></a><span data-ttu-id="962ce-405">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="962ce-405">Recommendations</span></span>

-   <span data-ttu-id="962ce-406">Используйте блокировки, если это возможно, так как они проще правильно использовать.</span><span class="sxs-lookup"><span data-stu-id="962ce-406">Use locks when possible because they are easier to use correctly.</span></span>
-   <span data-ttu-id="962ce-407">Избегайте слишком частой блокировки, чтобы затраты на блокировку не стали значительными.</span><span class="sxs-lookup"><span data-stu-id="962ce-407">Avoid locking too frequently, so that locking costs do not become significant.</span></span>
-   <span data-ttu-id="962ce-408">Старайтесь не удерживать блокировки слишком долго, чтобы избежать длительных ожиданий.</span><span class="sxs-lookup"><span data-stu-id="962ce-408">Avoid holding locks for too long, in order to avoid long stalls.</span></span>
-   <span data-ttu-id="962ce-409">Используйте программирование без блокировки, если это уместно, но не забывайте, что рост будет оправдан.</span><span class="sxs-lookup"><span data-stu-id="962ce-409">Use lockless programming when appropriate, but be sure that the gains justify the complexity.</span></span>
-   <span data-ttu-id="962ce-410">Используйте программирование или блокировки с неблокировкой в ситуациях, когда запрещены другие блокировки, например при совместном использовании данных между отложенными вызовами процедур и обычным кодом.</span><span class="sxs-lookup"><span data-stu-id="962ce-410">Use lockless programming or spin locks in situations where other locks are prohibited, such as when sharing data between deferred procedure calls and normal code.</span></span>
-   <span data-ttu-id="962ce-411">Используйте только стандартные алгоритмы программирования с неблокировкой, которые были проверены правильно.</span><span class="sxs-lookup"><span data-stu-id="962ce-411">Only use standard lockless programming algorithms that have been proven to be correct.</span></span>
-   <span data-ttu-id="962ce-412">При программировании независимо от блокировок при необходимости обязательно используйте переменные флагов и инструкции по барьеру памяти.</span><span class="sxs-lookup"><span data-stu-id="962ce-412">When doing lockless programming, be sure to use volatile flag variables and memory barrier instructions as needed.</span></span>
-   <span data-ttu-id="962ce-413">При использовании **интерлоккедкскскс** на Xbox 360 используйте варианты " **получить** " и " **выпуск** ".</span><span class="sxs-lookup"><span data-stu-id="962ce-413">When using **InterlockedXxx** on Xbox 360, use the **Acquire** and **Release** variants.</span></span>

## <a name="references"></a><span data-ttu-id="962ce-414">Ссылки</span><span class="sxs-lookup"><span data-stu-id="962ce-414">References</span></span>

-   <span data-ttu-id="962ce-415">Библиотека MSDN.</span><span class="sxs-lookup"><span data-stu-id="962ce-415">MSDN Library.</span></span> <span data-ttu-id="962ce-416">"[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)".</span><span class="sxs-lookup"><span data-stu-id="962ce-416">"[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)."</span></span> <span data-ttu-id="962ce-417">Справочник по языку C++.</span><span class="sxs-lookup"><span data-stu-id="962ce-417">C++ Language Reference.</span></span>
-   <span data-ttu-id="962ce-418">Вэнс Моррисон.</span><span class="sxs-lookup"><span data-stu-id="962ce-418">Vance Morrison.</span></span> <span data-ttu-id="962ce-419">"[Понимание влияния методов Low-Lock в многопоточных приложениях](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)".</span><span class="sxs-lookup"><span data-stu-id="962ce-419">"[Understand the Impact of Low-Lock Techniques in Multithreaded Apps](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)."</span></span> <span data-ttu-id="962ce-420">Журнал MSDN Magazine, Октябрь 2005.</span><span class="sxs-lookup"><span data-stu-id="962ce-420">MSDN Magazine, October 2005.</span></span>
-   <span data-ttu-id="962ce-421">Лйонс, Майкл.</span><span class="sxs-lookup"><span data-stu-id="962ce-421">Lyons, Michael.</span></span> <span data-ttu-id="962ce-422">"[Модель хранилища PowerPC и программирование AIX](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)".</span><span class="sxs-lookup"><span data-stu-id="962ce-422">"[PowerPC Storage Model and AIX Programming](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)."</span></span> <span data-ttu-id="962ce-423">IBM Девелоперворкс, 16 ноября 2005.</span><span class="sxs-lookup"><span data-stu-id="962ce-423">IBM developerWorks, 16 Nov 2005.</span></span>
-   <span data-ttu-id="962ce-424">Мккеннэй, Пол E. "[порядок памяти в современных микропроцессорах, часть II](https://www.linuxjournal.com/article/8212)".</span><span class="sxs-lookup"><span data-stu-id="962ce-424">McKenney, Paul E. "[Memory Ordering in Modern Microprocessors, Part II](https://www.linuxjournal.com/article/8212)."</span></span> <span data-ttu-id="962ce-425">Журнал Linux, 2005 сентября.</span><span class="sxs-lookup"><span data-stu-id="962ce-425">Linux Journal, September 2005.</span></span> <span data-ttu-id="962ce-426">\[В этой статье содержатся сведения об архитектуре x86.\]</span><span class="sxs-lookup"><span data-stu-id="962ce-426">\[This article has some x86 details.\]</span></span>
-   <span data-ttu-id="962ce-427">Корпорация Intel.</span><span class="sxs-lookup"><span data-stu-id="962ce-427">Intel Corporation.</span></span> <span data-ttu-id="962ce-428">"[Упорядочение памяти в архитектуре Intel® 64](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)".</span><span class="sxs-lookup"><span data-stu-id="962ce-428">"[Intel® 64 Architecture Memory Ordering](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)."</span></span> <span data-ttu-id="962ce-429">2007 августа.</span><span class="sxs-lookup"><span data-stu-id="962ce-429">August 2007.</span></span> <span data-ttu-id="962ce-430">\[Применяется к процессорам IA-32 и Intel 64.\]</span><span class="sxs-lookup"><span data-stu-id="962ce-430">\[Applies to both IA-32 and Intel 64 processors.\]</span></span>
-   <span data-ttu-id="962ce-431">Ниеблер, то есть</span><span class="sxs-lookup"><span data-stu-id="962ce-431">Niebler, Eric.</span></span> <span data-ttu-id="962ce-432">"[Отчет о командировках: прямое совещание в потоках на C++](https://www.artima.com/cppsource/threads_meeting.html)".</span><span class="sxs-lookup"><span data-stu-id="962ce-432">"[Trip Report: Ad-Hoc Meeting on Threads in C++](https://www.artima.com/cppsource/threads_meeting.html)."</span></span> <span data-ttu-id="962ce-433">Исходный код C++, 17 октября 2006.</span><span class="sxs-lookup"><span data-stu-id="962ce-433">The C++ Source, 17 Oct 2006.</span></span>
-   <span data-ttu-id="962ce-434">Харт, Томас E. 2006.</span><span class="sxs-lookup"><span data-stu-id="962ce-434">Hart, Thomas E. 2006.</span></span> <span data-ttu-id="962ce-435">"[Быстрое выполнение синхронизации блокировок: влияние восстановления памяти на производительность](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)".</span><span class="sxs-lookup"><span data-stu-id="962ce-435">"[Making Lockless Synchronization Fast: Performance Implications of Memory Reclamation](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)."</span></span> <span data-ttu-id="962ce-436">Материалы 2006 Международная параллельная и распределенная обработка Symposium (ИПДПС 2006), остров Роудз, Греция, Апрель 2006.</span><span class="sxs-lookup"><span data-stu-id="962ce-436">Proceedings of the 2006 International Parallel and Distributed Processing Symposium (IPDPS 2006), Rhodes Island, Greece, April 2006.</span></span>

 

 