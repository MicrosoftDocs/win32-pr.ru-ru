---
title: Написание программного кода для многоядерных процессоров Xbox 360 и Windows
description: В этом разделе приводятся некоторые рекомендации по началу работы с многопоточным программированием.
ms.assetid: 661f13a6-c73d-8513-2bad-0ef9d1a361a0
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 75899dacdfba829fc1a83e9393e6aa58574c9f30
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2020
ms.locfileid: "104414113"
---
# <a name="coding-for-multicore-on-xbox-360-and-windows"></a><span data-ttu-id="5d106-103">Написание программного кода для многоядерных процессоров Xbox 360 и Windows</span><span class="sxs-lookup"><span data-stu-id="5d106-103">Coding for multicore on Xbox 360 and Windows</span></span>

<span data-ttu-id="5d106-104">В течение многих лет производительность процессоров увеличилась непрерывно, а игры и другие программы использовали преимущества этого увеличения мощности без необходимости делать ничего особенного.</span><span class="sxs-lookup"><span data-stu-id="5d106-104">For years the performance of processors has increased steadily, and games and other programs have reaped the benefits of this increasing power without having to do anything special.</span></span>

<span data-ttu-id="5d106-105">Правила были изменены.</span><span class="sxs-lookup"><span data-stu-id="5d106-105">The rules have changed.</span></span> <span data-ttu-id="5d106-106">Производительность однопроцессорных ядер теперь увеличивается очень медленно, если вообще.</span><span class="sxs-lookup"><span data-stu-id="5d106-106">The performance of single processor cores is now increasing very slowly, if at all.</span></span> <span data-ttu-id="5d106-107">Однако вычислительные мощности, доступные на типичном компьютере или в консоли, продолжат расти.</span><span class="sxs-lookup"><span data-stu-id="5d106-107">However, the computing power available in a typical computer or console continues to grow.</span></span> <span data-ttu-id="5d106-108">Разница заключается в том, что большая часть этого выигрыша в производительности теперь связана с наличием нескольких процессорных ядер на одном компьютере, часто в одной микросхеме.</span><span class="sxs-lookup"><span data-stu-id="5d106-108">The difference is that most of this performance gain now comes from having multiple processor cores in a single machine, often in a single chip.</span></span> <span data-ttu-id="5d106-109">Процессор Xbox 360 имеет три ядра процессора на одной микросхеме, и примерно 70 процентов процессоров ПК, продаваемых в 2006, были многоядерными.</span><span class="sxs-lookup"><span data-stu-id="5d106-109">The Xbox 360 CPU has three processor cores on one chip, and roughly 70 percent of PC processors sold in 2006 were multi-core.</span></span>

<span data-ttu-id="5d106-110">Увеличение доступной вычислительной мощности так же просто, как в прошлом, но теперь разработчикам приходится писать многопоточный код для использования этой мощности.</span><span class="sxs-lookup"><span data-stu-id="5d106-110">The increases in available processing power are just as dramatic as in the past, but now developers have to write multithreaded code in order to use this power.</span></span> <span data-ttu-id="5d106-111">Многопоточное программирование приносит новые задачи проектирования и программирования.</span><span class="sxs-lookup"><span data-stu-id="5d106-111">Multi-threaded programming brings with it new design and programming challenges.</span></span> <span data-ttu-id="5d106-112">В этом разделе приводятся некоторые рекомендации по началу работы с многопоточным программированием.</span><span class="sxs-lookup"><span data-stu-id="5d106-112">This topic gives some advice on how to get started with multithreaded programming.</span></span>

## <a name="the-importance-of-good-design"></a><span data-ttu-id="5d106-113">Важность хорошего дизайна</span><span class="sxs-lookup"><span data-stu-id="5d106-113">The Importance of Good Design</span></span>

<span data-ttu-id="5d106-114">Хорошая разработка многопоточной программы очень важна, но она может быть очень сложной.</span><span class="sxs-lookup"><span data-stu-id="5d106-114">Good multithreaded program design is critical, but it can be very difficult.</span></span> <span data-ttu-id="5d106-115">Если вы ударили переместить Основные игровые системы на разные потоки, скорее всего, вы обнаружите, что каждый поток тратит большую часть времени на работу других потоков.</span><span class="sxs-lookup"><span data-stu-id="5d106-115">If you haphazardly move your major game systems onto different threads, you will likely find that each thread spends most of its time waiting on the other threads.</span></span> <span data-ttu-id="5d106-116">Этот тип проекта приводит к увеличению сложности и значительным усилиям по отладке, практически не повышая производительность.</span><span class="sxs-lookup"><span data-stu-id="5d106-116">This type of design leads to increased complexity and significant debugging effort, with virtually no performance gain.</span></span>

<span data-ttu-id="5d106-117">Каждый раз, когда потоки должны синхронизировать или предоставлять общий доступ к данным, существует вероятность повреждения данных, затрат на синхронизацию, взаимоблокировок и сложности.</span><span class="sxs-lookup"><span data-stu-id="5d106-117">Every time that threads have to synchronize or share data there is the potential for data corruption, synchronization overhead, deadlocks, and complexity.</span></span> <span data-ttu-id="5d106-118">Таким образом, многопоточной архитектуре необходимо четко документировать каждую синхронизацию и точку обмена данными, и она должна максимально сокращать такие моменты.</span><span class="sxs-lookup"><span data-stu-id="5d106-118">Therefore, your multithreaded design needs to clearly document every synchronization and communication point, and it should minimize such points as much as possible.</span></span> <span data-ttu-id="5d106-119">Когда потоки должны обмениваться данными, усилия по написанию кода будут увеличиваться, что может снизить производительность, если она влияет на слишком большой объем исходного кода.</span><span class="sxs-lookup"><span data-stu-id="5d106-119">Where threads need to communicate, coding effort will increase, which can lower productivity if it affects too much source code.</span></span>

<span data-ttu-id="5d106-120">Простейшая цель проектирования многопоточности — разбить код на большие независимые части.</span><span class="sxs-lookup"><span data-stu-id="5d106-120">The simplest design goal for multithreading is to break up the code into large independent pieces.</span></span> <span data-ttu-id="5d106-121">Если вы затем сделаете эти части недоступными только несколько раз в кадре, вы увидите значительное ускорение от многопоточности, не источником значительного сложность.</span><span class="sxs-lookup"><span data-stu-id="5d106-121">If you then restrict these pieces to communicating just a few times per frame, you will see significant speedup from multithreading, without undue complexity.</span></span>

## <a name="typical-threaded-tasks"></a><span data-ttu-id="5d106-122">Типичные потоковые задачи</span><span class="sxs-lookup"><span data-stu-id="5d106-122">Typical Threaded Tasks</span></span>

<span data-ttu-id="5d106-123">Некоторые типы задач проверены на податлива в отдельные потоки.</span><span class="sxs-lookup"><span data-stu-id="5d106-123">A few types of tasks have proven amenable to being put onto separate threads.</span></span> <span data-ttu-id="5d106-124">Следующий список не является исчерпывающим, но должен дать некоторые идеи.</span><span class="sxs-lookup"><span data-stu-id="5d106-124">The following list is not intended to be exhaustive, but should give some ideas.</span></span>

### <a name="rendering"></a><span data-ttu-id="5d106-125">Отрисовка</span><span class="sxs-lookup"><span data-stu-id="5d106-125">Rendering</span></span>

<span data-ttu-id="5d106-126">Отрисовка, которая может включать в себя проход по графу сцены или, возможно, только вызов функций D3D — часто учетные записи для времени ЦП 50% или больше.</span><span class="sxs-lookup"><span data-stu-id="5d106-126">Rendering — which may include walking the scene graph or, possibly, only calling D3D functions — often accounts for 50 percent or more of CPU time.</span></span> <span data-ttu-id="5d106-127">Таким образом, перемещение визуализации в другой поток может иметь значительные преимущества.</span><span class="sxs-lookup"><span data-stu-id="5d106-127">Therefore, moving rendering to another thread can have significant benefits.</span></span> <span data-ttu-id="5d106-128">Поток обновления может заполнять некоторый буфер описания рендеринга, который поток отрисовки может обработать.</span><span class="sxs-lookup"><span data-stu-id="5d106-128">The update thread can fill in some sort of render description buffer, which the rendering thread can then process.</span></span>

<span data-ttu-id="5d106-129">Поток обновления игры всегда находится в одном кадре впереди потока прорисовки, что означает, что он принимает два кадра перед отображением действий пользователя на экране.</span><span class="sxs-lookup"><span data-stu-id="5d106-129">The game update thread is always one frame ahead of the render thread, which means that it takes two frames before user actions show up on the screen.</span></span> <span data-ttu-id="5d106-130">Хотя эта увеличенная задержка может быть проблемой, увеличение частоты кадров при разделении рабочей нагрузки обычно позволяет сохранить общую задержку.</span><span class="sxs-lookup"><span data-stu-id="5d106-130">Although this increased latency can be a problem, the increased frame rate from splitting up the workload generally keeps the total latency acceptable.</span></span>

<span data-ttu-id="5d106-131">В большинстве случаев все действия по отрисовке по-прежнему выполняются в одном потоке, но это другой поток из обновления игры.</span><span class="sxs-lookup"><span data-stu-id="5d106-131">In most cases all rendering is still done on a single thread, but it is a different thread from the game update.</span></span>

<span data-ttu-id="5d106-132">\_МНОГОпотоковый флаг D3DCREATE иногда используется, чтобы разрешить отрисовку в одном потоке и создании ресурсов в других потоках. Этот флаг не учитывается на Xbox 360, и его следует избегать в Windows.</span><span class="sxs-lookup"><span data-stu-id="5d106-132">The D3DCREATE\_MULTITHREADED flag is sometimes used to allow rendering on one thread and resource creation on other threads; this flag is ignored on Xbox 360, and you should avoid using it on Windows.</span></span> <span data-ttu-id="5d106-133">В Windows указание этого флага приводит к тому, что D3D тратит значительное время на синхронизацию, что замедляет поток отрисовки.</span><span class="sxs-lookup"><span data-stu-id="5d106-133">On Windows, specifying this flag forces D3D to spend a significant amount of time on synchronization, thus slowing down the render thread.</span></span>

### <a name="file-decompression"></a><span data-ttu-id="5d106-134">Распаковка файлов</span><span class="sxs-lookup"><span data-stu-id="5d106-134">File Decompression</span></span>

<span data-ttu-id="5d106-135">Время загрузки всегда слишком велико, и потоковая передача данных в память без влияния на частоту кадров может оказаться сложной задачей.</span><span class="sxs-lookup"><span data-stu-id="5d106-135">Load times are always too long, and streaming data into memory without affecting the frame rate can be challenging.</span></span> <span data-ttu-id="5d106-136">Если все данные агрессивно сжимаются на диске, скорость передачи данных с жесткого диска или оптического диска скорее всего будет ограничивающим фактором.</span><span class="sxs-lookup"><span data-stu-id="5d106-136">If all data is aggressively compressed on disc, then data transfer speed from the hard drive or optical disc is less likely to be a limiting factor.</span></span> <span data-ttu-id="5d106-137">В однопотоковых процессорах обычно недостаточно процессорного времени для сжатия, чтобы помочь время загрузки.</span><span class="sxs-lookup"><span data-stu-id="5d106-137">On a single-threaded processor, there is usually not enough processor time available for compression to help load times.</span></span> <span data-ttu-id="5d106-138">Однако в многопроцессорной системе распаковка файлов использует циклы ЦП, которые в противном случае были бы потеряны. Это увеличивает время загрузки и потоковую передачу. и экономит место на диске.</span><span class="sxs-lookup"><span data-stu-id="5d106-138">On a multiprocessor system, however, file decompression uses CPU cycles that would otherwise be wasted; it improves load times and streaming; and it saves space on the disc.</span></span>

<span data-ttu-id="5d106-139">Не используйте распаковку файлов в качестве замены для обработки, которая должна выполняться во время рабочей среды.</span><span class="sxs-lookup"><span data-stu-id="5d106-139">Do not use file decompression as a replacement for processing that should be done during production.</span></span> <span data-ttu-id="5d106-140">Например, если посвятить дополнительный поток синтаксическому анализу XML-данных во время загрузки уровня, многопоточность не используется для улучшения работы проигрывателя.</span><span class="sxs-lookup"><span data-stu-id="5d106-140">For instance, if you devote an extra thread to parsing XML data during level loading, you are not using multithreading to improve the player's experience.</span></span>

<span data-ttu-id="5d106-141">При использовании потока распаковки файлов следует по-прежнему использовать асинхронный файловый ввод-вывод и большие операции чтения, чтобы обеспечить максимальную эффективность чтения данных.</span><span class="sxs-lookup"><span data-stu-id="5d106-141">When using a file decompression thread, you should still use asynchronous file I/O and large reads in order to maximize data-reading efficiency.</span></span>

### <a name="graphics-fluff"></a><span data-ttu-id="5d106-142">Графические проводимые самими</span><span class="sxs-lookup"><span data-stu-id="5d106-142">Graphics Fluff</span></span>

<span data-ttu-id="5d106-143">Существует множество графических изяществ, которые улучшают внешний вид игры, но не являются строго необходимыми.</span><span class="sxs-lookup"><span data-stu-id="5d106-143">There are many graphical niceties that improve the look of the game but aren't strictly necessary.</span></span> <span data-ttu-id="5d106-144">К ним относятся, например, создаваемые процедурные анимации в облаке, имитации ткани и волосы, процедурные волны, процедурные растительности, другие частицы или не игрового процесса физика.</span><span class="sxs-lookup"><span data-stu-id="5d106-144">These include things like procedurally generated cloud animations, cloth and hair simulations, procedural waves, procedural vegetation, more particles, or non-gameplay physics.</span></span>

<span data-ttu-id="5d106-145">Поскольку эти эффекты не влияют на игрового процесса, они не вызывают проблем с синхронизацией — они могут синхронизироваться с другими потоками один раз в кадре или реже.</span><span class="sxs-lookup"><span data-stu-id="5d106-145">Because these effects don't affect gameplay, they don't cause tricky synchronization problems—they can synchronize with the other threads once per frame or less often.</span></span> <span data-ttu-id="5d106-146">Кроме того, в играх для Windows эти эффекты могут увеличить ценность для игроков с многоядерными процессорами, в то время как на одноядерные компьютеры не указывается без предупреждения, что позволяет легко масштабироваться по широкому спектру возможностей.</span><span class="sxs-lookup"><span data-stu-id="5d106-146">Additionally, on games for Windows these effects can add value for gamers with multicore CPUs, while silently being omitted on single-core computers, thus giving an easy way of scaling across a wide range of capabilities.</span></span>

### <a name="physics"></a><span data-ttu-id="5d106-147">Физика</span><span class="sxs-lookup"><span data-stu-id="5d106-147">Physics</span></span>

<span data-ttu-id="5d106-148">Физика часто не может быть помещена в отдельный поток для параллельного выполнения с обновлением игры, так как для игры обычно требуется немедленное вычисление результатов физических вычислений.</span><span class="sxs-lookup"><span data-stu-id="5d106-148">Physics often cannot be put onto a separate thread to run in parallel with the game update because the game update usually requires the results of the physics calculations immediately.</span></span> <span data-ttu-id="5d106-149">Альтернативой многопоточности является запуск на нескольких процессорах.</span><span class="sxs-lookup"><span data-stu-id="5d106-149">The alternative for multithreading physics is to run it on multiple processors.</span></span> <span data-ttu-id="5d106-150">Хотя это можно сделать, это сложная задача, которая требует частого доступа к общим структурам данных.</span><span class="sxs-lookup"><span data-stu-id="5d106-150">Although this can be done, it is a complex task requiring frequent access to shared data structures.</span></span> <span data-ttu-id="5d106-151">Если вы можете хранить физическую рабочую нагрузку достаточно мало, чтобы вместить основной поток, ваша работа будет более простой.</span><span class="sxs-lookup"><span data-stu-id="5d106-151">If you can keep your physics workload low enough to fit on the main thread, your job will be simpler.</span></span>

<span data-ttu-id="5d106-152">Доступны библиотеки, поддерживающие выполнение физических потоков в нескольких потоках.</span><span class="sxs-lookup"><span data-stu-id="5d106-152">Libraries that support running physics on multiple threads are available.</span></span> <span data-ttu-id="5d106-153">Однако это может привести к возникновению проблемы: Если в игре используется физика, используется много потоков, но в остальной части времени используется мало.</span><span class="sxs-lookup"><span data-stu-id="5d106-153">However, this can lead to a problem: when your game is running physics, it uses many threads, but the rest of the time it uses few.</span></span> <span data-ttu-id="5d106-154">Выполнение физикы в нескольких потоках потребует адресации таким образом, чтобы Рабочая нагрузка равномерно распределена по кадру.</span><span class="sxs-lookup"><span data-stu-id="5d106-154">Running physics on multiple threads will require addressing this so that the workload is distributed evenly over the frame.</span></span> <span data-ttu-id="5d106-155">При написании многопоточного механизма обработки физических потоков необходимо уделить особое внимание всем структурам данных, точкам синхронизации и балансировке нагрузки.</span><span class="sxs-lookup"><span data-stu-id="5d106-155">If you write a multithreaded physics engine, you must pay careful attention to all of your data structures, synchronization points, and load balancing.</span></span>

## <a name="example-multithreaded-designs"></a><span data-ttu-id="5d106-156">Примеры многопоточных проектов</span><span class="sxs-lookup"><span data-stu-id="5d106-156">Example Multithreaded Designs</span></span>

<span data-ttu-id="5d106-157">Игры для Windows должны работать на компьютерах, имеющих разное количество ядер ЦП.</span><span class="sxs-lookup"><span data-stu-id="5d106-157">Games for Windows need to run on computers with different numbers of CPU cores.</span></span> <span data-ttu-id="5d106-158">Большинство игровых компьютеров по-прежнему имеют только одно ядро, хотя число 2-ядерных компьютеров быстро растет.</span><span class="sxs-lookup"><span data-stu-id="5d106-158">Most game machines still have only one core, although the number of two-core machines is growing rapidly.</span></span> <span data-ttu-id="5d106-159">Типичная игра для Windows может привести к нарушению рабочей нагрузки в одном потоке для обновления и отрисовки с дополнительными рабочими потоками для добавления дополнительных функциональных возможностей.</span><span class="sxs-lookup"><span data-stu-id="5d106-159">A typical game for Windows might break its workload into one thread for update and rendering, with optional worker threads for adding extra functionality.</span></span> <span data-ttu-id="5d106-160">Кроме того, может использоваться несколько фоновых потоков для выполнения файлового ввода-вывода и сети.</span><span class="sxs-lookup"><span data-stu-id="5d106-160">In addition, some background threads for doing file I/O and networking would probably be used.</span></span> <span data-ttu-id="5d106-161">На рис. 1 показаны потоки вместе с основными точками передачи данных.</span><span class="sxs-lookup"><span data-stu-id="5d106-161">Figure 1 shows the threads, together with the main data transfer points.</span></span>

<span data-ttu-id="5d106-162">**Рис. 1. Проектирование потоков в игре для Windows**</span><span class="sxs-lookup"><span data-stu-id="5d106-162">**Figure 1. Threading design in a game for Windows**</span></span>

![Проектирование потоков в игре для Windows](images/coding-for-multiple-cores-1.gif)

<span data-ttu-id="5d106-164">Стандартная игра Xbox 360 может использовать дополнительные ресурсоемкие программные потоки, поэтому она может разбивать свою рабочую нагрузку на поток обновления, поток отрисовки и три рабочих потока, как показано на рис. 2.</span><span class="sxs-lookup"><span data-stu-id="5d106-164">A typical Xbox 360 game can use additional CPU-intensive software threads, so it might break up its workload into an update thread, rendering thread, and three worker threads, as shown in Figure 2.</span></span>

<span data-ttu-id="5d106-165">**Рис. 2. Проектирование потоков в игре для Xbox 360**</span><span class="sxs-lookup"><span data-stu-id="5d106-165">**Figure 2. Threading design in a game for Xbox 360**</span></span>

![Проектирование потоков в игре для Xbox 360](images/coding-for-multiple-cores-2.gif)

<span data-ttu-id="5d106-167">За исключением файловых операций ввода-вывода и работы в сети, все эти задачи могут быть достаточно ресурсоемкими, чтобы использовать их в своем аппаратном потоке.</span><span class="sxs-lookup"><span data-stu-id="5d106-167">With the exception of file I/O and networking, these tasks all have the potential to be CPU-intensive enough to benefit from being on their own hardware thread.</span></span> <span data-ttu-id="5d106-168">Эти задачи также могут быть достаточно независимыми, чтобы их можно было выполнять для всего кадра без связи.</span><span class="sxs-lookup"><span data-stu-id="5d106-168">These tasks also have the potential to be independent enough that they can run for an entire frame without communicating.</span></span>

<span data-ttu-id="5d106-169">Поток обновления игры управляет входными данными контроллера, AI и физикой, а также подготавливает инструкции для других четырех потоков.</span><span class="sxs-lookup"><span data-stu-id="5d106-169">The game update thread manages controller input, AI, and physics, and prepares instructions for the other four threads.</span></span> <span data-ttu-id="5d106-170">Эти инструкции помещаются в буферы, принадлежащие потоку обновления игры, поэтому при создании инструкций не требуется синхронизация.</span><span class="sxs-lookup"><span data-stu-id="5d106-170">These instructions are placed into buffers owned by the game update thread, so no synchronization is required as the instructions are generated.</span></span>

<span data-ttu-id="5d106-171">В конце кадра поток обновления игры передает буферы инструкций четырем другим потокам, а затем начинает работу над следующим кадром, заполняя другой набор буферов инструкций.</span><span class="sxs-lookup"><span data-stu-id="5d106-171">At the end of the frame, the game update thread hands off the instruction buffers to the four other threads, and then starts working on the next frame, filling in another set of instruction buffers.</span></span>

<span data-ttu-id="5d106-172">Так как потоки обновления и отрисовки работают в локкстеп друг с другом, их буферы обмена данными просто передаются двойным буфером: в любой момент времени поток обновления заполняет один буфер, а поток прорисовки считывается из другого.</span><span class="sxs-lookup"><span data-stu-id="5d106-172">Because the update and rendering threads work in lockstep with each other, their communication buffers are simply double buffered: at any given time, the update thread is filling one buffer while the render thread is reading from the other.</span></span>

<span data-ttu-id="5d106-173">Другие рабочие потоки не обязательно привязаны к частоте кадров.</span><span class="sxs-lookup"><span data-stu-id="5d106-173">The other worker threads are not necessarily tied to the frame rate.</span></span> <span data-ttu-id="5d106-174">Распаковка фрагмента данных может занять гораздо меньше кадров или может занять много кадров.</span><span class="sxs-lookup"><span data-stu-id="5d106-174">Decompressing a piece of data may take much less than a frame, or it may take many frames.</span></span> <span data-ttu-id="5d106-175">Даже имитация ткани и перекрестного выполнения может не требоваться в точности на частоте кадров, поскольку менее частые обновления могут быть вполне приемлемыми.</span><span class="sxs-lookup"><span data-stu-id="5d106-175">Even the cloth and hair simulation may not need to run exactly at the frame rate because less frequent updates may be quite acceptable.</span></span> <span data-ttu-id="5d106-176">Таким образом, этим трем потокам требуются разные структуры данных для взаимодействия с потоком обновления и потоком отрисовки.</span><span class="sxs-lookup"><span data-stu-id="5d106-176">Therefore, these three threads need different data structures to communicate with the update thread and the render thread.</span></span> <span data-ttu-id="5d106-177">Каждому из них требуется очередь ввода, которая может содержать рабочие запросы, а потоку прорисовки необходима очередь данных, которая может содержать результаты, созданные потоками.</span><span class="sxs-lookup"><span data-stu-id="5d106-177">They each need an input queue that can hold work requests, and the render thread needs a data queue that can hold the results produced by the threads.</span></span> <span data-ttu-id="5d106-178">В конце каждого кадра в потоке обновления будет добавлен блок рабочих запросов к очередям рабочих потоков.</span><span class="sxs-lookup"><span data-stu-id="5d106-178">At the end of each frame the update thread will add a block of work requests to worker threads' queues.</span></span> <span data-ttu-id="5d106-179">Добавление в список только один раз за кадр гарантирует, что поток обновления минимизирует нагрузку на синхронизацию.</span><span class="sxs-lookup"><span data-stu-id="5d106-179">Adding to the list just once per frame ensures that the update thread minimizes the synchronization overhead.</span></span> <span data-ttu-id="5d106-180">Каждый рабочий поток извлекает назначения из рабочей очереди так быстро, как это возможно, используя цикл, который выглядит примерно так:</span><span class="sxs-lookup"><span data-stu-id="5d106-180">Each of the worker threads pulls assignments from the work queue as quickly as it can, using a loop that looks something like this:</span></span>


```C++
for(;;)
{
    while( WorkQueueNotEmpty() )
    {
        RemoveWorkItemFromWorkQueue();
        ProcessWorkItem();
        PutResultInDataQueue();
    }
    WaitForSingleObject( hWorkSemaphore ); 
}
```



<span data-ttu-id="5d106-181">Так как данные переходят от потоков обновления к рабочим потокам, а затем к потоку прорисовки, перед выполнением некоторых действий на экране может быть задержка в трех или более кадрах.</span><span class="sxs-lookup"><span data-stu-id="5d106-181">Because the data goes from the update threads to the worker threads and then to the render thread, there can be a delay of three or more frames before some actions make it to the screen.</span></span> <span data-ttu-id="5d106-182">Однако при назначении задач, отчувствительных к задержке, рабочим потокам это не должно быть проблемой.</span><span class="sxs-lookup"><span data-stu-id="5d106-182">However, if you assign latency-tolerant tasks to the worker threads, then this should not be a problem.</span></span>

<span data-ttu-id="5d106-183">В качестве альтернативного проекта можно создать несколько рабочих потоков из одной рабочей очереди.</span><span class="sxs-lookup"><span data-stu-id="5d106-183">An alternate design would be to have several worker threads all drawing from the same work queue.</span></span> <span data-ttu-id="5d106-184">Это обеспечит автоматическую балансировку нагрузки и сделает его более вероятной, чтобы все рабочие потоки оставались занятыми.</span><span class="sxs-lookup"><span data-stu-id="5d106-184">This would give automatic load balancing and would make it more likely that all of the worker threads would stay busy.</span></span>

<span data-ttu-id="5d106-185">Поток обновления игры должен не дать слишком много усилий рабочим потокам, иначе рабочие очереди могут постоянно расти.</span><span class="sxs-lookup"><span data-stu-id="5d106-185">The game update thread must take care to not give too much work to the worker threads, or else the work queues may continuously grow.</span></span> <span data-ttu-id="5d106-186">Управление этим потоком обновлений зависит от того, какие задачи выполняет рабочий поток.</span><span class="sxs-lookup"><span data-stu-id="5d106-186">How the update thread manages this depends on what sort of tasks the worker threads are doing.</span></span>

## <a name="simultaneous-multithreading-and-number-of-threads"></a><span data-ttu-id="5d106-187">Одновременная многопоточность и количество потоков</span><span class="sxs-lookup"><span data-stu-id="5d106-187">Simultaneous Multithreading and Number of Threads</span></span>

<span data-ttu-id="5d106-188">Все потоки не создаются равными.</span><span class="sxs-lookup"><span data-stu-id="5d106-188">All threads are not created equal.</span></span> <span data-ttu-id="5d106-189">Два аппаратных потока могут находиться на отдельных микросхемах, в одной микросхеме или даже в одном ядре.</span><span class="sxs-lookup"><span data-stu-id="5d106-189">Two hardware threads might be on separate chips, on the same chip, or even on the same core.</span></span> <span data-ttu-id="5d106-190">Наиболее важной конфигурацией для программистов игр является два аппаратных потока на одном ядре — Одновременная многопоточность (SMT) Hyper-Threading или технология технологии HT.</span><span class="sxs-lookup"><span data-stu-id="5d106-190">The most important configuration for game programmers to be aware of is two hardware threads on one core—Simultaneous Multi-Threading (SMT) or Hyper-Threading Technology (HT Technology).</span></span>

<span data-ttu-id="5d106-191">Потоки технологии SMT или HT совместно используют ресурсы ядра ЦП.</span><span class="sxs-lookup"><span data-stu-id="5d106-191">SMT or HT Technology threads share the resources of the CPU core.</span></span> <span data-ttu-id="5d106-192">Поскольку они совместно используют единицы выполнения, максимальное ускорение от выполнения двух потоков вместо одного обычно составляет 10 – 20 процентов, а не 100 процентов, которые возможны из двух независимых аппаратных потоков.</span><span class="sxs-lookup"><span data-stu-id="5d106-192">Because they share the execution units, the maximum speedup from running two threads instead of one is typically 10 to 20 percent, instead of the 100 percent that is possible from two independent hardware threads.</span></span>

<span data-ttu-id="5d106-193">Более существенно, SMT или технологии HT используют совместное использование инструкций L1 и кэшей данных.</span><span class="sxs-lookup"><span data-stu-id="5d106-193">More significantly, SMT or HT Technology threads share the L1 instruction and data caches.</span></span> <span data-ttu-id="5d106-194">Если шаблоны доступа к памяти несовместимы, они могут обеспечить борьба с кэшем и привести к большому количеству промахов в кэше.</span><span class="sxs-lookup"><span data-stu-id="5d106-194">If their memory access patterns are incompatible, they can end up fighting over the cache and causing many cache misses.</span></span> <span data-ttu-id="5d106-195">В худшем случае общая производительность ядра ЦП может фактически снижаться при выполнении второго потока.</span><span class="sxs-lookup"><span data-stu-id="5d106-195">In the worst case, the total performance for the CPU core can actually decrease when a second thread is run.</span></span> <span data-ttu-id="5d106-196">На Xbox 360 это довольно простая проблема.</span><span class="sxs-lookup"><span data-stu-id="5d106-196">On Xbox 360, this is a fairly simple problem.</span></span> <span data-ttu-id="5d106-197">Конфигурация Xbox 360 известна — три ядра ЦП, каждый с двумя аппаратными потоками, и разработчики назначают свои программные потоки конкретным потокам ЦП и могут измерять, чтобы определить, дает ли их проектирование потоков дополнительные показатели производительности.</span><span class="sxs-lookup"><span data-stu-id="5d106-197">The configuration of the Xbox 360 is known—three CPU cores each with two hardware threads—and developers assign their software threads to specific CPU threads and can measure to see whether their threading design gives them extra performance.</span></span>

<span data-ttu-id="5d106-198">В Windows ситуация сложнее.</span><span class="sxs-lookup"><span data-stu-id="5d106-198">On Windows, the situation is more complicated.</span></span> <span data-ttu-id="5d106-199">Количество потоков и их конфигурация будет отличаться от компьютера к компьютеру, а определение конфигурации будет сложным.</span><span class="sxs-lookup"><span data-stu-id="5d106-199">The number of threads and their configuration will vary from computer to computer, and determining the configuration is complicated.</span></span> <span data-ttu-id="5d106-200">Функция [**жетлогикалпроцессоринформатион**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) предоставляет сведения о связи между различными аппаратными потоками, а эта функция доступна в Windows Vista, Windows 7 и Windows XP SP3.</span><span class="sxs-lookup"><span data-stu-id="5d106-200">The function [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) gives information about the relationship between different hardware threads, and this function is available on Windows Vista, Windows 7, and Windows XP SP3.</span></span> <span data-ttu-id="5d106-201">Таким образом, для того чтобы решить, сколько "реальных" потоков доступно, необходимо использовать инструкцию CPUID и алгоритмы, заданные корпорацией Intel и AMD.</span><span class="sxs-lookup"><span data-stu-id="5d106-201">Therefore, for now you have to use the CPUID instruction and the algorithms given by Intel and AMD in order to decide how many "real" threads you have available.</span></span> <span data-ttu-id="5d106-202">Дополнительные сведения см. в ссылках.</span><span class="sxs-lookup"><span data-stu-id="5d106-202">See the references for more information.</span></span>

<span data-ttu-id="5d106-203">Пример Коредетектион в пакете SDK для DirectX содержит пример кода, который использует функцию [**жетлогикалпроцессоринформатион**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) или CPUID для возврата ТОПОЛОГИИ ядра ЦП.</span><span class="sxs-lookup"><span data-stu-id="5d106-203">The CoreDetection sample in the DirectX SDK contains sample code that uses the [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) function or the CPUID instruction to return the CPU core topology.</span></span> <span data-ttu-id="5d106-204">Инструкция CPUID используется, если **жетлогикалпроцессоринформатион** не поддерживается на текущей платформе.</span><span class="sxs-lookup"><span data-stu-id="5d106-204">The CPUID instruction is used if **GetLogicalProcessorInformation** is not supported on the current platform.</span></span> <span data-ttu-id="5d106-205">Коредетектион можно найти в следующих расположениях:</span><span class="sxs-lookup"><span data-stu-id="5d106-205">CoreDetection can be found in the following locations:</span></span>

<dl> <dt>

<span data-ttu-id="5d106-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Источника</span><span class="sxs-lookup"><span data-stu-id="5d106-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Source:</span></span>
</dt> <dd>

<span data-ttu-id="5d106-207">Корень пакета SDK для *DirectX* \\ Примеры \\ C++ \\ Разное \\ коредетектион</span><span class="sxs-lookup"><span data-stu-id="5d106-207">*DirectX SDK root*\\Samples\\C++\\Misc\\CoreDetection</span></span>

</dd> <dt>

<span data-ttu-id="5d106-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Объектов</span><span class="sxs-lookup"><span data-stu-id="5d106-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Executable:</span></span>
</dt> <dd>

<span data-ttu-id="5d106-209">Корень пакета SDK для *DirectX* \\ Примеры \\ для \\CoreDetection.exe "Прочие \\ ячейки C++ \\ "</span><span class="sxs-lookup"><span data-stu-id="5d106-209">*DirectX SDK root*\\Samples\\C++\\Misc\\Bin\\CoreDetection.exe</span></span>

</dd> </dl>

<span data-ttu-id="5d106-210">Самым надежным предположением является наличие только одного потока, интенсивно использующих ЦП, на ядро ЦП.</span><span class="sxs-lookup"><span data-stu-id="5d106-210">The safest assumption is to have no more than one CPU-intensive thread per CPU core.</span></span> <span data-ttu-id="5d106-211">Наличие большего количества потоков ЦП, чем ядер ЦП, не дает никаких преимуществ и приводит к дополнительным затратам и сложности дополнительных потоков.</span><span class="sxs-lookup"><span data-stu-id="5d106-211">Having more CPU-intensive threads than CPU cores gives little or no benefits, and brings the extra overhead and complexity of additional threads.</span></span>

## <a name="creating-threads"></a><span data-ttu-id="5d106-212">Создание потоков</span><span class="sxs-lookup"><span data-stu-id="5d106-212">Creating Threads</span></span>

<span data-ttu-id="5d106-213">Создание потоков является довольно простой операцией, но существует множество потенциальных ошибок.</span><span class="sxs-lookup"><span data-stu-id="5d106-213">Creating threads is a fairly simple operation, but there are many potential errors.</span></span> <span data-ttu-id="5d106-214">В приведенном ниже коде показан правильный способ создания потока, ожидания его завершения и очистки.</span><span class="sxs-lookup"><span data-stu-id="5d106-214">The code below shows the proper way of creating a thread, waiting for it to terminate, and then cleaning up.</span></span>


```C++
const int stackSize = 65536;
HANDLE hThread = (HANDLE)_beginthreadex( 0, stackSize,
            ThreadFunction, 0, 0, 0 );
// Do work on main thread here.
// Wait for child thread to complete
WaitForSingleObject( hThread, INFINITE );
CloseHandle( hThread );

...

unsigned __stdcall ThreadFunction( void* data )
{
#if _XBOX_VER >= 200
    // On Xbox 360 you must explicitly assign
    // software threads to hardware threads.
    XSetThreadProcessor( GetCurrentThread(), 2 );
#endif
    // Do child thread work here.
    return 0;
}
```



<span data-ttu-id="5d106-215">При создании потока можно указать размер стека для дочернего потока или указать нуль, в этом случае дочерний поток будет наследовать размер стека родительского потока.</span><span class="sxs-lookup"><span data-stu-id="5d106-215">When you create a thread, you have the option to specify the stack size for the child thread, or specify zero, in which case the child thread will inherit the parent thread's stack size.</span></span> <span data-ttu-id="5d106-216">В Xbox 360, где стеки полностью фиксируются при запуске потока, указание нуля может зарасходить значительный объем памяти, так как многим дочерним потокам не требуется такой же размер стека, как у родительского.</span><span class="sxs-lookup"><span data-stu-id="5d106-216">On Xbox 360, where stacks are fully committed when the thread starts, specifying zero can waste significant memory, because many child threads will not need as much stack as the parent.</span></span> <span data-ttu-id="5d106-217">На Xbox 360 также важно, чтобы размер стека был кратным 64-КБ.</span><span class="sxs-lookup"><span data-stu-id="5d106-217">On Xbox 360 it is also important that the stack size be a multiple of 64-KB.</span></span>

<span data-ttu-id="5d106-218">Если для создания потоков используется функция [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) , то среда выполнения C/C++ (CRT) не будет правильно инициализирована в Windows.</span><span class="sxs-lookup"><span data-stu-id="5d106-218">If you use the [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) function to create threads, then the C/C++ runtime (CRT) will not get properly initialized on Windows.</span></span> <span data-ttu-id="5d106-219">Вместо этого рекомендуется использовать функцию CRT [**\_ бегинсреадекс**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) .</span><span class="sxs-lookup"><span data-stu-id="5d106-219">We recommend that you use the CRT [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) function instead.</span></span>

<span data-ttu-id="5d106-220">Возвращаемое значение из [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) или [**\_ бегинсреадекс**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) является обработчиком потока.</span><span class="sxs-lookup"><span data-stu-id="5d106-220">The return value from [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) or [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) is a thread handle.</span></span> <span data-ttu-id="5d106-221">Этот поток можно использовать для ожидания завершения дочернего потока, что намного проще и гораздо эффективнее, чем циклический перебор в цикле проверки состояния потока.</span><span class="sxs-lookup"><span data-stu-id="5d106-221">This thread can be used to wait for the child thread to terminate, which is much simpler and much more efficient than spinning in a loop checking the thread status.</span></span> <span data-ttu-id="5d106-222">Чтобы дождаться завершения потока, просто вызовите [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) с помощью обработчика потока.</span><span class="sxs-lookup"><span data-stu-id="5d106-222">To wait for the thread to terminate, simply call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) with the thread handle.</span></span>

<span data-ttu-id="5d106-223">Ресурсы для потока не будут освобождены до тех пор, пока поток не завершится, а обработчик потока не будет закрыт.</span><span class="sxs-lookup"><span data-stu-id="5d106-223">The resources for the thread will not be freed until the thread has terminated and the thread handle has been closed.</span></span> <span data-ttu-id="5d106-224">Поэтому важно закрыть обработчик потока с помощью [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) после завершения работы с ним.</span><span class="sxs-lookup"><span data-stu-id="5d106-224">Therefore, it is important to close the thread handle with [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) when you are finished with it.</span></span> <span data-ttu-id="5d106-225">Если ожидается, что поток завершится с помощью [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), не закрывайте этот обработчик до тех пор, пока не завершится ожидание.</span><span class="sxs-lookup"><span data-stu-id="5d106-225">If you will be waiting for the thread to terminate with [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), be sure to not close the handle until after the wait has completed.</span></span>

<span data-ttu-id="5d106-226">На Xbox 360 необходимо явным образом назначить программные потоки конкретному аппаратному потоку с помощью **кссетсреадпроцессор**.</span><span class="sxs-lookup"><span data-stu-id="5d106-226">On Xbox 360, you must explicitly assign software threads to a particular hardware thread by using **XSetThreadProcessor**.</span></span> <span data-ttu-id="5d106-227">В противном случае все дочерние потоки будут оставаться в том же аппаратном потоке, что и родительский.</span><span class="sxs-lookup"><span data-stu-id="5d106-227">Otherwise, all child threads will stay on the same hardware thread as the parent.</span></span> <span data-ttu-id="5d106-228">В Windows можно использовать [**сетсреадаффинитимаск**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) для обеспечения строгого предложения операционной системе о том, на каких аппаратных потоках должен выполняться поток.</span><span class="sxs-lookup"><span data-stu-id="5d106-228">On Windows, you can use [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) to strongly suggest to the operating system which hardware threads your thread should run on.</span></span> <span data-ttu-id="5d106-229">Как правило, этот метод следует избегать в Windows, так как неизвестно, какие другие процессы могут быть запущены в системе.</span><span class="sxs-lookup"><span data-stu-id="5d106-229">This technique should generally be avoided on Windows since you don't know what other processes might be running on the system.</span></span> <span data-ttu-id="5d106-230">Обычно лучше позволить планировщику Windows назначать потоки в бездействующие аппаратные потоки.</span><span class="sxs-lookup"><span data-stu-id="5d106-230">It is typically better to let the Windows scheduler assign your threads to idle hardware threads.</span></span>

<span data-ttu-id="5d106-231">Создание потоков является дорогостоящей операцией.</span><span class="sxs-lookup"><span data-stu-id="5d106-231">Creating threads is an expensive operation.</span></span> <span data-ttu-id="5d106-232">Потоки должны создаваться и уничтожаться редко.</span><span class="sxs-lookup"><span data-stu-id="5d106-232">Threads should be created and destroyed rarely.</span></span> <span data-ttu-id="5d106-233">Если вы не хотите часто создавать и уничтожать потоки, используйте пул потоков, ожидающих работы.</span><span class="sxs-lookup"><span data-stu-id="5d106-233">If you find yourself wanting to create and destroy threads frequently, use a pool of threads that wait around for work instead.</span></span>

## <a name="synchronizing-threads"></a><span data-ttu-id="5d106-234">Синхронизация потоков</span><span class="sxs-lookup"><span data-stu-id="5d106-234">Synchronizing Threads</span></span>

<span data-ttu-id="5d106-235">Для совместной работы нескольких потоков необходимо иметь возможность синхронизировать потоки, передавать сообщения и запрашивать монопольный доступ к ресурсам.</span><span class="sxs-lookup"><span data-stu-id="5d106-235">For multiple threads to work together, you must be able to synchronize threads, pass messages, and request exclusive access to resources.</span></span> <span data-ttu-id="5d106-236">Windows и Xbox 360 поставляются с обширным набором примитивов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5d106-236">Windows and Xbox 360 come with a rich set of synchronization primitives.</span></span> <span data-ttu-id="5d106-237">Полные сведения об этих примитивах синхронизации см. в документации по платформе.</span><span class="sxs-lookup"><span data-stu-id="5d106-237">For full details on these synchronization primitives, see the platform documentation.</span></span>

### <a name="exclusive-access"></a><span data-ttu-id="5d106-238">Монопольный доступ</span><span class="sxs-lookup"><span data-stu-id="5d106-238">Exclusive Access</span></span>

<span data-ttu-id="5d106-239">Распространенной потребностью является получение монопольного доступа к ресурсу, структуре данных или пути кода.</span><span class="sxs-lookup"><span data-stu-id="5d106-239">Gaining exclusive access to a resource, data structure, or code path is a common need.</span></span> <span data-ttu-id="5d106-240">Одним из вариантов получения монопольного доступа является мьютекс, в котором показано обычное использование.</span><span class="sxs-lookup"><span data-stu-id="5d106-240">One option for gaining exclusive access is a mutex, whose typical usage is shown here.</span></span>


```C++
// Initialize
HANDLE mutex = CreateMutex( 0, FALSE, 0 );

// Use
void ManipulateSharedData()
{
    WaitForSingleObject( mutex, INFINITE );
    // Manipulate stuff...
    ReleaseMutex( mutex );
}

// Destroy
CloseHandle( mutex );
The kernel guarantees that, for a particular mutex, only one thread at a time can 
acquire it.
The main disadvantage to mutexes is that they are relatively expensive to acquire 
and release. A faster alternative is a critical section.
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection( &cs );

// Use
void ManipulateSharedData()
{
    EnterCriticalSection( &cs );
    // Manipulate stuff...
    LeaveCriticalSection( &cs );
}

// Destroy
DeleteCriticalSection( &cs );
```



<span data-ttu-id="5d106-241">Критические секции имеют схожую семантику для мьютексов, но их можно использовать для синхронизации только внутри процесса, а не между процессами.</span><span class="sxs-lookup"><span data-stu-id="5d106-241">Critical sections have similar semantics to mutexes, but they can be used to synchronize only within a process, not between processes.</span></span> <span data-ttu-id="5d106-242">Их основное преимущество заключается в том, что они выполняются примерно в двадцать раз быстрее, чем мьютексы.</span><span class="sxs-lookup"><span data-stu-id="5d106-242">Their main advantage is that they execute roughly twenty times faster than mutexes.</span></span>

### <a name="events"></a><span data-ttu-id="5d106-243">События</span><span class="sxs-lookup"><span data-stu-id="5d106-243">Events</span></span>

<span data-ttu-id="5d106-244">Если два потока (например, поток обновления и поток отрисовки) переходят на использование пары буферов описания рендеринга, им нужен способ указать, когда они выполняются с определенным буфером.</span><span class="sxs-lookup"><span data-stu-id="5d106-244">If two threads—perhaps an update thread and a render thread—are taking turns using a pair of render description buffers, they need a way to indicate when they are done with their particular buffer.</span></span> <span data-ttu-id="5d106-245">Это можно сделать, связав событие (выделенное с помощью [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) с каждым буфером.</span><span class="sxs-lookup"><span data-stu-id="5d106-245">This can be done by associating an event (allocated with [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) with each buffer.</span></span> <span data-ttu-id="5d106-246">Когда поток выполняется с помощью буфера, он может использовать [**выполнить SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) , чтобы сообщить об этом, а затем вызвать [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) для события другого буфера.</span><span class="sxs-lookup"><span data-stu-id="5d106-246">When a thread is done with a buffer, it can use [**SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) to signal this, and can then call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) on the other buffer's event.</span></span> <span data-ttu-id="5d106-247">Этот метод позволяет легко выполнить тройную буферизацию ресурсов.</span><span class="sxs-lookup"><span data-stu-id="5d106-247">This technique extrapolates easily to triple buffering of resources.</span></span>

### <a name="semaphores"></a><span data-ttu-id="5d106-248">Семафоры</span><span class="sxs-lookup"><span data-stu-id="5d106-248">Semaphores</span></span>

<span data-ttu-id="5d106-249">Семафор используется для управления количеством потоков, которые могут выполняться и обычно используются для реализации рабочих очередей.</span><span class="sxs-lookup"><span data-stu-id="5d106-249">A semaphore is used to control how many threads can be running and is commonly used to implement work queues.</span></span> <span data-ttu-id="5d106-250">Один поток добавляет работу в очередь и использует [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) каждый раз при добавлении нового элемента в очередь.</span><span class="sxs-lookup"><span data-stu-id="5d106-250">One thread adds work to a queue and uses [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) whenever it adds a new item to the queue.</span></span> <span data-ttu-id="5d106-251">Это позволяет освободить один рабочий поток из пула ожидающих потоков.</span><span class="sxs-lookup"><span data-stu-id="5d106-251">This allows one worker thread to be released from the pool of waiting threads.</span></span> <span data-ttu-id="5d106-252">Рабочие потоки просто вызывают [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), и когда он возвращает данные о том, что в очереди есть рабочий элемент.</span><span class="sxs-lookup"><span data-stu-id="5d106-252">The worker threads just call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), and when it returns they know there is a work item in the queue for them.</span></span> <span data-ttu-id="5d106-253">Кроме того, для обеспечения безопасного доступа к общей рабочей очереди необходимо использовать критически важный раздел или другой метод синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5d106-253">In addition, a critical section or other synchronization technique must be used in order to guarantee safe access to the shared work queue.</span></span>

### <a name="avoid-suspendthread"></a><span data-ttu-id="5d106-254">Избегайте Суспендсреад</span><span class="sxs-lookup"><span data-stu-id="5d106-254">Avoid SuspendThread</span></span>

<span data-ttu-id="5d106-255">Иногда, когда нужно, чтобы поток перестает работать, он может использовать [**суспендсреад**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) вместо правильных примитивов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5d106-255">Sometimes when you want a thread to stop what it is doing, it is tempting to use [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) instead of the correct synchronization primitives.</span></span> <span data-ttu-id="5d106-256">Это неплохое идея, и это может легко привести к взаимоблокировкам и другим проблемам.</span><span class="sxs-lookup"><span data-stu-id="5d106-256">This is always a bad idea and can easily lead to deadlocks and other problems.</span></span> <span data-ttu-id="5d106-257">**Суспендсреад** также взаимодействует с отладчиком Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="5d106-257">**SuspendThread** also interacts badly with the Visual Studio debugger.</span></span> <span data-ttu-id="5d106-258">Избегайте **суспендсреад**.</span><span class="sxs-lookup"><span data-stu-id="5d106-258">Avoid **SuspendThread**.</span></span> <span data-ttu-id="5d106-259">Вместо этого используйте [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) .</span><span class="sxs-lookup"><span data-stu-id="5d106-259">Use [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) instead.</span></span>

### <a name="waitforsingleobject-and-waitformultipleobjects"></a><span data-ttu-id="5d106-260">WaitForSingleObject и WaitForMultipleObjects</span><span class="sxs-lookup"><span data-stu-id="5d106-260">WaitForSingleObject and WaitForMultipleObjects</span></span>

<span data-ttu-id="5d106-261">Функция [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) — это наиболее часто используемая функция синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5d106-261">The function [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) is the most commonly used synchronization function.</span></span> <span data-ttu-id="5d106-262">Однако иногда требуется, чтобы поток дождался одновременного выполнения нескольких условий или до тех пор, пока не будет удовлетворен один из наборов условий.</span><span class="sxs-lookup"><span data-stu-id="5d106-262">However, sometimes you want a thread to wait until several conditions are simultaneously satisfied, or until one of a set of conditions are satisfied.</span></span> <span data-ttu-id="5d106-263">В этом случае следует использовать [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span><span class="sxs-lookup"><span data-stu-id="5d106-263">In this case, you should use [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span></span>

### <a name="interlocked-functions-and-lockless-programming"></a><span data-ttu-id="5d106-264">Блокируемые функции и программирование с блокировкой</span><span class="sxs-lookup"><span data-stu-id="5d106-264">Interlocked Functions and Lockless Programming</span></span>

<span data-ttu-id="5d106-265">Существует семейство функций для выполнения простых потокобезопасных операций без использования блокировок.</span><span class="sxs-lookup"><span data-stu-id="5d106-265">There is a family of functions for performing simple thread-safe operations without using locks.</span></span> <span data-ttu-id="5d106-266">Это семейство функций, блокируемых, например [**интерлоккединкремент**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span><span class="sxs-lookup"><span data-stu-id="5d106-266">These are the Interlocked family of functions, such as [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span></span> <span data-ttu-id="5d106-267">Эти функции и другие методы, использующие тщательный выбор флагов, вместе называются программированием с поддержкой блокировок.</span><span class="sxs-lookup"><span data-stu-id="5d106-267">These functions, plus other techniques using careful setting of flags, are together known as lockless programming.</span></span> <span data-ttu-id="5d106-268">Программирование без блокировок может быть очень сложным для правильной работы и существенно сложнее на Xbox 360, чем в Windows.</span><span class="sxs-lookup"><span data-stu-id="5d106-268">Lockless programming can be extremely tricky to do correctly, and is substantially more difficult on Xbox 360 than on Windows.</span></span>

<span data-ttu-id="5d106-269">Дополнительные сведения о программировании без блокировок см. в разделе [рекомендации по программированию для Xbox 360 и Microsoft Windows](./lockless-programming.md).</span><span class="sxs-lookup"><span data-stu-id="5d106-269">For more information about programming without locks, see [Lockless Programming Considerations for Xbox 360 and Microsoft Windows](./lockless-programming.md).</span></span>

### <a name="minimizing-synchronization"></a><span data-ttu-id="5d106-270">Минимизация синхронизации</span><span class="sxs-lookup"><span data-stu-id="5d106-270">Minimizing Synchronization</span></span>

<span data-ttu-id="5d106-271">Некоторые методы синхронизации выполняются быстрее, чем другие.</span><span class="sxs-lookup"><span data-stu-id="5d106-271">Some synchronization methods are faster than others.</span></span> <span data-ttu-id="5d106-272">Однако вместо оптимизации кода путем выбора наиболее быстрых методик синхронизации обычно лучше синхронизироваться реже.</span><span class="sxs-lookup"><span data-stu-id="5d106-272">However, rather than optimizing your code by choosing the fastest synchronization techniques possible, it is usually better to synchronize less often.</span></span> <span data-ttu-id="5d106-273">Это быстрее, чем слишком частое выполнение синхронизации, и делает более простым код, который проще отлаживать.</span><span class="sxs-lookup"><span data-stu-id="5d106-273">This is faster than synchronizing too frequently, and it makes for simpler code that is easier to debug.</span></span>

<span data-ttu-id="5d106-274">Для правильной работы некоторых операций, таких как выделение памяти, может потребоваться использовать примитивы синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5d106-274">Some operations, such as memory allocation, may have to use synchronization primitives in order to work correctly.</span></span> <span data-ttu-id="5d106-275">Таким образом, частое выделение памяти из общей кучи по умолчанию приведет к частым операциям синхронизации, что приведет к неэффективному снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="5d106-275">Therefore, doing frequent allocations from the default shared heap will result in frequent synchronization, which will waste some performance.</span></span> <span data-ttu-id="5d106-276">Предотвращение частого выделения памяти или использования куч для каждого потока (использование КУЧИ \_ без \_ сериализации при использовании хеапкреате) может избежать этой скрытой синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5d106-276">Avoiding frequent allocations or using per-thread heaps (using HEAP\_NO\_SERIALIZE if you use HeapCreate) can avoid this hidden synchronization.</span></span>

<span data-ttu-id="5d106-277">Другая причина скрытой синхронизации — D3DCREATE \_ многопоточность, что приводит к тому, что D3D в Windows будет использовать синхронизацию во многих операциях.</span><span class="sxs-lookup"><span data-stu-id="5d106-277">Another cause of hidden synchronization is D3DCREATE\_MULTITHREADED, which causes D3D on Windows to use synchronization on many operations.</span></span> <span data-ttu-id="5d106-278">(Этот флаг игнорируется на Xbox 360.)</span><span class="sxs-lookup"><span data-stu-id="5d106-278">(The flag is ignored on Xbox 360.)</span></span>

<span data-ttu-id="5d106-279">Данные по потокам, также известные как локальное хранилище потока, могут быть важным способом предотвращения синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5d106-279">Per-thread data, also known as thread local storage, can be an important way of avoiding synchronization.</span></span> <span data-ttu-id="5d106-280">Visual C++ позволяет объявлять глобальные переменные в качестве отдельных потоков с помощью синтаксиса **\_ \_ declspec (thread)** .</span><span class="sxs-lookup"><span data-stu-id="5d106-280">Visual C++ allows you to declare global variables as being per-thread with the **\_\_declspec(thread)** syntax.</span></span>


```C++
__declspec( thread ) int tls_i = 1;
```



<span data-ttu-id="5d106-281">Это дает каждому потоку в процессе обработки собственную копию TLS \_ i, на которую можно ссылаться безопасно и эффективно, не требуя синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5d106-281">This gives each thread in the process its own copy of tls\_i, which can be referenced safely and efficiently without requiring synchronization.</span></span>

<span data-ttu-id="5d106-282">Метод **\_ \_ declspec (thread)** не работает с динамически загружаемыми библиотеками DLL.</span><span class="sxs-lookup"><span data-stu-id="5d106-282">The **\_\_declspec(thread)** technique does not work with dynamically loaded DLLs.</span></span> <span data-ttu-id="5d106-283">При использовании динамически загружаемых библиотек DLL необходимо использовать семейство функций TLSAlloc для реализации локального хранилища потока.</span><span class="sxs-lookup"><span data-stu-id="5d106-283">If you use dynamically loaded DLLs, you will need to use the TLSAlloc family of functions to implement thread local storage.</span></span>

## <a name="destroying-threads"></a><span data-ttu-id="5d106-284">Уничтожение потоков</span><span class="sxs-lookup"><span data-stu-id="5d106-284">Destroying Threads</span></span>

<span data-ttu-id="5d106-285">Единственным надежным способом уничтожения потока является то, что сам поток завершается, либо путем возвращения из основной функции потока, либо путем вызова потока [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) или [**\_ ендсреадекс**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span><span class="sxs-lookup"><span data-stu-id="5d106-285">The only safe way to destroy a thread is to have the thread itself exit, either by returning from the main thread function or by having the thread call [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) or [**\_endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span></span> <span data-ttu-id="5d106-286">Если поток создается с помощью [**\_ бегинсреадекс**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), он должен использовать **\_ ендсреадекс** или возвращаться из основной функции потока, поскольку использование **ExitThread** не приведет к неправильному освобождению ресурсов CRT.</span><span class="sxs-lookup"><span data-stu-id="5d106-286">If a thread is created with [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), then it should use **\_endthreadex** or return from the main thread function, since using **ExitThread** won't properly free CRT resources.</span></span> <span data-ttu-id="5d106-287">Никогда не вызывайте функцию [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) , так как поток не будет корректно очищен.</span><span class="sxs-lookup"><span data-stu-id="5d106-287">Never call the [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) function, because the thread will not be properly cleaned up.</span></span> <span data-ttu-id="5d106-288">Потоки всегда должны зафиксировать самоубийства — они никогда не должны быть мурдеред.</span><span class="sxs-lookup"><span data-stu-id="5d106-288">Threads should always commit suicide—they should never be murdered.</span></span>

## <a name="openmp"></a><span data-ttu-id="5d106-289">OpenMP</span><span class="sxs-lookup"><span data-stu-id="5d106-289">OpenMP</span></span>

<span data-ttu-id="5d106-290">OpenMP — это расширение языка для добавления многопоточности в программу с помощью директив pragma для указания компилятора в параллелизации циклов.</span><span class="sxs-lookup"><span data-stu-id="5d106-290">OpenMP is a language extension for adding multithreading to your program by using pragmas to guide the compiler in parallelizing loops.</span></span> <span data-ttu-id="5d106-291">OpenMP поддерживается Visual C++ 2005 в Windows и Xbox 360. их можно использовать в сочетании с ручным управлением потоками.</span><span class="sxs-lookup"><span data-stu-id="5d106-291">OpenMP is supported by Visual C++ 2005 on Windows and Xbox 360 and can be used in conjunction with manual thread management.</span></span> <span data-ttu-id="5d106-292">OpenMP может быть удобным способом потоковой работы с частями кода, но вряд ли будет идеальным решением, особенно для игр.</span><span class="sxs-lookup"><span data-stu-id="5d106-292">OpenMP can be a convenient way to multithread parts of your code, but is unlikely to be the ideal solution, especially for games.</span></span> <span data-ttu-id="5d106-293">OpenMP может быть более подходящим для более длительных рабочих задач, таких как обработка изображений и другие ресурсы.</span><span class="sxs-lookup"><span data-stu-id="5d106-293">OpenMP may be more applicable to longer-running production tasks such as processing art and other resources.</span></span> <span data-ttu-id="5d106-294">Дополнительные сведения см. в документации по Visual C++ или перейдите на [веб-сайт](https://www.openmp.org/)OpenMP.</span><span class="sxs-lookup"><span data-stu-id="5d106-294">For more information, see the Visual C++ documentation or go to the OpenMP [website](https://www.openmp.org/).</span></span>

## <a name="profiling"></a><span data-ttu-id="5d106-295">Профилирование</span><span class="sxs-lookup"><span data-stu-id="5d106-295">Profiling</span></span>

<span data-ttu-id="5d106-296">Многопоточное профилирование имеет большое значение.</span><span class="sxs-lookup"><span data-stu-id="5d106-296">Multithreaded profiling is important.</span></span> <span data-ttu-id="5d106-297">Очень легко в итоге ожидать, когда потоки ожидают друг друга.</span><span class="sxs-lookup"><span data-stu-id="5d106-297">It is easy to end up with long stalls where threads are waiting on each other.</span></span> <span data-ttu-id="5d106-298">Такие ожидания трудно найти и диагностировать.</span><span class="sxs-lookup"><span data-stu-id="5d106-298">These stalls can be difficult to find and diagnose.</span></span> <span data-ttu-id="5d106-299">Чтобы определить их, рассмотрите возможность добавления инструментирования в вызовы синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5d106-299">To help identify them, consider adding instrumentation to your synchronization calls.</span></span> <span data-ttu-id="5d106-300">Профилировщик с выборкой может также помочь определить эти проблемы, поскольку он может записывать сведения о времени, не внося существенного изменения.</span><span class="sxs-lookup"><span data-stu-id="5d106-300">A sampling profiler can also help identify these problems because it can record timing information without substantially altering it.</span></span>

## <a name="timing"></a><span data-ttu-id="5d106-301">Временные свойства</span><span class="sxs-lookup"><span data-stu-id="5d106-301">Timing</span></span>

<span data-ttu-id="5d106-302">Инструкция RDTSC является одним из способов получения точных сведений о времени в Windows.</span><span class="sxs-lookup"><span data-stu-id="5d106-302">The rdtsc instruction is one way to get accurate timing information on Windows.</span></span> <span data-ttu-id="5d106-303">К сожалению, у RDTSC есть несколько проблем, которые делают его неудовлетворительным выбором для названия доставки.</span><span class="sxs-lookup"><span data-stu-id="5d106-303">Unfortunately, rdtsc has multiple problems that make it a poor choice for your shipping title.</span></span> <span data-ttu-id="5d106-304">Счетчики RDTSC не обязательно синхронизируются между процессорами, поэтому при перемещении потока между аппаратными потоками вы можете получить большие положительные или отрицательные различия.</span><span class="sxs-lookup"><span data-stu-id="5d106-304">The rdtsc counters are not necessarily synchronized between CPUs, so when your thread moves between hardware threads you may get large positive or negative differences.</span></span> <span data-ttu-id="5d106-305">В зависимости от параметров управления питанием частота, с которой увеличивается значение счетчика RDTSC, может также меняться во время выполнения игры.</span><span class="sxs-lookup"><span data-stu-id="5d106-305">Depending on power management settings, the frequency at which the rdtsc counter increments may also change as your game runs.</span></span> <span data-ttu-id="5d106-306">Во избежание этих трудностей следует предпочесть [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) и [**куериперформанцефрекуенци**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) для высокой точности времени в игре, используемой для доставки.</span><span class="sxs-lookup"><span data-stu-id="5d106-306">To avoid these difficulties, you should prefer [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) and [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) for high-precision timing in your shipping game.</span></span> <span data-ttu-id="5d106-307">Дополнительные сведения о времени см. в разделе [время игры и многоядерные процессоры](./game-timing-and-multicore-processors.md).</span><span class="sxs-lookup"><span data-stu-id="5d106-307">For more information about timing, see [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md).</span></span>

## <a name="debugging"></a><span data-ttu-id="5d106-308">Отладка</span><span class="sxs-lookup"><span data-stu-id="5d106-308">Debugging</span></span>

<span data-ttu-id="5d106-309">Visual Studio полностью поддерживает многопоточное отладку для Windows и Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="5d106-309">Visual Studio fully supports multithreaded debugging for Windows and Xbox 360.</span></span> <span data-ttu-id="5d106-310">Окно потоков Visual Studio позволяет переключаться между потоками, чтобы видеть различные стеки вызовов и локальные переменные.</span><span class="sxs-lookup"><span data-stu-id="5d106-310">The Visual Studio threads window lets you switch between threads in order to see the different call stacks and local variables.</span></span> <span data-ttu-id="5d106-311">Окно потоки также позволяет заморозить и разморозить определенные потоки.</span><span class="sxs-lookup"><span data-stu-id="5d106-311">The threads window also lets you freeze and thaw particular threads.</span></span>

<span data-ttu-id="5d106-312">На Xbox 360 можно использовать мета-переменную **\@ хвсреад** в окне контрольных значений для отображения аппаратного потока, в котором выполняется текущий выбранный программный поток.</span><span class="sxs-lookup"><span data-stu-id="5d106-312">On Xbox 360, you can use the **\@hwthread** meta-variable in the watch window to show the hardware thread on which the currently selected software thread is running.</span></span>

<span data-ttu-id="5d106-313">Окно потоки проще использовать, если вы назначите имена потоков осмысленно.</span><span class="sxs-lookup"><span data-stu-id="5d106-313">The threads window is easier to use if you name your threads meaningfully.</span></span> <span data-ttu-id="5d106-314">Visual Studio и другие отладчики Майкрософт позволяют присвоить имена потокам.</span><span class="sxs-lookup"><span data-stu-id="5d106-314">Visual Studio and other Microsoft debuggers allow you to name your threads.</span></span> <span data-ttu-id="5d106-315">Реализуйте следующую функцию **сетсреаднаме** и вызывайте ее из каждого потока при запуске.</span><span class="sxs-lookup"><span data-stu-id="5d106-315">Implement the following **SetThreadName** function and call it from each thread as it starts up.</span></span>


```C++
typedef struct tagTHREADNAME_INFO
{
    DWORD dwType;     // must be 0x1000
    LPCSTR szName;    // pointer to name (in user address space)
    DWORD dwThreadID; // thread ID (-1 = caller thread)
    DWORD dwFlags;    // reserved for future use, must be zero
} THREADNAME_INFO;

void SetThreadName( DWORD dwThreadID, LPCSTR szThreadName )
{
    THREADNAME_INFO info;
    info.dwType = 0x1000;
    info.szName = szThreadName;
    info.dwThreadID = dwThreadID;
    info.dwFlags = 0;

    __try
    {
        RaiseException( 0x406D1388, 0,
                    sizeof(info) / sizeof(DWORD),
            (DWORD*)&info );
    }
    __except( EXCEPTION_CONTINUE_EXECUTION ) {
    }
}

// Example usage:
SetThreadName(-1, "Main thread");
```



<span data-ttu-id="5d106-316">Отладчик ядра (KD) и WinDBG также поддерживают многопоточность отладки.</span><span class="sxs-lookup"><span data-stu-id="5d106-316">The kernel debugger (KD) and WinDBG also support multithreaded debugging.</span></span>

## <a name="testing"></a><span data-ttu-id="5d106-317">Тестирование</span><span class="sxs-lookup"><span data-stu-id="5d106-317">Testing</span></span>

<span data-ttu-id="5d106-318">Многопоточное программирование может быть непростой задачей, а некоторые многопоточные ошибки отображаются лишь редко, что затрудняет их поиск и исправление.</span><span class="sxs-lookup"><span data-stu-id="5d106-318">Multithreaded programming can be tricky, and some multithreaded bugs show up only rarely, making them difficult to find and fix.</span></span> <span data-ttu-id="5d106-319">Одним из лучших способов их очистки является тестирование на широком спектре компьютеров, особенно с четырьмя или более процессорами.</span><span class="sxs-lookup"><span data-stu-id="5d106-319">One of the best ways to flush them out is to test on a wide range of computers, particularly those with four or more processors.</span></span> <span data-ttu-id="5d106-320">Многопоточный код, который прекрасно работает на однопотоковых компьютерах, может мгновенно завершиться сбоем на компьютере с четырьмя процессорами.</span><span class="sxs-lookup"><span data-stu-id="5d106-320">Multithreaded code that works perfectly on a single-threaded computer may fail instantly on a four-processor computer.</span></span> <span data-ttu-id="5d106-321">Характеристики производительности и времени ЦП процессоров AMD и Intel могут значительно различаться, поэтому обязательно протестируйте многопроцессорные компьютеры на основе ЦП обоих поставщиков.</span><span class="sxs-lookup"><span data-stu-id="5d106-321">The performance and timing characteristics of AMD and Intel CPUs can vary substantially, so be sure to test on multiprocessor computers based on CPUs from both vendors.</span></span>

## <a name="windows-vista-and-windows-7-improvements"></a><span data-ttu-id="5d106-322">Улучшения в Windows Vista и Windows 7</span><span class="sxs-lookup"><span data-stu-id="5d106-322">Windows Vista and Windows 7 Improvements</span></span>

<span data-ttu-id="5d106-323">Для игр, предназначенных для более новых версий Windows, существует ряд интерфейсов API, которые могут упростить создание масштабируемых многопоточных приложений.</span><span class="sxs-lookup"><span data-stu-id="5d106-323">For games targeting the newer versions of Windows, there are a number of APIs that can simplify the creation of scalable multithreaded applications.</span></span> <span data-ttu-id="5d106-324">Это особенно справедливо при использовании нового API ThreadPool и некоторых дополнительных примитивов синкрхонзиатион (переменных условия, упрощенной блокировки чтения-записи и однократной инициализации).</span><span class="sxs-lookup"><span data-stu-id="5d106-324">This is particularly true with the new ThreadPool API and some additional syncrhonziation primitives (condition variables, the slim read/writer lock, and one-time initialization).</span></span> <span data-ttu-id="5d106-325">Обзор этих технологий можно найти в следующих статьях MSDN Magazine:</span><span class="sxs-lookup"><span data-stu-id="5d106-325">You can find an overview of these technologies in the following MSDN Magazine articles:</span></span>

-   [<span data-ttu-id="5d106-326">Повышение масштабируемости с помощью новых API пула потоков</span><span class="sxs-lookup"><span data-stu-id="5d106-326">Improve Scalability With New Thread Pool APIs</span></span>](/archive/msdn-magazine/2007/october/pooled-threads-improve-scalability-with-new-thread-pool-apis)
-   [<span data-ttu-id="5d106-327">Новые примитивы синхронизации в Windows Vista</span><span class="sxs-lookup"><span data-stu-id="5d106-327">Synchronization Primitives New To Windows Vista</span></span>](/archive/msdn-magazine/2007/june/concurrency-synchronization-primitives-new-to-windows-vista)

<span data-ttu-id="5d106-328">Приложения, использующие [функции Direct3D 11](../direct3d11/direct3d-11-features.md) в этих операционных системах, также могут воспользоваться преимуществами новой конструкции для параллельного создания объектов и списков отложенных контекстных команд для повышения масштабируемости при многопоточной отрисовке.</span><span class="sxs-lookup"><span data-stu-id="5d106-328">Applications using [Direct3D 11 Features](../direct3d11/direct3d-11-features.md) on these operating systems can also take advantage of the new design for concurrent object creation and deferred context command lists for better scalability for multithreaded rendering.</span></span>

## <a name="summary"></a><span data-ttu-id="5d106-329">Сводка</span><span class="sxs-lookup"><span data-stu-id="5d106-329">Summary</span></span>

<span data-ttu-id="5d106-330">При тщательном проектировании, позволяющем избежать взаимодействий между потоками, можно получить значительный выигрыш в производительности от многопоточного программирования, не требуя чрезмерной сложности кода.</span><span class="sxs-lookup"><span data-stu-id="5d106-330">With careful design that minimizes the interactions between threads, you can get substantial performance gains from multithreaded programming without adding excessive complexity to your code.</span></span> <span data-ttu-id="5d106-331">Это позволит вашему программному коду переключить следующую партию усовершенствований процессора и предоставить вам более привлекательные игровые возможности.</span><span class="sxs-lookup"><span data-stu-id="5d106-331">This will let your game code ride the next wave of processor improvements and deliver ever more compelling gaming experiences.</span></span>

## <a name="references"></a><span data-ttu-id="5d106-332">Ссылки</span><span class="sxs-lookup"><span data-stu-id="5d106-332">References</span></span>

-   <span data-ttu-id="5d106-333">Джим Беверидже & Роберт Веинер, *многопоточное приложение в Win32*, Addison-Wesley, 1997</span><span class="sxs-lookup"><span data-stu-id="5d106-333">Jim Beveridge & Robert Weiner, *Multithreading Applications in Win32*, Addison-Wesley, 1997</span></span>
-   <span data-ttu-id="5d106-334">Чак Валбаурн, [время игры и многоядерные процессоры](./game-timing-and-multicore-processors.md), корпорация майкрософт, 2005</span><span class="sxs-lookup"><span data-stu-id="5d106-334">Chuck Walbourn, [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span></span>
-   <span data-ttu-id="5d106-335">Библиотека MSDN: [ **жетлогикалпроцессоринформатион**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span><span class="sxs-lookup"><span data-stu-id="5d106-335">MSDN Library: [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span></span>
-   [<span data-ttu-id="5d106-336">OpenMP</span><span class="sxs-lookup"><span data-stu-id="5d106-336">OpenMP</span></span>](https://www.openmp.org/)

 

 