---
title: 64-разрядное программирование для разработчиков игр
description: В этой статье рассматриваются проблемы совместимости и переноса и помогает разработчикам упростить переход на 64-разрядные платформы.
ms.assetid: 23a7ed41-6637-0607-327e-983b622e9104
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b12e57ea1b3cc3272ca40465df31a04244d99e68
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104070325"
---
# <a name="64-bit-programming-for-game-developers"></a><span data-ttu-id="6d88f-103">64-разрядное программирование для разработчиков игр</span><span class="sxs-lookup"><span data-stu-id="6d88f-103">64-bit programming for Game Developers</span></span>

<span data-ttu-id="6d88f-104">Производители процессоров используют для настольных компьютеров только 64-разрядные процессоры, а даже наборы микросхем большинства ноутбуков поддерживают технологию x64.</span><span class="sxs-lookup"><span data-stu-id="6d88f-104">Processor manufacturers are exclusively shipping 64-bit processors in their desktop computers, and even the chipsets of most laptop computers support x64 technology.</span></span> <span data-ttu-id="6d88f-105">Очень важно, чтобы разработчики игр использовали преимущества усовершенствований, предоставляемых 64-разрядными процессорами, с новыми приложениями и обеспечить правильную работу их приложений на новых процессорах и в 64-разрядных выпусках Windows Vista и Windows 7.</span><span class="sxs-lookup"><span data-stu-id="6d88f-105">It is important for game developers to take advantage of the improvements that 64-bit processors offer with their new applications and to ensure that their earlier applications run correctly on the new processors and the 64-bit editions of Windows Vista and Windows 7.</span></span> <span data-ttu-id="6d88f-106">В этой статье рассматриваются проблемы совместимости и переноса и помогает разработчикам упростить переход на 64-разрядные платформы.</span><span class="sxs-lookup"><span data-stu-id="6d88f-106">This article addresses compatibility and porting issues and helps developers ease their transition to 64-bit platforms.</span></span>

<span data-ttu-id="6d88f-107">В настоящее время корпорация Майкрософт имеет следующие 64-разрядные операционные системы:</span><span class="sxs-lookup"><span data-stu-id="6d88f-107">Microsoft currently has the following 64-bit operating systems:</span></span>

-   <span data-ttu-id="6d88f-108">Windows Server 2003 с пакетом обновления 1</span><span class="sxs-lookup"><span data-stu-id="6d88f-108">Windows Server 2003 Service Pack 1</span></span>
-   <span data-ttu-id="6d88f-109">Windows XP Professional x64 Edition (доступно для изготовителей оборудования и для разработчиков с помощью MSDN)</span><span class="sxs-lookup"><span data-stu-id="6d88f-109">Windows XP Professional x64 Edition (available to OEMs and to developers through MSDN)</span></span>
-   <span data-ttu-id="6d88f-110">Windows Vista</span><span class="sxs-lookup"><span data-stu-id="6d88f-110">Windows Vista</span></span>
-   <span data-ttu-id="6d88f-111">Windows Server 2008</span><span class="sxs-lookup"><span data-stu-id="6d88f-111">Windows Server 2008</span></span>
-   <span data-ttu-id="6d88f-112">Windows 7</span><span class="sxs-lookup"><span data-stu-id="6d88f-112">Windows 7</span></span>
-   <span data-ttu-id="6d88f-113">Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="6d88f-113">Windows Server 2008 R2</span></span>

> [!Note]  
> <span data-ttu-id="6d88f-114">Windows Server 2008 R2 доступна только в виде 64-разрядного выпуска.</span><span class="sxs-lookup"><span data-stu-id="6d88f-114">Windows Server 2008 R2 is only available as a 64-bit edition.</span></span>

 

-   [<span data-ttu-id="6d88f-115">Различия в адресации памяти</span><span class="sxs-lookup"><span data-stu-id="6d88f-115">Differences in Addressable Memory</span></span>](#differences-in-addressable-memory)
-   [<span data-ttu-id="6d88f-116">Указание больших адресов при создании</span><span class="sxs-lookup"><span data-stu-id="6d88f-116">Specifying Large-Address-Aware When Building</span></span>](#specifying-large-address-aware-when-building)
-   [<span data-ttu-id="6d88f-117">Совместимость 32-разрядных приложений на 64-разрядных платформах</span><span class="sxs-lookup"><span data-stu-id="6d88f-117">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>](#compatibility-of-32-bit-applications-on-64-bit-platforms)
    -   [<span data-ttu-id="6d88f-118">Потенциальные ошибки совместимости</span><span class="sxs-lookup"><span data-stu-id="6d88f-118">Potential Compatibility Pitfalls</span></span>](#potential-compatibility-pitfalls)
-   [<span data-ttu-id="6d88f-119">Перенос приложений на 64-разрядные платформы</span><span class="sxs-lookup"><span data-stu-id="6d88f-119">Porting Applications to 64-Bit Platforms</span></span>](#porting-applications-to-64-bit-platforms)
-   [<span data-ttu-id="6d88f-120">Профилирование и оптимизация перенесенных приложений</span><span class="sxs-lookup"><span data-stu-id="6d88f-120">Profiling and Optimization of Ported Applications</span></span>](#profiling-and-optimization-of-ported-applications)
-   [<span data-ttu-id="6d88f-121">Управляемый код в 64-разрядной операционной системе</span><span class="sxs-lookup"><span data-stu-id="6d88f-121">Managed Code on a 64-bit Operating System</span></span>](#managed-code-on-a-64-bit-operating-system)
-   [<span data-ttu-id="6d88f-122">Влияние на производительность при выполнении 64-разрядной операционной системы</span><span class="sxs-lookup"><span data-stu-id="6d88f-122">Performance Implications of Running a 64-bit Operating System</span></span>](#performance-implications-of-running-a-64-bit-operating-system)
-   [<span data-ttu-id="6d88f-123">Сводка</span><span class="sxs-lookup"><span data-stu-id="6d88f-123">Summary</span></span>](#summary)

## <a name="differences-in-addressable-memory"></a><span data-ttu-id="6d88f-124">Различия в адресации памяти</span><span class="sxs-lookup"><span data-stu-id="6d88f-124">Differences in Addressable Memory</span></span>

<span data-ttu-id="6d88f-125">Первое, что большинство разработчиков заметит, это то, что 64-разрядные процессоры обеспечивают огромную LEAP в объеме физической и виртуальной памяти, которую можно решить.</span><span class="sxs-lookup"><span data-stu-id="6d88f-125">The first thing most developers notice is that 64-bit processors provide a huge leap in the amount of physical and virtual memory that can be addressed.</span></span>

-   <span data-ttu-id="6d88f-126">32-разрядные приложения на 32-разрядных платформах могут иметь до 2 ГБ.</span><span class="sxs-lookup"><span data-stu-id="6d88f-126">32-bit applications on 32-bit platforms can address up to 2 GB.</span></span>
-   <span data-ttu-id="6d88f-127">32-разрядные приложения, созданные с помощью флага компоновщика/LARGEADDRESSAWARE: YES в 32-bit Windows XP или Windows Server 2003 с параметром специальной загрузки/3gb, могут иметь до 3 ГБ.</span><span class="sxs-lookup"><span data-stu-id="6d88f-127">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on 32-bit Windows XP or Windows Server 2003 with the special /3gb boot option can address up to 3 GB.</span></span> <span data-ttu-id="6d88f-128">Это ограничивает ядро только 1 ГБ, что может привести к сбою некоторых драйверов и (или) служб.</span><span class="sxs-lookup"><span data-stu-id="6d88f-128">This constrains the kernel to only 1 GB which may cause some drivers and/or services to fail.</span></span>
-   <span data-ttu-id="6d88f-129">32-разрядные приложения, созданные с помощью флага компоновщика/LARGEADDRESSAWARE: YES в 32-разрядных выпусках Windows Vista, Windows Server 2008 и Windows 7, могут обращаться к памяти вплоть до числа, указанного в элементе данных конфигурации загрузки (BCD) Инкреасеусерва.</span><span class="sxs-lookup"><span data-stu-id="6d88f-129">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on the 32-bit editions of Windows Vista, Windows Server 2008, and Windows 7 can address memory up to the number specified by the boot configuration data (BCD) element IncreaseUserVa.</span></span> <span data-ttu-id="6d88f-130">Инкреасеусерва может иметь значение от 2048 (по умолчанию) до 3072 (которое соответствует объему памяти, настроенному с помощью параметра/3gb Boot в Windows XP).</span><span class="sxs-lookup"><span data-stu-id="6d88f-130">IncreaseUserVa can have a value ranging from 2048, the default, to 3072 (which matches the amount of memory configured by the /3gb boot option on Windows XP).</span></span> <span data-ttu-id="6d88f-131">Оставшаяся часть 4 ГБ выделяется ядру и может привести к сбою конфигурации драйвера и службы.</span><span class="sxs-lookup"><span data-stu-id="6d88f-131">The remainder of 4 GB is allocated to the kernel and can result in failing driver and service configurations.</span></span>

    <span data-ttu-id="6d88f-132">Дополнительные сведения о BCD см. в разделе [данные конфигурации загрузки](https://msdn.microsoft.com/library/aa362692.aspx) на сайте MSDN.</span><span class="sxs-lookup"><span data-stu-id="6d88f-132">For more information about BCD, see [Boot Configuration Data](https://msdn.microsoft.com/library/aa362692.aspx) on MSDN.</span></span>

-   <span data-ttu-id="6d88f-133">32-разрядные приложения на 64-разрядных платформах могут иметь до 2 ГБ или до 4 ГБ с флагом компоновщика/LARGEADDRESSAWARE: YES.</span><span class="sxs-lookup"><span data-stu-id="6d88f-133">32-bit applications on 64-bit platforms can address up to 2 GB, or up to 4 GB with the /LARGEADDRESSAWARE:YES linker flag.</span></span>
-   <span data-ttu-id="6d88f-134">64-разрядные приложения используют 43 бит для адресации, что обеспечивает 8 ТБ виртуального адреса для приложений и 8 ТБ, зарезервированные для ядра.</span><span class="sxs-lookup"><span data-stu-id="6d88f-134">64-bit applications use 43 bits for addressing, which provides 8 TB of virtual address for applications and 8 TB reserved for the kernel.</span></span>

<span data-ttu-id="6d88f-135">Помимо всего памяти, в 64-разрядных приложениях, использующих операции ввода-вывода с отображением в памяти, значительно возрастает увеличение виртуального адресного пространства.</span><span class="sxs-lookup"><span data-stu-id="6d88f-135">Beyond just memory, 64-bit applications that use memory-mapped file I/O benefit greatly from the increased virtual address space.</span></span> <span data-ttu-id="6d88f-136">64-разрядная архитектура также улучшает производительность операций с плавающей запятой и ускоряет передачу параметров.</span><span class="sxs-lookup"><span data-stu-id="6d88f-136">The 64-bit architecture also has improved floating-point performance and faster passing of parameters.</span></span> <span data-ttu-id="6d88f-137">64-разрядные процессоры имеют удвоенное количество регистров, как для типов данных общего назначения и расширения потоковой передачи SIMD (SSE), так и для поддержки наборов инструкций SSE и SSE2. Многие 64-разрядные процессоры даже поддерживают наборы инструкций SSE3.</span><span class="sxs-lookup"><span data-stu-id="6d88f-137">Sixty-four-bit processors have double the number of registers, of both general purpose and streaming SIMD extensions (SSE) types, as well as support for SSE and SSE2 instruction sets; many 64-bit processors even support SSE3 instruction sets.</span></span>

## <a name="specifying-large-address-aware-when-building"></a><span data-ttu-id="6d88f-138">Указание больших адресов при создании</span><span class="sxs-lookup"><span data-stu-id="6d88f-138">Specifying Large-Address-Aware When Building</span></span>

<span data-ttu-id="6d88f-139">При создании 32-разрядных приложений рекомендуется указывать большое количество адресов, используя флаг компоновщика/LARGEADDRESSAWARE, даже если приложение не предназначено для 64-разрядной платформы, из-за преимуществ, которые бесплатно предоставляются бесплатно.</span><span class="sxs-lookup"><span data-stu-id="6d88f-139">It is a good practice to specify large-address-aware when building 32-bit applications, by using the linker flag /LARGEADDRESSAWARE, even if the application is not intended for a 64-bit platform, because of the advantages that are gained at no cost.</span></span> <span data-ttu-id="6d88f-140">Как упоминалось ранее, включение этого флага для сборки позволяет 32-разрядной программе получить доступ к большему объему памяти с помощью специальных параметров загрузки в 32-разрядной ОС или в 64-разрядной ОС.</span><span class="sxs-lookup"><span data-stu-id="6d88f-140">As explained earlier, enabling this flag for a build allows a 32-bit program to access more memory with special boot options on a 32-bit OS or on a 64-bit OS.</span></span> <span data-ttu-id="6d88f-141">Тем не менее, разработчики должны быть внимательны, чтобы предположения о указателе не были сделаны, например при условии, что в 32-разрядном указателе никогда не задана старшая разрядность.</span><span class="sxs-lookup"><span data-stu-id="6d88f-141">However, developers must be careful that pointer assumptions are not made, such as assuming that the high-bit is never set in a 32-bit pointer.</span></span> <span data-ttu-id="6d88f-142">Как правило, рекомендуется включать флаг/LARGEADDRESSAWARE.</span><span class="sxs-lookup"><span data-stu-id="6d88f-142">In general, enabling the /LARGEADDRESSAWARE flag is a good practice.</span></span>

<span data-ttu-id="6d88f-143">32-битовые приложения, поддерживающие большие адреса, могут определить во время выполнения, сколько всего виртуального адресного пространства доступно для них с текущей конфигурацией ОС путем вызова [**глобалмемористатусекс**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).</span><span class="sxs-lookup"><span data-stu-id="6d88f-143">Thirty-two-bit applications that are large-address-aware can determine at run time how much total virtual address space is available to them with the current OS configuration by calling [**GlobalMemoryStatusEx**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).</span></span> <span data-ttu-id="6d88f-144">Результат Уллтоталвиртуал будет в диапазоне от 2147352576 байт (2 ГБ) до 4294836224 байт (4 ГБ).</span><span class="sxs-lookup"><span data-stu-id="6d88f-144">The ullTotalVirtual result will range from 2147352576 bytes (2 GB) to 4294836224 bytes (4 GB).</span></span> <span data-ttu-id="6d88f-145">Значения, превышающие 3221094400 (3 ГБ), можно получить только в 64-разрядных выпусках Windows.</span><span class="sxs-lookup"><span data-stu-id="6d88f-145">Values that are larger than 3221094400 (3 GB) can only be obtained on 64-bit editions of Windows.</span></span> <span data-ttu-id="6d88f-146">Например, если Инкреасеусерва имеет значение 2560, результатом будет Уллтоталвиртуал со значением 2684223488 байт.</span><span class="sxs-lookup"><span data-stu-id="6d88f-146">For example, if IncreaseUserVa has a value of 2560, the result is ullTotalVirtual with a value of 2684223488 bytes.</span></span>

## <a name="compatibility-of-32-bit-applications-on-64-bit-platforms"></a><span data-ttu-id="6d88f-147">Совместимость 32-разрядных приложений на 64-разрядных платформах</span><span class="sxs-lookup"><span data-stu-id="6d88f-147">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>

<span data-ttu-id="6d88f-148">64-разрядные операционные системы Windows являются двоичными совместимыми с архитектурой IA32, а большинство интерфейсов API, используемых в 32-разрядных приложениях, доступны в Windows 32-bit на Windows 64-bit Emulator, WOW64.</span><span class="sxs-lookup"><span data-stu-id="6d88f-148">Sixty-four-bit Windows operating systems are binary compatible with the IA32 architecture, and the majority of APIs that 32-bit applications use are available through the Windows 32-bit on Windows 64-bit Emulator, WOW64.</span></span> <span data-ttu-id="6d88f-149">WOW64 гарантирует, что эти API будут работать должным образом.</span><span class="sxs-lookup"><span data-stu-id="6d88f-149">WOW64 helps ensure that these APIs will work as intended.</span></span>

<span data-ttu-id="6d88f-150">WOW64 имеет слой выполнения, который обрабатывает маршалинг 32-разрядных данных.</span><span class="sxs-lookup"><span data-stu-id="6d88f-150">WOW64 has an execution layer that handles the marshalling of 32-bit data.</span></span> <span data-ttu-id="6d88f-151">WOW64 перенаправляет запросы DLL-файлов, перенаправляет некоторые ветви реестра для 32-разрядных приложений и отражает некоторые ветви реестра для 32-и 64-разрядных приложений.</span><span class="sxs-lookup"><span data-stu-id="6d88f-151">WOW64 redirects DLL file requests, redirects some registry branches for 32-bit applications, and reflects some registry branches for 32- and 64-bit applications.</span></span>

<span data-ttu-id="6d88f-152">Дополнительные сведения о WOW64 можно найти в статье [сведения о реализации WOW64](/windows/desktop/WinProg64/wow64-implementation-details) на сайте MSDN.</span><span class="sxs-lookup"><span data-stu-id="6d88f-152">More information on WOW64 can be found at [WOW64 Implementation Details](/windows/desktop/WinProg64/wow64-implementation-details) on MSDN.</span></span> <span data-ttu-id="6d88f-153">Рекомендации по созданию приложений, работающих на платформе WOW64, см. в разделе рекомендации [по использованию WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) в центре разработчиков оборудования для Windows.</span><span class="sxs-lookup"><span data-stu-id="6d88f-153">For best practices for building applications that run on WOW64, see [Best Practices for WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) on Windows Hardware Developer Central.</span></span>

### <a name="potential-compatibility-pitfalls"></a><span data-ttu-id="6d88f-154">Потенциальные ошибки совместимости</span><span class="sxs-lookup"><span data-stu-id="6d88f-154">Potential Compatibility Pitfalls</span></span>

<span data-ttu-id="6d88f-155">Большинство приложений, разработанных для 32-разрядной платформы, будут работать без проблем на 64-разрядной платформе.</span><span class="sxs-lookup"><span data-stu-id="6d88f-155">Most applications developed for a 32-bit platform will run without problems on a 64-bit platform.</span></span> <span data-ttu-id="6d88f-156">Некоторые приложения могут столкнуться с проблемами, которые могут включать в себя следующее:</span><span class="sxs-lookup"><span data-stu-id="6d88f-156">A few applications could have issues, which might include the following:</span></span>

-   <span data-ttu-id="6d88f-157">Все драйверы для 64-разрядных выпусков операционных систем Windows должны быть 64-разрядными версиями.</span><span class="sxs-lookup"><span data-stu-id="6d88f-157">All drivers for by 64-bit editions of Windows operating systems must be 64-bit versions.</span></span> <span data-ttu-id="6d88f-158">Необходимость в новых 64-разрядных драйверах влияет на схемы защиты от копирования, основанные на старых драйверах.</span><span class="sxs-lookup"><span data-stu-id="6d88f-158">Requiring new 64-bit drivers has implications for copy-protection schemes that rely on old drivers.</span></span> <span data-ttu-id="6d88f-159">Обратите внимание, что для загрузки в 64-разрядных выпусках Windows драйверы режима ядра должны быть подписаны с помощью Authenticode.</span><span class="sxs-lookup"><span data-stu-id="6d88f-159">Note that kernel-mode drivers must be Authenticode-signed to be loaded by 64-bit editions of Windows.</span></span>
-   <span data-ttu-id="6d88f-160">64-разрядные процессы не могут загружать 32-разрядные библиотеки DLL, а 32-разрядные процессы не могут 64 загружать динамические DLL-библиотеки.</span><span class="sxs-lookup"><span data-stu-id="6d88f-160">64-bit processes cannot load 32-bit DLLs, and 32-bit processes cannot load 64-bit DLLs.</span></span> <span data-ttu-id="6d88f-161">Прежде чем продолжить разработку, разработчики должны убедиться, что доступны 64-разрядные версии сторонних библиотек DLL.</span><span class="sxs-lookup"><span data-stu-id="6d88f-161">Developers must ensure that 64-bit versions of third-party DLLs are available before proceeding with development.</span></span> <span data-ttu-id="6d88f-162">Если необходимо использовать 32-разрядную библиотеку DLL в 64-разрядном процессе, можно использовать межпроцессное взаимодействие Windows (IPC).</span><span class="sxs-lookup"><span data-stu-id="6d88f-162">If you must use a 32-bit DLL in a 64-bit process, then Windows inter-process communication (IPC) can be used.</span></span> <span data-ttu-id="6d88f-163">COM-компоненты также могут использовать необработанные серверы и выполнять маршалинг для взаимодействия между границами, но это может привести к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="6d88f-163">COM components can also make use of out-of-process servers and marshalling to communicate between boundaries, but doing so may introduce a performance penalty.</span></span>
-   <span data-ttu-id="6d88f-164">Многие процессоры x64 также являются многоядерными процессорами, и разработчики должны протестировать, как это влияет на устаревшие приложения.</span><span class="sxs-lookup"><span data-stu-id="6d88f-164">Many x64 processors are also multi-core processors, and developers need to test to how this affects their legacy applications.</span></span> <span data-ttu-id="6d88f-165">Дополнительные сведения о многоядерных процессорах и последствиях для игровых приложений можно найти в области " [время игры" и в многоядерных процессорах](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span><span class="sxs-lookup"><span data-stu-id="6d88f-165">More information on multi-core processors and the implications for gaming applications can be found in [Game Timing and Multicore Processors](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span></span>
-   <span data-ttu-id="6d88f-166">Приложения также должны вызывать [**шжетфолдерпас**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) для обнаружения путей к файлам, так как некоторые имена папок изменились в некоторых случаях.</span><span class="sxs-lookup"><span data-stu-id="6d88f-166">Applications should also call [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) to discover file paths, as some folder names have changed in certain cases.</span></span> <span data-ttu-id="6d88f-167">Например, \_ программные файлы CSid \_ возвращают «C: \\ Program Files (x86)» для 32-разрядного приложения, работающего на 64-разрядной платформе вместо «C: \\ Program Files».</span><span class="sxs-lookup"><span data-stu-id="6d88f-167">For example, CSIDL\_PROGRAM\_FILES would return "C:\\Program Files(x86)" for a 32-bit application running on a 64-bit platform instead of "C:\\Program Files".</span></span> <span data-ttu-id="6d88f-168">Разработчики должны быть учитывать, как работают возможности перенаправления и отражения эмулятора WOW64.</span><span class="sxs-lookup"><span data-stu-id="6d88f-168">Developers must be mindful of how the WOW64 emulator's redirection and reflection capabilities work.</span></span>

<span data-ttu-id="6d88f-169">Кроме того, разработчики должны быть осторожными с 16-разрядными программами, которые по-прежнему могут использоваться.</span><span class="sxs-lookup"><span data-stu-id="6d88f-169">In addition, developers need to be wary of 16-bit programs that they might still be using.</span></span> <span data-ttu-id="6d88f-170">Подсистема WOW64 не может работать с 16-разрядными приложениями; Сюда входят старые установщики и все программы MS-DOS.</span><span class="sxs-lookup"><span data-stu-id="6d88f-170">WOW64 cannot handle 16-bit applications; this includes old installers and all MS-DOS programs.</span></span>

> [!Note]  
> <span data-ttu-id="6d88f-171">Наиболее распространенными проблемами совместимости являются установщики, выполняющие 16-разрядный код и не имеющие 64-разрядных драйверов для схем защиты копирования.</span><span class="sxs-lookup"><span data-stu-id="6d88f-171">The most common compatibility issues are installers that execute 16-bit code and not having 64-bit drivers for copy protection schemes.</span></span>

 

<span data-ttu-id="6d88f-172">В следующем разделе обсуждаются вопросы, связанные с переносом кода в 64-разрядный машинный код для разработчиков, желающих обеспечить работу своих устаревших программ на 64-разрядных платформах.</span><span class="sxs-lookup"><span data-stu-id="6d88f-172">The next section discusses issues related to porting code to 64-bit native for developers that want to ensure their legacy programs work on 64-bit platforms.</span></span> <span data-ttu-id="6d88f-173">Он также предназначен для разработчиков, не знакомых с 64-разрядным программированием.</span><span class="sxs-lookup"><span data-stu-id="6d88f-173">It is also for developers who are unfamiliar with 64-bit programming.</span></span>

## <a name="porting-applications-to-64-bit-platforms"></a><span data-ttu-id="6d88f-174">Перенос приложений на 64-разрядные платформы</span><span class="sxs-lookup"><span data-stu-id="6d88f-174">Porting Applications to 64-Bit Platforms</span></span>

<span data-ttu-id="6d88f-175">Наличие правильных средств и библиотек поможет упростить переход с 32-разр на 64-разрядную разработку.</span><span class="sxs-lookup"><span data-stu-id="6d88f-175">Having the right tools and libraries will help to ease the transition from 32-bit to 64-bit development.</span></span> <span data-ttu-id="6d88f-176">Пакет SDK для DirectX 9 содержит библиотеки для поддержки проектов на базе x86 и x64.</span><span class="sxs-lookup"><span data-stu-id="6d88f-176">The DirectX 9 SDK has libraries to support both x86- and x64-based projects.</span></span> <span data-ttu-id="6d88f-177">Microsoft Visual Studio 2005 и Visual Studio 2008 поддерживают создание кода как для x86, так и для x64, и они поставляются с библиотеками, оптимизированными для создания кода x64.</span><span class="sxs-lookup"><span data-stu-id="6d88f-177">Microsoft Visual Studio 2005 and Visual Studio 2008 support code generation for both x86 and x64, and they comes with libraries optimized for generating x64 code.</span></span> <span data-ttu-id="6d88f-178">Тем не менее, он также понадобится разработчикам для распространения сред выполнения Visual C в своих приложениях.</span><span class="sxs-lookup"><span data-stu-id="6d88f-178">However, it will also be necessary for developers to distribute the Visual C runtimes with their applications.</span></span> <span data-ttu-id="6d88f-179">Обратите внимание, что выпуски Express Visual Studio 2005 и Visual Studio 2008 не включают компилятор x64, но все это выполняется в выпусках Standard, Professional и Team System.</span><span class="sxs-lookup"><span data-stu-id="6d88f-179">Note that the Express Editions of Visual Studio 2005 and Visual Studio 2008 do not include the x64 compiler, but that the Standard, Professional, and Team System editions all do.</span></span>

<span data-ttu-id="6d88f-180">Разработчики, предназначенные для 32-разрядных платформ, могут подготовиться к 64-разрядной разработке, чтобы упростить их переход на более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="6d88f-180">Developers who are targeting 32-bit platforms can prepare for 64-bit development to make their transition easier later on.</span></span> <span data-ttu-id="6d88f-181">При компиляции 32-разрядных проектов разработчики должны использовать флаг/Wp64, который приведет к созданию предупреждений о проблемах, влияющих на переносимость.</span><span class="sxs-lookup"><span data-stu-id="6d88f-181">When compiling 32-bit projects, developers should use the /Wp64 flag, which will cause the generation of warnings about issues that affect portability.</span></span> <span data-ttu-id="6d88f-182">Переключение на 64-разрядные средства и библиотеки, вероятно, повлечет за собой создание большого количества новых ошибок сборки. Поэтому рекомендуется переключить средства и библиотеки, не зависящие от разрядов, и устранить предупреждения перед переключением на 64-разрядную сборку.</span><span class="sxs-lookup"><span data-stu-id="6d88f-182">Switching to 64-bit tools and libraries will probably generate a lot of new build errors initially; so, it is advisable to switch bit-neutral tools and libraries and correct any warnings before switching to a 64-bit build.</span></span>

<span data-ttu-id="6d88f-183">Однако изменить средства, изменить библиотеки и использовать определенные флаги компилятора будет недостаточно.</span><span class="sxs-lookup"><span data-stu-id="6d88f-183">Changing tools, changing libraries, and using certain compiler flags will not be enough, though.</span></span> <span data-ttu-id="6d88f-184">Предположения в стандартах кодирования должны быть переоценены, чтобы гарантировать, что текущие стандарты кодирования не допускают проблем переносимости.</span><span class="sxs-lookup"><span data-stu-id="6d88f-184">Assumptions in coding standards must be reevaluated to ensure that current coding standards don't allow portability issues.</span></span> <span data-ttu-id="6d88f-185">Проблемы переносимости могут включать усечение указателя, размер и выравнивание типов данных, зависимость от 32-разрядных библиотек DLL, использование устаревших API, код сборки и старые двоичные файлы.</span><span class="sxs-lookup"><span data-stu-id="6d88f-185">Portability issues can include pointer truncation, size and alignment of data types, reliance on 32-bit DLLs, use of legacy APIs, assembly code, and old binary files.</span></span>

> [!Note]  
> <span data-ttu-id="6d88f-186">Visual C++ 2010 содержит заголовки stdint. h и cstdint C99, которые определяют стандартные типы переносимости Int32 \_ t, UInt32 \_ t, Int64 \_ t, UInt64 \_ t, IntPtr \_ t и UIntPtr \_ t.</span><span class="sxs-lookup"><span data-stu-id="6d88f-186">Visual C++ 2010 includes the stdint.h and cstdint C99 headers which define the standard portability types int32\_t, uint32\_t, int64\_t, uint64\_t, intptr\_t, and uintptr\_t.</span></span> <span data-ttu-id="6d88f-187">Их использование вместе с \_ типами данных Standard птрдифф t и Size \_ t может быть рекомендуемое для типов Windows портабилти, используемых ниже для повышения переносимости кода.</span><span class="sxs-lookup"><span data-stu-id="6d88f-187">Using these along with the standard ptrdiff\_t and size\_t data types may be preferrable to the Windows portabilty types used below for improving portability of code.</span></span>

 

<span data-ttu-id="6d88f-188">Ниже перечислены основные проблемы, связанные с переносом.</span><span class="sxs-lookup"><span data-stu-id="6d88f-188">Major porting issues include the following:</span></span>

<dl> <dt>

<span data-ttu-id="6d88f-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Усечение указателя**</span><span class="sxs-lookup"><span data-stu-id="6d88f-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Pointer Truncation**</span></span>
</dt> <dd>

<span data-ttu-id="6d88f-190">Указатели — это 64 бит в 64-разрядной ОС, поэтому приведение указателей к другим типам данных может привести к усечению, а арифметические операции с указателями могут привести к повреждению.</span><span class="sxs-lookup"><span data-stu-id="6d88f-190">Pointers are 64-bits on a 64-bit OS, so casting pointers to other data types can result in truncation, and pointer arithmetic can result in corruption.</span></span> <span data-ttu-id="6d88f-191">Использование флага/Wp64 обычно выдает предупреждение об этом типе проблемы, но при использовании типов с помощью полиморфизма (INT \_ ptr, DWORD \_ ptr, Size \_ T, uint \_ PTR и т. д.) при приведении типа указателей рекомендуется полностью избежать этой проблемы.</span><span class="sxs-lookup"><span data-stu-id="6d88f-191">Using the /Wp64 flag will usually provide a warning about this kind of issue, but using polymorphic types (INT\_PTR, DWORD\_PTR, SIZE\_T, UINT\_PTR, and so on) when casting pointer types is a good practice to help avoid this issue altogether.</span></span> <span data-ttu-id="6d88f-192">Поскольку указатели являются 64-разрядными на новых платформах, разработчики должны проверить порядок указателей и типы данных в классах и структурах, чтобы уменьшить или исключить заполнение.</span><span class="sxs-lookup"><span data-stu-id="6d88f-192">Since pointers are 64-bit on new platforms, developers should check the ordering of pointers, and the data types in classes and structures, to reduce or eliminate padding.</span></span>

</dd> <dt>

<span data-ttu-id="6d88f-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Типы данных и двоичные файлы**</span><span class="sxs-lookup"><span data-stu-id="6d88f-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Data Types and Binary Files**</span></span>
</dt> <dd>

<span data-ttu-id="6d88f-194">Хотя указатели увеличиваются с 32 бит на 64 на 64-разрядной платформе, другие типы данных нет.</span><span class="sxs-lookup"><span data-stu-id="6d88f-194">While pointers increase from 32 bits to 64 on a 64-bit platform, other data types don't.</span></span> <span data-ttu-id="6d88f-195">Типы данных с фиксированной точностью (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32 и UINT64) можно использовать в местах, где должен быть известен размер типа данных. Например, в структуре двоичного файла.</span><span class="sxs-lookup"><span data-stu-id="6d88f-195">Fixed-precision data types (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32, UINT64) can be used in places where the size of the data type must be known; for example, in a binary file structure.</span></span> <span data-ttu-id="6d88f-196">Изменение размера указателя и выравнивания данных требует специальной обработки, чтобы обеспечить совместимость с 32-bit-to-64-разр.</span><span class="sxs-lookup"><span data-stu-id="6d88f-196">The changes in pointer size and data alignment require special handling to ensure 32-bit-to-64-bit compatibility.</span></span> <span data-ttu-id="6d88f-197">Дополнительные сведения можно найти в [Подготовности к 64-разрядной версии Windows: новые типы данных](/windows/desktop/WinProg64/the-new-data-types).</span><span class="sxs-lookup"><span data-stu-id="6d88f-197">More information can be found in [Getting Ready for 64-bit Windows: The New Data Types](/windows/desktop/WinProg64/the-new-data-types).</span></span>

</dd> <dt>

<span data-ttu-id="6d88f-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**Старые API Win32 и выравнивание данных**</span><span class="sxs-lookup"><span data-stu-id="6d88f-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**Older Win32 APIs and Data Alignment**</span></span>
</dt> <dd>

<span data-ttu-id="6d88f-199">Некоторые API-интерфейсы Win32 являются устаревшими и заменены более независимыми вызовами API, например Сетвиндовлонгптр вместо SetWindowLong.</span><span class="sxs-lookup"><span data-stu-id="6d88f-199">Some Win32 APIs have been deprecated and replaced with more neutral API calls such as SetWindowLongPtr in place of SetWindowLong.</span></span>

<span data-ttu-id="6d88f-200">Снижение производительности для неориентированных обращений больше на платформе x64, чем на платформе x86.</span><span class="sxs-lookup"><span data-stu-id="6d88f-200">The performance penalty for non-aligned accesses is greater on x64 platform than on an x86 platform.</span></span> <span data-ttu-id="6d88f-201">\_ \_ Для определения сведений о выравнивании, которые могут использоваться непосредственно в коде, можно использовать тип выравнивания (t) и макросы смещения поля (t, Member).</span><span class="sxs-lookup"><span data-stu-id="6d88f-201">The TYPE\_ALIGNMENT(t) and the FIELD\_OFFSET(t, member) macros can be used to determine alignment information that can used directly by code.</span></span> <span data-ttu-id="6d88f-202">Правильное использование упомянутых выше макросов должно устранить потенциальные несогласованные штрафы в доступе.</span><span class="sxs-lookup"><span data-stu-id="6d88f-202">Correct use of these aforementioned macros should eliminate potential non-aligned access penalties.</span></span>

<span data-ttu-id="6d88f-203">Дополнительные сведения о \_ макросе выравнивания типов, \_ макросе смещения поля и общей 64-разрядной информации о программировании можно найти в [64-разрядном программировании Windows: советы по миграции: дополнительные соображения](/windows/desktop/WinProg64/additional-considerations) и [Подготовка к 64-bit Windows: правила использования указателей](/windows/desktop/WinProg64/rules-for-using-pointers).</span><span class="sxs-lookup"><span data-stu-id="6d88f-203">More information on the TYPE\_ALIGNMENT macro, the FIELD\_OFFSET macro, and general 64-bit programming information can be found at [64-bit Windows Programming: Migration Tips: Additional Considerations](/windows/desktop/WinProg64/additional-considerations) and [Getting Ready for 64-bit Windows: Rules for Using Pointers](/windows/desktop/WinProg64/rules-for-using-pointers).</span></span>

</dd> <dt>

<span data-ttu-id="6d88f-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Код сборки**</span><span class="sxs-lookup"><span data-stu-id="6d88f-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Assembly Code**</span></span>
</dt> <dd>

<span data-ttu-id="6d88f-205">Встроенный код ассемблера не поддерживается на 64-разрядных платформах и должен быть заменен.</span><span class="sxs-lookup"><span data-stu-id="6d88f-205">Inline assembly code is not supported on 64-bit platforms and needs to be replaced.</span></span> <span data-ttu-id="6d88f-206">Изменения в архитектуре могли изменить узкие места приложений, а C/C++ или встроенные функции могут получить аналогичные результаты с кодом, который проще читать.</span><span class="sxs-lookup"><span data-stu-id="6d88f-206">Changes in the architecture may have changed application bottlenecks, and C/C++ or intrinsics can achieve similar results with code that is easier to read.</span></span> <span data-ttu-id="6d88f-207">Рекомендуется переключить весь код сборки на C или C++.</span><span class="sxs-lookup"><span data-stu-id="6d88f-207">The most advisable practice is to switch all assembly code to C or C++.</span></span> <span data-ttu-id="6d88f-208">Встроенные функции можно использовать вместо кода сборки, но их следует использовать только после полного профилирования и выполнения анализа.</span><span class="sxs-lookup"><span data-stu-id="6d88f-208">Intrinsics can be used in place of assembly code, but should only be used after full profiling and analysis has been performed.</span></span>

<span data-ttu-id="6d88f-209">X87, MMX и 3DNow!</span><span class="sxs-lookup"><span data-stu-id="6d88f-209">The x87, MMX, and 3DNow!</span></span> <span data-ttu-id="6d88f-210">наборы инструкций не рекомендуются в 64-разрядных режимах.</span><span class="sxs-lookup"><span data-stu-id="6d88f-210">instruction sets are deprecated in 64-bit modes.</span></span> <span data-ttu-id="6d88f-211">Наборы инструкций по-прежнему существуют для обеспечения обратной совместимости в 32-разрядном режиме. Однако, чтобы избежать проблем совместимости в будущем, не рекомендуется использовать их в текущих и будущих проектах.</span><span class="sxs-lookup"><span data-stu-id="6d88f-211">The instructions sets are still present for backward compatibility for 32-bit mode; however, to avoid compatibility issues in the future, their use in current and future projects is discouraged.</span></span>

</dd> <dt>

<span data-ttu-id="6d88f-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**Устаревшие API**</span><span class="sxs-lookup"><span data-stu-id="6d88f-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**Deprecated APIs**</span></span>
</dt> <dd>

<span data-ttu-id="6d88f-213">Некоторые старые API DirectX были удалены для 64-разрядных машинных приложений: DirectPlay 4 и более ранних версий, DirectDraw 6 и более ранних версий, Direct3D 8 и более ранних версий, Директинпут 7 и более ранних версий.</span><span class="sxs-lookup"><span data-stu-id="6d88f-213">Some older DirectX APIs have been dropped for 64-bit native applications: DirectPlay 4 and earlier, DirectDraw 6 and earlier, Direct3D 8 and earlier, and DirectInput 7 and earlier.</span></span> <span data-ttu-id="6d88f-214">Кроме того, основной API DirectMusic доступен для машинных 64-разрядных приложений, но уровень производительности и производитель DirectMusic являются устаревшими.</span><span class="sxs-lookup"><span data-stu-id="6d88f-214">Also, the core API of DirectMusic is available to native 64-bit applications, but the performance layer and DirectMusic Producer are deprecated.</span></span>

<span data-ttu-id="6d88f-215">Visual Studio выдает предупреждения об устаревании, и эти изменения не являются проблемой для разработчиков, использующих новейшие API.</span><span class="sxs-lookup"><span data-stu-id="6d88f-215">Visual Studio issues deprecation warnings, and these changes are not an issue for developers who use the latest APIs.</span></span>

</dd> </dl>

## <a name="profiling-and-optimization-of-ported-applications"></a><span data-ttu-id="6d88f-216">Профилирование и оптимизация перенесенных приложений</span><span class="sxs-lookup"><span data-stu-id="6d88f-216">Profiling and Optimization of Ported Applications</span></span>

<span data-ttu-id="6d88f-217">Все разработчики должны повторно профилировать все приложения, перенесенные в новые архитектуры.</span><span class="sxs-lookup"><span data-stu-id="6d88f-217">All developers need to re-profile any applications that are being ported to new architectures.</span></span> <span data-ttu-id="6d88f-218">Многие приложения, перенесенные на 64-разрядные платформы, имеют разные профили производительности из их 32-разрядных версий.</span><span class="sxs-lookup"><span data-stu-id="6d88f-218">Many applications being ported to 64-bit platforms will have different performance profiles from their 32-bit versions.</span></span> <span data-ttu-id="6d88f-219">Перед оценкой того, что необходимо оптимизировать, разработчикам необходимо выполнить 64-разрядные тесты производительности.</span><span class="sxs-lookup"><span data-stu-id="6d88f-219">Developers need to run 64-bit performance tests before assessing what needs to be optimized.</span></span> <span data-ttu-id="6d88f-220">Хорошая новость в этом заключается в том, что многие традиционные оптимизации работают на 64-разрядных платформах.</span><span class="sxs-lookup"><span data-stu-id="6d88f-220">The good news about this is that many traditional optimizations work on 64-bit platforms.</span></span> <span data-ttu-id="6d88f-221">Кроме того, 64-разрядные компиляторы также могут выполнять много операций оптимизации с правильным использованием флагов компилятора и подсказок кода.</span><span class="sxs-lookup"><span data-stu-id="6d88f-221">In addition, 64-bit compilers can also perform many optimizations with the correct use of compiler flags and coding hints.</span></span>

<span data-ttu-id="6d88f-222">Некоторые структуры могут иметь свои внутренние типы данных, переупорядоченные для экономии пространства памяти и улучшения кэширования.</span><span class="sxs-lookup"><span data-stu-id="6d88f-222">Some structures may have their internal data types reordered to conserve memory space and improve caching.</span></span> <span data-ttu-id="6d88f-223">В некоторых случаях вместо полного 64-разрядного указателя можно использовать индексы массивов.</span><span class="sxs-lookup"><span data-stu-id="6d88f-223">Array indices can be used instead of a full 64-bit pointer in some cases.</span></span> <span data-ttu-id="6d88f-224">Флаг/FP: Fast может улучшить оптимизацию и векторность с плавающей точкой.</span><span class="sxs-lookup"><span data-stu-id="6d88f-224">The /fp:fast flag can improve floating-point optimizing and vectorization.</span></span> <span data-ttu-id="6d88f-225">Использование \_ \_ restrict, declspec (restrict) и declspec (не псевдонима) может помочь компилятору разрешить псевдонимы и улучшить использование файла регистрации.</span><span class="sxs-lookup"><span data-stu-id="6d88f-225">Using \_\_restrict, declspec(restrict), and declspec(noalias) can help the compiler resolve aliasing and improve use of the register file.</span></span>

<span data-ttu-id="6d88f-226">Дополнительные сведения о/FP: Fast можно найти в [/FP (укажите Floating-Point поведение)](/cpp/build/reference/fp-specify-floating-point-behavior).</span><span class="sxs-lookup"><span data-stu-id="6d88f-226">More information on /fp:fast can be found at [/fp (Specify Floating-Point Behavior)](/cpp/build/reference/fp-specify-floating-point-behavior).</span></span>

<span data-ttu-id="6d88f-227">Дополнительные сведения о \_ \_ ограничении можно найти в [модификаторах, специфичных для Майкрософт](/cpp/cpp/microsoft-specific-modifiers).</span><span class="sxs-lookup"><span data-stu-id="6d88f-227">More information on \_\_restrict can be found at [Microsoft-Specific Modifiers](/cpp/cpp/microsoft-specific-modifiers).</span></span>

<span data-ttu-id="6d88f-228">Дополнительные сведения о declspec (restrict) можно найти в статье [рекомендации по оптимизации](/cpp/build/optimization-best-practices).</span><span class="sxs-lookup"><span data-stu-id="6d88f-228">More information on declspec(restrict) can be found at [Optimization Best Practices](/cpp/build/optimization-best-practices).</span></span>

<span data-ttu-id="6d88f-229">Дополнительные сведения о declspec можно найти по адресу [ \_ \_ declspec (](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx)No Alias).</span><span class="sxs-lookup"><span data-stu-id="6d88f-229">More information on declspec(noalias) can be found at [\_\_declspec(noalias)](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx).</span></span>

## <a name="managed-code-on-a-64-bit-operating-system"></a><span data-ttu-id="6d88f-230">Управляемый код в 64-разрядной операционной системе</span><span class="sxs-lookup"><span data-stu-id="6d88f-230">Managed Code on a 64-bit Operating System</span></span>

<span data-ttu-id="6d88f-231">Управляемый код используется многими разработчиками игр в цепочке инструментов, поэтому понимание того, как оно работает в 64-разрядной ОС, может быть полезным.</span><span class="sxs-lookup"><span data-stu-id="6d88f-231">Managed code is used by many game developers in their tool chain, so an understanding of how it behaves on a 64-bit OS can be helpful.</span></span> <span data-ttu-id="6d88f-232">Управляемый код — это нейтральный набор инструкций, поэтому при запуске управляемого приложения в 64-разрядной операционной системе среда CLR может запустить ее как 32-разрядный или 64-разрядный процесс.</span><span class="sxs-lookup"><span data-stu-id="6d88f-232">Managed code is instruction-set neutral, so when you run a managed application on a 64-bit OS, the Common Language Runtime (CLR) can run it as either a 32-bit or 64-bit process.</span></span> <span data-ttu-id="6d88f-233">По умолчанию среда CLR запускает управляемые приложения как 64-разрядные, и они должны работать нормально, не выполняя никаких проблем.</span><span class="sxs-lookup"><span data-stu-id="6d88f-233">By default, the CLR runs managed applications as 64-bit, and they should work fine with no problems.</span></span> <span data-ttu-id="6d88f-234">Однако если приложение зависит от библиотеки DLL, которая является собственной 32-разрядной, то при попытке вызвать эту БИБЛИОТЕКУ приложение завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="6d88f-234">However, if your application depends on a DLL that is native 32-bit, then your application will fail when it tries to call this DLL.</span></span> <span data-ttu-id="6d88f-235">В 64-разрядном процессе требуется полностью 64-разрядный код, а 32-bit DLL не может быть вызван из 64-разрядного процесса.</span><span class="sxs-lookup"><span data-stu-id="6d88f-235">A 64-bit process needs completely 64-bit code, and a 32-bit DLL cannot be called from a 64-bit process.</span></span> <span data-ttu-id="6d88f-236">Лучшим долгосрочным решением является компиляция машинного кода как 64-bit, но вполне разумное решение краткосрочного решения — просто пометить управляемое приложение как x86 только с помощью флага сборки/Platform: x86.</span><span class="sxs-lookup"><span data-stu-id="6d88f-236">The best long-term solution is to compile your native code as 64-bit also, but a perfectly reasonable short-term solution is to simply mark your managed application as being for x86 only by using the /platform:x86 build flag.</span></span>

## <a name="performance-implications-of-running-a-64-bit-operating-system"></a><span data-ttu-id="6d88f-237">Влияние на производительность при выполнении 64-разрядной операционной системы</span><span class="sxs-lookup"><span data-stu-id="6d88f-237">Performance Implications of Running a 64-bit Operating System</span></span>

<span data-ttu-id="6d88f-238">Поскольку процессоры с архитектурой AMD64 и Intel 64 могут выполнять 32-разрядные инструкции изначально, они могут запускать 32-разрядные приложения на полной скорости, даже в 64-разрядной ОС.</span><span class="sxs-lookup"><span data-stu-id="6d88f-238">Because processors with AMD64 and Intel 64 architecture can execute 32-bit instructions natively, they can run 32-bit applications at full speed, even on a 64-bit OS.</span></span> <span data-ttu-id="6d88f-239">При вызове функций операционной системы существует некоторая плата за преобразование параметров между 32-разрядным и 64-битным, но эта стоимость обычно незначительна.</span><span class="sxs-lookup"><span data-stu-id="6d88f-239">There is a modest cost for converting parameters between 32-bit and 64-bit when calling operating system functions, but this cost is generally negligible.</span></span> <span data-ttu-id="6d88f-240">Это означает, что при запуске 32-разрядных приложений в 64-разрядной ОС вы не сможете замедленовать.</span><span class="sxs-lookup"><span data-stu-id="6d88f-240">This means that you should see no slowdown when running 32-bit applications on a 64-bit OS.</span></span>

<span data-ttu-id="6d88f-241">При компиляции приложений как 64-разрядных, вычисления будут более сложными.</span><span class="sxs-lookup"><span data-stu-id="6d88f-241">When you compile applications as 64-bit, the calculations get more complicated.</span></span> <span data-ttu-id="6d88f-242">В 64-разрядной программе используются 64-битовые указатели, и его инструкции немного увеличиваются, поэтому потребность в памяти немного увеличивается.</span><span class="sxs-lookup"><span data-stu-id="6d88f-242">A 64-bit program uses 64-bit pointers, and its instructions are slightly larger, so the memory requirement is slightly increased.</span></span> <span data-ttu-id="6d88f-243">Это может привести к незначительному снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="6d88f-243">This can cause a slight drop in performance.</span></span> <span data-ttu-id="6d88f-244">С другой стороны, наличие двух регистров и возможность выполнять 64-разрядные целочисленные вычисления в одной инструкции зачастую больше, чем компенсация.</span><span class="sxs-lookup"><span data-stu-id="6d88f-244">On the other hand, having twice as many registers and having the ability to do 64-bit integer calculations in a single instruction will often more than compensate.</span></span> <span data-ttu-id="6d88f-245">В итоге 64-разрядное приложение может работать немного медленнее, чем то же приложение, скомпилированное в 32-бит, но оно часто выполняется немного быстрее.</span><span class="sxs-lookup"><span data-stu-id="6d88f-245">The net result is that a 64-bit application might run slightly slower than the same application compiled as 32-bit, but it will often run slightly faster.</span></span>

## <a name="summary"></a><span data-ttu-id="6d88f-246">Сводка</span><span class="sxs-lookup"><span data-stu-id="6d88f-246">Summary</span></span>

<span data-ttu-id="6d88f-247">64-разрядные архитектуры позволяют разработчикам отправлять ограничения на внешний вид, звук и воспроизведение игр.</span><span class="sxs-lookup"><span data-stu-id="6d88f-247">Sixty-four-bit architectures allow developers to push the limitations on how games look, sound, and play.</span></span> <span data-ttu-id="6d88f-248">Однако переход от 32-разрядного программирования к 64-разрядному программированию не является тривиальным.</span><span class="sxs-lookup"><span data-stu-id="6d88f-248">Transitioning from 32-bit programming to 64-bit programming is not trivial, however.</span></span> <span data-ttu-id="6d88f-249">Понимание различий между ними и с помощью новейших средств позволяет упростить и ускорить переход на 64-разрядные платформы.</span><span class="sxs-lookup"><span data-stu-id="6d88f-249">By understanding the differences between the two, and by using the newest tools, the transition to 64-bit platforms can be easier and faster.</span></span>

<span data-ttu-id="6d88f-250">Дополнительные сведения о 64-разрядном программировании можно найти в [Visual C++ центре разработчиков: 64-разрядное программирование](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span><span class="sxs-lookup"><span data-stu-id="6d88f-250">More information on 64-bit programming can be found at [Visual C++ Developer Center: 64-Bit Programming](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span></span>

 

 