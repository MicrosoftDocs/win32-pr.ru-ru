---
description: Функции Wait позволяют потоку блокировать свое выполнение.
ms.assetid: 9c66c71d-fdfd-42ae-895c-2fc842b5bc7a
title: Функции Wait
ms.topic: article
ms.date: 06/25/2020
ms.openlocfilehash: f5a21b0d95a316b926fcaad037004edc8c418246
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105664064"
---
# <a name="wait-functions"></a><span data-ttu-id="ebc25-103">Функции Wait</span><span class="sxs-lookup"><span data-stu-id="ebc25-103">Wait Functions</span></span>

<span data-ttu-id="ebc25-104">*Функции Wait* позволяют потоку блокировать свое выполнение.</span><span class="sxs-lookup"><span data-stu-id="ebc25-104">*Wait functions* allow a thread to block its own execution.</span></span> <span data-ttu-id="ebc25-105">Функции ожидания не возвращают, пока не будут выполнены указанные условия.</span><span class="sxs-lookup"><span data-stu-id="ebc25-105">The wait functions do not return until the specified criteria have been met.</span></span> <span data-ttu-id="ebc25-106">Тип функции Wait определяет набор используемых критериев.</span><span class="sxs-lookup"><span data-stu-id="ebc25-106">The type of wait function determines the set of criteria used.</span></span> <span data-ttu-id="ebc25-107">При вызове функции Wait она проверяет, выполнены ли условия ожидания.</span><span class="sxs-lookup"><span data-stu-id="ebc25-107">When a wait function is called, it checks whether the wait criteria have been met.</span></span> <span data-ttu-id="ebc25-108">Если критерии не выполнены, вызывающий поток переходит в состояние ожидания до тех пор, пока не будут выполнены условия условий ожидания или не истечет указанный интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="ebc25-108">If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the specified time-out interval elapses.</span></span>

-   [<span data-ttu-id="ebc25-109">Функции ожидания с одним объектом</span><span class="sxs-lookup"><span data-stu-id="ebc25-109">Single-object Wait Functions</span></span>](#single-object-wait-functions)
-   [<span data-ttu-id="ebc25-110">Функции ожидания с несколькими объектами</span><span class="sxs-lookup"><span data-stu-id="ebc25-110">Multiple-object Wait Functions</span></span>](#multiple-object-wait-functions)
-   [<span data-ttu-id="ebc25-111">Функции ожидания с оповещением</span><span class="sxs-lookup"><span data-stu-id="ebc25-111">Alertable Wait Functions</span></span>](#alertable-wait-functions)
-   [<span data-ttu-id="ebc25-112">Зарегистрированные функции ожидания</span><span class="sxs-lookup"><span data-stu-id="ebc25-112">Registered Wait Functions</span></span>](#registered-wait-functions)
-   [<span data-ttu-id="ebc25-113">Ожидание адреса</span><span class="sxs-lookup"><span data-stu-id="ebc25-113">Waiting on an Address</span></span>](#waiting-on-an-address)
-   [<span data-ttu-id="ebc25-114">Функции ожидания и интервалы времени ожидания</span><span class="sxs-lookup"><span data-stu-id="ebc25-114">Wait Functions and Time-out Intervals</span></span>](#wait-functions-and-time-out-intervals)
-   [<span data-ttu-id="ebc25-115">Функции ожидания и объекты синхронизации</span><span class="sxs-lookup"><span data-stu-id="ebc25-115">Wait Functions and Synchronization Objects</span></span>](#wait-functions-and-synchronization-objects)
-   [<span data-ttu-id="ebc25-116">Функции Wait и создание окон</span><span class="sxs-lookup"><span data-stu-id="ebc25-116">Wait Functions and Creating Windows</span></span>](#wait-functions-and-creating-windows)

## <a name="single-object-wait-functions"></a><span data-ttu-id="ebc25-117">Функции ожидания с одним объектом</span><span class="sxs-lookup"><span data-stu-id="ebc25-117">Single-object Wait Functions</span></span>

<span data-ttu-id="ebc25-118">Для функций [**сигналобжектандваит**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)и [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) требуется обработчик одного объекта синхронизации.</span><span class="sxs-lookup"><span data-stu-id="ebc25-118">The [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), and [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) functions require a handle to one synchronization object.</span></span> <span data-ttu-id="ebc25-119">Эти функции возвращают, когда происходит одно из следующих событий:</span><span class="sxs-lookup"><span data-stu-id="ebc25-119">These functions return when one of the following occurs:</span></span>

-   <span data-ttu-id="ebc25-120">Указанный объект находится в сигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="ebc25-120">The specified object is in the signaled state.</span></span>
-   <span data-ttu-id="ebc25-121">Интервал времени ожидания истекает.</span><span class="sxs-lookup"><span data-stu-id="ebc25-121">The time-out interval elapses.</span></span> <span data-ttu-id="ebc25-122">Интервал времени ожидания может быть установлен в **бесконечное** значение, чтобы указать, что время ожидания не будет истекает.</span><span class="sxs-lookup"><span data-stu-id="ebc25-122">The time-out interval can be set to **INFINITE** to specify that the wait will not time out.</span></span>

<span data-ttu-id="ebc25-123">Функция [**сигналобжектандваит**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait) позволяет вызывающему потоку атомарно установить состояние объекта в значение "сигнал" и подождать, пока состояние другого объекта не будет равно "сигнальному".</span><span class="sxs-lookup"><span data-stu-id="ebc25-123">The [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait) function enables the calling thread to atomically set the state of an object to signaled and wait for the state of another object to be set to signaled.</span></span>

## <a name="multiple-object-wait-functions"></a><span data-ttu-id="ebc25-124">Функции ожидания с несколькими объектами</span><span class="sxs-lookup"><span data-stu-id="ebc25-124">Multiple-object Wait Functions</span></span>

<span data-ttu-id="ebc25-125">Функции [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects), [**ваитформултиплеобжектсекс**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex), [**мсгваитформултиплеобжектс**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects)и [**мсгваитформултиплеобжектсекс**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex) позволяют вызывающему потоку указать массив, содержащий один или несколько дескрипторов объекта синхронизации.</span><span class="sxs-lookup"><span data-stu-id="ebc25-125">The [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects), [**WaitForMultipleObjectsEx**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex), [**MsgWaitForMultipleObjects**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects), and [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex) functions enable the calling thread to specify an array containing one or more synchronization object handles.</span></span> <span data-ttu-id="ebc25-126">Эти функции возвращают, когда происходит одно из следующих событий:</span><span class="sxs-lookup"><span data-stu-id="ebc25-126">These functions return when one of the following occurs:</span></span>

-   <span data-ttu-id="ebc25-127">Состоянию любого из указанных объектов присваивается значение «сигнальные» или состояниям всех объектов присвоено значение «сигнальный».</span><span class="sxs-lookup"><span data-stu-id="ebc25-127">The state of any one of the specified objects is set to signaled or the states of all objects have been set to signaled.</span></span> <span data-ttu-id="ebc25-128">Вы управляете тем, будет ли использоваться одно или все из этих состояний в вызове функции.</span><span class="sxs-lookup"><span data-stu-id="ebc25-128">You control whether one or all of the states will be used in the function call.</span></span>
-   <span data-ttu-id="ebc25-129">Интервал времени ожидания истекает.</span><span class="sxs-lookup"><span data-stu-id="ebc25-129">The time-out interval elapses.</span></span> <span data-ttu-id="ebc25-130">Интервал времени ожидания может быть установлен в **бесконечное** значение, чтобы указать, что время ожидания не будет истекает.</span><span class="sxs-lookup"><span data-stu-id="ebc25-130">The time-out interval can be set to **INFINITE** to specify that the wait will not time out.</span></span>

<span data-ttu-id="ebc25-131">Функция [**мсгваитформултиплеобжектс**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects) и [**мсгваитформултиплеобжектсекс**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex) позволяет указать объекты входных событий в массиве обработчиков объектов.</span><span class="sxs-lookup"><span data-stu-id="ebc25-131">The [**MsgWaitForMultipleObjects**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects) and [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex) function allow you to specify input event objects in the object handle array.</span></span> <span data-ttu-id="ebc25-132">Это делается при указании типа входных данных для ожидания в очереди ввода потока.</span><span class="sxs-lookup"><span data-stu-id="ebc25-132">This is done when you specify the type of input to wait for in the thread's input queue.</span></span> <span data-ttu-id="ebc25-133">Например, поток может использовать **мсгваитформултиплеобжектс** для блокирования его выполнения до тех пор, пока состояние указанного объекта не станет сигнальным, а в очереди входных данных потока будет доступно вход с помощью мыши.</span><span class="sxs-lookup"><span data-stu-id="ebc25-133">For example, a thread could use **MsgWaitForMultipleObjects** to block its execution until the state of a specified object has been set to signaled and there is mouse input available in the thread's input queue.</span></span> <span data-ttu-id="ebc25-134">Для получения входных данных [](/windows/win32/api/winuser/nf-winuser-getmessage) поток может использовать функцию [**пикмессажеа**](/windows/win32/api/winuser/nf-winuser-peekmessagea) или [**пикмессажев**](/windows/win32/api/winuser/nf-winuser-peekmessagew) .</span><span class="sxs-lookup"><span data-stu-id="ebc25-134">The thread can use the [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessageA**](/windows/win32/api/winuser/nf-winuser-peekmessagea) or [**PeekMessageW**](/windows/win32/api/winuser/nf-winuser-peekmessagew) function to retrieve the input.</span></span>

<span data-ttu-id="ebc25-135">При ожидании того, что состояния всех объектов должны быть сигнальными, эти функции с несколькими объектами не изменяют состояния указанных объектов до тех пор, пока не будут заданы состояния всех объектов.</span><span class="sxs-lookup"><span data-stu-id="ebc25-135">When waiting for the states of all objects to be set to signaled, these multiple-object functions do not modify the states of the specified objects until the states of all objects have been set signaled.</span></span> <span data-ttu-id="ebc25-136">Например, состояние объекта мьютекса может быть сигнальным, но вызывающий поток не получает владение, пока состояния других объектов, указанных в массиве, также не будут сигнальными.</span><span class="sxs-lookup"><span data-stu-id="ebc25-136">For example, the state of a mutex object can be signaled, but the calling thread does not get ownership until the states of the other objects specified in the array have also been set to signaled.</span></span> <span data-ttu-id="ebc25-137">В то же время другой поток может стать владельцем объекта Mutex, тем самым устанавливая его состояние на несигнальное.</span><span class="sxs-lookup"><span data-stu-id="ebc25-137">In the meantime, some other thread may get ownership of the mutex object, thereby setting its state to nonsignaled.</span></span>

<span data-ttu-id="ebc25-138">При ожидании того, что состояние одного объекта должно быть сигнальным, эти функции с несколькими объектами проверяют дескрипторы в массиве в порядке, начиная с индекса 0, до тех пор, пока не будет получен сигнал об одном из объектов.</span><span class="sxs-lookup"><span data-stu-id="ebc25-138">When waiting for the state of a single object to be set to signaled, these multiple-object functions check the handles in the array in order starting with index 0, until one of the objects is signaled.</span></span> <span data-ttu-id="ebc25-139">Если несколько объектов получают сигнал, функция возвращает индекс первого дескриптора в массиве, объект которого получил сигнал.</span><span class="sxs-lookup"><span data-stu-id="ebc25-139">If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled.</span></span>

## <a name="alertable-wait-functions"></a><span data-ttu-id="ebc25-140">Функции ожидания с оповещением</span><span class="sxs-lookup"><span data-stu-id="ebc25-140">Alertable Wait Functions</span></span>

<span data-ttu-id="ebc25-141">Функции [**мсгваитформултиплеобжектсекс**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**сигналобжектандваит**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**ваитформултиплеобжектсекс**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex)и [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) отличаются от других функций ожидания в том, что они могут дополнительно выполнить *операцию ожидания* с возможностью предупреждения.</span><span class="sxs-lookup"><span data-stu-id="ebc25-141">The [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**WaitForMultipleObjectsEx**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex), and [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) functions differ from the other wait functions in that they can optionally perform an *alertable wait operation*.</span></span> <span data-ttu-id="ebc25-142">В операции ожидания с оповещением функция может возвращать данные о выполнении указанных условий, но также может возвращать значение, если система помещает в очередь подпрограмму завершения ввода-вывода или APC для выполнения в ожидающем потоке.</span><span class="sxs-lookup"><span data-stu-id="ebc25-142">In an alertable wait operation, the function can return when the specified conditions are met, but it can also return if the system queues an I/O completion routine or an APC for execution by the waiting thread.</span></span> <span data-ttu-id="ebc25-143">Дополнительные сведения о выполняемых с предупреждениями операциях ожидания и подсистемах завершения ввода-вывода см. в разделе [Синхронизация и перекрывающиеся входные и выходные данные](synchronization-and-overlapped-input-and-output.md).</span><span class="sxs-lookup"><span data-stu-id="ebc25-143">For more information about alertable wait operations and I/O completion routines, see [Synchronization and Overlapped Input and Output](synchronization-and-overlapped-input-and-output.md).</span></span> <span data-ttu-id="ebc25-144">Дополнительные сведения о APC см. в разделе [асинхронные вызовы процедур](asynchronous-procedure-calls.md).</span><span class="sxs-lookup"><span data-stu-id="ebc25-144">For more information about APCs, see [Asynchronous Procedure Calls](asynchronous-procedure-calls.md).</span></span>

## <a name="registered-wait-functions"></a><span data-ttu-id="ebc25-145">Зарегистрированные функции ожидания</span><span class="sxs-lookup"><span data-stu-id="ebc25-145">Registered Wait Functions</span></span>

<span data-ttu-id="ebc25-146">Функция [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject) отличается от других функций ожидания тем, что операция ожидания выполняется потоком из [пула потоков](../procthread/thread-pooling.md).</span><span class="sxs-lookup"><span data-stu-id="ebc25-146">The [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject) function differs from the other wait functions in that the wait operation is performed by a thread from the [thread pool](../procthread/thread-pooling.md).</span></span> <span data-ttu-id="ebc25-147">При выполнении указанных условий функция обратного вызова выполняется рабочим потоком из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="ebc25-147">When the specified conditions are met, the callback function is executed by a worker thread from the thread pool.</span></span>

<span data-ttu-id="ebc25-148">По умолчанию зарегистрированная операция ожидания является операцией с несколькими ожиданиями.</span><span class="sxs-lookup"><span data-stu-id="ebc25-148">By default, a registered wait operation is a multiple-wait operation.</span></span> <span data-ttu-id="ebc25-149">Система сбрасывает таймер при каждом сигнале события (или истечении интервала времени ожидания) до тех пор, пока не будет вызвана функция [**UnregisterWaitEx**](unregisterwaitex.md) для отмены операции.</span><span class="sxs-lookup"><span data-stu-id="ebc25-149">The system resets the timer every time the event is signaled (or the time-out interval elapses) until you call the [**UnregisterWaitEx**](unregisterwaitex.md) function to cancel the operation.</span></span> <span data-ttu-id="ebc25-150">Чтобы указать, что операция ожидания должна выполняться только один раз, присвойте  параметру dwFlags [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject) значение **WT \_ ексекутеонлйонце**.</span><span class="sxs-lookup"><span data-stu-id="ebc25-150">To specify that a wait operation should be executed only once, set the *dwFlags* parameter of [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject) to **WT\_EXECUTEONLYONCE**.</span></span>

<span data-ttu-id="ebc25-151">Если поток вызывает функции, использующие APC, установите для параметра *dwFlags* в [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject) значение **WT \_ ексекутеинперсистентсреад**.</span><span class="sxs-lookup"><span data-stu-id="ebc25-151">If the thread calls functions that use APCs, set the *dwFlags* parameter of [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject) to **WT\_EXECUTEINPERSISTENTTHREAD**.</span></span>

## <a name="waiting-on-an-address"></a><span data-ttu-id="ebc25-152">Ожидание адреса</span><span class="sxs-lookup"><span data-stu-id="ebc25-152">Waiting on an Address</span></span>

<span data-ttu-id="ebc25-153">Поток может использовать функцию [**ваитонаддресс**](/windows/desktop/api/SynchAPI/nf-synchapi-waitonaddress) , чтобы ждать, пока значение целевого адреса изменится с нежелательного на любое другое значение.</span><span class="sxs-lookup"><span data-stu-id="ebc25-153">A thread can use the [**WaitOnAddress**](/windows/desktop/api/SynchAPI/nf-synchapi-waitonaddress) function to wait for the value of a target address to change from some undesired value to any other value.</span></span> <span data-ttu-id="ebc25-154">Это позволяет потокам ожидать изменения значения без необходимости прокрутки или обработки проблем синхронизации, которые могут возникать, когда поток фиксирует нежелательное значение, но значение изменяется до того, как поток может подождать.</span><span class="sxs-lookup"><span data-stu-id="ebc25-154">This enables threads to wait for a value to change without having to spin or handle the synchronization problems that can arise when the thread captures an undesired value but the value changes before the thread can wait.</span></span>

<span data-ttu-id="ebc25-155">[**Ваитонаддресс**](/windows/desktop/api/SynchAPI/nf-synchapi-waitonaddress) возвращает, когда код, изменяющий целевое значение, сигнализирует об изменении, вызывая [**вакебяддресссингле**](/windows/desktop/api/SynchAPI/nf-synchapi-wakebyaddresssingle) для пробуждения одного ожидающего потока или [**вакебяддрессалл**](/windows/desktop/api/SynchAPI/nf-synchapi-wakebyaddressall) для пробуждения всех ожидающих потоков.</span><span class="sxs-lookup"><span data-stu-id="ebc25-155">[**WaitOnAddress**](/windows/desktop/api/SynchAPI/nf-synchapi-waitonaddress) returns when code that modifies the target value signals the change by calling [**WakeByAddressSingle**](/windows/desktop/api/SynchAPI/nf-synchapi-wakebyaddresssingle) to wake a single waiting thread or [**WakeByAddressAll**](/windows/desktop/api/SynchAPI/nf-synchapi-wakebyaddressall) to wake all waiting threads.</span></span> <span data-ttu-id="ebc25-156">Если интервал времени ожидания указан с параметром **ваитонаддресс** и ни один поток не вызывает функцию пробуждения, функция возвращает значение по истечении интервала времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="ebc25-156">If a time-out interval is specified with **WaitOnAddress** and no thread calls a wake function, the function returns when the time-out interval elapses.</span></span> <span data-ttu-id="ebc25-157">Если интервал времени ожидания не указан, поток ждет бесконечно.</span><span class="sxs-lookup"><span data-stu-id="ebc25-157">If no time-out interval is specified, the thread waits indefinitely.</span></span>

## <a name="wait-functions-and-time-out-intervals"></a><span data-ttu-id="ebc25-158">Функции ожидания и интервалы времени ожидания</span><span class="sxs-lookup"><span data-stu-id="ebc25-158">Wait Functions and Time-out Intervals</span></span>

<span data-ttu-id="ebc25-159">Точность указанного интервала времени ожидания зависит от разрешения системных часов.</span><span class="sxs-lookup"><span data-stu-id="ebc25-159">The accuracy of the specified time-out interval depends on the resolution of the system clock.</span></span> <span data-ttu-id="ebc25-160">Системные часы "тактов" по постоянной ставке.</span><span class="sxs-lookup"><span data-stu-id="ebc25-160">The system clock "ticks" at a constant rate.</span></span> <span data-ttu-id="ebc25-161">Если интервал времени ожидания меньше, чем разрешение системных часов, время ожидания может истекает менее указанного промежутка времени.</span><span class="sxs-lookup"><span data-stu-id="ebc25-161">If the time-out interval is less than the resolution of the system clock, the wait may time out in less than the specified length of time.</span></span> <span data-ttu-id="ebc25-162">Если интервал времени ожидания больше одного деления, но меньше двух, ожидание может находиться в любом месте между одним и двумя тактами и так далее.</span><span class="sxs-lookup"><span data-stu-id="ebc25-162">If the time-out interval is greater than one tick but less than two, the wait can be anywhere between one and two ticks, and so on.</span></span>

<span data-ttu-id="ebc25-163">Чтобы увеличить точность интервала времени ожидания для функций ожидания, вызовите функцию **тимежетдевкапс** , чтобы определить поддерживаемое минимальное разрешение таймера и функцию **тимебегинпериод** , чтобы установить минимальное разрешение таймера.</span><span class="sxs-lookup"><span data-stu-id="ebc25-163">To increase the accuracy of the time-out interval for the wait functions, call the **timeGetDevCaps** function to determine the supported minimum timer resolution and the **timeBeginPeriod** function to set the timer resolution to its minimum.</span></span> <span data-ttu-id="ebc25-164">Будьте внимательны при вызове **тимебегинпериод**, так как частые вызовы могут существенно повлиять на системные часы, энергопотребление системы и планировщик.</span><span class="sxs-lookup"><span data-stu-id="ebc25-164">Use caution when calling **timeBeginPeriod**, as frequent calls can significantly affect the system clock, system power usage, and the scheduler.</span></span> <span data-ttu-id="ebc25-165">Если вы вызовите **тимебегинпериод**, вызовите его один раз в начале приложения и не забудьте вызвать функцию **тиминдпериод** в самом конце приложения.</span><span class="sxs-lookup"><span data-stu-id="ebc25-165">If you call **timeBeginPeriod**, call it one time early in the application and be sure to call the **timeEndPeriod** function at the very end of the application.</span></span>

## <a name="wait-functions-and-synchronization-objects"></a><span data-ttu-id="ebc25-166">Функции ожидания и объекты синхронизации</span><span class="sxs-lookup"><span data-stu-id="ebc25-166">Wait Functions and Synchronization Objects</span></span>

<span data-ttu-id="ebc25-167">Функции ожидания могут изменять состояния некоторых типов [объектов синхронизации](synchronization-objects.md).</span><span class="sxs-lookup"><span data-stu-id="ebc25-167">The wait functions can modify the states of some types of [synchronization objects](synchronization-objects.md).</span></span> <span data-ttu-id="ebc25-168">Изменение происходит только для объектов или объектов, сигнальное состояние которых привело к возврату функции.</span><span class="sxs-lookup"><span data-stu-id="ebc25-168">Modification occurs only for the object or objects whose signaled state caused the function to return.</span></span> <span data-ttu-id="ebc25-169">Функции ожидания могут изменять состояния объектов синхронизации следующим образом.</span><span class="sxs-lookup"><span data-stu-id="ebc25-169">Wait functions can modify the states of synchronization objects as follows:</span></span>

-   <span data-ttu-id="ebc25-170">Число объектов семафора уменьшается на единицу, а для состояния семафора устанавливается значение несигнальное, если его число равно нулю.</span><span class="sxs-lookup"><span data-stu-id="ebc25-170">The count of a semaphore object decreases by one, and the state of the semaphore is set to nonsignaled if its count is zero.</span></span>
-   <span data-ttu-id="ebc25-171">Состояния мьютекса, события автосброса и объектов уведомлений устанавливаются в несигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="ebc25-171">The states of mutex, auto-reset event, and change-notification objects are set to nonsignaled.</span></span>
-   <span data-ttu-id="ebc25-172">Для состояния таймера синхронизации задано несигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="ebc25-172">The state of a synchronization timer is set to nonsignaled.</span></span>
-   <span data-ttu-id="ebc25-173">Функции Wait не затрагивают состояния событий ручного сброса, таймера, процесса, потока и входных объектов консоли вручную.</span><span class="sxs-lookup"><span data-stu-id="ebc25-173">The states of manual-reset event, manual-reset timer, process, thread, and console input objects are not affected by a wait function.</span></span>

## <a name="wait-functions-and-creating-windows"></a><span data-ttu-id="ebc25-174">Функции Wait и создание окон</span><span class="sxs-lookup"><span data-stu-id="ebc25-174">Wait Functions and Creating Windows</span></span>

<span data-ttu-id="ebc25-175">Необходимо соблюдать осторожность при использовании функций ожидания и кода, который напрямую или косвенно создает Windows.</span><span class="sxs-lookup"><span data-stu-id="ebc25-175">You have to be careful when using the wait functions and code that directly or indirectly creates windows.</span></span> <span data-ttu-id="ebc25-176">Если поток создает какие-либо окна, он должен обрабатывать сообщения.</span><span class="sxs-lookup"><span data-stu-id="ebc25-176">If a thread creates any windows, it must process messages.</span></span> <span data-ttu-id="ebc25-177">Широковещательные сообщения отправляются во все окна системы.</span><span class="sxs-lookup"><span data-stu-id="ebc25-177">Message broadcasts are sent to all windows in the system.</span></span> <span data-ttu-id="ebc25-178">Если у вас есть поток, использующий функцию Wait без интервала ожидания, система взаимоблокируется.</span><span class="sxs-lookup"><span data-stu-id="ebc25-178">If you have a thread that uses a wait function with no time-out interval, the system will deadlock.</span></span> <span data-ttu-id="ebc25-179">Два примера кода, который косвенно создает окна — DDE и функция **CoInitialize** .</span><span class="sxs-lookup"><span data-stu-id="ebc25-179">Two examples of code that indirectly creates windows are DDE and the **CoInitialize** function.</span></span> <span data-ttu-id="ebc25-180">Поэтому при наличии потока, создающего окна, используйте [**мсгваитформултиплеобжектс**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects) или [**мсгваитформултиплеобжектсекс**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), а не другие функции Wait.</span><span class="sxs-lookup"><span data-stu-id="ebc25-180">Therefore, if you have a thread that creates windows, use [**MsgWaitForMultipleObjects**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects) or [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), rather than the other wait functions.</span></span>

 

 
