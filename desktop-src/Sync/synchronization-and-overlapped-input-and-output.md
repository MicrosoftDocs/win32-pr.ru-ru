---
description: Можно выполнять как синхронные, так и асинхронные (также называемые перекрывающиеся) операции ввода-вывода для файлов, именованных каналов и устройств с последовательным подключением.
ms.assetid: db44990e-5a0f-4153-8ff6-79dd7cda48af
title: Синхронизация и перекрытие входных и выходных данных
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e263bb39badc7cbfadd67d80eb169dc1fe6d6c35
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105664355"
---
# <a name="synchronization-and-overlapped-input-and-output"></a><span data-ttu-id="25aae-103">Синхронизация и перекрытие входных и выходных данных</span><span class="sxs-lookup"><span data-stu-id="25aae-103">Synchronization and Overlapped Input and Output</span></span>

<span data-ttu-id="25aae-104">Можно выполнять как синхронные, так и асинхронные (также называемые перекрывающиеся) операции ввода-вывода для файлов, именованных каналов и устройств с последовательным подключением.</span><span class="sxs-lookup"><span data-stu-id="25aae-104">You can perform either synchronous or asynchronous (also called overlapped) I/O operations on files, named pipes, and serial communications devices.</span></span> <span data-ttu-id="25aae-105">Функции [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile), [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile), [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol), [**ваиткоммевент**](/windows/win32/api/winbase/nf-winbase-waitcommevent), [**коннектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)и [**трансактнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) могут выполняться синхронно или асинхронно.</span><span class="sxs-lookup"><span data-stu-id="25aae-105">The [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile), [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile), [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol), [**WaitCommEvent**](/windows/win32/api/winbase/nf-winbase-waitcommevent), [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe), and [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) functions can be performed either synchronously or asynchronously.</span></span> <span data-ttu-id="25aae-106">Функции [**реадфиликс**](/windows/win32/api/fileapi/nf-fileapi-readfileex) и [**вритефиликс**](/windows/win32/api/fileapi/nf-fileapi-writefileex) могут выполняться только асинхронно.</span><span class="sxs-lookup"><span data-stu-id="25aae-106">The [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) functions can be performed only asynchronously.</span></span>

<span data-ttu-id="25aae-107">Когда функция выполняется синхронно, она не возвращает значение до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="25aae-107">When a function is executed synchronously, it does not return until the operation has been completed.</span></span> <span data-ttu-id="25aae-108">Это означает, что выполнение вызывающего потока может быть заблокировано в течение неопределенного периода времени, пока оно ожидает завершения длительной операции.</span><span class="sxs-lookup"><span data-stu-id="25aae-108">This means that the execution of the calling thread can be blocked for an indefinite period while it waits for a time-consuming operation to finish.</span></span> <span data-ttu-id="25aae-109">Функции, вызываемые для перекрывающейся операции, могут возвращаться немедленно, даже если операция не была завершена.</span><span class="sxs-lookup"><span data-stu-id="25aae-109">Functions called for overlapped operation can return immediately, even though the operation has not been completed.</span></span> <span data-ttu-id="25aae-110">Это позволяет выполнять трудоемкую операцию ввода-вывода в фоновом режиме, в то время как вызывающий поток может выполнять другие задачи.</span><span class="sxs-lookup"><span data-stu-id="25aae-110">This enables a time-consuming I/O operation to be executed in the background while the calling thread is free to perform other tasks.</span></span> <span data-ttu-id="25aae-111">Например, один поток может выполнять одновременные операции ввода-вывода с разными дескрипторами или даже одновременные операции чтения и записи с одним и тем же дескриптором.</span><span class="sxs-lookup"><span data-stu-id="25aae-111">For example, a single thread can perform simultaneous I/O operations on different handles, or even simultaneous read and write operations on the same handle.</span></span>

<span data-ttu-id="25aae-112">Чтобы синхронизировать выполнение с завершением перекрывающейся операции, вызывающий поток использует функцию [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) , функцию [**жетоверлаппедресултекс**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) или одну из [функций ожидания](wait-functions.md) , чтобы определить, когда была завершена операция перекрытия.</span><span class="sxs-lookup"><span data-stu-id="25aae-112">To synchronize its execution with the completion of the overlapped operation, the calling thread uses the [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) function, the [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) function, or one of the [wait functions](wait-functions.md) to determine when the overlapped operation has been completed.</span></span> <span data-ttu-id="25aae-113">Можно также использовать макрос [**хасоверлаппедиокомплетед**](/windows/desktop/api/WinBase/nf-winbase-hasoverlappediocompleted) для опроса завершения.</span><span class="sxs-lookup"><span data-stu-id="25aae-113">You can also use the [**HasOverlappedIoCompleted**](/windows/desktop/api/WinBase/nf-winbase-hasoverlappediocompleted) macro to poll for completion.</span></span>

<span data-ttu-id="25aae-114">Чтобы отменить все ожидающие асинхронные операции ввода-вывода, используйте функцию [**канцелиоекс**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) и предоставьте структуру [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) , указывающую запрос на отмену.</span><span class="sxs-lookup"><span data-stu-id="25aae-114">To cancel all pending asynchronous I/O operations, use the [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) function and provide an [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure that specifies the request to cancel.</span></span> <span data-ttu-id="25aae-115">Используйте функцию [**канцелио**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio) для отмены ожидающих асинхронных операций ввода-вывода, выданных вызывающим потоком для указанного маркера файла.</span><span class="sxs-lookup"><span data-stu-id="25aae-115">Use the [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio) function to cancel pending asynchronous I/O operations issued by the calling thread for the specified file handle.</span></span>

<span data-ttu-id="25aae-116">Для операций с перекрытием требуется файл, именованный канал или коммуникационное устройство, созданное с флагом " **\_ \_ Перекрытие флага файла** ".</span><span class="sxs-lookup"><span data-stu-id="25aae-116">Overlapped operations require a file, named pipe, or communications device that was created with the **FILE\_FLAG\_OVERLAPPED** flag.</span></span> <span data-ttu-id="25aae-117">Когда поток вызывает функцию (например, функцию [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) ) для выполнения операции перекрытия, вызывающий поток должен указать указатель на структуру [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="25aae-117">When a thread calls a function (such as the [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) function) to perform an overlapped operation, the calling thread must specify a pointer to an [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="25aae-118">(Если этот указатель равен **null**, возвращаемое значение функции может неправильно указывать на завершение операции.) Все члены **ПЕРЕкрывающейся** структуры должны быть инициализированы нулем, если только событие не будет использоваться для сигнализации о завершении операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="25aae-118">(If this pointer is **NULL**, the function return value may incorrectly indicate that the operation completed.) All of the members of the **OVERLAPPED** structure must be initialized to zero unless an event will be used to signal completion of an I/O operation.</span></span> <span data-ttu-id="25aae-119">Если используется событие, элемент **Хевент** структуры **OVERLAPPED** задает маркер для выделенного объекта события.</span><span class="sxs-lookup"><span data-stu-id="25aae-119">If an event is used, the **hEvent** member of the **OVERLAPPED** structure specifies a handle to the allocated event object.</span></span> <span data-ttu-id="25aae-120">Система Задает несигнальное состояние объекта события, когда вызов функции ввода-вывода возвращается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="25aae-120">The system sets the state of the event object to nonsignaled when a call to the I/O function returns before the operation has been completed.</span></span> <span data-ttu-id="25aae-121">Система устанавливает состояние объекта события, чтобы сообщить о завершении операции.</span><span class="sxs-lookup"><span data-stu-id="25aae-121">The system sets the state of the event object to signaled when the operation has been completed.</span></span> <span data-ttu-id="25aae-122">Событие требуется только в том случае, если в одно и то же время будет выполняться несколько необработанных операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="25aae-122">An event is needed only if there will be more than one outstanding I/O operation at the same time.</span></span> <span data-ttu-id="25aae-123">Если событие не используется, то каждая выполненная операция ввода-вывода будет сообщать файлу, именованному каналу или коммуникационному устройству.</span><span class="sxs-lookup"><span data-stu-id="25aae-123">If an event is not used, each completed I/O operation will signal the file, named pipe, or communications device.</span></span>

<span data-ttu-id="25aae-124">При вызове функции для выполнения операции перекрытия операция может быть завершена перед возвратом функции.</span><span class="sxs-lookup"><span data-stu-id="25aae-124">When a function is called to perform an overlapped operation, the operation might be completed before the function returns.</span></span> <span data-ttu-id="25aae-125">В этом случае результаты обрабатываются так, как если бы операция выполнялась синхронно.</span><span class="sxs-lookup"><span data-stu-id="25aae-125">When this happens, the results are handled as if the operation had been performed synchronously.</span></span> <span data-ttu-id="25aae-126">Однако если операция не была завершена, возвращаемое значение функции равно **false**, а функция [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) возвращает **\_ \_ Ожидание ввода-вывода ошибки**.</span><span class="sxs-lookup"><span data-stu-id="25aae-126">If the operation was not completed, however, the function's return value is **FALSE**, and the [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) function returns **ERROR\_IO\_PENDING**.</span></span>

<span data-ttu-id="25aae-127">Поток может управлять перекрывающейся операциями одним из двух методов:</span><span class="sxs-lookup"><span data-stu-id="25aae-127">A thread can manage overlapped operations by either of two methods:</span></span>

-   <span data-ttu-id="25aae-128">Используйте функцию [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) или [**жетоверлаппедресултекс**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) , чтобы дождаться завершения перекрывающейся операции.</span><span class="sxs-lookup"><span data-stu-id="25aae-128">Use the [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) or [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) function to wait for the overlapped operation to be completed.</span></span> <span data-ttu-id="25aae-129">Если используется **жетоверлаппедресултекс** , вызывающий поток может указать время ожидания для операции перекрытия или выполнить предупреждение.</span><span class="sxs-lookup"><span data-stu-id="25aae-129">If **GetOverlappedResultEx** is used, the calling thread can specify a timeout for the overlapped operation or perform an alertable wait.</span></span>
-   <span data-ttu-id="25aae-130">Укажите маркер для объекта события ручного [**сброса структуры в**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) одной из [функций ожидания](wait-functions.md) , а затем после возврата функции Wait вызовите [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) или [**жетоверлаппедресултекс**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex).</span><span class="sxs-lookup"><span data-stu-id="25aae-130">Specify a handle to the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure's manual-reset event object in one of the [wait functions](wait-functions.md) and then, after the wait function returns, call [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) or [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex).</span></span> <span data-ttu-id="25aae-131">Функция возвращает результаты завершенной операции перекрытия и для функций, в которых такая информация подходит, сообщает фактическое число переданных байтов.</span><span class="sxs-lookup"><span data-stu-id="25aae-131">The function returns the results of the completed overlapped operation, and for functions in which such information is appropriate, it reports the actual number of bytes that were transferred.</span></span>

<span data-ttu-id="25aae-132">При выполнении нескольких одновременных операций перекрытия в одном потоке вызывающий поток должен указать структуру [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) для каждой операции.</span><span class="sxs-lookup"><span data-stu-id="25aae-132">When performing multiple simultaneous overlapped operations on a single thread, the calling thread must specify an [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure for each operation.</span></span> <span data-ttu-id="25aae-133">Каждая **ПЕРЕкрывающаяся** структура должна задавать маркер для другого объекта события ручного сброса.</span><span class="sxs-lookup"><span data-stu-id="25aae-133">Each **OVERLAPPED** structure must specify a handle to a different manual-reset event object.</span></span> <span data-ttu-id="25aae-134">Чтобы дождаться завершения любой из перекрывающихся операций, поток указывает все обработчики событий ручного сброса в качестве критериев ожидания в одной из [функций ожидания](wait-functions.md)с несколькими объектами.</span><span class="sxs-lookup"><span data-stu-id="25aae-134">To wait for any one of the overlapped operations to be completed, the thread specifies all the manual-reset event handles as wait criteria in one of the multiple-object [wait functions](wait-functions.md).</span></span> <span data-ttu-id="25aae-135">Возвращаемое значение функции ожидания с несколькими объектами указывает, какой объект события ручного сброса был сигнальным, поэтому поток может определить, какая операция перекрытия привела к завершению операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="25aae-135">The return value of the multiple-object wait function indicates which manual-reset event object was signaled, so the thread can determine which overlapped operation caused the wait operation to be completed.</span></span>

<span data-ttu-id="25aae-136">Безопаснее использовать отдельный объект события для каждой перекрывающейся операции, а не указывать ни одного объекта события или повторно использовать один и тот же объект события для нескольких операций.</span><span class="sxs-lookup"><span data-stu-id="25aae-136">It is safer to use a separate event object for each overlapped operation, rather than specify no event object or reuse the same event object for multiple operations.</span></span> <span data-ttu-id="25aae-137">Если в структуре [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) не указан объект события, система сообщает о состоянии файла, именованного канала или коммуникационного устройства при завершении операции перекрытия.</span><span class="sxs-lookup"><span data-stu-id="25aae-137">If no event object is specified in the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure, the system signals the state of the file, named pipe, or communications device when the overlapped operation has been completed.</span></span> <span data-ttu-id="25aae-138">Таким образом, эти обработчики можно указать как объекты синхронизации в функции Wait, хотя их использование для этой цели может быть затруднено в управлении, так как при выполнении одновременных операций перекрытия на одном и том же файле, именованном канале или коммуникационном устройстве нет способа определить, какая операция привела к тому, что состояние объекта будет сигнальным.</span><span class="sxs-lookup"><span data-stu-id="25aae-138">Thus, you can specify these handles as synchronization objects in a wait function, though their use for this purpose can be difficult to manage because, when performing simultaneous overlapped operations on the same file, named pipe, or communications device, there is no way to know which operation caused the object's state to be signaled.</span></span>

<span data-ttu-id="25aae-139">Поток не должен повторно использовать событие с предположением, что событие будет сигнальным только операцией перекрытия этого потока.</span><span class="sxs-lookup"><span data-stu-id="25aae-139">A thread should not reuse an event with the assumption that the event will be signaled only by that thread's overlapped operation.</span></span> <span data-ttu-id="25aae-140">Событие получает сигнал в том же потоке, что и перекрывающаяся операция, которая завершается.</span><span class="sxs-lookup"><span data-stu-id="25aae-140">An event is signaled on the same thread as the overlapped operation that is completing.</span></span> <span data-ttu-id="25aae-141">Использование одного и того же события в нескольких потоках может привести к возникновению состояния гонки, в котором событие правильно сообщается для потока, операция которого завершается в первый и преждевременно для других потоков, использующих это событие.</span><span class="sxs-lookup"><span data-stu-id="25aae-141">Using the same event on multiple threads can lead to a race condition in which the event is signaled correctly for the thread whose operation completes first and prematurely for other threads using that event.</span></span> <span data-ttu-id="25aae-142">Затем, когда завершается следующая операция перекрытия, событие снова получает сигнал для всех потоков, использующих это событие, и так далее до тех пор, пока все перекрывающиеся операции не будут выполнены.</span><span class="sxs-lookup"><span data-stu-id="25aae-142">Then, when the next overlapped operation completes, the event is signaled again for all threads using that event, and so on until all overlapped operations are complete.</span></span>

<span data-ttu-id="25aae-143">Примеры, иллюстрирующие использование перекрывающихся операций, подпрограмм завершения и функции [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) , см. в разделе [использование каналов](../ipc/using-pipes.md).</span><span class="sxs-lookup"><span data-stu-id="25aae-143">For examples that illustrate the use of overlapped operations, completion routines, and the [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) function, see [Using Pipes](../ipc/using-pipes.md).</span></span>

<span data-ttu-id="25aae-144">\* \* Windows Vista, Windows Server 2003 и Windows XP: \* \*</span><span class="sxs-lookup"><span data-stu-id="25aae-144">\*\*Windows Vista, Windows Server 2003 and Windows XP:  \*\*</span></span>

<span data-ttu-id="25aae-145">Будьте внимательны при повторном использовании структур с [**ПЕРЕкрытием**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="25aae-145">Be careful when reusing [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structures.</span></span> <span data-ttu-id="25aae-146">Если **перекрывающиеся** структуры используются повторно в нескольких потоках, а [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) вызывается с параметром *Бваит* , для которого установлено **значение true**, вызывающий поток должен убедиться, что соответствующее событие сигнально, прежде чем повторно использовать структуру.</span><span class="sxs-lookup"><span data-stu-id="25aae-146">If **OVERLAPPED** structures are reused on multiple threads and [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) is called with the *bWait* parameter set to **TRUE**, the calling thread must ensure that the associated event is signaled before reusing the structure.</span></span> <span data-ttu-id="25aae-147">Это можно сделать с помощью функции [**WaitForSingleObject**](/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject) после вызова **GetOverlappedResult** , чтобы заставить поток ожидать завершения операции.</span><span class="sxs-lookup"><span data-stu-id="25aae-147">This can be accomplished by using the [**WaitForSingleObject**](/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject) function after calling **GetOverlappedResult** to force the thread to wait until the operation completes.</span></span> <span data-ttu-id="25aae-148">Обратите внимание, что объект события должен быть объектом события ручного сброса.</span><span class="sxs-lookup"><span data-stu-id="25aae-148">Note that the event object must be a manual-reset event object.</span></span> <span data-ttu-id="25aae-149">Если используется объект события автосброса, вызов **GetOverlappedResult** с параметром *бваит* , установленным в **значение true** , приводит к тому, что функция блокируется на неопределенное время.</span><span class="sxs-lookup"><span data-stu-id="25aae-149">If an autoreset event object is used, calling **GetOverlappedResult** with the *bWait* parameter set to **TRUE** causes the function to be blocked indefinitely.</span></span> <span data-ttu-id="25aae-150">Это поведение изменилось начиная с Windows 7 и Windows Server 2008 R2 для приложений, которые задают Windows 7 в качестве поддерживаемой операционной системы в манифесте приложения.</span><span class="sxs-lookup"><span data-stu-id="25aae-150">This behavior changed starting with Windows 7 and Windows Server 2008 R2 for applications that specify Windows 7 as the supported operating system in the application manifest.</span></span> <span data-ttu-id="25aae-151">Дополнительные сведения см. в разделе [манифесты приложений](/previous-versions/windows/desktop/adrms_sdk/application-manifests).</span><span class="sxs-lookup"><span data-stu-id="25aae-151">For more information see [Application Manifests](/previous-versions/windows/desktop/adrms_sdk/application-manifests).</span></span>

## <a name="related-topics"></a><span data-ttu-id="25aae-152">См. также</span><span class="sxs-lookup"><span data-stu-id="25aae-152">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="25aae-153">Основные понятия ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="25aae-153">I/O Concepts</span></span>](../fileio/i-o-concepts.md)
</dt> </dl>

 

 
