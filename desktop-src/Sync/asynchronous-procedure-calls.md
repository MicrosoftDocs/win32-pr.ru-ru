---
description: Асинхронный вызов процедур (APC) — это функция, которая выполняется асинхронно в контексте определенного потока.
ms.assetid: 0197d78e-a4dc-414b-88ba-c5ec5f2ed614
title: Асинхронные вызовы процедур
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dd95e9afd663e2a462335b3c47bfe99462b449e7
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "103999007"
---
# <a name="asynchronous-procedure-calls"></a><span data-ttu-id="284e6-103">Асинхронные вызовы процедур</span><span class="sxs-lookup"><span data-stu-id="284e6-103">Asynchronous Procedure Calls</span></span>

<span data-ttu-id="284e6-104">*Асинхронный вызов процедур* (APC) — это функция, которая выполняется асинхронно в контексте определенного потока.</span><span class="sxs-lookup"><span data-stu-id="284e6-104">An *asynchronous procedure call* (APC) is a function that executes asynchronously in the context of a particular thread.</span></span> <span data-ttu-id="284e6-105">Когда компания APC помещается в очередь потока, система выдает программное прерывание.</span><span class="sxs-lookup"><span data-stu-id="284e6-105">When an APC is queued to a thread, the system issues a software interrupt.</span></span> <span data-ttu-id="284e6-106">При следующем запланированном потоке будет запущена функция APC.</span><span class="sxs-lookup"><span data-stu-id="284e6-106">The next time the thread is scheduled, it will run the APC function.</span></span> <span data-ttu-id="284e6-107">Компания APC, созданная системой, называется *режимом ядра APC*.</span><span class="sxs-lookup"><span data-stu-id="284e6-107">An APC generated by the system is called a *kernel-mode APC*.</span></span> <span data-ttu-id="284e6-108">Компания APC, созданная приложением, называется *пользовательским режимом APC*.</span><span class="sxs-lookup"><span data-stu-id="284e6-108">An APC generated by an application is called a *user-mode APC*.</span></span> <span data-ttu-id="284e6-109">Поток должен находиться в состоянии оповещения для запуска в пользовательском режиме.</span><span class="sxs-lookup"><span data-stu-id="284e6-109">A thread must be in an alertable state to run a user-mode APC.</span></span>

<span data-ttu-id="284e6-110">Каждый поток имеет собственную очередь APC.</span><span class="sxs-lookup"><span data-stu-id="284e6-110">Each thread has its own APC queue.</span></span> <span data-ttu-id="284e6-111">Приложение помещает в очередь APC в поток, вызывая функцию [**куеуеусерапк**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) .</span><span class="sxs-lookup"><span data-stu-id="284e6-111">An application queues an APC to a thread by calling the [**QueueUserAPC**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) function.</span></span> <span data-ttu-id="284e6-112">Вызывающий поток задает адрес функции APC в вызове **куеуеусерапк**.</span><span class="sxs-lookup"><span data-stu-id="284e6-112">The calling thread specifies the address of an APC function in the call to **QueueUserAPC**.</span></span> <span data-ttu-id="284e6-113">Очередь APC является запросом потока на вызов функции APC.</span><span class="sxs-lookup"><span data-stu-id="284e6-113">The queuing of an APC is a request for the thread to call the APC function.</span></span>

<span data-ttu-id="284e6-114">При постановке в очередь пользовательского режима APC поток, в котором он находится в очереди, не направляется на вызов функции APC, если он не находится в состоянии оповещения.</span><span class="sxs-lookup"><span data-stu-id="284e6-114">When a user-mode APC is queued, the thread to which it is queued is not directed to call the APC function unless it is in an alertable state.</span></span> <span data-ttu-id="284e6-115">Поток входит в состояние оповещения при вызове функции [**слипекс**](/windows/win32/api/synchapi/nf-synchapi-sleepex), [**сигналобжектандваит**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**мсгваитформултиплеобжектсекс**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**ваитформултиплеобжектсекс**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex)или [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) .</span><span class="sxs-lookup"><span data-stu-id="284e6-115">A thread enters an alertable state when it calls the [**SleepEx**](/windows/win32/api/synchapi/nf-synchapi-sleepex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex), or [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) function.</span></span> <span data-ttu-id="284e6-116">Если ожидание достигнуто до постановки в очередь APC, поток больше не находится в состоянии ожидания с оповещением, поэтому функция APC не будет выполняться.</span><span class="sxs-lookup"><span data-stu-id="284e6-116">If the wait is satisfied before the APC is queued, the thread is no longer in an alertable wait state so the APC function will not be executed.</span></span> <span data-ttu-id="284e6-117">Однако компания APC по-прежнему находится в очереди, поэтому функция APC будет выполняться, когда поток вызовет другую функцию ожидания с оповещением.</span><span class="sxs-lookup"><span data-stu-id="284e6-117">However, the APC is still queued, so the APC function will be executed when the thread calls another alertable wait function.</span></span>

<span data-ttu-id="284e6-118">Функции [**реадфиликс**](/windows/win32/api/fileapi/nf-fileapi-readfileex), [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer), [**сетваитаблетимерекс**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex)и [**вритефиликс**](/windows/win32/api/fileapi/nf-fileapi-writefileex) реализуются с помощью APC в качестве механизма обратного вызова уведомлений о завершении.</span><span class="sxs-lookup"><span data-stu-id="284e6-118">The [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex), [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer), [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), and [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) functions are implemented using an APC as the completion notification callback mechanism.</span></span>

<span data-ttu-id="284e6-119">При использовании [пула потоков](../procthread/thread-pools.md)Обратите внимание, что APC не работает, а также другие механизмы сигнализации, поскольку система управляет временем существования потоков пула потоков, поэтому поток может быть завершен до доставки уведомления.</span><span class="sxs-lookup"><span data-stu-id="284e6-119">If you are using a [thread pool](../procthread/thread-pools.md), note that APCs do not work as well as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span> <span data-ttu-id="284e6-120">Вместо использования механизма сигнализации на основе APC, такого как параметр *Пфнкомплетионраутине* [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) или [**сетваитаблетимерекс**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), используйте ожидающий объект, например таймер, созданный с помощью [**креатесреадпултимер**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer).</span><span class="sxs-lookup"><span data-stu-id="284e6-120">Instead of using an APC-based signaling mechanism such as the *pfnCompletionRoutine* parameter of [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) or [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), use a waitable object such as a timer created with [**CreateThreadpoolTimer**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer).</span></span> <span data-ttu-id="284e6-121">Для ввода-вывода используйте объект завершения ввода-вывода, созданный с помощью [**креатесреадпулио**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) , или *Хевент* структуру с [**перекрытием**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) , где событие может быть передано в функцию [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) .</span><span class="sxs-lookup"><span data-stu-id="284e6-121">For I/O, use an I/O completion object created with [**CreateThreadpoolIo**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) or an *hEvent*-based [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure where the event can be passed to the [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) function.</span></span>

## <a name="synchronization-internals"></a><span data-ttu-id="284e6-122">Внутренние компоненты синхронизации</span><span class="sxs-lookup"><span data-stu-id="284e6-122">Synchronization Internals</span></span>

<span data-ttu-id="284e6-123">При выдаче запроса ввода-вывода структура выделяется для представления запроса.</span><span class="sxs-lookup"><span data-stu-id="284e6-123">When an I/O request is issued, a structure is allocated to represent the request.</span></span> <span data-ttu-id="284e6-124">Эта структура называется пакетом запросов ввода-вывода (IRP).</span><span class="sxs-lookup"><span data-stu-id="284e6-124">This structure is called an I/O request packet (IRP).</span></span> <span data-ttu-id="284e6-125">При синхронном вводе-выводе поток создает IRP, отправляет его в стек устройств и ожидает завершения запроса IRP в ядре.</span><span class="sxs-lookup"><span data-stu-id="284e6-125">With synchronous I/O, the thread builds the IRP, sends it to the device stack, and waits in the kernel for the IRP to complete.</span></span> <span data-ttu-id="284e6-126">При асинхронном вводе-выводе поток создает IRP и отправляет его в стек устройств.</span><span class="sxs-lookup"><span data-stu-id="284e6-126">With asynchronous I/O, the thread builds the IRP and sends it to the device stack.</span></span> <span data-ttu-id="284e6-127">Стек может немедленно завершить IRP, или же он может вернуть состояние ожидания, указывающее на то, что запрос выполняется.</span><span class="sxs-lookup"><span data-stu-id="284e6-127">The stack might complete the IRP immediately, or it might return a pending status indicating that the request is in progress.</span></span> <span data-ttu-id="284e6-128">В этом случае IRP по-прежнему связывается с потоком, поэтому он будет отменен, если поток завершится или вызовет функцию, например [**канцелио**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio).</span><span class="sxs-lookup"><span data-stu-id="284e6-128">When this happens, the IRP is still associated with the thread, so it will be canceled if the thread terminates or calls a function such as [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio).</span></span> <span data-ttu-id="284e6-129">Тем временем поток может продолжать выполнять другие задачи, пока стек устройств продолжает обрабатывать IRP.</span><span class="sxs-lookup"><span data-stu-id="284e6-129">In the meantime, the thread can continue to perform other tasks while the device stack continues to process the IRP.</span></span>

<span data-ttu-id="284e6-130">Существует несколько способов, которые система может указать на завершение IRP:</span><span class="sxs-lookup"><span data-stu-id="284e6-130">There are several ways that the system can indicate that the IRP has completed:</span></span>

-   <span data-ttu-id="284e6-131">Обновите перекрытый структуру с помощью результата операции, чтобы поток мог опросить, чтобы определить, завершена ли операция.</span><span class="sxs-lookup"><span data-stu-id="284e6-131">Update the overlapped structure with the result of the operation so the thread can poll to determine whether the operation has completed.</span></span>
-   <span data-ttu-id="284e6-132">Сигнализирует о событии в структуре OVERLAPPED, чтобы поток мог синхронизироваться с событием и пробуждении по завершении операции.</span><span class="sxs-lookup"><span data-stu-id="284e6-132">Signal the event in the overlapped structure so a thread can synchronize on the event and be woken when the operation completes.</span></span>
-   <span data-ttu-id="284e6-133">Помещает IRP в очередь ожидающего потока APC, чтобы поток выполнит процедуру APC при входе в состояние ожидания с оповещением и возвращал из операции ожидания с состоянием, указывающим на то, что выполнялась одна или несколько подпрограмм APC.</span><span class="sxs-lookup"><span data-stu-id="284e6-133">Queue the IRP to the thread's pending APC so that the thread will execute the APC routine when it enters an alertable wait state and return from the wait operation with a status indicating that it executed one or more APC routines.</span></span>
-   <span data-ttu-id="284e6-134">Помещает IRP в очередь на порт завершения ввода-вывода, где он будет выполняться следующим потоком, ожидающим порт завершения.</span><span class="sxs-lookup"><span data-stu-id="284e6-134">Queue the IRP to an I/O completion port, where it will be executed by the next thread that waits on the completion port.</span></span>

<span data-ttu-id="284e6-135">Потоки, ожидающие передачи данных на порт завершения ввода-вывода, не ожидают состояния, доступного для оповещения.</span><span class="sxs-lookup"><span data-stu-id="284e6-135">Threads that wait on an I/O completion port do not wait in an alertable state.</span></span> <span data-ttu-id="284e6-136">Таким образом, если эти потоки выдают запросы IRP, настроенные для завершения как APC в потоке, эти завершения IPC не будут выполняться своевременно. они будут выполняться только в том случае, если поток получает запрос от порта завершения ввода-вывода, а затем выводит предупреждение.</span><span class="sxs-lookup"><span data-stu-id="284e6-136">Therefore, if those threads issue IRPs that are set to complete as APCs to the thread, those IPC completions will not occur in a timely manner; they will occur only if the thread picks up a request from the I/O completion port and then happens to enter an alertable wait.</span></span>

## <a name="related-topics"></a><span data-ttu-id="284e6-137">См. также</span><span class="sxs-lookup"><span data-stu-id="284e6-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="284e6-138">Использование ожидающего таймера с асинхронным вызовом процедуры</span><span class="sxs-lookup"><span data-stu-id="284e6-138">Using a Waitable Timer with an Asynchronous Procedure Call</span></span>](using-a-waitable-timer-with-an-asynchronous-procedure-call.md)
</dt> </dl>

 

 
