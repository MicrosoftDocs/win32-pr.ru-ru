---
description: Компоненты часто предназначены для выполнения задач инициализации при первом вызове, а не при их загрузке.
ms.assetid: 404c083c-7bee-44c2-b8e7-da1901b6ab2f
title: Инициализация One-Time
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 16f451e3c51716b4ff6f33b55d8d8602b5d5c28f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105664519"
---
# <a name="one-time-initialization"></a><span data-ttu-id="842c9-103">Инициализация One-Time</span><span class="sxs-lookup"><span data-stu-id="842c9-103">One-Time Initialization</span></span>

<span data-ttu-id="842c9-104">Компоненты часто предназначены для выполнения задач инициализации при первом вызове, а не при их загрузке.</span><span class="sxs-lookup"><span data-stu-id="842c9-104">Components are often designed to perform initialization tasks when they are first called, rather than when they are loaded.</span></span> <span data-ttu-id="842c9-105">Функции однократной инициализации гарантируют, что инициализация выполняется только один раз, даже если несколько потоков могут попытаться выполнить инициализацию.</span><span class="sxs-lookup"><span data-stu-id="842c9-105">The one-time initialization functions ensure that this initialization occurs only once, even when multiple threads may attempt the initialization.</span></span>

<span data-ttu-id="842c9-106">**Windows Server 2003 и Windows XP:** Приложения должны предоставлять собственную синхронизацию для однократной инициализации с помощью [блокируемых функций](interlocked-variable-access.md) или другого механизма синхронизации.</span><span class="sxs-lookup"><span data-stu-id="842c9-106">**Windows Server 2003 and Windows XP:** Applications must provide their own synchronization for one-time initialization by using the [interlocked functions](interlocked-variable-access.md) or other synchronization mechanism.</span></span> <span data-ttu-id="842c9-107">Функции однократной инициализации доступны начиная с Windows Vista и Windows Server 2008.</span><span class="sxs-lookup"><span data-stu-id="842c9-107">The one-time initialization functions are available starting with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="842c9-108">Функции однократной инициализации предоставляют значительные преимущества, чтобы гарантировать, что только один поток выполняет инициализацию:</span><span class="sxs-lookup"><span data-stu-id="842c9-108">The one-time initialization functions provide significant advantages to ensure that only one thread performs the initialization:</span></span>

-   <span data-ttu-id="842c9-109">Они оптимизированы для ускорения.</span><span class="sxs-lookup"><span data-stu-id="842c9-109">They are optimized for speed.</span></span>
-   <span data-ttu-id="842c9-110">Они создают соответствующие барьеры на архитектуре процессора, которые им требуются.</span><span class="sxs-lookup"><span data-stu-id="842c9-110">They create the appropriate barriers on processor architectures that require them.</span></span>
-   <span data-ttu-id="842c9-111">Они поддерживают как блокировку, так и параллельную инициализацию.</span><span class="sxs-lookup"><span data-stu-id="842c9-111">They support both locked and parallel initialization.</span></span>
-   <span data-ttu-id="842c9-112">Они позволяют избежать внутренней блокировки, чтобы код мог выполняться асинхронно или синхронно.</span><span class="sxs-lookup"><span data-stu-id="842c9-112">They avoid internal locking so the code can operate asynchronously or synchronously.</span></span>

<span data-ttu-id="842c9-113">Система управляет процессом инициализации с помощью непрозрачной **инициализации \_ после** структуры, содержащей данные и сведения о состоянии.</span><span class="sxs-lookup"><span data-stu-id="842c9-113">The system manages the initialization process through an opaque **INIT\_ONCE** structure that contains data and state information.</span></span> <span data-ttu-id="842c9-114">Вызывающий объект выделяет эту структуру и инициализирует ее путем вызова [**инитонцеинитиализе**](/windows/win32/api/synchapi/nf-synchapi-initonceinitialize) (для динамической инициализации структуры) или присваивания константной **инициализации \_ после \_ статической \_ инициализации** переменной структуры (для статической инициализации структуры).</span><span class="sxs-lookup"><span data-stu-id="842c9-114">The caller allocates this structure and initializes it by either calling [**InitOnceInitialize**](/windows/win32/api/synchapi/nf-synchapi-initonceinitialize) (to initialize the structure dynamically) or assigning the constant **INIT\_ONCE\_STATIC\_INIT** to the structure variable (to initialize the structure statically).</span></span> <span data-ttu-id="842c9-115">Изначально данные, хранящиеся в структуре одноразовой инициализации, имеют значение NULL и ее состояние не инициализировано.</span><span class="sxs-lookup"><span data-stu-id="842c9-115">Initially, the data stored in the one-time initialization structure is NULL and its state is uninitialized.</span></span>

<span data-ttu-id="842c9-116">Структуры однократной инициализации нельзя совместно использовать между процессами.</span><span class="sxs-lookup"><span data-stu-id="842c9-116">One-time initialization structures cannot be shared across processes.</span></span>

<span data-ttu-id="842c9-117">Поток, выполняющий инициализацию, может дополнительно задать контекст, доступный вызывающему объекту после завершения инициализации.</span><span class="sxs-lookup"><span data-stu-id="842c9-117">The thread that performs the initialization can optionally set a context that is available to the caller after initialization is complete.</span></span> <span data-ttu-id="842c9-118">Контекстом может быть объект синхронизации, который может быть значением или структурой данных.</span><span class="sxs-lookup"><span data-stu-id="842c9-118">The context can be a synchronization object or it can be a value or data structure.</span></span> <span data-ttu-id="842c9-119">Если контекст является значением, его инициализация с низким порядком **\_ после \_ CTX \_ зарезервированных \_ битов** должна равняться нулю.</span><span class="sxs-lookup"><span data-stu-id="842c9-119">If the context is a value, its low-order **INIT\_ONCE\_CTX\_RESERVED\_BITS** must be zero.</span></span> <span data-ttu-id="842c9-120">Если контекст является структурой данных, структура данных должна быть выровняйтеся по **двойному значению**.</span><span class="sxs-lookup"><span data-stu-id="842c9-120">If the context is a data structure, the data structure must be **DWORD**-aligned.</span></span> <span data-ttu-id="842c9-121">Контекст возвращается вызывающему объекту в выходном параметре *lpContext* функции [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) или [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) .</span><span class="sxs-lookup"><span data-stu-id="842c9-121">The context is returned to the caller in the *lpContext* output parameter of the [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) or [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) function.</span></span>

<span data-ttu-id="842c9-122">Однократную инициализацию можно выполнять синхронно или асинхронно.</span><span class="sxs-lookup"><span data-stu-id="842c9-122">One-time initialization can be performed synchronously or asynchronously.</span></span> <span data-ttu-id="842c9-123">Необязательная функция обратного вызова может использоваться для синхронной однократной инициализации.</span><span class="sxs-lookup"><span data-stu-id="842c9-123">An optional callback function can be used for synchronous one-time initialization.</span></span>

## <a name="synchronous-one-time-initialization"></a><span data-ttu-id="842c9-124">Синхронная однократная инициализация</span><span class="sxs-lookup"><span data-stu-id="842c9-124">Synchronous One-time Initialization</span></span>

<span data-ttu-id="842c9-125">Следующие шаги описывают синхронную однократную инициализацию, которая не использует функцию обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="842c9-125">The following steps describe synchronous one-time initialization that does not use a callback function.</span></span>

1.  <span data-ttu-id="842c9-126">Первый поток для вызова функции [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) успешно запускает однократную инициализацию.</span><span class="sxs-lookup"><span data-stu-id="842c9-126">The first thread to call the [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) function successfully causes one-time initialization to begin.</span></span> <span data-ttu-id="842c9-127">Для синхронной однократной инициализации **InitOnceBeginInitialize** должен вызываться без флага **инициализации \_ \_ Async** .</span><span class="sxs-lookup"><span data-stu-id="842c9-127">For synchronous one-time initialization, **InitOnceBeginInitialize** must be called without the **INIT\_ONCE\_ASYNC** flag.</span></span>
2.  <span data-ttu-id="842c9-128">Последующие потоки, которые пытаются инициализировать инициализацию, блокируются до тех пор, пока первый поток не завершит инициализацию или не завершится ошибкой</span><span class="sxs-lookup"><span data-stu-id="842c9-128">Subsequent threads that attempt initialization are blocked until the first thread either completes initialization or fails.</span></span> <span data-ttu-id="842c9-129">Если первый поток завершается ошибкой, следующий поток разрешается выполнить инициализацию и т. д.</span><span class="sxs-lookup"><span data-stu-id="842c9-129">If the first thread fails, the next thread is allowed to attempt the initialization, and so on.</span></span>
3.  <span data-ttu-id="842c9-130">После завершения инициализации поток вызывает функцию [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) .</span><span class="sxs-lookup"><span data-stu-id="842c9-130">When initialization is finished, the thread calls the [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) function.</span></span> <span data-ttu-id="842c9-131">Поток может при необходимости создать объект синхронизации (или другие данные контекста) и указать его в параметре *lpContext* функции **InitOnceComplete** .</span><span class="sxs-lookup"><span data-stu-id="842c9-131">The thread can optionally create a synchronization object (or other context data) and specify it in the *lpContext* parameter of the **InitOnceComplete** function.</span></span>
4.  <span data-ttu-id="842c9-132">Если инициализация завершилась с ошибкой, то состояние структуры одноразовой инициализации изменяется на инициализировано, а обработчик *lpContext* (если таковой имеется) хранится в структуре инициализации.</span><span class="sxs-lookup"><span data-stu-id="842c9-132">If the initialization succeeds, the state of the one-time initialization structure is changed to initialized and the *lpContext* handle (if any) is stored in the initialization structure.</span></span> <span data-ttu-id="842c9-133">Последующие попытки инициализации возвращают данные контекста.</span><span class="sxs-lookup"><span data-stu-id="842c9-133">Subsequent initialization attempts return this context data.</span></span> <span data-ttu-id="842c9-134">Если инициализация завершается неудачно, данные имеют **значение NULL**.</span><span class="sxs-lookup"><span data-stu-id="842c9-134">If the initialization fails, the data is **NULL**.</span></span>

<span data-ttu-id="842c9-135">Следующие шаги описывают синхронную однократную инициализацию, которая использует функцию обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="842c9-135">The following steps describe synchronous one-time initialization that uses a callback function.</span></span>

1.  <span data-ttu-id="842c9-136">Первый поток для успешного вызова функции [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) передает указатель на определяемую приложением функцию обратного вызова [*инитонцекаллбакк*](/windows/win32/api/synchapi/nc-synchapi-pinit_once_fn) и любые данные, необходимые для функции обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="842c9-136">The first thread to successfully call the [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) function passes a pointer to an application-defined [*InitOnceCallback*](/windows/win32/api/synchapi/nc-synchapi-pinit_once_fn) callback function and any data required by the callback function.</span></span> <span data-ttu-id="842c9-137">Если вызов выполняется, функция обратного вызова *инитонцекаллбакк* выполняется.</span><span class="sxs-lookup"><span data-stu-id="842c9-137">If the call succeeds, the *InitOnceCallback* callback function executes.</span></span>
2.  <span data-ttu-id="842c9-138">Последующие потоки, которые пытаются инициализировать инициализацию, блокируются до тех пор, пока первый поток не завершит инициализацию или не завершится ошибкой</span><span class="sxs-lookup"><span data-stu-id="842c9-138">Subsequent threads that attempt initialization are blocked until the first thread either completes initialization or fails.</span></span> <span data-ttu-id="842c9-139">Если первый поток завершается ошибкой, следующий поток разрешается выполнить инициализацию и т. д.</span><span class="sxs-lookup"><span data-stu-id="842c9-139">If the first thread fails, the next thread is allowed to attempt the initialization, and so on.</span></span>
3.  <span data-ttu-id="842c9-140">После завершения инициализации функция обратного вызова возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="842c9-140">When initialization is finished, the callback function returns.</span></span> <span data-ttu-id="842c9-141">Функция обратного вызова может при необходимости создать объект синхронизации (или другие данные контекста) и указать его в выходном параметре *контекста* .</span><span class="sxs-lookup"><span data-stu-id="842c9-141">The callback function can optionally create a synchronization object (or other context data) and specify it in its *Context* output parameter.</span></span>
4.  <span data-ttu-id="842c9-142">Если инициализация завершилась с ошибкой, то состояние структуры одноразовой инициализации изменяется на инициализировано и обработчик *контекста* (если таковой имеется) хранится в структуре инициализации.</span><span class="sxs-lookup"><span data-stu-id="842c9-142">If the initialization succeeds, the state of the one-time initialization structure is changed to initialized and the *Context* handle (if any) is stored in the initialization structure.</span></span> <span data-ttu-id="842c9-143">Последующие попытки инициализации возвращают данные контекста.</span><span class="sxs-lookup"><span data-stu-id="842c9-143">Subsequent initialization attempts return this context data.</span></span> <span data-ttu-id="842c9-144">Если инициализация завершается неудачно, данные имеют **значение NULL**.</span><span class="sxs-lookup"><span data-stu-id="842c9-144">If the initialization fails, the data is **NULL**.</span></span>

## <a name="asynchronous-one-time-initialization"></a><span data-ttu-id="842c9-145">Асинхронная однократная инициализация</span><span class="sxs-lookup"><span data-stu-id="842c9-145">Asynchronous One-time Initialization</span></span>

<span data-ttu-id="842c9-146">Следующие шаги описывают асинхронную однократную инициализацию.</span><span class="sxs-lookup"><span data-stu-id="842c9-146">The following steps describe asynchronous one-time initialization.</span></span>

1.  <span data-ttu-id="842c9-147">Если несколько потоков одновременно пытаются начать инициализацию, вызвав [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) с параметром **init \_ Once \_**, функция будет выполнена для всех потоков, у которых для параметра *fPending* задано значение **true**.</span><span class="sxs-lookup"><span data-stu-id="842c9-147">If multiple threads simultaneously attempt to begin initialization by calling [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) with **INIT\_ONCE\_ASYNC**, the function succeeds for all of the threads with the *fPending* parameter set to **TRUE**.</span></span> <span data-ttu-id="842c9-148">Только один поток на самом деле завершится с инициализацией; другие одновременные попытки не изменяют состояние инициализации.</span><span class="sxs-lookup"><span data-stu-id="842c9-148">Only one thread will actually succeed at initialization; other concurrent attempts do not change the initialization state.</span></span>
2.  <span data-ttu-id="842c9-149">Когда [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) возвращает, параметр *fPending* указывает состояние инициализации:</span><span class="sxs-lookup"><span data-stu-id="842c9-149">When [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) returns, the *fPending* parameter indicates the initialization status:</span></span>
    -   <span data-ttu-id="842c9-150">Если *fPending* имеет **значение false**, то один поток был успешно инициализирован при инициализации.</span><span class="sxs-lookup"><span data-stu-id="842c9-150">If *fPending* is **FALSE**, one thread has succeeded at initialization.</span></span> <span data-ttu-id="842c9-151">Другие потоки должны очистить все созданные ими контекстные данные и использовать данные контекста в выходном параметре *lpContext* объекта [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize).</span><span class="sxs-lookup"><span data-stu-id="842c9-151">Other threads should clean up any context data they have created and use the context data in the *lpContext* output parameter of [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize).</span></span>
    -   <span data-ttu-id="842c9-152">Если *fPending* имеет **значение true**, инициализация еще не завершена и другие потоки должны продолжить работу.</span><span class="sxs-lookup"><span data-stu-id="842c9-152">If *fPending* is **TRUE**, initialization has not yet completed and other threads should continue.</span></span>
3.  <span data-ttu-id="842c9-153">Каждый поток вызывает функцию [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) .</span><span class="sxs-lookup"><span data-stu-id="842c9-153">Each thread calls the [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) function.</span></span> <span data-ttu-id="842c9-154">Поток может при необходимости создать объект синхронизации (или другие данные контекста) и указать его в параметре *lpContext* объекта **InitOnceComplete**.</span><span class="sxs-lookup"><span data-stu-id="842c9-154">The thread can optionally create a synchronization object (or other context data) and specify it in the *lpContext* parameter of **InitOnceComplete**.</span></span>
4.  <span data-ttu-id="842c9-155">Когда [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) возвращает, его возвращаемое значение указывает, был ли вызывающий поток завершен при инициализации.</span><span class="sxs-lookup"><span data-stu-id="842c9-155">When [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) returns, its return value indicates whether the calling thread succeeded at initialization.</span></span>
    -   <span data-ttu-id="842c9-156">Если [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) завершается успешно, вызывающий поток успешно завершил инициализацию.</span><span class="sxs-lookup"><span data-stu-id="842c9-156">If [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) succeeds, the calling thread has succeeded at initialization.</span></span> <span data-ttu-id="842c9-157">Состояние структуры одноразовой инициализации изменяется на инициализировано, а обработчик *lpContext* (если таковой имеется) хранится в структуре инициализации.</span><span class="sxs-lookup"><span data-stu-id="842c9-157">The state of the one-time initialization structure is changed to initialized and the *lpContext* handle (if any) is stored in the initialization structure.</span></span>
    -   <span data-ttu-id="842c9-158">Если [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) завершается сбоем, то другой поток был успешным при инициализации.</span><span class="sxs-lookup"><span data-stu-id="842c9-158">If [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) fails, another thread has succeeded at initialization.</span></span> <span data-ttu-id="842c9-159">Вызывающий поток должен очистить все созданные данные контекста и вызвать [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) с **init \_ \_ \_ только один раз** , чтобы получить все данные контекста, хранящиеся в структуре одноразовой инициализации.</span><span class="sxs-lookup"><span data-stu-id="842c9-159">The calling thread should clean up any context data it has created and call [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) with **INIT\_ONCE\_CHECK\_ONLY** to retrieve any context data stored in the one-time initialization structure.</span></span>

## <a name="calling-one-time-initialization-from-multiple-sites"></a><span data-ttu-id="842c9-160">Вызов инициализации One-Time из нескольких сайтов</span><span class="sxs-lookup"><span data-stu-id="842c9-160">Calling One-Time Initialization from multiple sites</span></span>

<span data-ttu-id="842c9-161">Однократная инициализация, защищенная одной структурой **init \_ Once** , может быть выполнена на сайтах несколько. разные обратные вызовы могут передаваться с каждого сайта, а синхронизация с ответом и без обратного вызова может быть смешанной.</span><span class="sxs-lookup"><span data-stu-id="842c9-161">One-time initialization guarded by a single **INIT\_ONCE** structure may be performed from mutiple sites; different callback may be passed from each site, and synchronization with and without callback may be mixed.</span></span> <span data-ttu-id="842c9-162">Инициализация все еще гуарантед для выполнения суцесфулли только один раз.</span><span class="sxs-lookup"><span data-stu-id="842c9-162">Initialization is still guaranted to perform sucesfully just once.</span></span>

<span data-ttu-id="842c9-163">Однако асинхронная и синхронная инициализация не могут быть смешанными: после попытки асинхронной инициализации произойдет сбой при попытке запустить синхронную инициализацию.</span><span class="sxs-lookup"><span data-stu-id="842c9-163">However, asynchronous and synchronous initialization cannot be mixed: once asynchronous initialization is attempted, attempts to start synchronous initialization would fail.</span></span>

## <a name="related-topics"></a><span data-ttu-id="842c9-164">См. также</span><span class="sxs-lookup"><span data-stu-id="842c9-164">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="842c9-165">Использование инициализации One-Time</span><span class="sxs-lookup"><span data-stu-id="842c9-165">Using One-Time Initialization</span></span>](using-one-time-initialization.md)
</dt> </dl>

 

 
