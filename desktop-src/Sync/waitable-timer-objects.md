---
description: Ожидающий объект таймера — это объект синхронизации, состояние которого задается сигнальным по наступлении указанного времени выполнения.
ms.assetid: 5d39ada0-ea31-40d7-b075-aeb657ee508c
title: Ожидающие объекты таймера
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2b9597617705fcd78bb71f63e33a475e3bca78e3
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105664063"
---
# <a name="waitable-timer-objects"></a><span data-ttu-id="08bae-103">Ожидающие объекты таймера</span><span class="sxs-lookup"><span data-stu-id="08bae-103">Waitable Timer Objects</span></span>

<span data-ttu-id="08bae-104">*Ожидающий объект таймера* — это объект синхронизации, состояние которого задается сигнальным по наступлении указанного времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="08bae-104">A *waitable timer object* is a synchronization object whose state is set to signaled when the specified due time arrives.</span></span> <span data-ttu-id="08bae-105">Существует два типа таймеров ожидания, которые можно создать: сброс и синхронизация вручную.</span><span class="sxs-lookup"><span data-stu-id="08bae-105">There are two types of waitable timers that can be created: manual-reset and synchronization.</span></span> <span data-ttu-id="08bae-106">Таймер любого типа также может быть периодическим таймером.</span><span class="sxs-lookup"><span data-stu-id="08bae-106">A timer of either type can also be a periodic timer.</span></span>



| <span data-ttu-id="08bae-107">Объект</span><span class="sxs-lookup"><span data-stu-id="08bae-107">Object</span></span>                | <span data-ttu-id="08bae-108">Описание</span><span class="sxs-lookup"><span data-stu-id="08bae-108">Description</span></span>                                                                                                                                                                                             |
|-----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="08bae-109">таймер сброса вручную</span><span class="sxs-lookup"><span data-stu-id="08bae-109">manual-reset timer</span></span>    | <span data-ttu-id="08bae-110">Таймер, состояние которого остается сигнальным до вызова [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) для установки нового времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="08bae-110">A timer whose state remains signaled until [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) is called to establish a new due time.</span></span>                                                                          |
| <span data-ttu-id="08bae-111">таймер синхронизации</span><span class="sxs-lookup"><span data-stu-id="08bae-111">synchronization timer</span></span> | <span data-ttu-id="08bae-112">Таймер, состояние которого остается сигнальным до тех пор, пока поток не завершит операцию ожидания объекта Timer.</span><span class="sxs-lookup"><span data-stu-id="08bae-112">A timer whose state remains signaled until a thread completes a wait operation on the timer object.</span></span>                                                                                                     |
| <span data-ttu-id="08bae-113">периодический таймер</span><span class="sxs-lookup"><span data-stu-id="08bae-113">periodic timer</span></span>        | <span data-ttu-id="08bae-114">Таймер, который активируется каждый раз, когда истекает указанный период, пока таймер не будет сброшен или отменен.</span><span class="sxs-lookup"><span data-stu-id="08bae-114">A timer that is reactivated each time the specified period expires, until the timer is reset or canceled.</span></span> <span data-ttu-id="08bae-115">Периодическим таймером является период таймера сброса вручную или периодическая синхронизация.</span><span class="sxs-lookup"><span data-stu-id="08bae-115">A periodic timer is either a periodic manual-reset timer or a periodic synchronization timer.</span></span> |



 

> [!Note]  
> <span data-ttu-id="08bae-116">При сигнале таймера процессор должен запуститься для обработки связанных инструкций.</span><span class="sxs-lookup"><span data-stu-id="08bae-116">When a timer is signaled, the processor must run to process the associated instructions.</span></span> <span data-ttu-id="08bae-117">Периодические таймеры с высокой частотой заключают, что процессор постоянно занят, что предотвращает остающуюся систему в более низком [энергопотреблении](../power/system-power-states.md) в течение любого значимого времени.</span><span class="sxs-lookup"><span data-stu-id="08bae-117">High-frequency periodic timers keep the processor continually busy, which prevents the system from remaining in a lower [power state](../power/system-power-states.md) for any meaningful amount of time.</span></span> <span data-ttu-id="08bae-118">Это может негативно повлиять на время работы батареи портативного компьютера и на сценарии, которые зависят от эффективного управления питанием, например больших центров обработки данных.</span><span class="sxs-lookup"><span data-stu-id="08bae-118">This can have a negative impact on portable computer battery life and scenarios that depend on effective power management, such as large datacenters.</span></span> <span data-ttu-id="08bae-119">Для повышения эффективности энергопотребления рассмотрите возможность использования уведомлений на основе событий вместо уведомлений на основе времени в приложении.</span><span class="sxs-lookup"><span data-stu-id="08bae-119">For greater energy efficiency, consider using event-based notifications instead of time-based notifications in your application.</span></span> <span data-ttu-id="08bae-120">Если требуется таймер, используйте таймер, сигнальный один раз, а не периодический таймер, или установите для интервала значение больше одной секунды.</span><span class="sxs-lookup"><span data-stu-id="08bae-120">If a timer is necessary, use a timer that is signaled once rather than a periodic timer, or set the interval to a value greater than one second.</span></span>

 

<span data-ttu-id="08bae-121">Поток использует функцию [**сбой createwaitabletimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) или [**креатеваитаблетимерекс**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerexw) для создания объекта Timer.</span><span class="sxs-lookup"><span data-stu-id="08bae-121">A thread uses the [**CreateWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) or [**CreateWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerexw) function to create a timer object.</span></span> <span data-ttu-id="08bae-122">Создание потока указывает, является ли таймер таймером сброса вручную или таймером синхронизации.</span><span class="sxs-lookup"><span data-stu-id="08bae-122">The creating thread specifies whether the timer is a manual-reset timer or a synchronization timer.</span></span> <span data-ttu-id="08bae-123">Создающий поток может указать имя для объекта Timer.</span><span class="sxs-lookup"><span data-stu-id="08bae-123">The creating thread can specify a name for the timer object.</span></span> <span data-ttu-id="08bae-124">Потоки в других процессах могут открыть обработчик для существующего таймера, указав его имя в вызове функции [**опенваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw) .</span><span class="sxs-lookup"><span data-stu-id="08bae-124">Threads in other processes can open a handle to an existing timer by specifying its name in a call to the [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw) function.</span></span> <span data-ttu-id="08bae-125">Любой поток с дескриптором объекта Timer может использовать одну из [функций ожидания](wait-functions.md) , чтобы ждать, пока состояние таймера не станет сигнальным.</span><span class="sxs-lookup"><span data-stu-id="08bae-125">Any thread with a handle to a timer object can use one of the [wait functions](wait-functions.md) to wait for the timer state to be set to signaled.</span></span>

-   <span data-ttu-id="08bae-126">Поток вызывает функцию [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) для активации таймера.</span><span class="sxs-lookup"><span data-stu-id="08bae-126">The thread calls the [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) function to activate the timer.</span></span> <span data-ttu-id="08bae-127">Обратите внимание на использование следующих параметров для **сетваитаблетимер**:</span><span class="sxs-lookup"><span data-stu-id="08bae-127">Note the use of the following parameters for **SetWaitableTimer**:</span></span>
-   <span data-ttu-id="08bae-128">Используйте параметр *лпдуетиме* , чтобы указать время, когда таймер должен быть установлен в сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="08bae-128">Use the *lpDueTime* parameter to specify the time at which the timer is to be set to the signaled state.</span></span> <span data-ttu-id="08bae-129">Если таймер сброса вручную установлен в сигнальное состояние, он остается в этом состоянии до тех пор, пока [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) не установит новое время выполнения.</span><span class="sxs-lookup"><span data-stu-id="08bae-129">When a manual-reset timer is set to the signaled state, it remains in this state until [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) establishes a new due time.</span></span> <span data-ttu-id="08bae-130">Если таймер синхронизации установлен в сигнальное состояние, он остается в этом состоянии до тех пор, пока поток не завершит операцию ожидания объекта Timer.</span><span class="sxs-lookup"><span data-stu-id="08bae-130">When a synchronization timer is set to the signaled state, it remains in this state until a thread completes a wait operation on the timer object.</span></span>
-   <span data-ttu-id="08bae-131">Используйте параметр *лпериод* функции [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) , чтобы указать период таймера.</span><span class="sxs-lookup"><span data-stu-id="08bae-131">Use the *lPeriod* parameter of the [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) function to specify the timer period.</span></span> <span data-ttu-id="08bae-132">Если период не равен нулю, таймер является периодическим таймером; она активируется повторно при каждом истечении периода времени, пока таймер не будет сброшен или отменен.</span><span class="sxs-lookup"><span data-stu-id="08bae-132">If the period is not zero, the timer is a periodic timer; it is reactivated each time the period expires, until the timer is reset or canceled.</span></span> <span data-ttu-id="08bae-133">Если точка равна нулю, таймер не является периодическим таймером; Она сообщается один раз, а затем деактивируется.</span><span class="sxs-lookup"><span data-stu-id="08bae-133">If the period is zero, the timer is not a periodic timer; it is signaled once and then deactivated.</span></span>

<span data-ttu-id="08bae-134">Поток может использовать функцию [**канцелваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-cancelwaitabletimer) , чтобы установить таймер в неактивное состояние.</span><span class="sxs-lookup"><span data-stu-id="08bae-134">A thread can use the [**CancelWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-cancelwaitabletimer) function to set the timer to the inactive state.</span></span> <span data-ttu-id="08bae-135">Чтобы сбросить таймер, вызовите [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer).</span><span class="sxs-lookup"><span data-stu-id="08bae-135">To reset the timer, call [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer).</span></span> <span data-ttu-id="08bae-136">По завершении работы с объектом Timer вызовите функцию [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) , чтобы закрыть маркер объекта Timer.</span><span class="sxs-lookup"><span data-stu-id="08bae-136">When you are finished with the timer object, call [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) to close the handle to the timer object.</span></span>

<span data-ttu-id="08bae-137">Поведение таймера ожидания можно суммировать следующим образом:</span><span class="sxs-lookup"><span data-stu-id="08bae-137">The behavior of a waitable timer can be summarized as follows:</span></span>

-   <span data-ttu-id="08bae-138">Если таймер установлен, он отменяется, если он уже активен, состояние таймера не сигнальное, а таймер помещается в очередь таймера ядра.</span><span class="sxs-lookup"><span data-stu-id="08bae-138">When a timer is set, it is canceled if it was already active, the state of the timer is nonsignaled, and the timer is placed in the kernel timer queue.</span></span>
-   <span data-ttu-id="08bae-139">По истечении времени таймера устанавливается сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="08bae-139">When a timer expires, the timer is set to the signaled state.</span></span> <span data-ttu-id="08bae-140">Если таймер содержит подпрограммы завершения, он помещается в очередь потока, который устанавливает таймер.</span><span class="sxs-lookup"><span data-stu-id="08bae-140">If the timer has a completion routine, it is queued to the thread that set the timer.</span></span> <span data-ttu-id="08bae-141">Процедура завершения остается в очереди потока [асинхронного вызова процедур](asynchronous-procedure-calls.md) (APC), пока поток не введет состояние ожидания с оповещением.</span><span class="sxs-lookup"><span data-stu-id="08bae-141">The completion routine remains in the [asynchronous procedure call](asynchronous-procedure-calls.md) (APC) queue of the thread until the thread enters an alertable wait state.</span></span> <span data-ttu-id="08bae-142">В это время отправляется компания APC, и вызывается подпрограммы завершения.</span><span class="sxs-lookup"><span data-stu-id="08bae-142">At that time, the APC is dispatched and the completion routine is called.</span></span> <span data-ttu-id="08bae-143">Если таймер является периодическим, он помещается обратно в очередь таймера ядра.</span><span class="sxs-lookup"><span data-stu-id="08bae-143">If the timer is periodic, it is placed back in the kernel timer queue.</span></span>
-   <span data-ttu-id="08bae-144">При отмене таймера он удаляется из очереди таймера ядра, если он находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="08bae-144">When a timer is canceled, it is removed from the kernel timer queue if it was pending.</span></span> <span data-ttu-id="08bae-145">Если срок действия таймера истек и по-прежнему имеется очередь APC в очереди для потока, который устанавливает таймер, то APC удаляется из очереди APC потока.</span><span class="sxs-lookup"><span data-stu-id="08bae-145">If the timer had expired and there is still an APC queued to the thread that set the timer, the APC is removed from the thread's APC queue.</span></span> <span data-ttu-id="08bae-146">Состояние сигнала таймера не изменяется.</span><span class="sxs-lookup"><span data-stu-id="08bae-146">The signaled state of the timer is not affected.</span></span>

## <a name="related-topics"></a><span data-ttu-id="08bae-147">См. также</span><span class="sxs-lookup"><span data-stu-id="08bae-147">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="08bae-148">Асинхронные вызовы процедур</span><span class="sxs-lookup"><span data-stu-id="08bae-148">Asynchronous Procedure Calls</span></span>](asynchronous-procedure-calls.md)
</dt> <dt>

[<span data-ttu-id="08bae-149">Использование ожидающих объектов таймера</span><span class="sxs-lookup"><span data-stu-id="08bae-149">Using Waitable Timer Objects</span></span>](using-waitable-timer-objects.md)
</dt> </dl>

 

 
