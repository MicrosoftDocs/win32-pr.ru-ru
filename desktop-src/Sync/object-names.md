---
description: Именованные объекты предоставляют процессам простой способ совместного использования дескрипторов объектов.
ms.assetid: 00a00227-45fc-49a1-8ff5-aeccb172d16a
title: Имена объектов
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ee746150a41f335a4073cb4b5ba282d17ad706f9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105663881"
---
# <a name="object-names"></a><span data-ttu-id="3c982-103">Имена объектов</span><span class="sxs-lookup"><span data-stu-id="3c982-103">Object Names</span></span>

<span data-ttu-id="3c982-104">Именованные объекты предоставляют процессам простой способ совместного использования дескрипторов объектов.</span><span class="sxs-lookup"><span data-stu-id="3c982-104">Named objects provide an easy way for processes to share object handles.</span></span> <span data-ttu-id="3c982-105">После того как процесс создал именованное событие, мьютекс, семафор или объект Timer, другие процессы могут использовать имя для вызова соответствующей функции ( [**опеневент**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**опенмутекс**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**опенсемафоре**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew)или [**опенваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) для открытия маркера объекта.</span><span class="sxs-lookup"><span data-stu-id="3c982-105">After a process has created a named event, mutex, semaphore, or timer object, other processes can use the name to call the appropriate function ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew), or [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) to open a handle to the object.</span></span> <span data-ttu-id="3c982-106">При сравнении имен учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="3c982-106">Name comparison is case sensitive.</span></span>

<span data-ttu-id="3c982-107">Имена событий, семафоров, мьютексов, ожидающих таймеров, объектов сопоставления файлов и заданий совместно используют одно и то же пространство имен.</span><span class="sxs-lookup"><span data-stu-id="3c982-107">The names of event, semaphore, mutex, waitable timer, file-mapping, and job objects share the same namespace.</span></span> <span data-ttu-id="3c982-108">При попытке создать объект, используя имя, которое используется объектом другого типа, функция завершается ошибкой, а [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) возвращает ошибочный **\_ \_ маркер**.</span><span class="sxs-lookup"><span data-stu-id="3c982-108">If you try to create an object using a name that is in use by an object of another type, the function fails and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_INVALID\_HANDLE**.</span></span> <span data-ttu-id="3c982-109">Поэтому при создании именованных объектов используйте уникальные имена и обязательно проверьте значения, возвращаемые функцией, для ошибок с повторяющимися именами.</span><span class="sxs-lookup"><span data-stu-id="3c982-109">Therefore, when creating named objects, use unique names and be sure to check function return values for duplicate-name errors.</span></span>

<span data-ttu-id="3c982-110">Если попытаться создать объект, используя имя, которое используется объектом того же типа, функция завершается с ошибкой, возвращая обработчик к существующему объекту, а [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) возвращает **ошибку \_ \_**.</span><span class="sxs-lookup"><span data-stu-id="3c982-110">If you try to create an object using a name that is in use by an object of same type, the function succeeds, returning a handle to the existing object, and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_ALREADY\_EXISTS**.</span></span> <span data-ttu-id="3c982-111">Например, если имя, указанное в вызове функции [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) , совпадает с именем существующего объекта Mutex, функция возвращает маркер существующего объекта.</span><span class="sxs-lookup"><span data-stu-id="3c982-111">For example, if the name specified in a call to the [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) function matches the name of an existing mutex object, the function returns a handle to the existing object.</span></span> <span data-ttu-id="3c982-112">В этом случае вызов **CreateMutex** эквивалентен вызову функции [**опенмутекс**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) .</span><span class="sxs-lookup"><span data-stu-id="3c982-112">In this case, the call to **CreateMutex** is equivalent to a call to the [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) function.</span></span> <span data-ttu-id="3c982-113">Наличие нескольких процессов использует **CreateMutex** для одного и того же мьютекса таким образом, что эквивалентно одному процессу, вызывающему **CreateMutex** , а другие процессы вызывают **опенмутекс**, за исключением того, что он устраняет необходимость в первом запуске процесса создания.</span><span class="sxs-lookup"><span data-stu-id="3c982-113">Having multiple processes use **CreateMutex** for the same mutex is therefore equivalent to having one process that calls **CreateMutex** while the other processes call **OpenMutex**, except that it eliminates the need to ensure that the creating process is started first.</span></span> <span data-ttu-id="3c982-114">Однако при использовании этого метода для объектов мьютекса ни один из вызывающих процессов не должен запрашивать немедленное владение мьютексом.</span><span class="sxs-lookup"><span data-stu-id="3c982-114">When using this technique for mutex objects, however, none of the calling processes should request immediate ownership of the mutex.</span></span> <span data-ttu-id="3c982-115">Если несколько процессов запрашивают немедленное владение, может быть трудно предсказать, какой процесс фактически получает первоначальный владение.</span><span class="sxs-lookup"><span data-stu-id="3c982-115">If multiple processes do request immediate ownership, it can be difficult to predict which process actually gets the initial ownership.</span></span>

<span data-ttu-id="3c982-116">В среде служб терминалов имеется глобальное пространство имен для событий, семафоров, мьютексов, ожидающих таймеров, объектов сопоставления файлов и объектов заданий.</span><span class="sxs-lookup"><span data-stu-id="3c982-116">A Terminal Services environment has a global namespace for events, semaphores, mutexes, waitable timers, file-mapping objects, and job objects.</span></span> <span data-ttu-id="3c982-117">Кроме того, каждый сеанс клиента служб терминалов имеет собственное отдельное пространство имен для этих объектов.</span><span class="sxs-lookup"><span data-stu-id="3c982-117">In addition, each Terminal Services client session has its own separate namespace for these objects.</span></span> <span data-ttu-id="3c982-118">Клиентские процессы служб терминалов могут использовать имена объектов с \\ префиксом "Global" или "Local \\ ", чтобы явно создать объект в пространстве имен Global или Session.</span><span class="sxs-lookup"><span data-stu-id="3c982-118">Terminal Services client processes can use object names with a "Global\\" or "Local\\" prefix to explicitly create an object in the global or session namespace.</span></span> <span data-ttu-id="3c982-119">Дополнительные сведения см. в разделе [пространства имен объектов ядра](../termserv/kernel-object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="3c982-119">For more information, see [Kernel Object Namespaces](../termserv/kernel-object-namespaces.md).</span></span> <span data-ttu-id="3c982-120">Быстрое переключение пользователей реализуется с помощью сеансов служб терминалов (каждый пользователь входит в другой сеанс).</span><span class="sxs-lookup"><span data-stu-id="3c982-120">Fast user switching is implemented using Terminal Services sessions (each user logs into a different session).</span></span> <span data-ttu-id="3c982-121">Имена объектов ядра должны соответствовать рекомендациям, изложенным в руководстве по службам терминалов, чтобы приложения поддерживали несколько пользователей.</span><span class="sxs-lookup"><span data-stu-id="3c982-121">Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</span></span>

<span data-ttu-id="3c982-122">Объекты синхронизации можно создавать в закрытом пространстве имен.</span><span class="sxs-lookup"><span data-stu-id="3c982-122">Synchronization objects can be created in a private namespace.</span></span> <span data-ttu-id="3c982-123">Дополнительные сведения см. в разделе [пространства имен объектов](object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="3c982-123">For more information, see [Object Namespaces](object-namespaces.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="3c982-124">См. также</span><span class="sxs-lookup"><span data-stu-id="3c982-124">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="3c982-125">Использование именованных объектов</span><span class="sxs-lookup"><span data-stu-id="3c982-125">Using Named Objects</span></span>](using-named-objects.md)
</dt> </dl>

 

 
