---
title: Изменение интерфейсов с обратной совместимостью
description: Методы, описанные в теории управления версиями для RPC и COM, могут быть неприемлемыми по многим причинам.
ms.assetid: 7dec4b67-3d50-453f-b0ef-290d091186fd
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 314daecc6b55aaf4a348411010eb578149f86921
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "103793501"
---
# <a name="changing-interfaces-in-a-backward-compatible-manner"></a><span data-ttu-id="e576f-103">Изменение интерфейсов с обратной совместимостью</span><span class="sxs-lookup"><span data-stu-id="e576f-103">Changing Interfaces in a Backward Compatible Manner</span></span>

<span data-ttu-id="e576f-104">Методы, описанные в [теории управления версиями для RPC и com](the-versioning-theory-for-rpc-and-com.md) , могут быть неприемлемыми по многим причинам.</span><span class="sxs-lookup"><span data-stu-id="e576f-104">The methods explained in [The Versioning Theory for RPC and COM](the-versioning-theory-for-rpc-and-com.md) may be unacceptable for many reasons.</span></span> <span data-ttu-id="e576f-105">Изменение версии интерфейса в соответствии с правилами требует, чтобы новые клиенты не могли взаимодействовать со старыми серверами.</span><span class="sxs-lookup"><span data-stu-id="e576f-105">Changing an interface version according to the rules essentially requires that new clients not communicate with old servers.</span></span> <span data-ttu-id="e576f-106">Это часто невозможно при использовании коммерческого программного обеспечения, развернутого в поле.</span><span class="sxs-lookup"><span data-stu-id="e576f-106">This is frequently impossible with commercial software deployed in the field.</span></span> <span data-ttu-id="e576f-107">Иногда в Windows появились изменения в интерфейсе, отсутствующие в измененных идентификаторах GUID или версиях.</span><span class="sxs-lookup"><span data-stu-id="e576f-107">Sometimes, Windows has introduced interface changes absent of changed GUIDs or versions.</span></span> <span data-ttu-id="e576f-108">Это было следствием того, что новые клиенты должны взаимодействовать с устаревшими серверами, а решение, которое новый клиент будет поддерживать как старый, так и новый интерфейс, было нежелательным.</span><span class="sxs-lookup"><span data-stu-id="e576f-108">This was a result of new clients needing to communicate with legacy servers, and because the solution that a new client would support both the old and new interfaces was deemed undesirable.</span></span>

## <a name="best-practice"></a><span data-ttu-id="e576f-109">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="e576f-109">Best practice</span></span>

<span data-ttu-id="e576f-110">Это разумные методы обхода проблемы несовместимости сети, когда идентификатор GUID и версия интерфейса не могут быть изменены.</span><span class="sxs-lookup"><span data-stu-id="e576f-110">These are the reasonable methods of working around the wire incompatibility issue when the interface GUID and version cannot be changed.</span></span>

1.  <span data-ttu-id="e576f-111">Приложение должно знать о возможностях другой стороны.</span><span class="sxs-lookup"><span data-stu-id="e576f-111">Have the application be aware of the other side's capabilities.</span></span>

    <span data-ttu-id="e576f-112">Клиент и сервер имеют протокол, который позволяет каждому (или по крайней мере новому клиенту) установить удостоверение партнера.</span><span class="sxs-lookup"><span data-stu-id="e576f-112">The client and server have a protocol that enables each (or at least the new client) to establish the identity of the partner.</span></span> <span data-ttu-id="e576f-113">Как правило, для нового клиента достаточно знать о функциях, поддерживаемых старыми и новыми серверами.</span><span class="sxs-lookup"><span data-stu-id="e576f-113">Typically it is sufficient to have the new client be aware of features supported by old and new servers.</span></span> <span data-ttu-id="e576f-114">Это можно легко сделать, когда приложение придерживается к контексту соединения и поддерживается посредством типа *ксксксжетинфо* вызова функции, выполняемого клиентом перед выполнением любых операций RPC.</span><span class="sxs-lookup"><span data-stu-id="e576f-114">This may easily be done when an application holds on to a connection context, and be supported through an *XxxGetInfo* type of function call executed by the client before performing any RPC operations.</span></span> <span data-ttu-id="e576f-115">Когда приложение управляет функциями в выпуске на сервер, вызов с несовместимостью со старым сервером или клиентом не может произойти, так как приложение управляет тем, какие вызовы выдаются серверу.</span><span class="sxs-lookup"><span data-stu-id="e576f-115">When an application manages the features on a per-server release basis, a call with an incompatibility to the old server/client can never occur, since the application controls which calls are issued to which server.</span></span> <span data-ttu-id="e576f-116">В конце концов, приложение является упреждающим в предотвращении несоответствия.</span><span class="sxs-lookup"><span data-stu-id="e576f-116">The bottom line is that the application is proactive in preventing a mismatch from happening.</span></span> <span data-ttu-id="e576f-117">Это может быть выполнено вместе со второй практикой.</span><span class="sxs-lookup"><span data-stu-id="e576f-117">This may be performed in conjunction with the second practice.</span></span>

2.  <span data-ttu-id="e576f-118">Познакомьтесь с новым удаленным API.</span><span class="sxs-lookup"><span data-stu-id="e576f-118">Introduce a new remote API.</span></span>

    <span data-ttu-id="e576f-119">Новый удаленный метод не противоречит существующим методам, если он добавлен в конец интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e576f-119">A new remote method does not collide with existing methods if it is added at the very end of the interface.</span></span> <span data-ttu-id="e576f-120">Старые клиенты могут вызывать новые серверы, как они всегда имеют.</span><span class="sxs-lookup"><span data-stu-id="e576f-120">Old clients can call new servers as they always have.</span></span> <span data-ttu-id="e576f-121">Новый клиент может вызвать новый метод, не зная удостоверения сервера, при условии, что он наблюдает за ошибками, поступающими от вызываемого сервера.</span><span class="sxs-lookup"><span data-stu-id="e576f-121">The new client can call the new method without knowing the server's identity, provided it watches for the errors coming from the server being called.</span></span> <span data-ttu-id="e576f-122">Во время выполнения RPC всегда проверяется номер метода для каждого интерфейса перед отправкой, чтобы гарантировать, что метод находится в соответствующей таблице v-table.</span><span class="sxs-lookup"><span data-stu-id="e576f-122">The RPC run time always checks the method number for each interface before a dispatch to ensure the method is within an appropriate v-table.</span></span> <span data-ttu-id="e576f-123">Для метода, неизвестного для сервера, время выполнения RPC вызывает исключение RPC \_ S \_ прокнум \_ за пределами \_ \_ диапазона.</span><span class="sxs-lookup"><span data-stu-id="e576f-123">For a method that is unknown to a server, the RPC run time raises the exception RPC\_S\_PROCNUM\_OUT\_OF\_RANGE.</span></span> <span data-ttu-id="e576f-124">Это исключение возникает только в данной конкретной ситуации.</span><span class="sxs-lookup"><span data-stu-id="e576f-124">This exception is raised only in this particular situation.</span></span> <span data-ttu-id="e576f-125">Таким образом, новый клиент может отслеживать исключение в виде подписи, что вызов перешел на старый сервер, и может правильно изменить его поведение.</span><span class="sxs-lookup"><span data-stu-id="e576f-125">Therefore, a new client can watch for the exception as a sign that the call went to an old server and can modify its behavior gracefully.</span></span>

3.  <span data-ttu-id="e576f-126">Новые параметры или новые типы данных вводятся только в новых методах.</span><span class="sxs-lookup"><span data-stu-id="e576f-126">Introduce new parameters or new data types only in the new methods.</span></span>

    <span data-ttu-id="e576f-127">Одной из причин появления нового метода является избежание несовместимости данных.</span><span class="sxs-lookup"><span data-stu-id="e576f-127">One reason to introduce a new method is to avoid data incompatibility.</span></span> <span data-ttu-id="e576f-128">Если новый тип данных введен или просто изменен, в принципе он должен использоваться только в новом методе (или методах).</span><span class="sxs-lookup"><span data-stu-id="e576f-128">If a new data type is introduced or simply modified, in principle it should be used only in a new method (or methods).</span></span> <span data-ttu-id="e576f-129">См. [примеры несовместимых изменений](examples-of-incompatible-changes.md) для примеров несовместимых изменений типов данных.</span><span class="sxs-lookup"><span data-stu-id="e576f-129">See [Examples of Incompatible Changes](examples-of-incompatible-changes.md) for examples of incompatible data type changes.</span></span> <span data-ttu-id="e576f-130">Единственным важным исключением из этого правила является описание в элементе 4.</span><span class="sxs-lookup"><span data-stu-id="e576f-130">The only notable exception to this rule is described in item four.</span></span>

4.  <span data-ttu-id="e576f-131">Сопоставьте новые параметры или новые типы данных с помощью оболочки.</span><span class="sxs-lookup"><span data-stu-id="e576f-131">Map new parameters or new data types through a wrapper.</span></span>

    <span data-ttu-id="e576f-132">Это решение применимо, когда пользователю необходимо предоставить новый параметр или тип данных, но на самом деле нет необходимости в удаленной удаленном режиме или при сопоставлении со старыми типами данных или параметрами.</span><span class="sxs-lookup"><span data-stu-id="e576f-132">This solution applies when a new parameter or data type must be exposed to a user, but actually does not have to be remoted separately or can be mapped to the old data types or parameters.</span></span> <span data-ttu-id="e576f-133">Например, многие системные API-интерфейсы поочередно пополняют и выполняют удаленный вызов.</span><span class="sxs-lookup"><span data-stu-id="e576f-133">For example, many system APIs turn around and execute a remote call.</span></span> <span data-ttu-id="e576f-134">Они могут или не выполнять некоторый тип сопоставления из известных типов данных для типов данных, фактически используемых в базовом вызове RPC.</span><span class="sxs-lookup"><span data-stu-id="e576f-134">They may or may not be doing some kind of mapping from the user known data types to the data types actually used in the underlying RPC call.</span></span> <span data-ttu-id="e576f-135">Поэтому всегда стоит проанализировать, нужно ли распространить изменения в пользовательском интерфейсе как изменение в удаленном интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="e576f-135">It is therefore always worth examining if the change in the user interface needs to propagate as a change to a remote interface.</span></span>

    <span data-ttu-id="e576f-136">Подобная ситуация может возникнуть, когда пользователь напрямую обращается к удаленному API, но для создания нового сопоставления типа или некоторых других дополнительных действий, которые стали необходимыми, можно ввести программу-оболочку.</span><span class="sxs-lookup"><span data-stu-id="e576f-136">A similar situation may happen when the user calls a remote API directly, but a wrapper could be introduced to do a new type mapping or some other additional actions that have become necessary.</span></span> <span data-ttu-id="e576f-137">В языке определения интерфейсов (IDL) предусмотрено несколько способов облегчения такого пересопоставления, а именно для \[ [**вызова метода \_ as**](/windows/desktop/Midl/call-as) \] , \[ [**передачи \_ как**](/windows/desktop/Midl/transmit-as) \] и \[ [**\_ маршалирования**](/windows/desktop/Midl/wire-marshal) \] .</span><span class="sxs-lookup"><span data-stu-id="e576f-137">Interface Definition Language (IDL) has several ways of facilitating such remapping, namely \[[**call\_as**](/windows/desktop/Midl/call-as)\], \[[**transmit\_as**](/windows/desktop/Midl/transmit-as)\], and \[[**wire\_marshal**](/windows/desktop/Midl/wire-marshal)\].</span></span> <span data-ttu-id="e576f-138">Атрибут \[ **вызвать \_ как** \] вводит обертку функции для клиента и сервера.</span><span class="sxs-lookup"><span data-stu-id="e576f-138">The \[**call\_as**\] attribute introduces a function wrapper on the client and server.</span></span> <span data-ttu-id="e576f-139">Оба кода помещаются между пользовательским кодом и маршалером.</span><span class="sxs-lookup"><span data-stu-id="e576f-139">Both are placed between the user code and the marshaler.</span></span> <span data-ttu-id="e576f-140">Другие атрибуты связаны с прямым сопоставлением типов.</span><span class="sxs-lookup"><span data-stu-id="e576f-140">The other attributes deal with direct type mapping.</span></span> <span data-ttu-id="e576f-141">Для проблем с расширением \[ **вызовите метод \_ как** , \] наиболее часто используемый, и проще всего понимать и манипулировать без каких-либо ловушек.</span><span class="sxs-lookup"><span data-stu-id="e576f-141">For extension problems, \[**call\_as**\] is the most frequently used, and is easiest to understand and manipulate without pitfalls.</span></span>

5.  <span data-ttu-id="e576f-142">Изменение типов данных с помощью объединения, используемого по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="e576f-142">Modify data types through a defaultless union.</span></span>

    <span data-ttu-id="e576f-143">Изменение атрибута или типа данных обычно приводит к несовместимости сети.</span><span class="sxs-lookup"><span data-stu-id="e576f-143">Changing an attribute or data type typically leads to wire incompatibility.</span></span> <span data-ttu-id="e576f-144">Примеры [несовместимых изменений](examples-of-incompatible-changes.md) см. в примерах.</span><span class="sxs-lookup"><span data-stu-id="e576f-144">See [Examples of Incompatible Changes](examples-of-incompatible-changes.md) for examples.</span></span> <span data-ttu-id="e576f-145">Однако в случае объединения без предложения Default можно управлять несовместимостью так же, как и при использовании процедуры вне диапазона, как описано выше.</span><span class="sxs-lookup"><span data-stu-id="e576f-145">However, in the case of a union without a default clause, the incompatibility may be managed in a way similar to the case of a procedure out of range, as described previously.</span></span> <span data-ttu-id="e576f-146">Эта схема легко подходит для популярных типов *ксксксинфо* , использующих объединения.</span><span class="sxs-lookup"><span data-stu-id="e576f-146">This scheme is readily applicable to the popular *XxxINFO* types that use unions.</span></span>

    <span data-ttu-id="e576f-147">Например, вызов следующего вида</span><span class="sxs-lookup"><span data-stu-id="e576f-147">For example, a call like this</span></span>

    ```C++
    XxxGetInfo( [in] level, [out] XxxINFO  * pInfo );
    ```

    

    <span data-ttu-id="e576f-148">может возвращать сведения на уровне 1, 2 или 3, где *ксксксинфо* является объединением с тремя ветвями: 1, 2 и 3.</span><span class="sxs-lookup"><span data-stu-id="e576f-148">could return information at level 1, 2 or 3, with *XxxINFO* being a union with three branches: 1, 2 and 3.</span></span>

6.  <span data-ttu-id="e576f-149">Используйте атрибут \[ [**Range**](/windows/desktop/Midl/range) \] для указания диапазона.</span><span class="sxs-lookup"><span data-stu-id="e576f-149">Use the \[[**range**](/windows/desktop/Midl/range)\] attribute to specify range.</span></span>

    <span data-ttu-id="e576f-150">Можно указать \[ [](/windows/desktop/Midl/range) \] атрибут Range для простого типа масштабирования без нарушения обратной совместимости.</span><span class="sxs-lookup"><span data-stu-id="e576f-150">You can specify the \[[**range**](/windows/desktop/Midl/range)\] attribute on a simple scale type without breaking backward compatibility.</span></span> <span data-ttu-id="e576f-151">Этот атрибут не влияет на формат подключения, но во время немаршалинга RPC проверяет значение на канале, чтобы убедиться в том, что он находится в диапазоне, указанном в IDL-файле.</span><span class="sxs-lookup"><span data-stu-id="e576f-151">This attribute does not affect wire format, but during unmarshalling RPC checks the value on wire to confirm that it is within the range specified in the .idl file.</span></span> <span data-ttu-id="e576f-152">В противном случае \_ \_ возникает исключение "Ошибка RPC X недопустимая \_ Привязка".</span><span class="sxs-lookup"><span data-stu-id="e576f-152">If not, a RPC\_X\_INVALID\_BOUND exception is thrown.</span></span> <span data-ttu-id="e576f-153">Это особенно удобно, если сервер знает максимальный размер массива размеров.</span><span class="sxs-lookup"><span data-stu-id="e576f-153">This is especially useful if the server knows the maximum size of a sized array.</span></span>

    <span data-ttu-id="e576f-154">Пример:</span><span class="sxs-lookup"><span data-stu-id="e576f-154">For example:</span></span>

    ```C++
    HRESULT Method1( [in, range(0,100)] ULONG m, [size_is(m)] ULONG *plong); 
    ```

    

<span data-ttu-id="e576f-155">Поведение RPC, если указанный уровень равен 4, а ARM отсутствует, зависит от определения объединения.</span><span class="sxs-lookup"><span data-stu-id="e576f-155">The RPC behavior when the indicated level is 4 and the arm is missing, depends on the definition of the union.</span></span> <span data-ttu-id="e576f-156">Для объединения с определенным предложением по умолчанию RPC передает тип, указанный в предложении по умолчанию, для любого значения, отличного от известных меток ARM (в данном случае любой другой, кроме 1, 2 или 3).</span><span class="sxs-lookup"><span data-stu-id="e576f-156">For a union with the default clause defined, RPC transmits a type indicated in the default clause for anything different than the known arm labels (in this case, anything other than 1, 2 or 3).</span></span> <span data-ttu-id="e576f-157">Для объединения без заданной по умолчанию в результате распаковки возникает исключение, так как по определению нет значения по умолчанию, к которому будет возвращаться значение.</span><span class="sxs-lookup"><span data-stu-id="e576f-157">For a defaultless union, the unmarshaler raises an exception because by definition there is no default to fall back to.</span></span> <span data-ttu-id="e576f-158">Исключением является \_ \_ Недопустимый \_ тег RPC S.</span><span class="sxs-lookup"><span data-stu-id="e576f-158">The exception is RPC\_S\_INVALID\_TAG.</span></span>

<span data-ttu-id="e576f-159">Опять же, новый клиент может изменить его поведение при обнаружении, что он назывался старым сервером.</span><span class="sxs-lookup"><span data-stu-id="e576f-159">Again, a new client can adjust its behavior upon discovering that it called an old server.</span></span>

<span data-ttu-id="e576f-160">В следующих рекомендациях показано, что если необходимо разработать тип данных, поддерживающий удаленное взаимодействие, который можно расширить в будущем, используйте в IDL-файле нестандартное объединение.</span><span class="sxs-lookup"><span data-stu-id="e576f-160">What follows from these recommended practices is that if a remotable data type must be designed that can be extended in future, use a defaultless union in the IDL file.</span></span> <span data-ttu-id="e576f-161">По выбору, инкапсулированное объединение является немного более понятным.</span><span class="sxs-lookup"><span data-stu-id="e576f-161">Given a choice, an encapsulated union is slightly cleaner.</span></span>

<span data-ttu-id="e576f-162">Из-за особенностей внутреннего представления сетевого протокола NDR64 рекомендации по добавлению подлокотников, приведенных выше в этом разделе, должны быть дополнены следующим образом: Новая добавляемая ARM не может изменить выравнивание объединения, а в частности, самое большое выравнивание не должно меняться.</span><span class="sxs-lookup"><span data-stu-id="e576f-162">Due to quirks of internal representation of the NDR64 wire protocol, the recommendation for adding arms provided earlier in this section needs to be qualified as follows: The new arm being added cannot change the alignment of the union, and in particular, the biggest alignment of the arms should not change.</span></span> <span data-ttu-id="e576f-163">Обычно это не проблема, так как указатель в ARM приводит к выравниванию до 8.</span><span class="sxs-lookup"><span data-stu-id="e576f-163">This is typically not an issue, as a pointer in an arm forces alignment to 8.</span></span> <span data-ttu-id="e576f-164">Конструкция, в которой каждая ARM является указателем на тип ARM, является одним из чистых способов удовлетворения требования.</span><span class="sxs-lookup"><span data-stu-id="e576f-164">A design where each arm is a pointer to an arm type is one clean way of satisfying the requirement.</span></span>

 

 