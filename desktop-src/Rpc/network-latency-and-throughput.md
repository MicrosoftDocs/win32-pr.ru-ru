---
title: Задержка и пропускная способность сети
description: Задержка и пропускная способность сети с помощью удаленного вызова процедур (RPC).
ms.assetid: 8285fd73-eb54-4c06-b01a-1bffafb7e675
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c5c51c4db75b904ac5feae8c4a1cc5965fc2b06e
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "104258902"
---
# <a name="network-latency-and-throughput"></a><span data-ttu-id="fe3ee-103">Задержка и пропускная способность сети</span><span class="sxs-lookup"><span data-stu-id="fe3ee-103">Network Latency and Throughput</span></span>

<span data-ttu-id="fe3ee-104">Три основные проблемы связаны с оптимальным использованием сети:</span><span class="sxs-lookup"><span data-stu-id="fe3ee-104">Three major issues relate to optimal use of the network:</span></span>

-   <span data-ttu-id="fe3ee-105">Задержка в сети</span><span class="sxs-lookup"><span data-stu-id="fe3ee-105">Network latency</span></span>
-   <span data-ttu-id="fe3ee-106">Насыщенность сети</span><span class="sxs-lookup"><span data-stu-id="fe3ee-106">Network saturation</span></span>
-   <span data-ttu-id="fe3ee-107">Последствия обработки пакетов</span><span class="sxs-lookup"><span data-stu-id="fe3ee-107">Packet processing implications</span></span>

<span data-ttu-id="fe3ee-108">В этом разделе описывается задача программирования, которая требует использования RPC, затем проектирует два решения: один плохо написанный и один хорошо написанный.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-108">This section introduces a programming task requiring use of RPC, then designs two solutions: one poorly written and one well written.</span></span> <span data-ttu-id="fe3ee-109">Затем оба решения изучены, и их влияние на производительность сети обсуждается.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-109">Both solutions are then scrutinized, and their affect on network performance is discussed.</span></span>

<span data-ttu-id="fe3ee-110">Прежде чем обсуждать два решения, в следующих разделах обсуждаются и проявляются проблемы с производительностью, связанные с сетью.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-110">Before discussing the two solutions, the next few sections discuss and clarify network related performance issues.</span></span>

## <a name="network-latency"></a><span data-ttu-id="fe3ee-111">Задержка сети</span><span class="sxs-lookup"><span data-stu-id="fe3ee-111">Network Latency</span></span>

<span data-ttu-id="fe3ee-112">Пропускная способность сети и задержка сети являются отдельными терминами.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-112">Network bandwidth and network latency are separate terms.</span></span> <span data-ttu-id="fe3ee-113">Сети с высокой пропускной способностью не гарантируют низкую задержку.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-113">Networks with high bandwidth do not guarantee low latency.</span></span> <span data-ttu-id="fe3ee-114">Например, сетевой путь, обход вспомогательной ссылки, часто имеет высокую задержку, хотя пропускная способность очень высока.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-114">For example, a network path traversing a satellite link often has high latency, even though throughput is very high.</span></span> <span data-ttu-id="fe3ee-115">Нечастое сетевое время, прохождение по вспомогательной ссылке в течение пяти и более секунд с задержкой.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-115">It is not uncommon for a network round trip traversing a satellite link to have five or more seconds of latency.</span></span> <span data-ttu-id="fe3ee-116">Такая задержка заключается в том, что приложение, предназначенное для отправки запроса, ожидания ответа, отправки другого запроса, ожидания другого ответа и т. д., будет ожидать по меньшей мере пять секунд для каждого обмена пакетами, независимо от того, насколько быстро работает сервер.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-116">The implication of such a delay is this: an application designed to send a request, wait for a reply, send another request, wait for another reply, and so on, will wait at least five seconds for each packet exchange, regardless of how fast the server is.</span></span> <span data-ttu-id="fe3ee-117">Несмотря на повышение скорости работы компьютеров, передача спутниковых данных и Сетевые носители основываются на скорости падения, которая обычно остается постоянной.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-117">Despite the increasing speed of computers, satellite transmissions and network media are based on the speed of light, which generally stays constant.</span></span> <span data-ttu-id="fe3ee-118">Таким образом, маловероятно, что возникают задержки в существующих вспомогательных сетях.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-118">As such, improvements in latency for existing satellite networks is unlikely to occur.</span></span>

## <a name="network-saturation"></a><span data-ttu-id="fe3ee-119">Насыщенность сети</span><span class="sxs-lookup"><span data-stu-id="fe3ee-119">Network Saturation</span></span>

<span data-ttu-id="fe3ee-120">Некоторое насыщенность происходит во многих сетях.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-120">Some saturation occurs in many networks.</span></span> <span data-ttu-id="fe3ee-121">Наиболее простыми сетями, к которым наследуется насыщенность, являются медленные каналы связи, такие как стандартные аналоговые модемы 56K.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-121">The easiest networks to saturate are slow modem links, such as standard 56k analog modems.</span></span> <span data-ttu-id="fe3ee-122">Однако связи Ethernet с несколькими компьютерами в одном сегменте также могут быть насыщены.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-122">However, Ethernet links with many computers on a single segment can also become saturated.</span></span> <span data-ttu-id="fe3ee-123">То же самое относится к глобальным сетям с низкой пропускной способностью или избыточным каналом связи, например маршрутизатором или коммутатором, который может управлять ограниченным объемом трафика.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-123">The same is true about wide area networks with a low-bandwidth or otherwise overburdened link, such as a router or switch that can handle a limited amount of traffic.</span></span> <span data-ttu-id="fe3ee-124">В таких случаях, если сеть отправляет больше пакетов, чем может справиться слабая ссылка, она удаляет пакеты.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-124">In such these cases, if the network sends more packets than its weakest link can handle, it drops packets.</span></span> <span data-ttu-id="fe3ee-125">Чтобы избежать перегрузки, стек TCP Windows масштабируется обратно при обнаружении пропущенных пакетов, что может привести к значительным задержкам.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-125">To avoid congestion the Windows TCP stack scales back when dropped packets are detected which can result in significant delays.</span></span>

## <a name="packet-processing-implications"></a><span data-ttu-id="fe3ee-126">Последствия обработки пакетов</span><span class="sxs-lookup"><span data-stu-id="fe3ee-126">Packet Processing Implications</span></span>

<span data-ttu-id="fe3ee-127">Когда программы разрабатываются для сред более высокого уровня, таких как RPC, COM и даже сокеты Windows, разработчики, как правило, забывают, какой объем работы проходит в фоновом режиме для каждого отправленного или полученного пакета.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-127">When programs are developed for higher level environments like RPC, COM, and even Windows Sockets, developers tend to forget how much work takes place behind the scenes for each sent or received packet.</span></span> <span data-ttu-id="fe3ee-128">Когда пакет поступает из сети, компьютер может обслуживать прерывание от сетевой карты.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-128">When a packet arrives from the network, an interrupt from the network card is serviced by the computer.</span></span> <span data-ttu-id="fe3ee-129">Затем отложенный вызов процедуры (DPC) помещается в очередь, и его необходимо использовать в драйверах.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-129">Then a Deferred Procedure Call (DPC) is queued, and must make its way through the drivers.</span></span> <span data-ttu-id="fe3ee-130">Если используется какая-либо форма безопасности, пакет может быть расшифрован или проверен криптографический хэш.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-130">If any form of security is used, the packet may have to be decrypted, or the cryptographic hash verified.</span></span> <span data-ttu-id="fe3ee-131">Также необходимо выполнить проверку допустимости для каждого состояния.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-131">A number of validity checks must also be performed at each state.</span></span> <span data-ttu-id="fe3ee-132">Только после этого пакет прибывает в окончательном месте назначения: серверный код.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-132">Only then does the packet arrive at the final destination: the server code.</span></span> <span data-ttu-id="fe3ee-133">Отправка большого количества небольших фрагментов данных приводит к увеличению нагрузки на обработку пакетов для каждого небольшого фрагмента данных.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-133">Sending many small chunks of data results in packet processing overhead for each small chunk of data.</span></span> <span data-ttu-id="fe3ee-134">Отправка одного большого фрагмента данных, как правило, потребляет значительно меньше времени ЦП во всей системе, несмотря на то, что стоимость выполнения для многих небольших фрагментов по сравнению с одним большим фрагментом может быть одинаковой для серверного приложения.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-134">Sending one big chunk of data tends to consume significantly less CPU time throughout the system, even though the cost of execution for many small chunks compared to one large chunk may be the same for the server application.</span></span>

## <a name="example-1-a-poorly-designed-rpc-server"></a><span data-ttu-id="fe3ee-135">Пример 1. плохо спроектированный сервер RPC</span><span class="sxs-lookup"><span data-stu-id="fe3ee-135">Example 1: A Poorly Designed RPC Server</span></span>

<span data-ttu-id="fe3ee-136">Представьте себе приложение, которое должно обращаться к удаленным файлам, а задача в наличии — проектирование интерфейса RPC для управления удаленным файлом.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-136">Imagine an application that must access remote files, and the task at hand is to design an RPC interface for manipulating the remote file.</span></span> <span data-ttu-id="fe3ee-137">Самым простым решением является отражение файловых подпрограмм Studio для локальных файлов.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-137">The simplest solution is to mirror the studio file routines for local files.</span></span> <span data-ttu-id="fe3ee-138">Это может привести к появлению поясной очистки и знакомого интерфейса.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-138">Doing so may result in a deceptively clean and familiar interface.</span></span> <span data-ttu-id="fe3ee-139">Ниже приведен сокращенный IDL-файл:</span><span class="sxs-lookup"><span data-stu-id="fe3ee-139">Here is an abbreviated .idl file:</span></span>

``` syntax
typedef [context_handle] void *remote_file;
... .
interface remote_file
{
    remote_file remote_fopen(file_name);
    void remote_fclose(remote_file ...);
    size_t remote_fread(void *, size_t, size_t, remote_file ...);
    size_t remote_fwrite(const void *, size_t, size_t, remote_file ...);
    size_t remote_fseek(remote_file ..., long, int);
}
```

<span data-ttu-id="fe3ee-140">Это кажется достаточно элегантным, но на самом деле это набор, соблюдающий время для аварийного выполнения.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-140">This seems elegant enough, but actually, this is a time-honored recipe for performance disaster.</span></span> <span data-ttu-id="fe3ee-141">В отличие от популярного мнения, удаленный вызов процедур не просто вызовом локальной процедуры с передачей связи между вызывающей и вызываемой стороной.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-141">Contrary to popular opinion, remote procedure call is not simply a local procedure call with a wire between the caller and callee.</span></span>

<span data-ttu-id="fe3ee-142">Чтобы увидеть, как этот рецепт задействует производительность, рассмотрите файл в формате 2000, где 20 байтов считываются с начала, а затем 20 байт с конца и посмотрим, как это работает.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-142">To see how this recipe burns performance, consider a 2K file, where 20 bytes are read from the beginning, and then 20 bytes from the end, and see how this performs.</span></span> <span data-ttu-id="fe3ee-143">На стороне клиента выполняются следующие вызовы (для краткости опущено несколько путей кода):</span><span class="sxs-lookup"><span data-stu-id="fe3ee-143">On the client side, the following calls are made (many code paths are omitted for brevity):</span></span>

``` syntax
rfp = remote_fopen("c:\\sample.txt");
remote_read(...);
remote_fseek(...);
remote_read(...);
remote_fclose(rfp);
```

<span data-ttu-id="fe3ee-144">Теперь представьте, что сервер отделен от клиента по вспомогательной ссылке с пятью секундами времени приема-передачи.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-144">Now imagine that the server is separated from the client by a satellite link with a five-second round-trip time.</span></span> <span data-ttu-id="fe3ee-145">Каждый из этих вызовов должен ожидать ответа, прежде чем он сможет продолжаться, что означает абсолютный минимум для выполнения этой последовательности, равной 25 секундам.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-145">Each of those calls must wait for a response before it can proceed, which means an absolute minimum for executing this sequence of 25 seconds.</span></span> <span data-ttu-id="fe3ee-146">Учитывая, что извлекается только 40 байт, это аутражеаусли снижение производительности.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-146">Considering we are retrieving only 40 bytes, this is outrageously slow performance.</span></span> <span data-ttu-id="fe3ee-147">Клиенты этого приложения будут фуриаус.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-147">Customers of this application would be furious.</span></span>

<span data-ttu-id="fe3ee-148">Теперь представьте, что сеть перегружена, так как производительность маршрутизатора где-то находится в сетевом пути, перегружена.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-148">Now imagine the network is saturated, because a router's capacity somewhere in the network path is overburdened.</span></span> <span data-ttu-id="fe3ee-149">Такая схема заставляет маршрутизатор обрабатывать по крайней мере 10 пакетов, если нет безопасности (по одному для каждого запроса и по одному для каждого ответа).</span><span class="sxs-lookup"><span data-stu-id="fe3ee-149">This design forces the router to handle at least 10 packets if we do not have security (one for each request, and one for each reply).</span></span> <span data-ttu-id="fe3ee-150">Это тоже неплохо.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-150">That, too, is not good.</span></span>

<span data-ttu-id="fe3ee-151">Эта схема также заставляет сервер получать пять пакетов и отправлять пять пакетов.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-151">This design also forces the server to receive five packets and send five packets.</span></span> <span data-ttu-id="fe3ee-152">Опять же, не очень хорошая реализация.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-152">Again, not a very good implementation.</span></span>

## <a name="example-2-a-better-designed-rpc-server"></a><span data-ttu-id="fe3ee-153">Пример 2. Улучшенный разработанный RPC-сервер</span><span class="sxs-lookup"><span data-stu-id="fe3ee-153">Example 2: A Better Designed RPC Server</span></span>

<span data-ttu-id="fe3ee-154">Давайте перейдем к интерфейсу, рассмотренному в примере 1, и посмотрим, можно ли улучшить его.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-154">Let's redesign the interface discussed in Example 1, and see whether we can make it better.</span></span> <span data-ttu-id="fe3ee-155">Важно отметить, что предоставление этому серверу действительно хорошо требует знания шаблона использования для заданных файлов: в этом примере не предполагается, что такие знания не принимаются.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-155">It is important to note that making this server really good requires knowledge of the usage pattern for the given files: such knowledge is not assumed for this example.</span></span> <span data-ttu-id="fe3ee-156">Поэтому это более эффективный сервер RPC, но не оптимально разработанный сервер RPC.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-156">Therefore, this is a better designed RPC server, but not an optimally designed RPC server.</span></span>

<span data-ttu-id="fe3ee-157">Идея в этом примере состоит в том, чтобы свернуть максимально возможное количество удаленных операций в одну операцию.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-157">The idea in this example is to collapse as many remote operations into one operation as possible.</span></span> <span data-ttu-id="fe3ee-158">Первая последующая предпринятая ошибка:</span><span class="sxs-lookup"><span data-stu-id="fe3ee-158">The first attempt is the following:</span></span>

``` syntax
typedef [context_handle] void *remote_file;
typedef struct
{
    long position;
    int origin;
} remote_seek_instruction;
... .
interface remote_file
{
    remote_fread(file_name, void *, size_t, size_t, [in, out] remote_file ..., BOOL CloseWhenDone, remote_seek_instruction *...);
    size_t remote_fwrite(file_name, const void *, size_t, size_t, [in, out] remote_file ..., BOOL CloseWhenDone, remote_seek_instruction *...);
}
```

<span data-ttu-id="fe3ee-159">В этом примере выполняется сворачивание всех операций для чтения и записи, что позволяет необязательно открыть одну операцию, а также необязательное закрытие и поиск.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-159">This example collapses all operations to a read and write, which allows for an optional open on the same operation, as well as an optional close and seek.</span></span>

<span data-ttu-id="fe3ee-160">Такая же последовательность операций, написанная в сокращенном виде, выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="fe3ee-160">This same sequence of operation, when written in abbreviated form, looks like this:</span></span>

``` syntax
remote_read("c:\\sample.txt", ..., &rfp, FALSE, NULL);
remote_read(NULL, ..., &rfp, TRUE, seek_to_20_bytes_before_end);
```

<span data-ttu-id="fe3ee-161">При рассмотрении лучшего спроектированного сервера RPC во втором вызове сервер проверяет, что *\_ имя файла* имеет **значение NULL**, и использует сохраненный открытый файл в запросах предложений.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-161">When considering the better designed RPC server, on the second call the server checks that the *file\_name* is **NULL**, and uses the stored open file in rfp.</span></span> <span data-ttu-id="fe3ee-162">Затем он видит указания по поиску и помещает указатель файла на 20 байт перед концом, прежде чем он начнет чтение.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-162">Then it sees there are seek instructions, and will position the file pointer 20 bytes before the end before it reads.</span></span> <span data-ttu-id="fe3ee-163">По завершении он узнает, что флаг **клосевхендоне** имеет значение **true**, и закроет файл и закроет поле запроса предложений.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-163">When done, it will recognize the **CloseWhenDone** flag is set to **TRUE**, and will close the file, and close rfp.</span></span>

<span data-ttu-id="fe3ee-164">В сети с высокой задержкой эта лучшая версия занимает 10 секунд (в 2,5 раз быстрее) и требует обработки всего четырех пакетов. два получает от сервера и два отправляются с сервера.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-164">On the high latency network, this better version takes 10 seconds to complete (2.5 times faster) and requires processing of only four packets; two receives from the server, and two sends from the server.</span></span> <span data-ttu-id="fe3ee-165">Дополнительные функции *IFS* и распаковка сервера выполняются незначительно по сравнению с остальными.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-165">The extra *ifs* and unmarshaling the server performs are negligible compared to everything else.</span></span>

<span data-ttu-id="fe3ee-166">Если упорядочивание причин задано правильно, интерфейс можно даже сделать асинхронным, а два вызова могут отправляться параллельно.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-166">If causal ordering is specified properly, the interface can even be made asynchronous, and the two calls can be sent in parallel.</span></span> <span data-ttu-id="fe3ee-167">Когда используются вызовы порядка возникновения причин, они по-прежнему передаются по порядку, что означает, что в сети с высокой задержкой приободрилися только 5-секундная задержка, даже если количество отправленных и полученных пакетов одинаково.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-167">When causal ordering is used calls are still dispatched in order, which means on the high latency network only a five-second delay is endured, even though the number of packets sent and received is the same.</span></span>

<span data-ttu-id="fe3ee-168">Мы можем свернуть это еще больше, создав один метод, который принимает массив структур, каждый элемент массива, описывающий операцию с файлом. удаленный вариант точечной или собираемой операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-168">We can collapse this even further by creating one method that takes an array of structures, each member of the array describing a particular file operation; a remote variation of scatter/gather I/O.</span></span> <span data-ttu-id="fe3ee-169">Подход оплачивается при условии, что результат каждой операции не требует дальнейшей обработки на клиенте. Иными словами, приложение будет считывать 20 байт в конце, независимо от того, что прочитано первыми 20 байтами.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-169">The approach pays off as long as the result of each operation does not require further processing on the client; in other words the application is going to read the 20 bytes at the end regardless of what the first 20 bytes read are.</span></span>

<span data-ttu-id="fe3ee-170">Однако если определенная обработка должна быть выполнена на первых 20 байтах после их считывания для определения следующей операции, то свертывание всего в одну операцию не работает (по крайней мере, не во всех случаях).</span><span class="sxs-lookup"><span data-stu-id="fe3ee-170">However, if some processing must be performed on the first 20 bytes after reading them to determine the next operation, collapsing everything into one operation does not work (at least not in all cases).</span></span> <span data-ttu-id="fe3ee-171">Элегантность RPC заключается в том, что приложение может иметь оба метода в интерфейсе и вызывать любой из них в зависимости от потребностей.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-171">The elegance of RPC is that an application can have both methods in the interface, and call either method depending on need.</span></span>

<span data-ttu-id="fe3ee-172">Как правило, при использовании сети лучше объединять как можно больше вызовов в один вызов.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-172">In general, when the network is involved it is best to combine as many calls onto a single call as possible.</span></span> <span data-ttu-id="fe3ee-173">Если приложение имеет два независимых действия, используйте асинхронные операции и разрешите их параллельное выполнение.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-173">If an application has two independent activities, use asynchronous operations and let them run in parallel.</span></span> <span data-ttu-id="fe3ee-174">По сути, не заключайте конвейер в полный режим.</span><span class="sxs-lookup"><span data-stu-id="fe3ee-174">Essentially, keep the pipeline full.</span></span>

 

 




