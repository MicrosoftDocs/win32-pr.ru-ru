---
title: Работа с потерей подключения
description: Работа с потерей подключения
ms.assetid: a90fcb5a-773e-4c21-bf6c-c3519ec13a09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: de8e7a8088cfe09a4c4026c16cc3dc5ea36b3430
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "103792799"
---
# <a name="dealing-with-loss-of-connectivity"></a>Работа с потерей подключения

После завершения вызова RPC соединение не закрывается. он помечен как бесплатный. Таким образом, сервер может быть отключен или может быть потерян в процессе или между вызовами, в то время как подключение находится в пуле. В зависимости от политики, время выполнения RPC повторно пытается выполнить эти вызовы, только если выполняются следующие два условия.

-   Возможно, сервер не может выполнить вызов, или вызов идемпотентными.
-   Клиент может эффективно реализовывать повторные попытки с учетом производительности.

Следующие абзацы расширяют и проясняют два условия.

Вызов идемпотентными — это вызов, который может быть выполнен на сервере несколько раз без нежелательных побочных эффектов. Например, наличие вызова RPC, который запрашивает баланс в банке для заданной учетной записи, — это идемпотентными. Если этот вызов выполняется дважды из-за потери подключения, вред не выполняется. Еще один пример вызова идемпотентными — изменение адреса клиента в базе данных. Выполнение дважды выполняется правильно, так как второе выполнение просто заменяет уже существующий адрес на тот же адрес. Операция, например "Вычитание 50 долларов из учетной записи XYZ", не идемпотентными. Отключение сетевого подключения не должно приводить к множественному выполнению такого вызова.

Чтобы быть в безопасности, во время выполнения RPC все вызовы обрабатываются как не идемпотентными. \[Атрибут идемпотентными \] не поддерживается для [**нкакн \_ IP \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp)и игнорируется. Таким образом, первое условие в приведенном выше списке уменьшается до *сервера, который, возможно, не может выполнить вызов*.

Во многих случаях время выполнения RPC не может определить, что вызов еще не выполнялся на сервере. В таких случаях клиент не будет выполнять повторный вызов.

В следующих примерах показано, когда во время выполнения RPC происходит или не выполняется повторная попытка вызова:

-   Сервер перезагружается.

    Простой вызов RPC без безопасности выполняется для интерфейса, для которого предыдущий вызов не был выполнен после перезагрузки. Так как в этом интерфейсе не было совершенных вызовов, время выполнения RPC сначала пытается согласовать использование интерфейса. Он отправляет пакет, используя соединение в пуле. Поскольку сервер был перезагружен и соединение больше не является допустимым, оно возвращает ошибку. Поскольку время выполнения RPC на стороне клиента еще не начинало отправку данных для фактического вызова, клиент определяет, что серверу не удалось выполнить эти данные. Поэтому он закрывает подключение и выполняет поиск другого подключения в пуле. Если не удается найти подключение, откроется новое соединение и будет предпринята попытка согласовать использование интерфейса. Если это произойдет успешно, вызывается вызов (то есть повторная попытка, так как ошибка была обнаружена до начала вызова).

-   Вызов RPC с безопасностью уровня конфиденциальности (шифрование) выполняется для соединения с уже согласованным контекстом безопасности.

    Чтобы обеспечить эффективную производительность, во время выполнения RPC выполняется шифрование упакованного пакета (по открытым текстовым данным). Если попытка отправки данных завершается ошибкой, то время выполнения RPC не может повторить вызов, так как данные в открытом тексте были перезаписаны зашифрованными данными и не могут повторно зашифровать данные с помощью нового контекста безопасности. Поэтому повторные попытки не выполняются.

-   Отправка не первого фрагмента завершается ошибкой.

    Повторная попытка не выполняется, так как во время выполнения RPC можно отменить содержимое первого фрагмента, когда оно будет завершено, и не сможет повторить попытку отправки первого фрагмента.

-   Отправляется запрос RPC.

    Сервер прерывает подключение. Повторная попытка не выполняется, так как RPC не может определить, был ли сервер получил вызов и начал его выполнение.

Если сервер использует динамическую конечную точку, RPC не будет повторно разрешать конечную точку во время повторных попыток. Это означает, что если сервер выключается и создается резервная копия, он может находиться в другой конечной точке, а RPC не будет прозрачно повторно разрешать конечную точку при повторной попытке вызова. Для принудительного повторного разрешения конечной точки клиент RPC должен вызвать [**рпкбиндингресет**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) перед повторным выполнением вызова.

Во многих из этих случаев, если клиент RPC может определить, является ли вызов идемпотентными, или же он хранит данные, которые удаляются RPC, он может создать механизм повтора поверх RPC.

> [!Note]  
> Если сервер является кластером и на разных узлах кластера работают разные версии серверного программного обеспечения, то повторная попытка RPC может нарушить вызов на другом узле кластера в случае отработки отказа и, возможно, на другой версии сервера. В таких сценариях развертывания убедитесь, что клиент не использует определенную версию серверного программного обеспечения для выполнения данного вызова. Если это так, клиент должен создать механизм на основе RPC, который обнаруживает и обрабатывает такие условия.

 

 

 