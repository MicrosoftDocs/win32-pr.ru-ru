---
title: Работа с потерей подключения
description: Работа с потерей подключения
ms.assetid: a90fcb5a-773e-4c21-bf6c-c3519ec13a09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: de8e7a8088cfe09a4c4026c16cc3dc5ea36b3430
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "103792799"
---
# <a name="dealing-with-loss-of-connectivity"></a><span data-ttu-id="42db5-103">Работа с потерей подключения</span><span class="sxs-lookup"><span data-stu-id="42db5-103">Dealing with Loss of Connectivity</span></span>

<span data-ttu-id="42db5-104">После завершения вызова RPC соединение не закрывается. он помечен как бесплатный.</span><span class="sxs-lookup"><span data-stu-id="42db5-104">After an RPC call completes the connection is not closed; it is marked as free.</span></span> <span data-ttu-id="42db5-105">Таким образом, сервер может быть отключен или может быть потерян в процессе или между вызовами, в то время как подключение находится в пуле.</span><span class="sxs-lookup"><span data-stu-id="42db5-105">As such, the server can go down or network connectivity can be lost during or between calls, while a connection is sitting in the pool.</span></span> <span data-ttu-id="42db5-106">В зависимости от политики, время выполнения RPC повторно пытается выполнить эти вызовы, только если выполняются следующие два условия.</span><span class="sxs-lookup"><span data-stu-id="42db5-106">As a matter of policy, the RPC run time re-attempts those calls only if the following two conditions are met:</span></span>

-   <span data-ttu-id="42db5-107">Возможно, сервер не может выполнить вызов, или вызов идемпотентными.</span><span class="sxs-lookup"><span data-stu-id="42db5-107">The server cannot possibly execute the call, or the call is idempotent.</span></span>
-   <span data-ttu-id="42db5-108">Клиент может эффективно реализовывать повторные попытки с учетом производительности.</span><span class="sxs-lookup"><span data-stu-id="42db5-108">The client can implement retries in a performance-efficient manner.</span></span>

<span data-ttu-id="42db5-109">Следующие абзацы расширяют и проясняют два условия.</span><span class="sxs-lookup"><span data-stu-id="42db5-109">The following paragraphs expand and clarify the two conditions.</span></span>

<span data-ttu-id="42db5-110">Вызов идемпотентными — это вызов, который может быть выполнен на сервере несколько раз без нежелательных побочных эффектов.</span><span class="sxs-lookup"><span data-stu-id="42db5-110">An idempotent call is a call that can be executed more than once on the server without undesirable side effects.</span></span> <span data-ttu-id="42db5-111">Например, наличие вызова RPC, который запрашивает баланс в банке для заданной учетной записи, — это идемпотентными.</span><span class="sxs-lookup"><span data-stu-id="42db5-111">For example, having an RPC call that queries the balance in the bank for a given account is idempotent.</span></span> <span data-ttu-id="42db5-112">Если этот вызов выполняется дважды из-за потери подключения, вред не выполняется.</span><span class="sxs-lookup"><span data-stu-id="42db5-112">If this call is executed twice due to loss of connectivity, no harm is done.</span></span> <span data-ttu-id="42db5-113">Еще один пример вызова идемпотентными — изменение адреса клиента в базе данных.</span><span class="sxs-lookup"><span data-stu-id="42db5-113">Another example of an idempotent call is changing the address of a customer in a database.</span></span> <span data-ttu-id="42db5-114">Выполнение дважды выполняется правильно, так как второе выполнение просто заменяет уже существующий адрес на тот же адрес.</span><span class="sxs-lookup"><span data-stu-id="42db5-114">Executing twice is fine, since the second execution simply replaces the already-current address with the same address.</span></span> <span data-ttu-id="42db5-115">Операция, например "Вычитание 50 долларов из учетной записи XYZ", не идемпотентными.</span><span class="sxs-lookup"><span data-stu-id="42db5-115">An operation like "subtract fifty dollars from account xyz" is not idempotent.</span></span> <span data-ttu-id="42db5-116">Отключение сетевого подключения не должно приводить к множественному выполнению такого вызова.</span><span class="sxs-lookup"><span data-stu-id="42db5-116">Loss of network connectivity should not result in multiple executions of such a call.</span></span>

<span data-ttu-id="42db5-117">Чтобы быть в безопасности, во время выполнения RPC все вызовы обрабатываются как не идемпотентными.</span><span class="sxs-lookup"><span data-stu-id="42db5-117">To be safe, the RPC run time treats all calls as non-idempotent.</span></span> <span data-ttu-id="42db5-118">\[Атрибут идемпотентными \] не поддерживается для [**нкакн \_ IP \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp)и игнорируется.</span><span class="sxs-lookup"><span data-stu-id="42db5-118">The \[idempotent\] attribute is not supported for [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp), and is ignored.</span></span> <span data-ttu-id="42db5-119">Таким образом, первое условие в приведенном выше списке уменьшается до *сервера, который, возможно, не может выполнить вызов*.</span><span class="sxs-lookup"><span data-stu-id="42db5-119">As such, the first condition in the preceding list is reduced to *the server that cannot possibly execute the call*.</span></span>

<span data-ttu-id="42db5-120">Во многих случаях время выполнения RPC не может определить, что вызов еще не выполнялся на сервере.</span><span class="sxs-lookup"><span data-stu-id="42db5-120">In many cases the RPC run time is unable to conclusively determine the call was not already executed on the server.</span></span> <span data-ttu-id="42db5-121">В таких случаях клиент не будет выполнять повторный вызов.</span><span class="sxs-lookup"><span data-stu-id="42db5-121">In such cases, the client will not retry executing the call.</span></span>

<span data-ttu-id="42db5-122">В следующих примерах показано, когда во время выполнения RPC происходит или не выполняется повторная попытка вызова:</span><span class="sxs-lookup"><span data-stu-id="42db5-122">The following examples illustrate when the RPC run time does or does not retry a call:</span></span>

-   <span data-ttu-id="42db5-123">Сервер перезагружается.</span><span class="sxs-lookup"><span data-stu-id="42db5-123">A server is rebooted.</span></span>

    <span data-ttu-id="42db5-124">Простой вызов RPC без безопасности выполняется для интерфейса, для которого предыдущий вызов не был выполнен после перезагрузки.</span><span class="sxs-lookup"><span data-stu-id="42db5-124">A simple, no-security RPC call is made on an interface on which no previous call has been made after the reboot.</span></span> <span data-ttu-id="42db5-125">Так как в этом интерфейсе не было совершенных вызовов, время выполнения RPC сначала пытается согласовать использование интерфейса.</span><span class="sxs-lookup"><span data-stu-id="42db5-125">Since no calls were made on this interface, the RPC run time first attempts to negotiate use of the interface.</span></span> <span data-ttu-id="42db5-126">Он отправляет пакет, используя соединение в пуле.</span><span class="sxs-lookup"><span data-stu-id="42db5-126">It sends a packet using a connection in the pool.</span></span> <span data-ttu-id="42db5-127">Поскольку сервер был перезагружен и соединение больше не является допустимым, оно возвращает ошибку.</span><span class="sxs-lookup"><span data-stu-id="42db5-127">Since the server was rebooted, and the connection is no longer valid, it returns an error.</span></span> <span data-ttu-id="42db5-128">Поскольку время выполнения RPC на стороне клиента еще не начинало отправку данных для фактического вызова, клиент определяет, что серверу не удалось выполнить эти данные.</span><span class="sxs-lookup"><span data-stu-id="42db5-128">Since the client side RPC run time has not yet started sending the data for the actual call, the client determines that the server could not possibly have executed on those data.</span></span> <span data-ttu-id="42db5-129">Поэтому он закрывает подключение и выполняет поиск другого подключения в пуле.</span><span class="sxs-lookup"><span data-stu-id="42db5-129">Therefore, it closes the connection and looks for another connection in the pool.</span></span> <span data-ttu-id="42db5-130">Если не удается найти подключение, откроется новое соединение и будет предпринята попытка согласовать использование интерфейса.</span><span class="sxs-lookup"><span data-stu-id="42db5-130">If it cannot find a connection, it opens a new connection and tries to negotiate use of the interface again.</span></span> <span data-ttu-id="42db5-131">Если это произойдет успешно, вызывается вызов (то есть повторная попытка, так как ошибка была обнаружена до начала вызова).</span><span class="sxs-lookup"><span data-stu-id="42db5-131">If this succeeds, the call is made (that is, a retry is made, because the failure was detected before the call was started).</span></span>

-   <span data-ttu-id="42db5-132">Вызов RPC с безопасностью уровня конфиденциальности (шифрование) выполняется для соединения с уже согласованным контекстом безопасности.</span><span class="sxs-lookup"><span data-stu-id="42db5-132">An RPC call with privacy-level security (encryption) is made on a connection with an already-negotiated security context.</span></span>

    <span data-ttu-id="42db5-133">Чтобы обеспечить эффективную производительность, во время выполнения RPC выполняется шифрование упакованного пакета (по открытым текстовым данным).</span><span class="sxs-lookup"><span data-stu-id="42db5-133">To ensure efficient performance, the RPC run time encrypts the marshaled packet inline (over the clear text data).</span></span> <span data-ttu-id="42db5-134">Если попытка отправки данных завершается ошибкой, то время выполнения RPC не может повторить вызов, так как данные в открытом тексте были перезаписаны зашифрованными данными и не могут повторно зашифровать данные с помощью нового контекста безопасности.</span><span class="sxs-lookup"><span data-stu-id="42db5-134">If the attempt to send the data fails, the RPC run time cannot retry the call, since the clear text data have been overwritten with the encrypted data, and it cannot re-encrypt the data with a new security context.</span></span> <span data-ttu-id="42db5-135">Поэтому повторные попытки не выполняются.</span><span class="sxs-lookup"><span data-stu-id="42db5-135">Therefore, no retry is made.</span></span>

-   <span data-ttu-id="42db5-136">Отправка не первого фрагмента завершается ошибкой.</span><span class="sxs-lookup"><span data-stu-id="42db5-136">The sending of a non-first fragment fails.</span></span>

    <span data-ttu-id="42db5-137">Повторная попытка не выполняется, так как во время выполнения RPC можно отменить содержимое первого фрагмента, когда оно будет завершено, и не сможет повторить попытку отправки первого фрагмента.</span><span class="sxs-lookup"><span data-stu-id="42db5-137">Retry is not made, since the RPC run time may choose to discard the contents of the first fragment once it is complete, and has no way to retry sending the first fragment.</span></span>

-   <span data-ttu-id="42db5-138">Отправляется запрос RPC.</span><span class="sxs-lookup"><span data-stu-id="42db5-138">The RPC request is sent.</span></span>

    <span data-ttu-id="42db5-139">Сервер прерывает подключение.</span><span class="sxs-lookup"><span data-stu-id="42db5-139">The server aborts the connection.</span></span> <span data-ttu-id="42db5-140">Повторная попытка не выполняется, так как RPC не может определить, был ли сервер получил вызов и начал его выполнение.</span><span class="sxs-lookup"><span data-stu-id="42db5-140">No retry is attempted, since RPC cannot discern whether the server received the call and started executing it.</span></span>

<span data-ttu-id="42db5-141">Если сервер использует динамическую конечную точку, RPC не будет повторно разрешать конечную точку во время повторных попыток.</span><span class="sxs-lookup"><span data-stu-id="42db5-141">If the server uses a dynamic endpoint, RPC will not re-resolve the endpoint during retries.</span></span> <span data-ttu-id="42db5-142">Это означает, что если сервер выключается и создается резервная копия, он может находиться в другой конечной точке, а RPC не будет прозрачно повторно разрешать конечную точку при повторной попытке вызова.</span><span class="sxs-lookup"><span data-stu-id="42db5-142">This means that if a server is brought down and comes back up, it may reside on a different endpoint, and RPC will not transparently re-resolve the endpoint when a call is retried.</span></span> <span data-ttu-id="42db5-143">Для принудительного повторного разрешения конечной точки клиент RPC должен вызвать [**рпкбиндингресет**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) перед повторным выполнением вызова.</span><span class="sxs-lookup"><span data-stu-id="42db5-143">To force re-resolving of the endpoint, the RPC client should calling [**RpcBindingReset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) before it retries a call.</span></span>

<span data-ttu-id="42db5-144">Во многих из этих случаев, если клиент RPC может определить, является ли вызов идемпотентными, или же он хранит данные, которые удаляются RPC, он может создать механизм повтора поверх RPC.</span><span class="sxs-lookup"><span data-stu-id="42db5-144">In many of these cases, if an RPC client can determine whether a call is idempotent, or if it keeps data that RPC discards, it may choose to build a retry mechanism on top of RPC.</span></span>

> [!Note]  
> <span data-ttu-id="42db5-145">Если сервер является кластером и на разных узлах кластера работают разные версии серверного программного обеспечения, то повторная попытка RPC может нарушить вызов на другом узле кластера в случае отработки отказа и, возможно, на другой версии сервера.</span><span class="sxs-lookup"><span data-stu-id="42db5-145">If the server is a cluster, and the different nodes of the cluster run different versions of the server software, an RPC retry may land the call on a different node of the cluster in the case of failover, and potentially on a different version of the server.</span></span> <span data-ttu-id="42db5-146">В таких сценариях развертывания убедитесь, что клиент не использует определенную версию серверного программного обеспечения для выполнения данного вызова.</span><span class="sxs-lookup"><span data-stu-id="42db5-146">In such deployment scenarios, make sure the client does not rely on a particular version of the server software to execute a given call.</span></span> <span data-ttu-id="42db5-147">Если это так, клиент должен создать механизм на основе RPC, который обнаруживает и обрабатывает такие условия.</span><span class="sxs-lookup"><span data-stu-id="42db5-147">If it does, the client should build a mechanism on top of RPC that detects and handles such conditions.</span></span>

 

 

 