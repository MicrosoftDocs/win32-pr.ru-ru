---
title: Обработка ошибок (RPC)
description: В синхронном RPC клиент выполняет удаленный вызов, который возвращает код успеха или ошибки.
ms.assetid: 7dfc9f84-ce3c-49f3-8f72-b212095133fd
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 017892b94438cc73f88cbfe60c03c088bf3ebcc9
ms.sourcegitcommit: 8fa6614b715bddf14648cce36d2df22e5232801a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/10/2020
ms.locfileid: "104071028"
---
# <a name="error-handling-rpc"></a><span data-ttu-id="8d4fe-103">Обработка ошибок (RPC)</span><span class="sxs-lookup"><span data-stu-id="8d4fe-103">Error Handling (RPC)</span></span>

<span data-ttu-id="8d4fe-104">В синхронном RPC клиент выполняет удаленный вызов, который возвращает код успеха или ошибки.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-104">In synchronous RPC, a client makes a remote call that returns with either a success or failure code.</span></span> <span data-ttu-id="8d4fe-105">Асинхронный вызов процедур (RPC) предоставляет больше возможностей для вызова сбоя, и эти сбои обрабатываются по-разному в зависимости от того, где и когда они происходят.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-105">Asynchronous RPC provides more opportunities for a call to fail, and these failures are handled differently, depending on where and when they occur.</span></span> <span data-ttu-id="8d4fe-106">В следующей таблице описаны способы, в которых вызов может завершиться неудачно, и как он обрабатывается.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-106">The following table describes the ways in which a call can fail, and how it is handled.</span></span>

## <a name="client-side-cleanup"></a><span data-ttu-id="8d4fe-107">Очистка на стороне клиента</span><span class="sxs-lookup"><span data-stu-id="8d4fe-107">Client-side Cleanup</span></span>



| <span data-ttu-id="8d4fe-108">Симптом сбоя</span><span class="sxs-lookup"><span data-stu-id="8d4fe-108">Failure symptom</span></span>                                                                                                                                  | <span data-ttu-id="8d4fe-109">Очистка</span><span class="sxs-lookup"><span data-stu-id="8d4fe-109">Cleanup</span></span>                                                                                                                         |
|--------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="8d4fe-110">Клиент перехватывает исключение при вызове удаленной процедуры.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-110">Client catches an exception when it calls the remote procedure.</span></span>                                                                                  | <span data-ttu-id="8d4fe-111">Вызовы API RPC не требуются.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-111">No RPC API calls are necessary.</span></span> <span data-ttu-id="8d4fe-112">Все состояния RPC были очищены.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-112">All RPC state has been cleaned up.</span></span>                                                              |
| <span data-ttu-id="8d4fe-113">Клиент получает уведомление о завершении вызова, но при вызове [**рпкасинккомплетекалл**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall)он получает код ошибки.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-113">Client receives a call complete notification, but when it calls [**RpcAsyncCompleteCall**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall), it receives an error code.</span></span> | <span data-ttu-id="8d4fe-114">Вызовы API RPC не требуются.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-114">No RPC API calls are necessary.</span></span> <span data-ttu-id="8d4fe-115">Все состояния RPC были очищены.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-115">All RPC state has been cleaned up.</span></span>                                                              |
| <span data-ttu-id="8d4fe-116">Клиент выдает непрерванные или отмененные отмены.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-116">Client issues non-abortive or abortive cancel.</span></span>                                                                                                   | <span data-ttu-id="8d4fe-117">Клиент должен ждать уведомления и вызвать [**рпкасинккомплетекалл**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall) при получении уведомления.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-117">Client must wait for notification, and call [**RpcAsyncCompleteCall**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall) when the notification arrives.</span></span> |



 

<span data-ttu-id="8d4fe-118">При очистке на стороне сервера ключевой концепцией является точка передачи.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-118">In server side cleanup, a key concept is the hand-off point.</span></span> <span data-ttu-id="8d4fe-119">Во время серверной обработки асинхронного вызова часть обработки обычно выполняется в потоке, который получил вызов (также известен как *поток Dispatcher*), а затем, при необходимости, поток диспетчера помещает достаточное состояние в блок памяти и сигнализирует другому потоку (также известному как *Рабочий поток*) продолжить обработку для вызова.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-119">During the server side processing of an asynchronous call, some processing is usually performed on the thread that received the call (also known as the *dispatcher thread*), and then, optionally, the dispatcher thread puts enough state into a memory block and signals another thread (also known as *worker thread*) to continue processing for the call.</span></span> <span data-ttu-id="8d4fe-120">Момент, когда поток Dispatcher успешно сигнализирует, что рабочий поток называется *точкой* передачи.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-120">The moment at which the dispatcher thread successfully signals that the worker thread is called the *hand-off point*.</span></span>

## <a name="server-side-cleanup"></a><span data-ttu-id="8d4fe-121">Очистка на стороне сервера</span><span class="sxs-lookup"><span data-stu-id="8d4fe-121">Server Side Cleanup</span></span>



| <span data-ttu-id="8d4fe-122">Произошла ошибка</span><span class="sxs-lookup"><span data-stu-id="8d4fe-122">Error encountered</span></span>      | <span data-ttu-id="8d4fe-123">Очистка</span><span class="sxs-lookup"><span data-stu-id="8d4fe-123">Cleanup</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="8d4fe-124">Перед отправной точкой.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-124">Before hand-off point.</span></span> | <span data-ttu-id="8d4fe-125">Создать исключение.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-125">Throw exception.</span></span> <span data-ttu-id="8d4fe-126">Вызов [**рпкасинккомплетекалл**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall) не требуется.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-126">No call to [**RpcAsyncCompleteCall**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall) is necessary.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="8d4fe-127">После отправной точки.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-127">After hand-off point.</span></span>  | <span data-ttu-id="8d4fe-128">Вызовите [**рпкасинкаборткалл**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasyncabortcall) или, если ошибка не является неустранимой, и результаты по-прежнему могут возвращаться клиенту [**рпкасинккомплетекалл**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall).</span><span class="sxs-lookup"><span data-stu-id="8d4fe-128">Call [**RpcAsyncAbortCall**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasyncabortcall) or, if the error is not fatal and results can still be returned to the client, [**RpcAsyncCompleteCall**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall).</span></span> <span data-ttu-id="8d4fe-129">Если вызов функции **рпкасинккомплетекалл** завершается ошибкой, среда выполнения RPC освобождает параметры.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-129">If the **RpcAsyncCompleteCall** function call fails, the RPC runtime frees the parameters.</span></span> <span data-ttu-id="8d4fe-130">Пользователь не должен иметь доступ к этим параметрам.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-130">The user must not access those parameters.</span></span> <span data-ttu-id="8d4fe-131">Поток Dispatcher не должен выполнять какую-либо значительную обработку, которая может завершиться ошибкой после точки, так как она больше не может безопасно прерывать вызов.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-131">The dispatcher thread must not perform any substantial processing that may fail after the hand off point, because it no longer can safely abort the call.</span></span> <span data-ttu-id="8d4fe-132">В частности, он не должен вызывать исключение после точки, а также может привести к сбою сервера.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-132">Specifically, it must not throw an exception after the hand off point, or the server may crash.</span></span> |



 

## <a name="special-error-handling-cases-for-pipes"></a><span data-ttu-id="8d4fe-133">Специальные случаи обработки ошибок для каналов</span><span class="sxs-lookup"><span data-stu-id="8d4fe-133">Special Error Handling Cases for Pipes</span></span>

<span data-ttu-id="8d4fe-134">Существуют особые случаи обработки ошибок при использовании каналов.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-134">There are special cases for error handling when using pipes.</span></span> <span data-ttu-id="8d4fe-135">В следующем списке объясняется источник сбоя и способы его устранения.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-135">The following list explains the source of the failure, and how to handle the error.</span></span>



| <span data-ttu-id="8d4fe-136">Источник сбоя</span><span class="sxs-lookup"><span data-stu-id="8d4fe-136">Source of failure</span></span>                                                                                                 | <span data-ttu-id="8d4fe-137">Принцип обработки</span><span class="sxs-lookup"><span data-stu-id="8d4fe-137">How handled</span></span>                                                                                                |
|-------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="8d4fe-138">Клиент вызывает принудительную отправку, и вызов завершается с ошибкой.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-138">Client calls push and the call fails.</span></span>                                                                             | <span data-ttu-id="8d4fe-139">Вызовы API RPC не требуются.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-139">No RPC API calls are necessary.</span></span> <span data-ttu-id="8d4fe-140">Все состояния RPC были очищены.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-140">All RPC state has been cleaned up.</span></span>                                         |
| <span data-ttu-id="8d4fe-141">Клиент вызывает [**рпкасинккомплетекалл**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall) перед стоком [**в**](/windows/desktop/Midl/in) каналах.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-141">Client calls [**RpcAsyncCompleteCall**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall) before the [**in**](/windows/desktop/Midl/in) pipes are drained.</span></span> | <span data-ttu-id="8d4fe-142">Вызов завершается ошибкой с соответствующим кодом ошибки заполнения канала.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-142">Call fails with the appropriate pipe-filling error code.</span></span>                                                   |
| <span data-ttu-id="8d4fe-143">Клиент вызывает метод Pull, и вызов завершается с ошибкой.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-143">Client calls pull and the call fails.</span></span>                                                                             | <span data-ttu-id="8d4fe-144">Вызовы API RPC не требуются.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-144">No RPC API calls are necessary.</span></span> <span data-ttu-id="8d4fe-145">Все состояния RPC были очищены.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-145">All RPC state has been cleaned up.</span></span>                                         |
| <span data-ttu-id="8d4fe-146">Клиент или сервер вызывает метод Push или Pull в неправильном порядке.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-146">Either client or server calls push or pull in the wrong order.</span></span>                                                    | <span data-ttu-id="8d4fe-147">Время выполнения возвращает состояние ошибки заполнения канала.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-147">Run-time returns pipe-filling error status.</span></span>                                                                |
| <span data-ttu-id="8d4fe-148">Сервер вызывает метод Push или Pull, и вызов завершается с ошибкой.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-148">Server calls push or pull and the call fails.</span></span>                                                                     | <span data-ttu-id="8d4fe-149">Функция Push возвращает код ошибки.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-149">Push returns a failure code.</span></span> <span data-ttu-id="8d4fe-150">Вызов [**рпкасинккомплетекалл**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall) не требуется.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-150">No call to [**RpcAsyncCompleteCall**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccompletecall) is necessary.</span></span> |
| <span data-ttu-id="8d4fe-151">Сервер вызывает **рпкасинккомплетекалл** перед стоком каналов.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-151">Server calls **RpcAsyncCompleteCall** before the pipes have been drained.</span></span>                                         | <span data-ttu-id="8d4fe-152">Вызов канала возвращает состояние ошибки заполнения канала.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-152">The pipe call returns a pipe filling error status.</span></span>                                                         |
| <span data-ttu-id="8d4fe-153">После отправки операция получения завершается ошибкой.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-153">After the dispatch, a receive operation fails.</span></span>                                                                    | <span data-ttu-id="8d4fe-154">В следующий раз, когда сервер вызывает метод Pull для получения данных канала, возвращается ошибка.</span><span class="sxs-lookup"><span data-stu-id="8d4fe-154">The next time the server calls pull to receive pipe data, an error is returned.</span></span>                            |



 

 

 
