---
title: Предотвращение зависаний на стороне клиента
description: Существует два способа зависания сетевого подключения клиентом, что может привести к потере запросов сервера или сбою сервера. При использовании параметров по умолчанию RPC никогда не истечет время ожидания вызова, и клиентский поток будет ждать ответа неограниченно долго.
ms.assetid: 2c201e29-9d9c-48e6-b0b5-68e4b25c3fb7
keywords:
- Удаленный вызов процедур RPC, рекомендации, предотвращение зависаний клиента
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 18d4b5fc92ca18b575d081cd7b5abf90929e7df5
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "103791989"
---
# <a name="preventing-client-side-hangs"></a><span data-ttu-id="be05f-105">Предотвращение зависаний на стороне клиента</span><span class="sxs-lookup"><span data-stu-id="be05f-105">Preventing Client-side Hangs</span></span>

<span data-ttu-id="be05f-106">Существует два способа зависания клиента. сетевое подключение может привести к потере серверных запросов или сбою сервера.</span><span class="sxs-lookup"><span data-stu-id="be05f-106">There are two ways your client can hang: network connectivity can cause server requests to become lost, or the server itself can crash.</span></span> <span data-ttu-id="be05f-107">При использовании параметров по умолчанию RPC никогда не истечет время ожидания вызова, и клиентский поток будет ждать ответа неограниченно долго.</span><span class="sxs-lookup"><span data-stu-id="be05f-107">With default options, RPC will never time out a call, and your client thread will wait forever for a response.</span></span>

<span data-ttu-id="be05f-108">Существует два метода предотвращения этого: поддерживать активность и истечение времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="be05f-108">There are two methods to prevent this: keep alives and time outs.</span></span>

## <a name="tcp-keep-alives"></a><span data-ttu-id="be05f-109">Активность обновления TCP</span><span class="sxs-lookup"><span data-stu-id="be05f-109">TCP Keep Alives</span></span>

<span data-ttu-id="be05f-110">Клиент может быть настроен для периодической проверки связи с сервером, чтобы убедиться, что сервер активен и работает.</span><span class="sxs-lookup"><span data-stu-id="be05f-110">The client can be set up to periodically ping the server to ensure the server is alive and running.</span></span> <span data-ttu-id="be05f-111">Проверки связи — это активность TCP-соединений для последовательностей протокола [**\_ http**](/windows/desktop/Midl/ncacn-http) [**нкакн \_ IP \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp) и нкакн, поэтому они эффективны при использовании ЦП и пропускной способности сети.</span><span class="sxs-lookup"><span data-stu-id="be05f-111">The pings are TCP keep-alives for the [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp) and [**ncacn\_http**](/windows/desktop/Midl/ncacn-http) protocol sequences, and as such, they are efficient in CPU utilization and network bandwidth.</span></span> <span data-ttu-id="be05f-112">Чтобы включить проверку активности для данного удаленного вызова процедуры, используйте функцию [**рпкмгмтсеткомтимеаут**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) перед инициацией вызова.</span><span class="sxs-lookup"><span data-stu-id="be05f-112">To enable keep alives on a given remote procedure call, use the [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) function before the call is initiated.</span></span> <span data-ttu-id="be05f-113">Эта функция принимает в качестве аргументов маркер привязки и время ожидания.</span><span class="sxs-lookup"><span data-stu-id="be05f-113">This function takes a binding handle and a time out as arguments.</span></span> <span data-ttu-id="be05f-114">При каждом вызове удаленной процедуры для этого маркера привязки после **рпкмгмтсеткомтимеаут** использует заданное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="be05f-114">Every remote procedure call on this binding handle after **RpcMgmtSetComTimeout** uses the supplied time out.</span></span>

<span data-ttu-id="be05f-115">Параметр времени ожидания для функции [**рпкмгмтсеткомтимеаут**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) указывает, как долго время выполнения RPC будет ожидать, прежде чем будет включен режим поддержания активности.</span><span class="sxs-lookup"><span data-stu-id="be05f-115">The Timeout parameter for the [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) function specifies how long the RPC run time waits before it turns on keep alives.</span></span> <span data-ttu-id="be05f-116">Время ожидания — это значение от 0 до 10, где 0 — минимальное время ожидания, а 10 — бесконечное время ожидания (без времени ожидания).</span><span class="sxs-lookup"><span data-stu-id="be05f-116">The time out is a value between 0 and 10, where 0 is the minimal time out, and 10 is infinite time out (no time out).</span></span> <span data-ttu-id="be05f-117">Время ожидания выходит за пределы секунд; преобразование из значения времени ожидания, предоставленного функции **рпкмгмтсеткомтимеаут** , в секундах выполняется во время выполнения RPC и зависит от реализации.</span><span class="sxs-lookup"><span data-stu-id="be05f-117">The time out itself is not in seconds; the translation from the time-out value supplied to the **RpcMgmtSetComTimeout** function to seconds is done by the RPC run time, and is implementation specific.</span></span>

<span data-ttu-id="be05f-118">В следующей таблице приведено преобразование в секунды для Windows 2000 и Windows XP.</span><span class="sxs-lookup"><span data-stu-id="be05f-118">The following table provides the translation to seconds for Windows 2000 and Windows XP.</span></span> <span data-ttu-id="be05f-119">В будущих версиях Windows может измениться сопоставление между параметром timeout и значением времени ожидания в секундах:</span><span class="sxs-lookup"><span data-stu-id="be05f-119">Future versions of Windows may change the mapping between the Timeout parameter and the time-out value in seconds:</span></span>

| <span data-ttu-id="be05f-120">Параметр времени ожидания</span><span class="sxs-lookup"><span data-stu-id="be05f-120">Timeout parameter</span></span>                       | <span data-ttu-id="be05f-121">Фактическое время ожидания в секундах</span><span class="sxs-lookup"><span data-stu-id="be05f-121">Actual time out in seconds</span></span> |
|-----------------------------------------|----------------------------|
| <span data-ttu-id="be05f-122">0 ( \_ \_ \_ минимальное время ожидания привязки RPC C \_ )</span><span class="sxs-lookup"><span data-stu-id="be05f-122">0 (RPC\_C\_BINDING\_MIN\_TIMEOUT)</span></span>       | <span data-ttu-id="be05f-123">120</span><span class="sxs-lookup"><span data-stu-id="be05f-123">120</span></span>                        |
| <span data-ttu-id="be05f-124">1</span><span class="sxs-lookup"><span data-stu-id="be05f-124">1</span></span>                                       | <span data-ttu-id="be05f-125">240</span><span class="sxs-lookup"><span data-stu-id="be05f-125">240</span></span>                        |
| <span data-ttu-id="be05f-126">2</span><span class="sxs-lookup"><span data-stu-id="be05f-126">2</span></span>                                       | <span data-ttu-id="be05f-127">360</span><span class="sxs-lookup"><span data-stu-id="be05f-127">360</span></span>                        |
| <span data-ttu-id="be05f-128">3</span><span class="sxs-lookup"><span data-stu-id="be05f-128">3</span></span>                                       | <span data-ttu-id="be05f-129">480</span><span class="sxs-lookup"><span data-stu-id="be05f-129">480</span></span>                        |
| <span data-ttu-id="be05f-130">4</span><span class="sxs-lookup"><span data-stu-id="be05f-130">4</span></span>                                       | <span data-ttu-id="be05f-131">600</span><span class="sxs-lookup"><span data-stu-id="be05f-131">600</span></span>                        |
| <span data-ttu-id="be05f-132">5 ( \_ \_ время ожидания привязки RPC C \_ по умолчанию \_ )</span><span class="sxs-lookup"><span data-stu-id="be05f-132">5 (RPC\_C\_BINDING\_DEFAULT\_TIMEOUT)</span></span>   | <span data-ttu-id="be05f-133">720</span><span class="sxs-lookup"><span data-stu-id="be05f-133">720</span></span>                        |
| <span data-ttu-id="be05f-134">6</span><span class="sxs-lookup"><span data-stu-id="be05f-134">6</span></span>                                       | <span data-ttu-id="be05f-135">840</span><span class="sxs-lookup"><span data-stu-id="be05f-135">840</span></span>                        |
| <span data-ttu-id="be05f-136">7</span><span class="sxs-lookup"><span data-stu-id="be05f-136">7</span></span>                                       | <span data-ttu-id="be05f-137">960</span><span class="sxs-lookup"><span data-stu-id="be05f-137">960</span></span>                        |
| <span data-ttu-id="be05f-138">8</span><span class="sxs-lookup"><span data-stu-id="be05f-138">8</span></span>                                       | <span data-ttu-id="be05f-139">1080</span><span class="sxs-lookup"><span data-stu-id="be05f-139">1080</span></span>                       |
| <span data-ttu-id="be05f-140">9 ( \_ \_ \_ Максимальное время ожидания привязки RPC C \_ )</span><span class="sxs-lookup"><span data-stu-id="be05f-140">9 (RPC\_C\_BINDING\_MAX\_TIMEOUT)</span></span>       | <span data-ttu-id="be05f-141">1200</span><span class="sxs-lookup"><span data-stu-id="be05f-141">1200</span></span>                       |
| <span data-ttu-id="be05f-142">10 ( \_ \_ \_ бесконечное время ожидания привязки RPC C \_ )</span><span class="sxs-lookup"><span data-stu-id="be05f-142">10 (RPC\_C\_BINDING\_INFINITE\_TIMEOUT)</span></span> | <span data-ttu-id="be05f-143">Бесконечное время ожидания</span><span class="sxs-lookup"><span data-stu-id="be05f-143">Infinite time out</span></span>          |



 

<span data-ttu-id="be05f-144">После включения поддержания активности клиент отправляет один пакет проверки активности каждую секунду.</span><span class="sxs-lookup"><span data-stu-id="be05f-144">Once the keep alives are turned on, the client sends one keep alive packet every second.</span></span> <span data-ttu-id="be05f-145">Если нет подтверждения от сервера в течение трех или более активных сеансов, то клиент объявляет соединение неактивным и завершает удаленный вызов процедуры.</span><span class="sxs-lookup"><span data-stu-id="be05f-145">If there is no acknowledgment from the server for three or more keep alives, the client declares the connection dead and fails the remote procedure call.</span></span> <span data-ttu-id="be05f-146">Если сервер отправляет ответ в течение заданного времени ожидания, то функция поддержания активности не будет включена.</span><span class="sxs-lookup"><span data-stu-id="be05f-146">If the server sends a response within the specified time out, keep alives will not be turned on.</span></span> <span data-ttu-id="be05f-147">Если сервер реагирует на активность, но не отвечает на удаленный вызов процедур, клиент продолжает отправлять сообщения о существовании.</span><span class="sxs-lookup"><span data-stu-id="be05f-147">If the server responds to keep alives, but does not respond to the remote procedure call, the client continues sending keep alives.</span></span> <span data-ttu-id="be05f-148">Когда сервер отвечает на вызов RPC, проверка активности отключена.</span><span class="sxs-lookup"><span data-stu-id="be05f-148">Once the server responds to the RPC call, the keep alives are turned off.</span></span> <span data-ttu-id="be05f-149">Для Windows 2000 функция поддержания активности включена только для синхронных вызовов RPC.</span><span class="sxs-lookup"><span data-stu-id="be05f-149">For Windows 2000, keep alives are turned on only for synchronous RPC calls.</span></span> <span data-ttu-id="be05f-150">Для Windows XP функция поддержания активности включена для асинхронных вызовов RPC.</span><span class="sxs-lookup"><span data-stu-id="be05f-150">For Windows XP, keep alives are turned on for asynchronous RPC calls as well.</span></span>

<span data-ttu-id="be05f-151">Чтобы обеспечить своевременное реагирование клиентского приложения на сетевые проблемы, необходимо установить самое низкое значение.</span><span class="sxs-lookup"><span data-stu-id="be05f-151">It is tempting to set keep alives to the lowest value to ensure the client application responds to network problems in a timely fashion.</span></span> <span data-ttu-id="be05f-152">Следует соблюдать осторожность в отношении таких искушения, а также применять принудительное применение к определенному значению.</span><span class="sxs-lookup"><span data-stu-id="be05f-152">Careful consideration should be given to such temptation, and scrutiny applied to whether an aggressive value is warranted.</span></span> <span data-ttu-id="be05f-153">При восстановлении подключения сервер, который временно теряет подключение, может обнаружиться в состоянии поддержания активности от многочисленных клиентов.</span><span class="sxs-lookup"><span data-stu-id="be05f-153">A server that temporarily loses connectivity may find itself flooded with keep alives from numerous clients once connectivity is restored.</span></span> <span data-ttu-id="be05f-154">Кроме того, длительные вычислительные задачи могут занять более двух минут, и сервер может найти больше времени на время ЦП, чем выполнение полезных действий.</span><span class="sxs-lookup"><span data-stu-id="be05f-154">In addition, long computational tasks can take more than two minutes, and the server may find itself spending more CPU time answering keep alives than performing useful work.</span></span> <span data-ttu-id="be05f-155">Поэтому следует использовать проверку активности.</span><span class="sxs-lookup"><span data-stu-id="be05f-155">Therefore, keep alives should be used with moderation.</span></span> <span data-ttu-id="be05f-156">Если клиент не может допустить своего потока в течение длительных периодов, следует учитывать асинхронные вызовы RPC.</span><span class="sxs-lookup"><span data-stu-id="be05f-156">If the client cannot tolerate its thread being tied up for long periods, asynchronous RPC should be considered.</span></span>

<span data-ttu-id="be05f-157">Другие последовательности протоколов могут реализовывать различные механизмы обнаружения серверов, которые не отвечают, в зависимости от того, какой транспорт используется.</span><span class="sxs-lookup"><span data-stu-id="be05f-157">Other protocol sequences may implement different mechanisms for detecting unresponsive servers, depending on which transport is used.</span></span> <span data-ttu-id="be05f-158">Транспорт [**нкалрпк**](/windows/desktop/Midl/ncalrpc) не использует проверки активности.</span><span class="sxs-lookup"><span data-stu-id="be05f-158">The [**ncalrpc**](/windows/desktop/Midl/ncalrpc) transport does not use keep alives.</span></span> <span data-ttu-id="be05f-159">Так как все связи в **нкалрпк** являются локальными, если сервер не отвечает на запросы во время выполнения вызова, время выполнения RPC на клиенте немедленно вызовет сбой.</span><span class="sxs-lookup"><span data-stu-id="be05f-159">Since all communications in **ncalrpc** are local, if the server becomes unresponsive while a call is in progress, the RPC run time on the client immediately fails the call.</span></span>

## <a name="call-time-outs"></a><span data-ttu-id="be05f-160">Время ожидания вызова</span><span class="sxs-lookup"><span data-stu-id="be05f-160">Call Time Outs</span></span>

<span data-ttu-id="be05f-161">Проверка активности протокола TCP выполняется, если сетевое подключение потеряно или если сервер аварийно завершает работу.</span><span class="sxs-lookup"><span data-stu-id="be05f-161">TCP keep alives are fine if network connectivity is lost, or if the server crashes.</span></span> <span data-ttu-id="be05f-162">Но если сервер взаимоблокируется в пользовательском режиме, то проверка активности TCP возвращается успешно, но вызов никогда не будет возвращать.</span><span class="sxs-lookup"><span data-stu-id="be05f-162">But if the server deadlocks in user mode, TCP keep alives return successfully but the call will never return.</span></span> <span data-ttu-id="be05f-163">Чтобы справиться с этим сценарием, в Windows XP был добавлен новый параметр времени выполнения: \_ \_ \_ время ожидания вызова RPC C \_ .</span><span class="sxs-lookup"><span data-stu-id="be05f-163">To deal with this scenario, a new run-time option was added for Windows XP: RPC\_C\_OPT\_CALL\_TIMEOUT.</span></span> <span data-ttu-id="be05f-164">Этот параметр указывает времени выполнения RPC на настройку таймера при каждой отправке запроса на сервер.</span><span class="sxs-lookup"><span data-stu-id="be05f-164">This option instructs the RPC run time to set up a timer each time it sends a request to the server.</span></span> <span data-ttu-id="be05f-165">Если срок действия таймера истекает, вызов автоматически отменяется и завершается \_ с \_ отменой вызова RPC S \_ .</span><span class="sxs-lookup"><span data-stu-id="be05f-165">If the timer expires, the call is automatically canceled and completes with RPC\_S\_CALL\_CANCELLED.</span></span> <span data-ttu-id="be05f-166">Пока сервер отвечает в течение указанного времени, клиент не будет отменять вызов.</span><span class="sxs-lookup"><span data-stu-id="be05f-166">As long as the server responds within the specified time limit, the client will not cancel the call.</span></span> <span data-ttu-id="be05f-167">Это означает, что вызов из нескольких фрагментов может занять больше времени, чем время ожидания, так как каждый ответ сервера получается в течение времени ожидания, даже несмотря на то, что время ожидания всех откликов превышает промежуток времени.</span><span class="sxs-lookup"><span data-stu-id="be05f-167">This means a multifragment call may take more than the time-out period to complete, as each response from the server is received within the time-out period, even though the time period for all responses to arrive was more than the time-out period.</span></span>

<span data-ttu-id="be05f-168">Кроме того, при отмене вызова сервер не уведомляется об отмене.</span><span class="sxs-lookup"><span data-stu-id="be05f-168">Also, when a call is canceled the server is not notified of the cancellation.</span></span> <span data-ttu-id="be05f-169">Таким образом, сервер, скорее всего, будет выполнять вызов в некоторый момент, и клиент просто игнорирует ответ от сервера.</span><span class="sxs-lookup"><span data-stu-id="be05f-169">The server, therefore, will likely execute the call at some point, and the client will simply ignore the response from the server.</span></span>

<span data-ttu-id="be05f-170">Наиболее опасная ловушка с истечением времени вызова — это установка короткого времени ожидания и повторный вызов на том же сервере.</span><span class="sxs-lookup"><span data-stu-id="be05f-170">The most dangerous pitfall with call time outs is establishing a short time out and retrying the call on the same server.</span></span> <span data-ttu-id="be05f-171">В следующем сценарии показаны опасности такого подхода.</span><span class="sxs-lookup"><span data-stu-id="be05f-171">The following scenario illustrates the dangers of this approach:</span></span>

<span data-ttu-id="be05f-172">Представьте себе сервер, который работает почти как емкость.</span><span class="sxs-lookup"><span data-stu-id="be05f-172">Imagine a server that operates near capacity.</span></span> <span data-ttu-id="be05f-173">У него есть несколько клиентов с очень коротким временем ожидания, например пять секунд.</span><span class="sxs-lookup"><span data-stu-id="be05f-173">It has a number of clients with very short time outs, such as five seconds.</span></span> <span data-ttu-id="be05f-174">Временная утрата сетевого подключения или перегрузки на маршрутизаторе приводит к задержке в ответах сервера на несколько секунд.</span><span class="sxs-lookup"><span data-stu-id="be05f-174">A temporary loss of network connectivity or congestion at a router causes a lapse in server replies for a few seconds.</span></span> <span data-ttu-id="be05f-175">В сетях Ethernet эта ситуация может быть легко вызвана увеличением нагрузки на связь, которую сервер использует совместно с другим компьютером.</span><span class="sxs-lookup"><span data-stu-id="be05f-175">On Ethernet networks, this situation can easily be caused by a burst of activity on a link that the server shares with another machine.</span></span> <span data-ttu-id="be05f-176">Сервер не управляет отправкой всех ответов до 5-секундного истечения времени ожидания. Клиенты отменили свои вызовы и сразу же попытайтесь повторить попытку.</span><span class="sxs-lookup"><span data-stu-id="be05f-176">The server does not manage to send all replies before the five-second time out. The clients get their calls canceled, and immediately retry.</span></span> <span data-ttu-id="be05f-177">Сервер не знает, что вызовы выполняют повторы, а также выполняет их.</span><span class="sxs-lookup"><span data-stu-id="be05f-177">The server is not aware the calls are retries, and executes them as well.</span></span> <span data-ttu-id="be05f-178">Таким способом, вместо выполнения обычной рабочей нагрузки вызовов он выполняет 30-50% больше вызовов в зависимости от количества истечения времени ожидания клиентов. Если это превышает емкость, и сервер не может отвечать на все клиенты в течение пяти секунд, на сервер отправляются еще один цикл вызовов.</span><span class="sxs-lookup"><span data-stu-id="be05f-178">Thus, instead of executing its normal workload of calls, it executes 30-50% more calls, depending on how many clients timed out. If this exceeds its capacity, and the server cannot respond to all clients within five seconds, another round of calls are sent to the server.</span></span> <span data-ttu-id="be05f-179">Клиенты продолжают выполнять одни и те же вызовы, а так как сервер перегружается при обработке предыдущих вызовов, он не может ответить в течение времени ожидания. После ответа клиенты достигли времени ожидания, выдавали новый вызов и отменили ответ.</span><span class="sxs-lookup"><span data-stu-id="be05f-179">The clients keep reissuing the same calls, and since the server is overloaded processing previous calls, it is unable to respond within the time out. Once it responds, the clients have hit the time out, issued a new call, and discarded the answer.</span></span> <span data-ttu-id="be05f-180">В худшем случае сервер не будет восстанавливаться до перезагрузки, а в зависимости от шаблона клиентского доступа может не восстанавливаться до тех пор, пока не остановится достаточное количество клиентов.</span><span class="sxs-lookup"><span data-stu-id="be05f-180">In a worst case scenario, the server will not recover until reboot, and depending on client access pattern, may not recover until a sufficient number of clients are stopped.</span></span>

> [!Note]  
> <span data-ttu-id="be05f-181">Время ожидания вызовов работает только в последовательностях протокола [**\_ http**](/windows/desktop/Midl/ncacn-http) [**нкакн \_ IP \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp) и нкакн.</span><span class="sxs-lookup"><span data-stu-id="be05f-181">Call time outs work only on the [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp) and [**ncacn\_http**](/windows/desktop/Midl/ncacn-http) protocol sequences.</span></span>

 

 

 