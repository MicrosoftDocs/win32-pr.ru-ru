---
title: Управление памятью заглушки сервера
description: Управление памятью заглушки сервера
ms.assetid: 99e3ee56-5adb-4b25-bcf2-316d1bbdbdba
keywords:
- Управление памятью заглушки сервера
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6e052df6da999e5371ac498a1d39852b4be2b5e
ms.sourcegitcommit: ae73f4dd3cf5a3c6a1ea7d191ca32a5b01f6686b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/08/2020
ms.locfileid: "103891177"
---
# <a name="server-stub-memory-management"></a><span data-ttu-id="6228c-104">Управление памятью заглушки сервера</span><span class="sxs-lookup"><span data-stu-id="6228c-104">Server Stub Memory Management</span></span>

## <a name="an-introduction-to-server-stub-memory-management"></a><span data-ttu-id="6228c-105">Введение в Server-Stub управления памятью</span><span class="sxs-lookup"><span data-stu-id="6228c-105">An Introduction to Server-Stub Memory Management</span></span>

<span data-ttu-id="6228c-106">Созданные MIDL-заглушки действуют как интерфейс между клиентским процессом и серверным процессом.</span><span class="sxs-lookup"><span data-stu-id="6228c-106">MIDL-generated stubs act as the interface between a client process and a server process.</span></span> <span data-ttu-id="6228c-107">Клиентская заглушка маршалирует все данные, передаваемые в параметры, помеченные атрибутом [**\[ in \]**](../midl/in.md) , и отправляет их в заглушку сервера.</span><span class="sxs-lookup"><span data-stu-id="6228c-107">A client stub marshals all data passed to parameters marked with the [**\[in\]**](../midl/in.md) attribute, and sends it to the server stub.</span></span> <span data-ttu-id="6228c-108">Заглушка сервера при получении этих данных восстанавливает стек вызовов, а затем выполняет соответствующую функцию сервера, реализованную пользователем.</span><span class="sxs-lookup"><span data-stu-id="6228c-108">The server stub, upon receiving this data, reconstructs the call stack, and then executes the corresponding user-implemented server function.</span></span> <span data-ttu-id="6228c-109">Заглушка сервера также маршалирует данные параметров, отмеченные атрибутом [**\[ out \]**](../midl/out-idl.md) , и возвращает их клиентскому приложению.</span><span class="sxs-lookup"><span data-stu-id="6228c-109">The server stub also marshals the parameter data marked with the [**\[out\]**](../midl/out-idl.md) attribute and returns it to the client application.</span></span>

<span data-ttu-id="6228c-110">32-битный формат упакованных данных, используемый MSRPC, — это совместимая версия синтаксиса передачи представления данных сети (NDR).</span><span class="sxs-lookup"><span data-stu-id="6228c-110">The 32-bit marshaled data format used by MSRPC is a compliant version of the Network Data Representation (NDR) transfer syntax.</span></span> <span data-ttu-id="6228c-111">Дополнительные сведения об этом формате см. [на веб-сайте Open Group](https://www.opengroup.org/).</span><span class="sxs-lookup"><span data-stu-id="6228c-111">For more information about this format, see [The Open Group website](https://www.opengroup.org/).</span></span> <span data-ttu-id="6228c-112">В 64-разрядных платформах для повышения производительности можно использовать расширение Microsoft 64-bit для преобразования NDR с именем NDR64.</span><span class="sxs-lookup"><span data-stu-id="6228c-112">For 64-bit platforms, a Microsoft 64-bit extension to NDR transfer syntax called NDR64 can be used for better performance.</span></span>

## <a name="unmarshaling-inbound-data"></a><span data-ttu-id="6228c-113">Распаковка входящих данных</span><span class="sxs-lookup"><span data-stu-id="6228c-113">Unmarshaling Inbound Data</span></span>

<span data-ttu-id="6228c-114">В MSRPC клиентская заглушка маршалирует все данные параметров, помеченные как, [**\[ \] в один**](../midl/in.md) непрерывный буфер для передачи в заглушку сервера.</span><span class="sxs-lookup"><span data-stu-id="6228c-114">In MSRPC, the client stub marshals all of the parameter data tagged as [**\[in\]**](../midl/in.md) in one continuous buffer for transmission to the server stub.</span></span> <span data-ttu-id="6228c-115">Аналогичным образом заглушка сервера маршалирует все данные, отмеченные атрибутом [**\[ out \]**](../midl/out-idl.md) , в непрерывном буфере для возврата к клиентской заглушке.</span><span class="sxs-lookup"><span data-stu-id="6228c-115">Likewise, the server stub marshals all data marked with the [**\[out\]**](../midl/out-idl.md) attribute in a continuous buffer for return to the client stub.</span></span> <span data-ttu-id="6228c-116">Хотя уровень сетевых протоколов, находящихся под RPC, может фрагментировать и паккетизе буфер для передачи, фрагментация прозрачна для заглушек RPC.</span><span class="sxs-lookup"><span data-stu-id="6228c-116">While the network protocol layer beneath RPC can fragment and packetize the buffer for transmission, the fragmentation is transparent to the RPC stubs.</span></span>

<span data-ttu-id="6228c-117">Выделение памяти для создания кадра вызовов сервера может быть дорогостоящей операцией.</span><span class="sxs-lookup"><span data-stu-id="6228c-117">Memory allocation for creating the server call frame can be an expensive operation.</span></span> <span data-ttu-id="6228c-118">Заглушка сервера попытается уменьшить использование ненужного объема памяти, если это возможно, и предполагается, что серверная подпрограмма не будет освобождать или перераспределять данные **\[ , \]** помеченные атрибутами [**\[ in \]**](../midl/in.md) или in.</span><span class="sxs-lookup"><span data-stu-id="6228c-118">The server stub will attempt to minimize unnecessary memory usage when possible, and it is assumed that the server routine will not free or reallocate data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="6228c-119">Заглушка сервера пытается повторно использовать данные в буфере везде, где это возможно, чтобы избежать избыточного дублирования.</span><span class="sxs-lookup"><span data-stu-id="6228c-119">The server stub attempts to reuse data in the buffer whenever possible to avoid unnecessary duplication.</span></span> <span data-ttu-id="6228c-120">Общее правило состоит в том, что если упакованный формат данных совпадает с форматом памяти, RPC будет использовать указатели на упакованные данные вместо выделения дополнительной памяти для одинаково отформатированных данных.</span><span class="sxs-lookup"><span data-stu-id="6228c-120">The general rule is that if the marshaled data format is the same as the memory format, RPC will use pointers to the marshalled data instead of allocating additional memory for identically formatted data.</span></span>

<span data-ttu-id="6228c-121">Например, следующий вызов RPC определяется структурой, упакованной формат которой идентичен его формату в памяти.</span><span class="sxs-lookup"><span data-stu-id="6228c-121">For example, the following RPC call is defined with a structure whose marshaled format is identical to its in-memory format.</span></span>

``` syntax
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```

<span data-ttu-id="6228c-122">В этом случае RPC не выделяет дополнительную память для данных, на которые ссылается *плинструктуре*; Вместо этого он просто передает указатель на упакованные данные в реализацию функции на стороне сервера.</span><span class="sxs-lookup"><span data-stu-id="6228c-122">In this case, RPC does not allocate additional memory for the data referenced by *plInStructure*; rather, it simply passes the pointer to the marshaled data to the server-side function implementation.</span></span> <span data-ttu-id="6228c-123">Заглушка сервера RPC проверяет буфер во время процесса распаковки, если заглушка компилируется с помощью флага "-устойчивости" (который является параметром по умолчанию в последней версии компилятора MIDL).</span><span class="sxs-lookup"><span data-stu-id="6228c-123">The RPC server stub verifies the buffer during the unmarshaling process if the stub is compiled using the "-robust" flag (which is a default setting in the nmost recent version of the MIDL compiler).</span></span> <span data-ttu-id="6228c-124">RPC гарантирует, что данные, передаваемые в реализацию функции на стороне сервера, являются допустимыми.</span><span class="sxs-lookup"><span data-stu-id="6228c-124">RPC guarantees that the data passed to the server-side function implementation is valid.</span></span>

<span data-ttu-id="6228c-125">Имейте в виду, что память выделяется для *плаутструктуре*, так как на сервер не передаются данные.</span><span class="sxs-lookup"><span data-stu-id="6228c-125">Be aware that memory is allocated for *plOutStructure*, since no data is passed to the server for it.</span></span>

## <a name="memory-allocation-for-inbound-data"></a><span data-ttu-id="6228c-126">Выделение памяти для входящих данных</span><span class="sxs-lookup"><span data-stu-id="6228c-126">Memory Allocation for Inbound Data</span></span>

<span data-ttu-id="6228c-127">Случаи могут возникать, когда заглушка сервера выделяет память для данных параметров, помеченных атрибутами [**\[ in \]**](../midl/in.md) или **\[ in \]** .</span><span class="sxs-lookup"><span data-stu-id="6228c-127">Cases can arise where the server stub allocates memory for parameter data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="6228c-128">Это происходит, когда формат упакованных данных отличается от формата памяти или если структуры, составляющие Упакованные данные, достаточно сложны и должны считываться в атомарном виде с помощью заглушки сервера RPC.</span><span class="sxs-lookup"><span data-stu-id="6228c-128">This occurs when the marshaled data format differs from the memory format, or when the structures that comprise the marshaled data are sufficient complex and must be read atomically by the RPC server stub.</span></span> <span data-ttu-id="6228c-129">Ниже приведено несколько типичных случаев, когда необходимо выделить память для данных, полученных заглушкой сервера.</span><span class="sxs-lookup"><span data-stu-id="6228c-129">Listed below are several common cases when memory must be allocated for data received by the server stub.</span></span>

-   <span data-ttu-id="6228c-130">Данные являются переменным массивом или согласованным переменным массивом.</span><span class="sxs-lookup"><span data-stu-id="6228c-130">The data is a varying array or a conformant varying array.</span></span> <span data-ttu-id="6228c-131">Это массивы (или указатели на массивы), для которых задан атрибут [**\[ length \_ () \]**](../midl/length-is.md) или [**\[ First \_ — () \]**](../midl/first-is.md) .</span><span class="sxs-lookup"><span data-stu-id="6228c-131">These are arrays (or pointers to arrays) that have the [**\[length\_is()\]**](../midl/length-is.md) or [**\[first\_is()\]**](../midl/first-is.md) attribute set on them.</span></span> <span data-ttu-id="6228c-132">В отчете NDR только первый элемент этих массивов маршалируется и передается.</span><span class="sxs-lookup"><span data-stu-id="6228c-132">In NDR, only the first element of these arrays are marshaled and transmitted.</span></span> <span data-ttu-id="6228c-133">Например, в приведенном ниже фрагменте кода для данных, передаваемых в параметре *ПС* , будет выделена память.</span><span class="sxs-lookup"><span data-stu-id="6228c-133">For example, in the code snippet below, the data passed in the parameter *pv* will have memory allocated for it.</span></span>

    ``` syntax
    void RpcFunction
    (
        [in] long size,
        [in, out] long *pLength,
        [in, out, size_is(size), length_is(*pLength)] long *pv
    );
    ```

-   <span data-ttu-id="6228c-134">Данные представляют собой строку размера или несогласованную строку.</span><span class="sxs-lookup"><span data-stu-id="6228c-134">The data is a sized string or non-conformant string.</span></span> <span data-ttu-id="6228c-135">Эти строки обычно являются указателями на символьные данные, помеченные атрибутом [**\[ size \_ — () \]**](../midl/size-is.md) .</span><span class="sxs-lookup"><span data-stu-id="6228c-135">These strings are usually pointers to character data tagged with the [**\[size\_is()\]**](../midl/size-is.md) attribute.</span></span> <span data-ttu-id="6228c-136">В приведенном ниже примере в строке, передаваемой в функцию на стороне сервера **сизедстринг** , будет выделена память, в то время как строка, передаваемая в функцию **нормалстринг** , будет использоваться повторно.</span><span class="sxs-lookup"><span data-stu-id="6228c-136">In the example below, the string passed to the **SizedString** server-side function will have memory allocated, whereas the string passed to the **NormalString** function will be reused.</span></span>

    ``` syntax
    void SizedString
    (
        [in] long size,
        [in, size_is(size), string] char *str
    );

    void NormalString
    (
        [in, string] char str
    );
    ```

-   <span data-ttu-id="6228c-137">Данные — это простой тип, размер памяти которого отличается от его упакованного размера, например **enum16** и **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="6228c-137">The data is a simple type whose memory size differs from its marshaled size, such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="6228c-138">Данные определяются структурой, выравнивание памяти которого меньше естественного выравнивания, содержит любой из приведенных выше типов данных или имеет замыкающий байт.</span><span class="sxs-lookup"><span data-stu-id="6228c-138">The data is defined by a structure whose memory alignment is smaller than the natural alignment, contains any of the above data types, or has trailing byte padding.</span></span> <span data-ttu-id="6228c-139">Например, Следующая сложная структура данных принудительно применяет 2-байтовое выравнивание, а в конце — заполнение.</span><span class="sxs-lookup"><span data-stu-id="6228c-139">For example, the following complex data structure has forced 2-byte alignment and has padding at the end.</span></span>

    ``` syntax
#pragma pack(2)
    typedef struct ComplexPackedStructure
    {
        char c;  
        long l;   // alignment is forced at the second byte
        char c2;  // there will be a trailing one-byte pad to keep 2-byte alignment
    }
    ```

-   <span data-ttu-id="6228c-140">Данные содержат структуру, которая должна быть упакована в поле по полю.</span><span class="sxs-lookup"><span data-stu-id="6228c-140">The data contains a structure that must be marshaled field by field.</span></span> <span data-ttu-id="6228c-141">Эти поля включают в себя указатели интерфейса, определенные в интерфейсах DCOM. Игнорируемые указатели; целочисленные значения, заданные с помощью атрибута [**\[ \] Range**](../midl/range.md) ; элементы массивов, определенные с помощью [**\[ проводного \_ \] маршалирования**](../midl/wire-marshal.md), [**\[ пользовательского \_ маршалирования \]**](../midl/user-marshal.md), [**\[ передачи \_ как \]**](../midl/transmit-as.md) и [**\[ представления \_ в виде \]**](../midl/represent-as.md) атрибутов; и внедренных сложных структур данных.</span><span class="sxs-lookup"><span data-stu-id="6228c-141">These fields include interface pointers defined in DCOM interfaces; ignored pointers; integer values set with the [**\[range\]**](../midl/range.md) attribute; elements of arrays defined with the [**\[wire\_marshal\]**](../midl/wire-marshal.md), [**\[user\_marshal\]**](../midl/user-marshal.md), [**\[transmit\_as\]**](../midl/transmit-as.md) and [**\[represent\_as\]**](../midl/represent-as.md) attributes; and embedded complex data structures.</span></span>
-   <span data-ttu-id="6228c-142">Данные содержат объединение, структуру, содержащую объединение, или массив объединений.</span><span class="sxs-lookup"><span data-stu-id="6228c-142">The data contains a union, a structure containing a union, or an array of unions.</span></span> <span data-ttu-id="6228c-143">В связи с передачей маршалируется только конкретная ветвь объединения.</span><span class="sxs-lookup"><span data-stu-id="6228c-143">Only the specific branch of the union is marshaled on the wire.</span></span>
-   <span data-ttu-id="6228c-144">Данные содержат структуру с многомерным массивом, имеющим по крайней мере одно нефиксированное измерение.</span><span class="sxs-lookup"><span data-stu-id="6228c-144">The data contains a structure with a multidimensional conformant array that has at least one non-fixed dimension.</span></span>
-   <span data-ttu-id="6228c-145">Данные содержат массив сложных структур.</span><span class="sxs-lookup"><span data-stu-id="6228c-145">The data contains an array of complex structures.</span></span>
-   <span data-ttu-id="6228c-146">Данные содержат массив простых типов данных, таких как **enum16** и **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="6228c-146">The data contains an array of simple data types such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="6228c-147">Данные содержат массив указателей ссылок и интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="6228c-147">The data contains an array of ref and interface pointers.</span></span>
-   <span data-ttu-id="6228c-148">К данным применяется атрибут [**\[ принудительного \_ выделения \]**](../midl/force-allocate.md) , примененный к указателю.</span><span class="sxs-lookup"><span data-stu-id="6228c-148">The data has a [**\[force\_allocate\]**](../midl/force-allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="6228c-149">Данные имеют атрибут [**\[ выделения (все \_ узлы) \]**](../midl/allocate.md) , примененный к указателю.</span><span class="sxs-lookup"><span data-stu-id="6228c-149">The data has a [**\[allocate(all\_nodes)\]**](../midl/allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="6228c-150">Данные имеют атрибут [**\[ \_ количества \] байтов**](../midl/byte-count.md) , примененный к указателю.</span><span class="sxs-lookup"><span data-stu-id="6228c-150">The data has a [**\[byte\_count\]**](../midl/byte-count.md) attribute applied to a pointer.</span></span>

## <a name="64-bit-data-and-ndr64-transfer-syntax"></a><span data-ttu-id="6228c-151">64-разрядный синтаксис преобразования данных и NDR64</span><span class="sxs-lookup"><span data-stu-id="6228c-151">64-bit Data and NDR64 Transfer Syntax</span></span>

<span data-ttu-id="6228c-152">Как упоминалось ранее, 64-разрядные данные обработаны с использованием определенного синтаксиса 64-разрядной пересылки, именуемого NDR64.</span><span class="sxs-lookup"><span data-stu-id="6228c-152">As mentioned previously, 64-bit data is marshalled using a specific 64-bit transfer syntax called NDR64.</span></span> <span data-ttu-id="6228c-153">Этот синтаксис передачи был разработан для устранения конкретной проблемы, возникающей при маршалировании указателей по 32-разрядному NDR и передаче в заглушку сервера на 64-разрядной платформе.</span><span class="sxs-lookup"><span data-stu-id="6228c-153">This transfer syntax was developed to address the specific issue that arises when pointers are marshaled under 32-bit NDR and transmitted to a server-stub on a 64-bit platform.</span></span> <span data-ttu-id="6228c-154">В этом случае упакованный 32-разрядный указатель данных не соответствует 64-бит, а выделение памяти будет неизменно.</span><span class="sxs-lookup"><span data-stu-id="6228c-154">In this case, a marshaled 32-bit data pointer does not match a 64-bit one, and memory allocation will invariably occur.</span></span> <span data-ttu-id="6228c-155">Чтобы создать более единообразное поведение на 64-разрядных платформах, корпорация Майкрософт разработала новый синтаксис перемещения, именуемый NDR64.</span><span class="sxs-lookup"><span data-stu-id="6228c-155">To create a more consistent behavior on 64-bit platforms, Microsoft developed a new transfer syntax called NDR64.</span></span>

<span data-ttu-id="6228c-156">Ниже приведен пример, иллюстрирующий эту проблему.</span><span class="sxs-lookup"><span data-stu-id="6228c-156">An example illustrating this problem is as follows:</span></span>


```C++
typedef struct PtrStruct
{
  long l;
  long *pl;
}
```



<span data-ttu-id="6228c-157">Эта структура при маршалировании будет повторно использоваться заглушкой сервера в 32-разрядной системе.</span><span class="sxs-lookup"><span data-stu-id="6228c-157">This structure, when marshaled, will be reused by the server stub on a 32-bit system.</span></span> <span data-ttu-id="6228c-158">Однако если серверная заглушка находится в 64-разрядной системе, то данные, Упакованные NDR, имеют размер 4 байта, но требуемый объем памяти будет равен 8.</span><span class="sxs-lookup"><span data-stu-id="6228c-158">However, if the server stub resides on a 64-bit system, the NDR-marshaled data is 4 bytes in length, but the required memory size will be 8.</span></span> <span data-ttu-id="6228c-159">В результате выделение памяти принудительно и повторное использование буфера будет происходить редко.</span><span class="sxs-lookup"><span data-stu-id="6228c-159">As a result, memory allocation is forced, and buffer reuse will rarely occur.</span></span> <span data-ttu-id="6228c-160">NDR64 решает эту проблему, делая упакованный размер указателя 64-бит.</span><span class="sxs-lookup"><span data-stu-id="6228c-160">NDR64 addresses this problem by making the marshaled size of a pointer 64-bit.</span></span>

<span data-ttu-id="6228c-161">В отличие от 32-разрядных NDR, простые ТЕС данных, такие как **enum16** и **\_ \_ int3264** , не делают структуру или массив сложными в NDR64.</span><span class="sxs-lookup"><span data-stu-id="6228c-161">In contrast with 32-bit NDR, simple data tyes such as **enum16** and **\_\_int3264** do not make a structure or array complex under NDR64.</span></span> <span data-ttu-id="6228c-162">Аналогично, начальные значения панели не делают структуру сложной.</span><span class="sxs-lookup"><span data-stu-id="6228c-162">Likewise, trailing pad values do not make a structure complex.</span></span> <span data-ttu-id="6228c-163">Указатели интерфейса обрабатываются как уникальные указатели на верхнем уровне. в результате структуры и массивы, содержащие указатели интерфейсов, не считаются сложными и не потребует определенного выделения памяти для их использования.</span><span class="sxs-lookup"><span data-stu-id="6228c-163">Interface pointers are treated as unique pointers at the top level; as a result, structures and arrays containing interface pointers are not considered complex and will not require specific memory allocation for their use.</span></span>

## <a name="initializing-outbound-data"></a><span data-ttu-id="6228c-164">Инициализация исходящих данных</span><span class="sxs-lookup"><span data-stu-id="6228c-164">Initializing Outbound Data</span></span>

<span data-ttu-id="6228c-165">После того как все входящие данные будут отменены, заглушке сервера необходимо инициализировать указатели только для исходящих сообщений, помеченные атрибутом [**\[ out \]**](../midl/out-idl.md) .</span><span class="sxs-lookup"><span data-stu-id="6228c-165">After all of the inbound data has been unmarshalled, the server stub needs to initialize the outbound-only pointers marked with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span>


```C++
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```



<span data-ttu-id="6228c-166">В приведенном выше вызове заглушка сервера должна инициализировать *плаутструктуре* , так как она отсутствовала в упакованных данных, и является подразумеваемым указателем [**\[ ссылки \]**](../midl/ref.md) , который должен быть доступен для реализации функции сервера.</span><span class="sxs-lookup"><span data-stu-id="6228c-166">In the above call, the server stub must initialize *plOutStructure* because it was not present in the marshaled data, and it is an implied [**\[ref\]**](../midl/ref.md) pointer that must be made available to the server function implementation.</span></span> <span data-ttu-id="6228c-167">Заглушка RPC-сервера инициализирует и отменяет все ссылочные указатели верхнего уровня с атрибутом [**\[ out \]**](../midl/out-idl.md) .</span><span class="sxs-lookup"><span data-stu-id="6228c-167">The RPC server stub initializes and zeroes out any top-level reference-only pointers with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span> <span data-ttu-id="6228c-168">Все указатели на неиспользуемые ссылки, расположенные под ним, также рекурсивно инициализируются. **\[ \]**</span><span class="sxs-lookup"><span data-stu-id="6228c-168">Any **\[out\]** reference pointers beneath it are recursively initialized as well.</span></span> <span data-ttu-id="6228c-169">Рекурсия останавливается в любых указателях с установленными для них атрибутами [**\[ Unique \]**](../midl/unique.md) или [**\[ ptr \]**](../midl/ptr.md) .</span><span class="sxs-lookup"><span data-stu-id="6228c-169">The recursion stops at any pointers with the [**\[unique\]**](../midl/unique.md) or [**\[ptr\]**](../midl/ptr.md) attributes set on them.</span></span>

<span data-ttu-id="6228c-170">Реализация серверной функции не может напрямую изменять значения указателей верхнего уровня и, таким же, не может перераспределять их.</span><span class="sxs-lookup"><span data-stu-id="6228c-170">The server function implementation cannot directly alter top-level pointer values, and thus cannot reallocate them.</span></span> <span data-ttu-id="6228c-171">Например, в реализации **процессрпкструктуре** выше следующий код является недопустимым:</span><span class="sxs-lookup"><span data-stu-id="6228c-171">For example, in the implementation of **ProcessRpcStructure** above, the following code is invalid:</span></span>


```C++
void ProcessRpcStructure(RpcStructure *plInStructure, rpcStructure *plOutStructure)
{
    plOutStructure = MIDL_user_allocate(sizeof(RpcStructure));
    Process(plOutStructure);
}
```



<span data-ttu-id="6228c-172">*плаутструктуре* — это значение стека, и его изменение не распространяется обратно в RPC.</span><span class="sxs-lookup"><span data-stu-id="6228c-172">*plOutStructure* is a stack value and its change is not propagated back to RPC.</span></span> <span data-ttu-id="6228c-173">Реализация серверной функции может попытаться избежать распределения, пытаясь освободить *плаутструктуре*, что может привести к повреждению памяти.</span><span class="sxs-lookup"><span data-stu-id="6228c-173">The server function implementation can attempt to avoid allocation by attempting to free *plOutStructure*, which may result in memory corruption.</span></span> <span data-ttu-id="6228c-174">Заглушка сервера выделит место для указателя верхнего уровня в памяти (в случае указателя на указатель) и простой структуры верхнего уровня, размер которой в стеке меньше ожидаемого.</span><span class="sxs-lookup"><span data-stu-id="6228c-174">The server stub will then allocate space for the top-level pointer in memory (in the pointer-to-pointer case) and a top-level simple structure whose size on the stack is smaller than expected.</span></span>

<span data-ttu-id="6228c-175">При определенных обстоятельствах клиент может указать размер выделяемой памяти на стороне сервера.</span><span class="sxs-lookup"><span data-stu-id="6228c-175">The client can, under certain circumstances, specify the memory allocation size of the server side.</span></span> <span data-ttu-id="6228c-176">В следующем примере клиент указывает размер исходящих данных в параметре входящего *размера* .</span><span class="sxs-lookup"><span data-stu-id="6228c-176">In the following example, the client specifies the size of the outbound data in the inbound *size* parameter.</span></span>

``` syntax
void VariableSizeData
(
    [in] long size,
    [out, size_is(size)] char *pv
);
```

<span data-ttu-id="6228c-177">После расмаршалинга входящих данных, включая *Размер*, заглушка сервера выделяет буфер для *ПС* с размером "sizeof (char) \* size".</span><span class="sxs-lookup"><span data-stu-id="6228c-177">After unmarshalling the inbound data, including *size*, the server stub allocates a buffer for *pv* with a size of "sizeof(char)\*size".</span></span> <span data-ttu-id="6228c-178">После выделения пространства заглушка сервера отменяет буфер.</span><span class="sxs-lookup"><span data-stu-id="6228c-178">After the space has been allocated, the server stub zeroes out the buffer.</span></span> <span data-ttu-id="6228c-179">Обратите внимание, что в этом конкретном случае заглушка выделяет память с помощью **\_ \_ выделяющих пользователем MIDL ()**, так как размер буфера определяется во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="6228c-179">Note that in this particular case, the stub allocates the memory with **MIDL\_user\_allocate()**, since the size of the buffer is determined at runtime.</span></span>

<span data-ttu-id="6228c-180">Имейте в виду, что в случае интерфейсов DCOM созданные MIDL-заглушки могут не участвовать вообще, если клиент и сервер используют один и тот же контейнер COM или если **икаллфраме** реализован.</span><span class="sxs-lookup"><span data-stu-id="6228c-180">Be aware that in the case of DCOM interfaces, MIDL-generated stubs may not be involved at all if the client and server share the same COM apartment, or if **ICallFrame** is implemented.</span></span> <span data-ttu-id="6228c-181">В этом случае сервер не может зависеть от поведения при выделении и должен независимо проверять память на уровне клиента.</span><span class="sxs-lookup"><span data-stu-id="6228c-181">In this case, the server cannot depend on the allocation behavior, and needs to independently verify client-sized memory.</span></span>

## <a name="server-side-function-implementations-and-outbound-data-marshaling"></a><span data-ttu-id="6228c-182">Реализации функций на стороне сервера и маршалирование исходящих данных</span><span class="sxs-lookup"><span data-stu-id="6228c-182">Server-side Function Implementations and Outbound Data Marshaling</span></span>

<span data-ttu-id="6228c-183">Сразу после обработки входящих данных и инициализации памяти, выделенной для хранения исходящих данных, заглушка сервера RPC выполняет серверную реализацию функции, вызываемой клиентом.</span><span class="sxs-lookup"><span data-stu-id="6228c-183">Immediately subsequent to the unmarshalling on inbound data and the initialization of the memory allocated to contain outbound data, the RPC server stub executes the server-side implementation of the function called by the client.</span></span> <span data-ttu-id="6228c-184">В настоящее время сервер может изменять данные, специально помеченные атрибутом **\[ in, out \]** , и заполнять память, выделенную для исходящих данных (данные, помеченные как [**\[ out \]**](../midl/out-idl.md)).</span><span class="sxs-lookup"><span data-stu-id="6228c-184">At this time, the server can modify the data specifically marked with the **\[in, out\]** attribute, and it can populate the memory allocated for outbound-only data (the data tagged with [**\[out\]**](../midl/out-idl.md)).</span></span>

<span data-ttu-id="6228c-185">Общие правила обработки упакованных данных параметров просты: сервер может выделить только новый объем памяти или изменить память, специально выделенную заглушкой сервера.</span><span class="sxs-lookup"><span data-stu-id="6228c-185">The general rules for the manipulation of marshalled parameter data are simple: the server can only allocate new memory or modify the memory specifically allocated by the server stub.</span></span> <span data-ttu-id="6228c-186">Перераспределение или освобождение существующей памяти для данных может негативно сказаться на результатах и производительности вызова функции, и его отладка может быть очень сложной.</span><span class="sxs-lookup"><span data-stu-id="6228c-186">Reallocating or releasing existing memory for data can have a negative impact on the results and performance of the function call, and can be very difficult to debug.</span></span>

<span data-ttu-id="6228c-187">Логически сервер RPC находится в адресном пространстве, отличном от клиента, и обычно предполагается, что они не используют общую память.</span><span class="sxs-lookup"><span data-stu-id="6228c-187">Logically, the RPC server lives in a different address space than the client, and it can generally be assumed that they do not share memory.</span></span> <span data-ttu-id="6228c-188">В результате реализация функции сервера может использовать данные, помеченные атрибутом [**\[ in \]**](../midl/in.md) , как "вспомогательную" память, не влияя на адреса памяти клиента.</span><span class="sxs-lookup"><span data-stu-id="6228c-188">As a result, it is safe for the server function implementation to use the data marked with the [**\[in\]**](../midl/in.md) attribute as "scratch" memory without affecting the client memory addresses.</span></span> <span data-ttu-id="6228c-189">С другой стороны, сервер не должен пытаться перераспределить или освободить **\[ \] данные, в результате** чего управление этими пробелами будет производиться заглушкой сервера RPC.</span><span class="sxs-lookup"><span data-stu-id="6228c-189">That said, the server should not attempt to reallocate or release **\[in\]** data, leaving the control of those spaces to the RPC server stub itself.</span></span>

<span data-ttu-id="6228c-190">Как правило, реализация функции сервера не требует перераспределения или освобождения данных, помеченных атрибутом **\[ in, out \]** .</span><span class="sxs-lookup"><span data-stu-id="6228c-190">Generally, the server function implementation does not need to reallocate or release data marked with the **\[in, out\]** attribute.</span></span> <span data-ttu-id="6228c-191">Для данных фиксированного размера логика реализации функции может напрямую изменять данные.</span><span class="sxs-lookup"><span data-stu-id="6228c-191">For fixed size data, the function implementation logic can directly modify the data.</span></span> <span data-ttu-id="6228c-192">Аналогично, для данных с переменным размером реализация функции не должна изменять значение поля, передаваемое атрибуту [**\[ size, \_ ( \] )**](../midl/size-is.md) .</span><span class="sxs-lookup"><span data-stu-id="6228c-192">Likewise, for variable-sized data, the function implementation must not modify the field value supplied to the [**\[size\_is()\]**](../midl/size-is.md) attribute, either.</span></span> <span data-ttu-id="6228c-193">Измените значение поля, используемое для изменения размера данных, в буфере меньшего или большего размера, возвращенного клиенту, который может быть недостаточным для работы с ненормальной длиной.</span><span class="sxs-lookup"><span data-stu-id="6228c-193">Change the field value used to size the data results in a smaller or larger buffer returned to the client which may be ill-equipped to deal with the abnormal length.</span></span>

<span data-ttu-id="6228c-194">Если в ситуации возникает ситуация, когда Серверная подпрограмма должна перераспределить память, используемую данными, помеченными атрибутом **\[ in, \] out** , то вполне возможно, что реализация функции на стороне сервера не будет иметь знания о том, что в качестве указателя, предоставленного заглушкой, выделяется память, выделенная с помощью **\_ интерфейса пользователя MIDL \_ ()** или упакованного кабельного буфера.</span><span class="sxs-lookup"><span data-stu-id="6228c-194">If circumstances occur where the server routine has to reallocate the memory used by data marked with the **\[in, out\]** attribute, it is entirely possible that the server-side function implementation will not know if the pointer provided by the stub is to memory allocated with **MIDL\_user\_allocate()** or the marshaled wire buffer.</span></span> <span data-ttu-id="6228c-195">Чтобы обойти эту проблему, MS RPC может гарантировать отсутствие утечки памяти или повреждения, если для данных задан атрибут [**\[ принудительного \_ выделения \]**](../midl/force-allocate.md) .</span><span class="sxs-lookup"><span data-stu-id="6228c-195">To work around this problem, MS RPC can ensure that no memory leak or corruption occurs if the [**\[force\_allocate\]**](../midl/force-allocate.md) attribute is set on the data.</span></span> <span data-ttu-id="6228c-196">Если задано **\[ принудительное \_ выделение \]** , заглушка сервера всегда выделяет память для указателя, несмотря на то, что производительность будет снижаться при каждом использовании.</span><span class="sxs-lookup"><span data-stu-id="6228c-196">When **\[force\_allocate\]** is set, the server stub will always allocate memory for the pointer, although the caveat is that performance will decrease for every use of it.</span></span>

<span data-ttu-id="6228c-197">Когда вызов возвращается из реализации функции на стороне сервера, заглушка сервера маршалирует данные, помеченные атрибутом [**\[ out \]**](../midl/out-idl.md) , и отправляет их клиенту.</span><span class="sxs-lookup"><span data-stu-id="6228c-197">When the call returns from the server-side function implementation, the server stub marshals the data marked with the [**\[out\]**](../midl/out-idl.md) attribute and sends it to the client.</span></span> <span data-ttu-id="6228c-198">Имейте в виду, что заглушка не маршалирует данные, если реализация функции на стороне сервера создает исключение.</span><span class="sxs-lookup"><span data-stu-id="6228c-198">Be aware that the stub does not marshal the data if the server-side function implementation throws an exception.</span></span>

## <a name="releasing-allocated-memory"></a><span data-ttu-id="6228c-199">Освобождение выделенной памяти</span><span class="sxs-lookup"><span data-stu-id="6228c-199">Releasing Allocated Memory</span></span>

<span data-ttu-id="6228c-200">Заглушка сервера RPC освободит стековую память после возврата вызова из функции на стороне сервера, независимо от того, возникает исключение или нет.</span><span class="sxs-lookup"><span data-stu-id="6228c-200">The RPC server stub will release the stack memory after the call has returned from the server-side function, whether an exception occurs or not.</span></span> <span data-ttu-id="6228c-201">Заглушка сервера освобождает всю память, выделенную заглушке, а также всю память, выделенную с помощью **\_ пользовательского \_ выделения MIDL ()**.</span><span class="sxs-lookup"><span data-stu-id="6228c-201">The server stub frees all memory allocated by the stub as well as any memory allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="6228c-202">Реализация функции на стороне сервера всегда должна обеспечить целостное состояние RPC, вызывая исключение или возвращая код ошибки.</span><span class="sxs-lookup"><span data-stu-id="6228c-202">The server-side function implementation must always give RPC a consistent state, either by throwing an exception or returning an error code.</span></span> <span data-ttu-id="6228c-203">Если функция завершается ошибкой во время заполнения сложных структур данных, она должна гарантировать, что все указатели указывают на допустимые данные или имеют значение **null**.</span><span class="sxs-lookup"><span data-stu-id="6228c-203">If the function fails during the population of complicated data structures, it must ensure that all pointers point to valid data or are set to **NULL**.</span></span>

<span data-ttu-id="6228c-204">Во время этого прохода заглушка сервера освобождает всю память, которая не является частью упакованного буфера, содержащего данные [**\[ в \]**](../midl/in.md) .</span><span class="sxs-lookup"><span data-stu-id="6228c-204">During this pass, the server stub frees all memory that is not part of the marshaled buffer containing the [**\[in\]**](../midl/in.md) data.</span></span> <span data-ttu-id="6228c-205">Единственным исключением из этого поведения является данные с установленным для них атрибутом [**\[ выделения (не \_ свободен) \]**](../midl/allocate.md) . заглушка сервера не освобождает память, связанную с этими указателями.</span><span class="sxs-lookup"><span data-stu-id="6228c-205">One exception to this behavior is data with the [**\[allocate(dont\_free)\]**](../midl/allocate.md) attribute set on them - the server stub does not free any memory associated with these pointers.</span></span>

<span data-ttu-id="6228c-206">После освобождения заглушки сервера памяти, выделенной заглушкой и реализацией функции, заглушка вызывает определенную функцию уведомления, если для конкретных данных указан атрибут [**\[ \_ флага \] Notify**](../midl/notify-flag.md) .</span><span class="sxs-lookup"><span data-stu-id="6228c-206">After the server stub releases the memory allocated by the stub and the function implementation, the stub calls a specific notification function if the [**\[notify\_flag\]**](../midl/notify-flag.md) attribute is specified for particular data.</span></span>

## <a name="marshalling-a-linked-list-over-rpc----an-example"></a><span data-ttu-id="6228c-207">Пример маршалинга связанного списка через RPC</span><span class="sxs-lookup"><span data-stu-id="6228c-207">Marshalling a Linked List over RPC -- An Example</span></span>


```C++
typedef struct _LINKEDLIST
{
    long lSize;
    [size_is(lSize)] char *pData;
    struct _LINKEDLIST *pNext;
} LINKEDLIST, *PLINKEDLIST;

void Test
(
    [in] LINKEDLIST *pIn,
    [in, out] PLINKEDLIST *pInOut,
    [out] LINKEDLIST *pOut
);
```



<span data-ttu-id="6228c-208">В приведенном выше примере формат памяти для **LINKEDLIST** будет идентичен формату упакованной связи.</span><span class="sxs-lookup"><span data-stu-id="6228c-208">In the above example, the memory format for **LINKEDLIST** will be identical to the marshaled wire format.</span></span> <span data-ttu-id="6228c-209">В результате Серверная заглушка не выделяет память для всей цепочки указателей данных под *закреплением*.</span><span class="sxs-lookup"><span data-stu-id="6228c-209">As a result, the server stub does not allocate memory for the entire chain of data pointers under *pIn*.</span></span> <span data-ttu-id="6228c-210">Вместо этого RPC повторно использует кабельный буфер для всего связанного списка.</span><span class="sxs-lookup"><span data-stu-id="6228c-210">Rather, RPC reuses the wire buffer for the entire linked list.</span></span> <span data-ttu-id="6228c-211">Аналогичным образом заглушка не выделяет память для использования в *схеме*, а вместо этого повторно использует проводной буфер, упакованный клиентом.</span><span class="sxs-lookup"><span data-stu-id="6228c-211">Similarly, the stub does not allocate memory for *pInOut*, but instead reuses the wire buffer marshaled by the client.</span></span>

<span data-ttu-id="6228c-212">Поскольку сигнатура функции содержит параметр исходящего трафика *тоска*, заглушка сервера выделяет память для хранения возвращаемых данных.</span><span class="sxs-lookup"><span data-stu-id="6228c-212">Because the function signature contains an outbound parameter, *pOut*, the server stub allocates memory to contain the returned data.</span></span> <span data-ttu-id="6228c-213">Выделенная память изначально обнуляется, а параметр **пнекст** имеет значение **null**.</span><span class="sxs-lookup"><span data-stu-id="6228c-213">The allocated memory is initially zeroes out, with **pNext** set to **NULL**.</span></span> <span data-ttu-id="6228c-214">Приложение может выделить память для нового связанного списка и указать *тоска* -> **пнекст** .</span><span class="sxs-lookup"><span data-stu-id="6228c-214">The application can allocate the memory for a new linked list and point *pOut*->**pNext** to it.</span></span> <span data-ttu-id="6228c-215">закрепление и связанный список, который он содержит, можно использовать в качестве вспомогательной области, но приложение не должно изменять какие *-* либо указатели пнекст.</span><span class="sxs-lookup"><span data-stu-id="6228c-215">*pIn* and the linked list it contains can be used as a scratch area, but the application should not change any of the pNext pointers.</span></span>

<span data-ttu-id="6228c-216">Приложение может свободно изменять содержимое связанного списка, на которое указывает *Схема контактов*, но не должно изменять ни один из **пнекстх** указателей, а только ссылку верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="6228c-216">The application can freely change the content of the linked list pointed to by *pInOut*, but it must not change any of the **pNext** pointers, let alone the top-level link itself.</span></span> <span data-ttu-id="6228c-217">Если приложение принимает решение сократить связанный список, оно не сможет понять, есть ли ссылки на **пнекст** указатели, чтобы внутренний буфер RPC или буфер, специально выделенный с помощью **\_ пользовательского выделения MIDL \_ ()**.</span><span class="sxs-lookup"><span data-stu-id="6228c-217">If the application decides to shorten the linked list, it cannot know if any given **pNext** pointer links tto an RPC internal buffer or a buffer specifically allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="6228c-218">Чтобы обойти эту ошибку, необходимо добавить определенное объявление типа для указателей на связанные списки, которые принудительно задают выделение пользователей, как показано в приведенном ниже коде.</span><span class="sxs-lookup"><span data-stu-id="6228c-218">To work around this issue, you add a specific type declaration for linked list pointers that forces user allocation, as seen in the code below.</span></span>

``` syntax
typedef [force_allocate] PLINKEDLIST;
```

<span data-ttu-id="6228c-219">Этот атрибут заставляет заглушку сервера распределять каждый узел связанного списка отдельно, и приложение может освободить сокращенную часть связанного списка, вызвав метод **MIDL \_ user \_ Free ()**.</span><span class="sxs-lookup"><span data-stu-id="6228c-219">This attribute forces the server stub to allocate each node of the linked list separately, and the application can free the shortened part of the linked list by calling **MIDL\_user\_free()**.</span></span> <span data-ttu-id="6228c-220">Затем приложение может безопасно установить указатель **пнекст** в конце нового сокращенного связанного списка до **значения NULL**.</span><span class="sxs-lookup"><span data-stu-id="6228c-220">The application can then safely set the **pNext** pointer at the end of the newly-shortened linked list to **NULL**.</span></span>

 

 