---
title: Реализация выходных каналов на клиенте
description: При использовании выходного канала для передачи данных с сервера клиенту необходимо реализовать процедуру принудительной отправки в клиенте.
ms.assetid: ab544daf-fbf7-4b00-95a8-55c149a86c27
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4ff274491e2b665d86b550853d07c3ff6a4b2a83
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "103791994"
---
# <a name="implementing-output-pipes-on-the-client"></a>Реализация выходных каналов на клиенте

При использовании выходного канала для передачи данных с сервера клиенту необходимо реализовать процедуру принудительной отправки в клиенте. Процедура Push принимает указатель на буфер и число элементов из клиентской заглушки и, если число элементов больше 0, обрабатывает данные. Например, он может скопировать данные из буфера заглушки в собственную память. Кроме того, он может обработать данные в буфере заглушки и сохранить их в файл. Если число элементов равно нулю, процедура Push завершает все необходимые задачи очистки перед возвратом.

В следующем примере клиентская функция Рецеивелонгс выделяет структуру канала и глобальный буфер памяти. Он инициализирует структуру, выполняет удаленный вызов процедур, а затем освобождает память.

## <a name="example"></a>Пример


```C++
//file: client.c (fragment)
#include <windows.h>
#include "pipedemo.h"
long *  globalPipeData;
long    globalBuffer[BUF_SIZE];
 
ulong   pipeDataIndex; /* state variable */
 
void ReceiveLongs()
{
    LONG_PIPE *outputPipe;
    idl_long_int i;
 
    globalPipeData =
        (long *)malloc( sizeof(long) * PIPE_SIZE );
    
    pipeDataIndex = 0;
    outputPipe.state =  (rpc_ss_pipe_state_t )&pipeDataIndex;
    outputPipe.push  = PipePush;
    outputPipe.alloc = PipeAlloc;
 
    OutPipe( &outputPipe ); /* Make the rpc */
 
    free( (void *)globalPipeData );
 
}//end ReceiveLongs()

void PipeAlloc( rpc_ss_pipe_state_t stateInfo,
                ulong requestedSize,
                long **allocatedBuffer,
                ulong *allocatedSize )
{ 
    ulong *state = (ulong *)stateInfo;
    if ( requestedSize > (BUF_SIZE*sizeof(long)) )
    {
       *allocatedSize = BUF_SIZE * sizeof(long);
    }
    else
    {
       *allocatedSize = requestedSize;
    }
    *allocatedBuffer = globalBuffer; 
} //end PipeAlloc
 
void PipePush( rpc_ss_pipe_state_t stateInfo,
               long *buffer,
               ulong numberOfElements )
{
    ulong elementsToCopy, i;
    ulong *state = (ulong *)stateInfo;

    if (numberOfElements == 0)/* end of data */
    {
        *state = 0; /* Reset the state = global index */
    }
    else
    {
        if (*state + numberOfElements > PIPE_SIZE)
            elementsToCopy = PIPE_SIZE - *state;
        else
            elementsToCopy = numberOfElements;
 
        for (i=0; i <elementsToCopy; i++)
        { 
            /*client receives data */
            globalPipeData[*state] = buffer[i];
            (*state)++;
        }
    }
}//end PipePush
```



Этот пример включает файл заголовка, созданный компилятором MIDL. Дополнительные сведения см. [в разделе Определение каналов в IDL-файле](defining-pipes-in-idl-files.md). Он также объявляет переменную Глобалпипедата, которая используется в качестве приемника данных. Переменная Глобалбуффер — это буфер, используемый процедурой Push для получения блоков данных, которые он хранит в Глобалпипедата.

Функция Рецеивелонгс объявляет канал и выделяет пространство памяти для переменной приемника глобальных данных. В программе Client/Server приемник данных может представлять собой файл или структуру данных, создаваемую клиентом. В этом простом примере источником данных является динамически выделяемый буфер длинных целых чисел.

Перед началом передачи данных клиентская программа должна инициализировать структуру выходного канала. Он должен устанавливать указатели на переменную состояния, процедуру push и процедуру выделения. В этом примере переменная конвейера вывода называется Аутпутпипе.

Клиенты предупреждают серверы о том, что они готовы принимать данные, путем вызова удаленной процедуры на сервере. В этом примере Удаленная процедура называется «внешним каналом». Когда клиент вызывает удаленную процедуру, сервер начинает передавать данные. Каждый раз при поступлении данных заглушка клиента вызывает процедуры распределения и принудительного выполнения клиента по мере необходимости.

Вместо выделения памяти каждый раз, когда необходим буфер, процедура выделения в этом примере просто устанавливает указатель на переменную Глобалбуффер. Затем процедура по запросу повторно использует этот буфер при каждой передаче данных. Более сложным клиентским программам может потребоваться выделить новый буфер каждый раз, когда сервер извлекает данные от клиента.

Процедура Push в этом примере использует переменную состояния для отслеживания следующего места, где данные будут храниться в глобальном буфере приемника данных. Он записывает данные из буфера канала в буфер приемника. Клиентская заглушка затем получает следующий блок данных с сервера и сохраняет их в буфере канала. После отправки всех данных сервер передает буфер нулевого размера. В этом случае процедура Push-уведомлений перестает получать данные.

## <a name="related-topics"></a>См. также

<dl> <dt>

[дать](/windows/desktop/Midl/pipe)
</dt> <dt>

[**/Oi**](/windows/desktop/Midl/-oi)
</dt> </dl>

 

 