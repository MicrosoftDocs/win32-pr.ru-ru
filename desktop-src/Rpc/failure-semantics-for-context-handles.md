---
title: Семантика сбоев для дескрипторов контекста
description: В этом разделе обсуждается семантика сбоев для дескрипторов контекста.
ms.assetid: fcf28519-39ad-4823-bc27-f3502e4d540c
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c4528b3f5160b92a4e6f10dbcf877e9fec59f81b
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "104068037"
---
# <a name="failure-semantics-for-context-handles"></a><span data-ttu-id="0ca2b-103">Семантика сбоев для дескрипторов контекста</span><span class="sxs-lookup"><span data-stu-id="0ca2b-103">Failure Semantics for Context Handles</span></span>

<span data-ttu-id="0ca2b-104">В этом разделе обсуждается семантика сбоев для дескрипторов контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-104">This topic discusses failure semantics for context handles.</span></span>

## <a name="failure-semantics-when-closing-the-context-handle-fails"></a><span data-ttu-id="0ca2b-105">Семантика сбоя при закрытии маркера контекста</span><span class="sxs-lookup"><span data-stu-id="0ca2b-105">Failure Semantics when Closing the Context Handle Fails</span></span>

<span data-ttu-id="0ca2b-106">Представьте себе, что клиентское приложение пытается закрыть обработчик контекста, Открытый на сервере, без закрытия клиентского процесса.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-106">Imagine a client application is attempting to close a context handle it opened on the server, without shutting down the client process.</span></span> <span data-ttu-id="0ca2b-107">Кроме того, предположим, что вызов сервера для закрытия обработчика контекста завершается неудачно (например, у клиента недостаточно памяти).</span><span class="sxs-lookup"><span data-stu-id="0ca2b-107">Also, assume the call to the server to close the context handle fails (for example, the client is out of memory).</span></span> <span data-ttu-id="0ca2b-108">Правильный способ решения этой ситуации — вызвать функцию [**рпкссдестройклиентконтекст**](/windows/desktop/api/Rpcndr/nf-rpcndr-rpcssdestroyclientcontext) .</span><span class="sxs-lookup"><span data-stu-id="0ca2b-108">The proper way to handle this situation is to call the [**RpcSsDestroyClientContext**](/windows/desktop/api/Rpcndr/nf-rpcndr-rpcssdestroyclientcontext) function.</span></span> <span data-ttu-id="0ca2b-109">В этом случае клиент очищает свою сторону обработчика контекста и прерывает подключение к серверу.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-109">In such a case the client cleans up its side of the context handle, and abortively closes the connection to the server.</span></span> <span data-ttu-id="0ca2b-110">Так как подключение действительно является пулом подключений (см. раздел [RPC и сеть](rpc-and-the-network.md)), который подсчитывается по одной ссылке на каждую открытую привязку или маркер контекста, удаление обработчика контекста путем вызова функции **рпкссдестройклиентконтекст** не приводит к уничтожению соединения.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-110">Since the connection is really a connection pool (see [RPC and the Network](rpc-and-the-network.md)), which is reference-counted with one reference for each opened binding or context handle, destroying the context handle by calling the **RpcSsDestroyClientContext** function does not actually destroy the connection.</span></span> <span data-ttu-id="0ca2b-111">Вместо этого уменьшается число ссылок для пула соединений.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-111">Rather, it decrements the reference count for the connection pool.</span></span> <span data-ttu-id="0ca2b-112">Чтобы подключения в пуле были закрыты, клиенту необходимо закрыть все дескрипторы привязки и дескрипторы контекста на этом сервере от клиентского процесса.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-112">For connections in the pool to be closed, the client needs to close all binding handles and context handles to that server from the client process.</span></span> <span data-ttu-id="0ca2b-113">Затем все подключения в пуле закрываются, а механизм запуска сервера инициируется и очищается.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-113">Then all connections in the pool are closed, and the server run-down mechanism is initiated and cleans up.</span></span>

## <a name="failure-semantics-during-change-of-state-of-the-context-handle"></a><span data-ttu-id="0ca2b-114">Семантика сбоя при изменении состояния маркера контекста</span><span class="sxs-lookup"><span data-stu-id="0ca2b-114">Failure Semantics During Change of State of the Context Handle</span></span>

<span data-ttu-id="0ca2b-115">Сведения в этом разделе относятся к платформам Windows XP и более поздних версий.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-115">The information in this section refers to Windows XP and later platforms.</span></span>

<span data-ttu-id="0ca2b-116">Дескрипторы контекста — это просто параметры функции.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-116">Context handles are simply parameters to a function.</span></span> <span data-ttu-id="0ca2b-117">Все изменения в состоянии обработчика контекста происходят, когда параметры маршалируются или расмаршалируются.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-117">All changes in the state of a context handle happen when parameters are marshaled or unmarshaled.</span></span> <span data-ttu-id="0ca2b-118">Например, если клиент открывает обработчик контекста (изменяет его с **null** на значение, отличное от **null**), то во время выполнения RPC на самом деле не открывается часть этого маркера RPC до тех пор, пока аргументы не будут упакованы для отправки клиенту.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-118">For example, if a client opens a context handle (changes it from **NULL** to non-**NULL**), the RPC run-time does not actually open the RPC portion of the handle until the arguments are marshaled for sending to the client.</span></span> <span data-ttu-id="0ca2b-119">Сбои могут возникать во время промежуточного выполнения.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-119">Failures can occur during the interim.</span></span> <span data-ttu-id="0ca2b-120">Из-за различных возможных сетевых или нехватки ресурсов передача пакета клиенту может завершиться ошибкой.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-120">Due to a variety of possible network or low resource conditions, transmission of the packet to the client could fail.</span></span> <span data-ttu-id="0ca2b-121">Или серверная подпрограммы может вызвать исключение при попытке изменить маркер контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-121">Or the server routine may throw an exception while attempting to change a context handle.</span></span> <span data-ttu-id="0ca2b-122">В таких или других случаях сбоя клиент и сервер могут получить непоследовательные представления маркера контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-122">In these or other failure situations, the client and server may get inconsistent views of the context handle.</span></span> <span data-ttu-id="0ca2b-123">В этом разделе описывается правило для состояния маркера контекста, а также ответственность за выполнение кода клиента и сервера во время различных условий сбоя.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-123">This section explains the rule for the state of the context handle, and the responsibility of client and server code during various failure conditions.</span></span>

-   <span data-ttu-id="0ca2b-124">Получен **нулевой** маркер контекста, но Серверная подпрограммы встречает ошибку и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-124">A **NULL** context handle arrives, but the server routine encounters a failure and throws an exception.</span></span>

    <span data-ttu-id="0ca2b-125">Серверная подпрограммы должна выполнять очистку любого состояния, связанного с обработчиком контекста, который мог быть создан.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-125">It is the responsibility of the server routine to clean up any context handle–related state it may have created.</span></span> <span data-ttu-id="0ca2b-126">Время выполнения RPC очищает свое состояние.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-126">The RPC run time cleans up its state.</span></span>

-   <span data-ttu-id="0ca2b-127">Поступают дескрипторы контекста, отличные от **null** , но Серверная подпрограммы встречает ошибку и создает исключение.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-127">A non-**NULL** context handles arrives, but the server routine encounters a failure and throws an exception.</span></span>

    <span data-ttu-id="0ca2b-128">Если серверная операция закрыла обработчик контекста, клиент не узнает о нем, так как вызов не будет выполнен. дальнейшее использование маркера контекста приведет к \_ \_ \_ \_ ошибке несовпадения контекста RPC X SS на клиенте.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-128">If the server routine closed the context handle, the client will not know about it, since the call will not succeed; further use of the context handle will result in an RPC\_X\_SS\_CONTEXT\_MISMATCH error on the client.</span></span> <span data-ttu-id="0ca2b-129">Если серверная подпрограммы не изменяет контекстный маркер, клиент по-прежнему может его использовать.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-129">If the server routine does not modify the context handle, the client can still use it.</span></span> <span data-ttu-id="0ca2b-130">Если серверная операция изменяет данные, хранящиеся в контексте сервера, то новые вызовы клиента будут использовать эти сведения.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-130">If the server routine changes the information stored in the server context, new calls from the client will use that information.</span></span>

-   <span data-ttu-id="0ca2b-131">Получен **ненулевой** контекстный маркер, и Серверная операция закрывает этот обработчик, но либо маршалирование, либо после неудачного маршалирования контекстного маркера, либо обработка после сбоя упаковки.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-131">A non-**NULL** context handle arrives, and the server routine closes the handle, but either marshaling after the context handle was marshaled failed, or processing after marshaling failed.</span></span>

    <span data-ttu-id="0ca2b-132">Маркер контекста закрыт, и последующие вызовы этого клиента с помощью этого обработчика контекста приводят к \_ \_ \_ \_ ошибке несовпадения контекста RPC X SS на клиенте.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-132">The context handle is closed, and further calls by this client using this context handle result in an RPC\_X\_SS\_CONTEXT\_MISMATCH error on the client.</span></span>

-   <span data-ttu-id="0ca2b-133">Получен **нулевой** маркер контекста, и сервер создает его контекст для этого обработчика, но либо упакованный, либо после неудачного маршалирования обработчика контекста, либо обработки после сбоя упаковки.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-133">A **NULL** context handle arrives, and the server creates its context for this handle, but either marshaling after the context handle was marshaled failed, or processing after marshaling failed.</span></span>

    <span data-ttu-id="0ca2b-134">В этом случае во время выполнения RPC вызывается выполнение для этого обработчика контекста и очищает состояние RPC для этого обработчика контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-134">In this case, the RPC run time invokes the run down for this context handle, and cleans up the RPC state for this context handle.</span></span> <span data-ttu-id="0ca2b-135">Обработчик контекста не будет создан на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-135">The context handle will not be created on the client side.</span></span>

-   <span data-ttu-id="0ca2b-136">Получен **ненулевой** контекстный маркер, и сервер либо не изменяет контекстный обработчик, либо изменяет данные, хранящиеся в контексте сервера, а маршалирование завершается неудачей после маршалирования маркера контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-136">A non-**NULL** context handle arrives, and the server either does not change the context handle, or it changes the information stored in the server context, and marshaling fails after the context handle is marshaled.</span></span>

    <span data-ttu-id="0ca2b-137">Новые вызовы от клиента будут использовать контекстный обработчик, который имеет сервер.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-137">New calls from the client will use the context handle that the server has.</span></span>

-   <span data-ttu-id="0ca2b-138">Получен **нулевой** маркер контекста, и сервер не устанавливает его ничего, кроме **null**, но вызов завершается неудачей до маршалирования маркера контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-138">A **NULL** context handle arrives, and the server does not set it to anything other than **NULL**, but the call fails before the context handle is marshaled.</span></span>

    <span data-ttu-id="0ca2b-139">В этом случае на клиенте не создается маркер контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-139">In this case, no context handle is created on the client.</span></span>

-   <span data-ttu-id="0ca2b-140">Получен **ненулевой** контекстный маркер, и сервер устанавливает для него **значение NULL**, но маршалирование завершается неудачей перед упаковкой маркера контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-140">A non-**NULL** context handle arrives, and the server sets it to **NULL**, but marshaling fails before the context handle is marshaled.</span></span>

    <span data-ttu-id="0ca2b-141">В этом случае маркер контекста остается закрытым на сервере, и клиент получает \_ \_ \_ ошибки несоответствия контекста RPC X SS \_ при попытке использовать контекстный маркер.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-141">In this case, the context handle remains closed on the server, and the client gets RPC\_X\_SS\_CONTEXT\_MISMATCH errors when it tries to use the context handle.</span></span>

-   <span data-ttu-id="0ca2b-142">На сервере поступает **нулевой** маркер контекста, и сервер устанавливает для него значение, отличное от **null**, но при маршалировании происходит сбой, прежде чем будет выполнен маршалирование контекстного маркера.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-142">A **NULL** context handle arrives on the server, and the server sets it to non-**NULL**, but marshaling fails before the context handle is marshaled.</span></span>

    <span data-ttu-id="0ca2b-143">Запуск обработчика контекста должен быть вызван, чтобы сервер мог выполнить очистку, и на клиенте не будет создаваться маркер контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-143">The context handle run down is to be invoked so that the server can clean up, and no context handle will be created on the client.</span></span>

-   <span data-ttu-id="0ca2b-144">Получен **ненулевой** контекстный маркер, и сервер либо не изменяет контекстный обработчик, либо изменяет сведения, хранящиеся в контексте сервера, и маршалирование завершается неудачей перед упаковкой маркера контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-144">A non-**NULL** context handle arrives, and the server either does not change the context handle, or it changes the information stored in the server context, and marshaling fails before the context handle is marshaled.</span></span>

    <span data-ttu-id="0ca2b-145">Новые вызовы от клиента будут использовать состояние на сервере.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-145">New calls from the client will use the state on the server.</span></span>

-   <span data-ttu-id="0ca2b-146">Маркер контекста объявляется как возвращаемое значение, а Серверная операция возвращает **значение NULL** для обработчика контекста, и маршалирование завершается неудачей перед упаковкой маркера контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-146">A context handle is declared as a return value, and the server routine returns **NULL** for the context handle and marshaling fails before the context handle is marshaled.</span></span>

    <span data-ttu-id="0ca2b-147">В этом случае на клиенте не создается новый контекст.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-147">In this case, no new context is created on the client.</span></span>

-   <span data-ttu-id="0ca2b-148">Маркер контекста объявляется как возвращаемое значение, а Серверная операция возвращает не **значение NULL** для обработчика контекста, и маршалирование завершается неудачей перед упаковкой маркера контекста.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-148">A context handle is declared as a return value, and the server routine returns non-**NULL** for the context handle and marshaling fails before the context handle is marshaled.</span></span>

    <span data-ttu-id="0ca2b-149">Во время выполнения RPC вызывается подлежащая запуску обработчик контекста, чтобы дать ему возможность выполнить очистку, и на клиенте не будет создаваться новый контекст.</span><span class="sxs-lookup"><span data-stu-id="0ca2b-149">The RPC run time calls the context handle run-down routine to give it a chance to clean up, and no new context is created on the client.</span></span>

 

 




