---
title: Методы IDL для лучшего проектирования интерфейсов и методов
description: Рассмотрите возможность использования следующих методов языка IDL для повышения безопасности и производительности при разработке интерфейсов RPC и методов, обрабатывающих как согласованные, так и варианты данных.
ms.assetid: 651bdb5c-ad56-4526-9b7d-7165141e7ceb
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b897d8d1f2f5e1c11a5328fb095341871e3689e0
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "104410869"
---
# <a name="idl-techniques-for-better-interface-and-method-design"></a>Методы IDL для лучшего проектирования интерфейсов и методов

Рассмотрите возможность использования следующих методов языка IDL для повышения безопасности и производительности при разработке интерфейсов RPC и методов, обрабатывающих как согласованные, так и варианты данных. Атрибуты, упоминаемые в этом разделе, являются атрибутами IDL, заданными в параметрах метода, обрабатывающих либо согласованные данные (например, \[ **размер \_** \] и \[ **максимум \_ —** \] атрибуты), либо данные типа Variant (например, \[ **длина \_** \] и \[ атрибуты **строки** \] ).

## <a name="using-the-range-attribute-with-conformant-data-parameters"></a>Использование \[ атрибута Range \] с параметрами согласованных данных

Атрибут \[ **Range** \] указывает среде выполнения RPC выполнить дополнительную проверку размера во время процесса демаршалирования данных. В частности, он проверяет, что указанный размер данных, переданный в качестве связанного параметра, находится в пределах указанного диапазона.

Атрибут \[ **Range** \] не влияет на формат сети.

Если значение на линии подключения выходит за пределы допустимого диапазона, RPC выдает исключение "RPC \_ x \_ invalidd \_ или RPC \_ x \_ Bad" \_ \_ . Это обеспечивает дополнительный уровень проверки данных и может помочь предотвратить распространенные ошибки безопасности, такие как переполнение буфера. Аналогично, использование \[ **диапазона** \] может повысить производительность приложения, поскольку согласованные данные, отмеченные им, имеют четко определенные ограничения, доступные для рассмотрения службой RPC.

## <a name="rpc-server-stub-memory-management-rules"></a>Правила управления памятью заглушки RPC-сервера

При создании IDL-файлов для приложения с поддержкой RPC важно понимать правила управления памятью заглушки RPC-сервера. Приложения могут улучшить использование ресурсов сервера с помощью \[ **диапазона** \] в сочетании с согласованными данными, как указано выше, а также намеренно избегать применения атрибутов IDL данных переменной длины, таких как \[ **\_ ,** например, длины, \] к согласованным данным.

Применение \[ **длины \_** не \] рекомендуется для полей структуры данных, определенных в IDL-файле.

## <a name="best-practices-for-variable-length-data-parameters"></a>Рекомендации по использованию параметров данных переменной длины

Ниже приведены некоторые рекомендации, которые следует учитывать при определении атрибутов IDL для структур данных с переменным размером, параметров и полей методов.

-   Используйте раннее корреляцию. Обычно лучше определить параметр или поле размера переменной, чтобы оно наблюдаться сразу после целочисленного типа управления.

    Например,

    ``` syntax
    earlyCorr
    (
    [in, range(MIN_COUNT, MAX_COUNT)] long size, 
    [in,size_is(size)] char *pv
    );
    ```

    лучше, чем

    ``` syntax
    lateCorr
    (
    [in,size_is(size)] char *pv, 
    [in, range(MIN_COUNT, MAX_COUNT)] long size)
    );
    ```

    Where **еарликорр** объявляет параметр size непосредственно перед параметром данных переменной длины, а **латекорр** объявляет параметр size после него. Использование раннего соответствия повышает производительность в целом, особенно в тех случаях, когда метод вызывается часто.

-   Для параметров, помеченных \[ атрибутом **out \_ , Size** \] и, где длина данных известна на стороне клиента или когда клиент имеет приемлемую верхнюю границу, определение метода должно быть похоже на следующее с точки зрения атрибутов и последовательности параметров:

    ``` syntax
    outKnownSize
    (
    [in,range(MIN_COUNT, MAX_COUNT)] long lSize,
    [out,size_is(lSize)] UserDataType * pArr
    );
    ```

    В этом случае клиент предоставляет буфер фиксированного размера для *Парр*, позволяя службе RPC на стороне сервера выделить буфер достаточного размера с хорошей степенью гарантии. Обратите внимание, что в примере данные получаются с сервера ( \[ **out** \] ). Определение аналогично тому, что данные передаются на сервер ( \[ **в** \] ).

-   В ситуациях, когда серверный компонент RPC-приложения определяет длину данных, определение метода должно выглядеть следующим образом:

    ``` syntax
    typedef [range(MIN_COUNT,MAX_COUNT)] long RANGED_LONG;

    outUnknownSize
    (
    [out] RANGED_LONG *pSize,
    [out,size_is(,*pSize)] UserDataType **ppArr
    );
    ```

    **С \_ диапазоном LONG** — это тип, определенный для заглушек клиента и сервера, и указанного размера, который клиент может правильно предвидеть. В этом примере клиент передает *ппарр* как **null**, а компонент серверного приложения RPC выделяет правильный объем памяти. После возврата служба RPC на стороне клиента выделяет память для возвращаемых данных.

-   Если клиент хочет отправить подмножество большого согласованного массива на сервер, приложение может указать размер подмножества, как показано в следующем примере:

    ``` syntax
    inConformantVaryingArray
    (
    [in,range(MIN_COUNT,MAX_COUNT)] long lSize,
    [in] long lLength, 
    [in,size_is(lSize), length_is(lLength)] UserDataType *pArr
    );
    ```

    Таким образом, RPC будет передавать только элементы *лленгс* массива по каналу передачи. Однако это определение заставляет службу RPC выделять память размером *лсизе* на стороне сервера.

-   Если компонент клиентского приложения определяет максимальный размер массива, который может быть возвращен сервером, но позволяет серверу передавать подмножество этого массива, приложение может указать такое поведение, определив IDL, как показано в следующем примере:

    ``` syntax
    inMaxSizeOutLength
    (
    [in, range(MIN_COUNT, MAX_COUNT)] long lSize,
    [out] long *pLength,
    [out,size_is(lSize), length_is(*pLength)] UserDataType *pArr
    );
    ```

    Компонент клиентского приложения задает максимальный размер массива, а сервер указывает, сколько элементов он передает клиенту.

-   Если компонент серверного приложения должен вернуть строку в компонент клиентского приложения и если клиент знает максимальный размер, возвращаемый сервером, приложение может использовать согласованный строковый тип, как показано в следующем примере:

    ``` syntax
    outStringKnownSize
    (
    [in,range(MIN_COUNT, MAX_STRING)] long lSize,
    [out,size_is(lSize),string] wchar_t *pString
    );
    ```

-   Если компонент клиентского приложения не должен управлять размером строки, служба RPC может специально выделить память, как показано в следующем примере:

    ``` syntax
    outStringUnknownSize
    (
    [out] LPWSTR *ppStr
    );
    ```

    При вызове метода RPC компонент клиентского приложения должен задать для *Ппстр* **значение NULL** .

 

 




