---
title: Указание конечных точек
description: Указание хорошо известных и динамических конечных точек в удаленном вызове процедур (RPC).
ms.assetid: fc39b527-11e6-45a7-b3b5-8bcf469633d8
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 373fb2818dd14670f5a939aa524c81fcdb05e20b
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "105650356"
---
# <a name="specifying-endpoints"></a><span data-ttu-id="93f50-103">Указание конечных точек</span><span class="sxs-lookup"><span data-stu-id="93f50-103">Specifying Endpoints</span></span>

<span data-ttu-id="93f50-104">Конечная точка — это сетевой адрес серверного процесса для удаленных вызовов процедур.</span><span class="sxs-lookup"><span data-stu-id="93f50-104">An endpoint is a network-specific address of a server process for remote procedure calls.</span></span> <span data-ttu-id="93f50-105">Фактическое имя конечной точки зависит от используемой последовательности протоколов.</span><span class="sxs-lookup"><span data-stu-id="93f50-105">The actual name of the endpoint depends on the protocol sequence used.</span></span> <span data-ttu-id="93f50-106">Например, порты использования TCP, UDP и HTTP.</span><span class="sxs-lookup"><span data-stu-id="93f50-106">For example, TCP, UDP, and HTTP use ports.</span></span> <span data-ttu-id="93f50-107">Именованные каналы используют имя именованного канала.</span><span class="sxs-lookup"><span data-stu-id="93f50-107">Named pipes uses a named pipe name.</span></span> <span data-ttu-id="93f50-108">Клиентские и серверные приложения могут использовать хорошо известную конечную точку или динамическую конечную точку.</span><span class="sxs-lookup"><span data-stu-id="93f50-108">Client/server applications can use a well-known endpoint or a dynamic endpoint.</span></span> <span data-ttu-id="93f50-109">В этом разделе представлены методы, используемые серверными программами для указания хорошо известных и динамических конечных точек.</span><span class="sxs-lookup"><span data-stu-id="93f50-109">This section presents the techniques that server programs use to specify well-known and dynamic endpoints.</span></span> <span data-ttu-id="93f50-110">Сведения рассматриваются в следующих разделах:</span><span class="sxs-lookup"><span data-stu-id="93f50-110">The information is discussed in the following topics:</span></span>

-   [<span data-ttu-id="93f50-111">Указание хорошо известных конечных точек</span><span class="sxs-lookup"><span data-stu-id="93f50-111">Specifying Well-known Endpoints</span></span>](#specifying-well-known-endpoints)
-   [<span data-ttu-id="93f50-112">Указание динамических конечных точек</span><span class="sxs-lookup"><span data-stu-id="93f50-112">Specifying Dynamic Endpoints</span></span>](#specifying-dynamic-endpoints)

## <a name="specifying-well-known-endpoints"></a><span data-ttu-id="93f50-113">Указание хорошо известных конечных точек</span><span class="sxs-lookup"><span data-stu-id="93f50-113">Specifying Well-known Endpoints</span></span>

<span data-ttu-id="93f50-114">Если сервер использует хорошо известную конечную точку, он может включать данные конечной точки как часть записи базы данных службы имен.</span><span class="sxs-lookup"><span data-stu-id="93f50-114">When your server uses a well-known endpoint, it can include the endpoint data as part of its name service database entry.</span></span> <span data-ttu-id="93f50-115">Если это так, то маркер привязки клиента содержит полный адрес сервера, включающий известную конечную точку, когда клиент импортирует маркер привязки из записи сервера.</span><span class="sxs-lookup"><span data-stu-id="93f50-115">If it does, the client's binding handle contains a complete server address that includes the well-known endpoint when the client imports the binding handle from the server entry.</span></span>

<span data-ttu-id="93f50-116">Серверная программа также может указывать хорошо известные конечные точки одновременно с указанием последовательностей протоколов.</span><span class="sxs-lookup"><span data-stu-id="93f50-116">Your server program can also specify well-known endpoints at the same time it specifies protocol sequences.</span></span> <span data-ttu-id="93f50-117">Вызовите функцию [**рпксерверусепротсекеп**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep) или [**рпксерверусепротсекепекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex) .</span><span class="sxs-lookup"><span data-stu-id="93f50-117">Invoke either the [**RpcServerUseProtseqEp**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep) or [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex) function.</span></span> <span data-ttu-id="93f50-118">Различие между ними заключается в том, что последняя функция имеет дополнительный параметр, который сервер может использовать для управления динамическим выделением портов.</span><span class="sxs-lookup"><span data-stu-id="93f50-118">The difference between the two is that the latter function has an extra parameter your server can use to control dynamic port allocation.</span></span>

<span data-ttu-id="93f50-119">Если серверная программа указывает сведения о конечной точке таким образом, она также должна вызывать функцию [**рпцепрегистер**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) для регистрации конечной точки на карте конечных точек.</span><span class="sxs-lookup"><span data-stu-id="93f50-119">If your server program specifies its endpoint information in this way, it should also call the [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) function to register the endpoint in the endpoint map.</span></span> <span data-ttu-id="93f50-120">Несмотря на то что конечная точка всегда одинакова, клиент может использовать карту конечных точек для поиска сервера.</span><span class="sxs-lookup"><span data-stu-id="93f50-120">Even though the endpoint is always the same, the client may use the endpoint map to find the server.</span></span>

<span data-ttu-id="93f50-121">Как и в случае с последовательностями протокола, приложение может указывать сведения о конечной точке в IDL-файле.</span><span class="sxs-lookup"><span data-stu-id="93f50-121">Like protocol sequences, an application can specify endpoint information in its IDL file.</span></span> <span data-ttu-id="93f50-122">Если это так, он должен одновременно регистрировать как последовательности протокола, так и конечные точки, вызывая функцию [**рпксерверусеаллпротсексиф**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsif) или [**рпксерверусеаллпротсексифекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsifex) .</span><span class="sxs-lookup"><span data-stu-id="93f50-122">When it does, it should register both the protocol sequences and endpoints at the same time by invoking the [**RpcServerUseAllProtseqsIf**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsif) or [**RpcServerUseAllProtseqsIfEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsifex) function.</span></span> <span data-ttu-id="93f50-123">В этом случае клиент имеет доступ к сведениям о конечной точке через спецификацию интерфейса в IDL-файле.</span><span class="sxs-lookup"><span data-stu-id="93f50-123">In this case, the client has access to the endpoint information through the interface specification in the IDL file.</span></span> <span data-ttu-id="93f50-124">Поэтому нет необходимости вызывать функцию [**рпцепрегистер**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) .</span><span class="sxs-lookup"><span data-stu-id="93f50-124">Therefore, it is not necessary to call the [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) function.</span></span>

## <a name="specifying-dynamic-endpoints"></a><span data-ttu-id="93f50-125">Указание динамических конечных точек</span><span class="sxs-lookup"><span data-stu-id="93f50-125">Specifying Dynamic Endpoints</span></span>

<span data-ttu-id="93f50-126">Динамическая конечная точка — это конечная точка, которую компьютер узла сервера назначает при запуске сервера.</span><span class="sxs-lookup"><span data-stu-id="93f50-126">A dynamic endpoint is an endpoint that the server host computer assigns when the server begins execution.</span></span> <span data-ttu-id="93f50-127">Большинство серверных приложений используют динамические конечные точки, чтобы избежать конфликтов с другими программами по ограниченному числу портов, доступных на компьютере узла сервера.</span><span class="sxs-lookup"><span data-stu-id="93f50-127">Most server applications use dynamic endpoints to avoid conflict with other programs over the limited number of ports that are available on the server host computer system.</span></span> <span data-ttu-id="93f50-128">Однако программы, использующие именованные каналы или последовательность протокола [**нкалрпк**](/windows/desktop/Midl/ncalrpc) , имеют очень большое пространство имен конечных точек.</span><span class="sxs-lookup"><span data-stu-id="93f50-128">However, programs using named pipes or the [**ncalrpc**](/windows/desktop/Midl/ncalrpc) protocol sequence have a very large endpoint name space.</span></span> <span data-ttu-id="93f50-129">Они получают меньше от динамических конечных точек, чем от программ, использующих другие транспорты.</span><span class="sxs-lookup"><span data-stu-id="93f50-129">They benefit less from dynamic endpoints than programs using other transports.</span></span>

<span data-ttu-id="93f50-130">Серверные программы регистрируют динамические конечные точки в базе данных карт конечных точек.</span><span class="sxs-lookup"><span data-stu-id="93f50-130">Server programs register dynamic endpoints in an endpoint map database.</span></span> <span data-ttu-id="93f50-131">Если вы хотите, чтобы сервер использовал любую доступную конечную точку, вызовите [**рпксерверусеаллпротсекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqs), [**рпксерверусеаллпротсексекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsex), [**рпксерверусепротсек**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseq) или [**рпксерверусепротсекекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqex).</span><span class="sxs-lookup"><span data-stu-id="93f50-131">If you want the server to use any available endpoint, call [**RpcServerUseAllProtSeqs**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqs), [**RpcServerUseAllProtseqsEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsex), [**RpcServerUseProtseq**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseq) or [**RpcServerUseProtseqEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqex).</span></span> <span data-ttu-id="93f50-132">При этом в библиотеке времени выполнения RPC задается использование всех или одной допустимой последовательности протоколов с динамическими конечными точками.</span><span class="sxs-lookup"><span data-stu-id="93f50-132">This sets the RPC run-time library to use all or one valid protocol sequence(s) with dynamic endpoints.</span></span> <span data-ttu-id="93f50-133">Затем сервер должен вызвать [**рпксерверинкбиндингс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverinqbindings) , чтобы получить набор допустимых дескрипторов привязки.</span><span class="sxs-lookup"><span data-stu-id="93f50-133">The server should then call [**RpcServerInqBindings**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverinqbindings) to obtain a set of valid binding handles.</span></span> <span data-ttu-id="93f50-134">Сервер передает набор дескрипторов привязки или вектора привязки в функцию [**рпцепрегистер**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) , чтобы зарегистрировать все подходящие конечные точки в карте конечных точек.</span><span class="sxs-lookup"><span data-stu-id="93f50-134">The server passes the set of binding handles, or binding vector, to the function [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) to register all suitable endpoints in the endpoint map.</span></span> <span data-ttu-id="93f50-135">Для каждого вызова, который выполняет сервер, **рпцепрегистер**, должен существовать соответствующий вызов [**рпкбиндингвекторфри**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingvectorfree) , чтобы освободить память, используемую вектором привязки.</span><span class="sxs-lookup"><span data-stu-id="93f50-135">For each call your server makes to **RpcEpRegister**, there should be a corresponding call to [**RpcBindingVectorFree**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingvectorfree) to release the memory that the binding vector uses.</span></span>

<span data-ttu-id="93f50-136">Обратите внимание, что серверные программы могут использовать функцию [**рпцепрегистернореплаце**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregisternoreplace) , а не [**рпцепрегистер**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister).</span><span class="sxs-lookup"><span data-stu-id="93f50-136">Note that server programs can use the [**RpcEpRegisterNoReplace**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregisternoreplace) function rather than [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister).</span></span> <span data-ttu-id="93f50-137">Программы обычно используют **рпцепрегистернореплаце** , когда несколько копий серверной программы должны выполняться в системе узла сервера.</span><span class="sxs-lookup"><span data-stu-id="93f50-137">Programs typically use **RpcEpRegisterNoReplace** when multiple copies of a server program must run on a server host system.</span></span>

<span data-ttu-id="93f50-138">Функции [**рпцепрегистер**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) и [**рпцепрегистернореплаце**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregisternoreplace) добавляют интерфейсы и дескрипторы привязки сервера в базу данных сопоставителя конечных точек.</span><span class="sxs-lookup"><span data-stu-id="93f50-138">Both the [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) and [**RpcEpRegisterNoReplace**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregisternoreplace) functions add the server's interfaces and binding handles to the endpoint mapper database.</span></span> <span data-ttu-id="93f50-139">Когда клиент выполняет удаленный вызов процедуры с помощью частично привязанного маркера, Библиотека времени выполнения клиента запрашивает сопоставитель конечной точки сервера для конечной точки совместимого экземпляра сервера.</span><span class="sxs-lookup"><span data-stu-id="93f50-139">When the client makes a remote procedure call using a partially bound handle, the client's run-time library asks the server computer's endpoint mapper for the endpoint of a compatible server instance.</span></span> <span data-ttu-id="93f50-140">Клиентская библиотека предоставляет UUID интерфейса, последовательность протокола и, при наличии, идентификатор UUID объекта в маркере привязки клиента.</span><span class="sxs-lookup"><span data-stu-id="93f50-140">The client library supplies the interface UUID, protocol sequence, and, if present, the object UUID in the client binding handle.</span></span> <span data-ttu-id="93f50-141">Средство сопоставления конечных точек выполняет поиск записи базы данных, соответствующей клиентской информации.</span><span class="sxs-lookup"><span data-stu-id="93f50-141">The endpoint mapper looks for a database entry that matches the client's information.</span></span> <span data-ttu-id="93f50-142">Идентификатор UUID интерфейса клиента/сервера, основная версия интерфейса и последовательность протокола должны полностью совпадать.</span><span class="sxs-lookup"><span data-stu-id="93f50-142">The client/server interface UUID, the interface major version, and protocol sequence must all match exactly.</span></span> <span data-ttu-id="93f50-143">Кроме того, дополнительный номер версии интерфейса сервера должен быть больше или равен дополнительному номеру версии клиента.</span><span class="sxs-lookup"><span data-stu-id="93f50-143">In addition, the server's interface minor version must be greater than or equal to the client's minor version.</span></span>

<span data-ttu-id="93f50-144">Если все тесты выполнены успешно, средство сопоставления конечных точек возвращает допустимую конечную точку, а библиотека времени выполнения клиента обновляет конечную точку в маркере привязки.</span><span class="sxs-lookup"><span data-stu-id="93f50-144">If all tests are successful, the endpoint mapper returns the valid endpoint and the client run-time library updates the endpoint in the binding handle.</span></span>

<span data-ttu-id="93f50-145">Динамические конечные точки автоматически очищаются из базы данных сопоставителя конечных точек при остановке серверного процесса.</span><span class="sxs-lookup"><span data-stu-id="93f50-145">Dynamic endpoints are automatically purged from the endpoint mapper database when the server process stops running.</span></span> <span data-ttu-id="93f50-146">Можно либо удалить конечную точку из базы данных сопоставителя конечных точек перед завершением работы серверной программы с помощью функции [**рпцепунрегистер**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepunregister) , либо разрешить автоматическую очистку для управления удалением конечной точки.</span><span class="sxs-lookup"><span data-stu-id="93f50-146">You can either remove the endpoint from the endpoint mapper database before the server program exits using the [**RpcEpUnregister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepunregister) function, or you can allow automatic cleanup to manage removal of the endpoint.</span></span>

 

 