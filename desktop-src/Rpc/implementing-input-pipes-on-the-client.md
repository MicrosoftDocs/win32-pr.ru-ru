---
title: Реализация входных каналов на клиенте
description: При использовании входного канала для передачи данных с клиента на сервер необходимо реализовать процедуру извлечения.
ms.assetid: e941a6be-ca91-42b1-9323-ffc63d521f6c
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2810caa31c4932294797a5ed502c6f93d8613ea0
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "103890900"
---
# <a name="implementing-input-pipes-on-the-client"></a>Реализация входных каналов на клиенте

При использовании входного канала для передачи данных с клиента на сервер необходимо реализовать процедуру извлечения. Процедура извлечения должна находить данные для передачи, считывать данные в буфер и задавать количество элементов для отправки. Не все данные должны находиться в буфере, когда сервер начинает извлекать данные в себя. Процедура Pull может выполнить добавочную заливку буфера.

Если больше нет данных для отправки, процедура задает для последнего аргумента значение 0. При отправке всех данных процедура извлечения должна выполнить необходимую очистку перед возвратом. Для параметра, который является \[ выходным \] каналом, процедура извлечения должна сбрасывать переменную состояния клиента после передачи всех данных, чтобы процедура Push могла использовать ее для получения данных.

Следующий пример извлекается из программы Пипедемо, входящей в комплект SDK для платформы.


```C++
//file: client.c (fragment)
#include <windows.h>
#include "pipedemo.h"
long *globalPipeData;
long    globalBuffer[BUF_SIZE];
 
ulong   pipeDataIndex; /* state variable */
 
void SendLongs()
{
    LONG_PIPE inPipe;
    int i;
    globalPipeData =
        (long *)malloc( sizeof(long) * PIPE_SIZE );
 
    for (i=0; i<PIPE_SIZE; i++)
        globalPipeData[i] = IN_VALUE;
 
    pipeDataIndex = 0;
    inPipe.state =  (rpc_ss_pipe_state_t )&pipeDataIndex;
    inPipe.pull  = PipePull;
    inPipe.alloc = PipeAlloc;
 
    InPipe( inPipe ); /* Make the rpc */
 
    free( (void *)globalPipeData );

}//end SendLongs
 
void PipeAlloc( rpc_ss_pipe_state_t stateInfo,
                ulong requestedSize,
                long **allocatedBuffer,
                ulong *allocatedSize )
{ 
    ulong *state = (ulong *)stateInfo;
    if ( requestedSize > (BUF_SIZE*sizeof(long)) )
    {
       *allocatedSize = BUF_SIZE * sizeof(long);
    }
    else
    {
       *allocatedSize = requestedSize;
    }
    *allocatedBuffer = globalBuffer; 
} //end PipeAlloc
 
void PipePull( rpc_ss_pipe_state_t stateInfo,
               long *inputBuffer,
               ulong maxBufSize,
               ulong *sizeToSend )
{
    ulong currentIndex;
    ulong i;
    ulong elementsToRead;
    ulong *state = (ulong *)stateInfo;

    currentIndex = *state;
    if (*state >=  PIPE_SIZE )
    {
        *sizeToSend = 0; /* end of pipe data */
        *state = 0; /* Reset the state = global index */
    }
    else 
    {
        if ( currentIndex + maxBufSize > PIPE_SIZE )
            elementsToRead = PIPE_SIZE - currentIndex;
        else
            elementsToRead = maxBufSize;
 
        for (i=0; i < elementsToRead; i++)
        {
            /*client sends data */
            inputBuffer[i] = globalPipeData[i + currentIndex];
        }
 
        *state +=   elementsToRead;
        *sizeToSend = elementsToRead;
    } 
}//end PipePull
```



Этот пример включает файл заголовка, созданный компилятором MIDL. Дополнительные сведения см. [в разделе Определение каналов в IDL-файлах](defining-pipes-in-idl-files.md). Он также объявляет переменную, которая используется в качестве источника данных с именем Глобалпипедата. Переменная Глобалбуффер — это буфер, который используется процедурой извлечения для отправки блоков данных, получаемых из Глобалпипедата.

Функция Сендлонгс объявляет входной канал и выделяет память для переменной источника данных Глобалпипедата. В программе Client/Server источником данных может быть файл или структура, создаваемая клиентом. Кроме того, клиентская программа может получать данные с сервера, обрабатывать их и возвращать на сервер, используя входной канал. В этом простом примере источником данных является динамически выделяемый буфер длинных целых чисел.

Перед началом перемещения клиент должен установить указатели на переменную состояния, процедуру Pull и процедуру выделения. Эти указатели хранятся в переменной канала, объявляемой клиентом. В этом случае Сендлонгс объявляет неконвейерный. Для переменной состояния можно использовать любой подходящий тип данных.

Клиенты инициируют передачу данных по каналу, вызывая удаленную процедуру на сервере. Вызов удаленной процедуры сообщает серверной программе о том, что клиент готов к передаче. Затем сервер может извлечь данные в себя. В этом примере вызывается Удаленная процедура с именем onpipe. После передачи данных на сервер функция Сендлонгс освобождает динамически выделяемый буфер.

Вместо выделения памяти каждый раз, когда требуется буфер. процедура выделения в этом примере просто устанавливает указатель на переменную Глобалбуффер. Процедура извлечения повторно использует этот буфер каждый раз при передаче данных. Более сложным клиентским программам может потребоваться выделить новый буфер каждый раз, когда сервер извлекает данные от клиента.

Заглушка клиента вызывает процедуру извлечения. Процедура извлечения в этом примере использует переменную состояния для отслеживания следующей позицией в глобальном буфере источника данных для чтения из. Он считывает данные из исходного буфера в буфер канала. Заглушка клиента передает данные на сервер. Когда все данные отправлены, процедура Pull устанавливает размер буфера равным нулю. Это указывает серверу на необходимость перестают извлекать данные.

## <a name="related-topics"></a>См. также

<dl> <dt>

[дать](/windows/desktop/Midl/pipe)
</dt> <dt>

[**/Oi**](/windows/desktop/Midl/-oi)
</dt> </dl>

 

 