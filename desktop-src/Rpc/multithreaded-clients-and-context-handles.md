---
title: Многопоточные клиенты и дескрипторы контекста
description: При наличии многопоточного клиента, где несколько потоков используют один и тот же экземпляр обработчика контекста, доступ к экземпляру обработчика контекста сериализуется на сервере по умолчанию.
ms.assetid: 192be467-b1e0-422b-878a-738cb7d72b5b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 67c621d75d8cc48ca1f71719066f455e0efce39f
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104070317"
---
# <a name="multithreaded-clients-and-context-handles"></a><span data-ttu-id="0ba81-103">Многопоточные клиенты и дескрипторы контекста</span><span class="sxs-lookup"><span data-stu-id="0ba81-103">Multithreaded Clients and Context Handles</span></span>

<span data-ttu-id="0ba81-104">При наличии многопоточного клиента, где несколько потоков используют один и тот же экземпляр обработчика контекста, доступ к экземпляру обработчика контекста сериализуется на сервере по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0ba81-104">When you have a multithreaded client where multiple threads are using the same context handle instance, access to the context handle instance is serialized at the server by default.</span></span> <span data-ttu-id="0ba81-105">Это позволяет избежать необходимости защиты диспетчера сервера от другого потока от того же клиента, изменяющего контекст или использующий его контекст при отправке вызова.</span><span class="sxs-lookup"><span data-stu-id="0ba81-105">This saves the server manager from having to guard against another thread from the same client changing the context or the context running down while a call is dispatched.</span></span> <span data-ttu-id="0ba81-106">Однако в некоторых случаях сериализация может повлиять на производительность.</span><span class="sxs-lookup"><span data-stu-id="0ba81-106">However, in certain cases serialization may impact performance.</span></span>

<span data-ttu-id="0ba81-107">Рассмотрим следующее: два клиентских потока вызывают удаленный вызов процедуры, который не изменяет состояние контекста (например, вызов просто получает от него некоторые значения).</span><span class="sxs-lookup"><span data-stu-id="0ba81-107">Consider the following: two client threads invoke a remote procedure call that does not change the state of the context (for example, the call simply obtains some values from it).</span></span> <span data-ttu-id="0ba81-108">Такие вызовы не обязательно должны быть сериализованы.</span><span class="sxs-lookup"><span data-stu-id="0ba81-108">Such calls do not need to be serialized.</span></span>

<span data-ttu-id="0ba81-109">В таких ситуациях в Windows XP предусмотрена модель сериализации в смешанном режиме, где каждый метод может быть объявлен как монопольный или общий доступ к обработчику контекста.</span><span class="sxs-lookup"><span data-stu-id="0ba81-109">For such situations, Windows XP offers a mixed mode serialization model, where each method may be declared to have exclusive or shared access to a context handle.</span></span> <span data-ttu-id="0ba81-110">Дополнительные сведения см. в разделе [ \_ \_ сериализация обработчика контекста](/windows/desktop/Midl/context-handle-serialize) и [ \_ \_ обработчик контекста](/windows/desktop/Midl/context-handle-noserialize) .</span><span class="sxs-lookup"><span data-stu-id="0ba81-110">See [context\_handle\_serialize](/windows/desktop/Midl/context-handle-serialize) and [context\_handle\_noserialize](/windows/desktop/Midl/context-handle-noserialize) for details.</span></span>

<span data-ttu-id="0ba81-111">В версиях Windows, предшествовавших Windows XP, единственным средством, позволяющим одновременный доступ к контекстному обработчику, является вызов функции [**рпкссдонтсериализеконтекст**](/previous-versions/aa378473(v=vs.80)) , позволяющей отправлять несколько вызовов в одном обработчике контекста.</span><span class="sxs-lookup"><span data-stu-id="0ba81-111">In versions of Windows prior to Windows XP, the only means of allowing concurrent access to a context handle is to call the [**RpcSsDontSerializeContext**](/previous-versions/aa378473(v=vs.80)) function to allow multiple calls to be dispatched on a single context handle.</span></span> <span data-ttu-id="0ba81-112">Вызов функции **рпкссдонтсериализеконтекст** полностью не отключает сериализацию; При возникновении контекстного запуска подпрограммы запуска контекста выполняются только после завершения всех невыполненных запросов клиентов.</span><span class="sxs-lookup"><span data-stu-id="0ba81-112">Calling the **RpcSsDontSerializeContext** function does not disable serialization entirely; when a context run-down occurs, the context run-down routine runs only when all outstanding client requests have completed.</span></span> <span data-ttu-id="0ba81-113">Вызов **рпкскдонтсериализеконтекст** влияет на весь процесс и не подлежащем.</span><span class="sxs-lookup"><span data-stu-id="0ba81-113">A call to **RpcScDontSerializeContext** affects the entire process, and is not revertible.</span></span> <span data-ttu-id="0ba81-114">Использование **рпкскдонтсериализеконтекст** в Windows XP и более поздних версиях не рекомендуется; Это делает серверный код очень запутанным при надежной работе с условиями гонки, присущими совершенно несерийные среды.</span><span class="sxs-lookup"><span data-stu-id="0ba81-114">Using **RpcScDontSerializeContext** in Windows XP and later versions is not recommended; it makes server code very complicated when dealing reliably with race conditions inherent in completely non-serialized environments.</span></span>

 

 