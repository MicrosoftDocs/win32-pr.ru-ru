---
title: Поиск конечных точек
description: Серверные программы прослушивают конечные точки для клиентских запросов. Синтаксис строки конечной точки зависит от используемой последовательности протокола. Например, конечная точка TCP/IP является номером порта, а синтаксис конечной точки для именованных каналов — допустимое имя канала.
ms.assetid: 330bbe9f-b7e9-4a5b-86d8-824edec960d2
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bb0a97df3408a4d3c24dff9de28553f9e4b2210d
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104337785"
---
# <a name="finding-endpoints"></a><span data-ttu-id="dd3fe-105">Поиск конечных точек</span><span class="sxs-lookup"><span data-stu-id="dd3fe-105">Finding Endpoints</span></span>

<span data-ttu-id="dd3fe-106">Серверные программы прослушивают конечные точки для клиентских запросов.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-106">Server programs listen to endpoints for client requests.</span></span> <span data-ttu-id="dd3fe-107">Синтаксис строки конечной точки зависит от используемой последовательности протокола.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-107">The syntax of the endpoint string depends on the protocol sequence you use.</span></span> <span data-ttu-id="dd3fe-108">Например, конечная точка TCP/IP является номером порта, а синтаксис конечной точки для именованных каналов — допустимое имя канала.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-108">For example, the endpoint for TCP/IP is a port number, and the endpoint syntax for named pipes is a valid pipe name.</span></span>

<span data-ttu-id="dd3fe-109">Существует два типа конечных точек: хорошо известные и динамические.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-109">There are two types of endpoints: well-known and dynamic.</span></span> <span data-ttu-id="dd3fe-110">Выбор типа конечной точки, используемой программой, определяет, указывает ли конечная точка распределенное приложение или библиотека времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-110">Your choice of which type of endpoint your program uses determines whether the distributed application or the run-time library specifies the endpoint.</span></span>

<span data-ttu-id="dd3fe-111">В этом разделе обсуждаются конечные точки и предоставляются сведения о том, как их найти.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-111">This section discusses endpoints and presents information on how to find them.</span></span> <span data-ttu-id="dd3fe-112">Он состоит из следующих разделов:</span><span class="sxs-lookup"><span data-stu-id="dd3fe-112">It is organized into the following topics:</span></span>

-   [<span data-ttu-id="dd3fe-113">Использование конечных точек Well-Known</span><span class="sxs-lookup"><span data-stu-id="dd3fe-113">Using Well-Known Endpoints</span></span>](#using-well-known-endpoints)
-   [<span data-ttu-id="dd3fe-114">Использование динамических конечных точек</span><span class="sxs-lookup"><span data-stu-id="dd3fe-114">Using Dynamic Endpoints</span></span>](#using-dynamic-endpoints)
-   [<span data-ttu-id="dd3fe-115">Экспорт Well-Known конечных точек в базу данных карт конечных точек</span><span class="sxs-lookup"><span data-stu-id="dd3fe-115">Exporting Well-Known Endpoints Into the Endpoint Map Database</span></span>](#exporting-well-known-endpoints-into-the-endpoint-map-database)

> [!Note]  
> <span data-ttu-id="dd3fe-116">Термины *статические конечные точки* и *хорошо известные конечные точки* эквивалентны и взаимозаменяемы.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-116">The terms *static endpoints* and *well-known endpoints* are equivalent, and used interchangeably.</span></span>

 

<span data-ttu-id="dd3fe-117">Клиентское приложение может использовать карту конечных точек для определения того, запущена ли в данный момент серверная программа.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-117">It is possible for your client application to use the endpoint map to determine whether or not a server program is currently running.</span></span> <span data-ttu-id="dd3fe-118">Клиент может вызвать [**рпкмгмтинкифидс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqifids), [**рпкмгмтепелтинкбегин**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin)и [**рпкмгмтепелтинкдоне**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) , чтобы узнать, зарегистрировал ли сервер конкретный интерфейс, требуемый на карте конечных точек.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-118">Your client can call [**RpcMgmtInqIfIds**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqifids), [**RpcMgmtEpEltInqBegin**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin), and [**RpcMgmtEpEltInqDone**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) to see if the server has registered the particular interface it requires in the endpoint map.</span></span>

## <a name="using-well-known-endpoints"></a><span data-ttu-id="dd3fe-119">Использование хорошо известных конечных точек</span><span class="sxs-lookup"><span data-stu-id="dd3fe-119">Using Well-known Endpoints</span></span>

<span data-ttu-id="dd3fe-120">Хорошо известные конечные точки — это предварительно назначенные конечные точки, которые серверная программа использует при каждом запуске.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-120">Well-known endpoints are pre-assigned endpoints that the server program uses every time it runs.</span></span> <span data-ttu-id="dd3fe-121">Поскольку сервер всегда прослушивает эту конкретную конечную точку, клиент всегда пытается подключиться к нему.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-121">Because the server always listens to that particular endpoint, the client always attempts to connect to it.</span></span> <span data-ttu-id="dd3fe-122">Хорошо известные конечные точки обычно назначаются центром, ответственным за транспортный протокол.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-122">Well-known endpoints are usually assigned by the authority responsible for the transport protocol.</span></span> <span data-ttu-id="dd3fe-123">Поскольку компьютеры узлов сервера имеют конечное количество доступных конечных точек, разработчикам приложений настоятельно не рекомендуется использовать известные конечные точки.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-123">Because server host computers have a finite number of available endpoints, application developers are strongly discouraged from using well-known endpoints.</span></span> <span data-ttu-id="dd3fe-124">Другое преимущество динамических конечных точек заключается в том, что они упрощают долгосрочное управление и обслуживание системы.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-124">Another advantage of dynamic endpoints is that they simplify long-term management and maintenance of the system.</span></span>

<span data-ttu-id="dd3fe-125">Распределенное приложение может указать хорошо известную конечную точку в строке и передать эту строку в качестве параметра в функцию [**рпксерверусепротсекеп**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep).</span><span class="sxs-lookup"><span data-stu-id="dd3fe-125">A distributed application can specify a well-known endpoint in a string and pass that string as a parameter to the function [**RpcServerUseProtseqEp**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep).</span></span> <span data-ttu-id="dd3fe-126">Кроме того, строка конечной точки может отображаться в заголовке интерфейса IDL-файла как часть \[ атрибута интерфейса [конечной точки](/windows/desktop/Midl/endpoint) \] .</span><span class="sxs-lookup"><span data-stu-id="dd3fe-126">Alternatively, the endpoint string can appear in the IDL file interface header as part of the \[ [endpoint](/windows/desktop/Midl/endpoint)\] interface attribute.</span></span>

<span data-ttu-id="dd3fe-127">Для реализации хорошо известной конечной точки можно использовать два подхода:</span><span class="sxs-lookup"><span data-stu-id="dd3fe-127">You can use two approaches to implement the well-known endpoint:</span></span>

-   <span data-ttu-id="dd3fe-128">Указать всю информацию в привязке строк</span><span class="sxs-lookup"><span data-stu-id="dd3fe-128">Specify all information in a string binding</span></span>
-   <span data-ttu-id="dd3fe-129">Хранение хорошо известной конечной точки в базе данных службы имен</span><span class="sxs-lookup"><span data-stu-id="dd3fe-129">Store the well-known endpoint in the name service database</span></span>

<span data-ttu-id="dd3fe-130">Вы можете записать всю информацию, необходимую для установки привязки в распределенное приложение при разработке.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-130">You can write all of the information needed to establish a binding into a distributed application when you develop it.</span></span> <span data-ttu-id="dd3fe-131">Клиент может указать хорошо известную конечную точку непосредственно в строке, вызвать [**рпкстрингбиндингкомпосе**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcstringbindingcompose) , чтобы создать строку, содержащую все сведения о привязке, и предоставить эту строку функции [**рпкбиндингфромстрингбиндинг**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding) для получения маркера.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-131">The client can specify the well-known endpoint directly in a string, call [**RpcStringBindingCompose**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcstringbindingcompose) to create a string that contains all the binding information, and supply this string to the function [**RpcBindingFromStringBinding**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding) to obtain a handle.</span></span> <span data-ttu-id="dd3fe-132">Клиент и сервер могут быть жестко запрограммированы для использования хорошо известной конечной точки или написаны таким образом, чтобы информация о конечной точке поступила из командной строки, файла данных, файла конфигурации или IDL-файла.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-132">The client and server can be hard-coded to use a well-known endpoint, or written so that the endpoint information comes from the command line, a data file, a configuration file, or the IDL file.</span></span>

<span data-ttu-id="dd3fe-133">Клиентское приложение также может запрашивать в базе данных службы имен сведения о известной конечной точке.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-133">Your client application can also query a name service database for well-known endpoint information.</span></span>

## <a name="using-dynamic-endpoints"></a><span data-ttu-id="dd3fe-134">Использование динамических конечных точек</span><span class="sxs-lookup"><span data-stu-id="dd3fe-134">Using Dynamic Endpoints</span></span>

<span data-ttu-id="dd3fe-135">Количество конечных точек для конкретного сервера и определенной последовательности протоколов обычно ограничено.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-135">The number of endpoints for a particular server and a particular protocol sequence are usually limited.</span></span> <span data-ttu-id="dd3fe-136">Например, при использовании последовательности протокола [ \_ IP \_ TCP нкакн](/windows/desktop/Midl/ncacn-ip-tcp) , указывающей на то, что сетевое взаимодействие RPC происходит по протоколу TCP/IP, доступно только ограниченное число портов (большинство систем имеют диапазон от 1025 до 5000).</span><span class="sxs-lookup"><span data-stu-id="dd3fe-136">For example, when you use the [ncacn\_ip\_tcp](/windows/desktop/Midl/ncacn-ip-tcp) protocol sequence, indicating that RPC network communication occurs using TCP/IP, only a limited number of ports are available (most systems have only the range 1025 through 5000 opened).</span></span> <span data-ttu-id="dd3fe-137">Библиотеки времени выполнения RPC позволяют назначать конечные точки динамически, по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-137">The RPC run-time libraries allow you to assign endpoints dynamically, as needed.</span></span> <span data-ttu-id="dd3fe-138">Так как количество идентификаторов UUID интерфейса практически не ограничено, использование UUID интерфейса для направления вызова предоставляет больше места для расширения и повышает гибкость.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-138">Since the number of possible interface UUIDs is practically unlimited, using the interface UUID to direct the call offers more room for expansion and more flexibility.</span></span>

<span data-ttu-id="dd3fe-139">По умолчанию функции библиотеки времени выполнения RPC выполняют поиск сведений о конечной точке при запросе к базе данных службы имен.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-139">By default, the RPC run-time library functions search for endpoint information when they query a name service database.</span></span> <span data-ttu-id="dd3fe-140">Если конечная точка является динамической, то база данных службы имен не будет содержать сведения о конечной точке.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-140">If the endpoint is dynamic, the name service database will not contain endpoint information.</span></span> <span data-ttu-id="dd3fe-141">Однако запрос предоставит клиентской программе имя сервера.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-141">However, the query will give your client program the name of a server.</span></span> <span data-ttu-id="dd3fe-142">Затем он может выполнить поиск на карте конечных точек сервера.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-142">It can then search the server's endpoint map.</span></span>

<span data-ttu-id="dd3fe-143">Если клиенту необходимо выполнить удаленный вызов процедуры с помощью динамической конечной точки, предпочтительным методом является вызов в маркере привязки с частичным связыванием.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-143">If the client needs to make a remote procedure call using a dynamic endpoint, the preferred method is to make the call on a partially bound binding handle.</span></span> <span data-ttu-id="dd3fe-144">Во время выполнения RPC конечная точка разрешается прозрачно.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-144">The RPC run time resolves the endpoint transparently.</span></span> <span data-ttu-id="dd3fe-145">Этот метод является предпочтительным для использования функции [**рпцепресолвебиндинг**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepresolvebinding) , так как он позволяет использовать расширенные механизмы кэширования во время выполнения RPC.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-145">This method is superior to using the [**RpcEpResolveBinding**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepresolvebinding) function, as it allows advanced caching mechanisms in the RPC run time.</span></span>

<span data-ttu-id="dd3fe-146">Если требуется более конкретный контроль над выбором конечной точки, клиенты могут выполнять поиск в конечной точке по одной записи за раз, вызывая функции [**рпкмгмтепелтинкбегин**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin), [**рпкмгмтепелтинкнекст**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqnext)и [**рпкмгмтепелтинкдоне**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) .</span><span class="sxs-lookup"><span data-stu-id="dd3fe-146">If more specific control over endpoint selection is required, clients can search the endpoint map one entry at a time by calling the [**RpcMgmtEpEltInqBegin**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin), [**RpcMgmtEpEltInqNext**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqnext), and [**RpcMgmtEpEltInqDone**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) functions.</span></span>

## <a name="exporting-well-known-endpoints-into-the-endpoint-map-database"></a><span data-ttu-id="dd3fe-147">Экспорт хорошо известных конечных точек в базу данных карт конечных точек</span><span class="sxs-lookup"><span data-stu-id="dd3fe-147">Exporting Well-known Endpoints into the Endpoint Map Database</span></span>

<span data-ttu-id="dd3fe-148">Можно смешивать два подхода к поиску конечных точек, особенно при переходе распределенной системы из хорошо известной модели конечных точек в модель динамической конечной точки.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-148">It is possible to mix the two approaches to finding endpoints, especially when a distributed system is transitioning from a well-known endpoint model to a dynamic endpoint model.</span></span> <span data-ttu-id="dd3fe-149">В таких переходах промежуточная версия сервера будет использовать хорошо известную конечную точку, но она также будет регистрировать хорошо известную конечную точку с базой данных с картой конечной точки.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-149">In such transitions, an intermediate version of the server will use a well-known endpoint, but it will also register the well-known endpoint with the endpoint map database.</span></span> <span data-ttu-id="dd3fe-150">Такой подход позволяет клиентам, использующим хорошо известную конечную точку, и клиентам, использующим динамическую конечную точку, подключаться.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-150">This approach allows clients that use well known endpoint and clients that use a dynamic endpoint to connect.</span></span> <span data-ttu-id="dd3fe-151">После обновления всех серверов можно развернуть новую версию клиента, использующую только динамические конечные точки.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-151">Once all servers are upgraded, a new client version can be deployed that uses dynamic endpoints only.</span></span> <span data-ttu-id="dd3fe-152">После обновления всех клиентов окончательная версия сервера может завершиться с помощью хорошо известных конечных точек и начинать использовать только динамические конечные точки.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-152">Once all clients are upgraded, a final server version can stop using well-known endpoints and begin using dynamic endpoints only.</span></span>

<span data-ttu-id="dd3fe-153">Такой подход позволяет использовать путь перехода для приложений, которые начали работать с хорошо известной конечной точкой, но выполнять миграцию на динамическую конечную точку без необходимости одновременного обновления всех серверов и клиентов.</span><span class="sxs-lookup"><span data-stu-id="dd3fe-153">This approach allows a transition path for applications that have started with a well-known endpoint but want to migrate to a dynamic endpoint without requiring a simultaneous update of all servers and clients.</span></span>

 

 