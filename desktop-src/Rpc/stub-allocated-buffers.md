---
title: Буферы Stub-Allocated
description: Вместо того чтобы принудительно выполнять отдельный вызов для каждого узла дерева или графа, можно направлять заглушки для расчета размера данных и выделения и освобождения памяти, вызывая один вызов для \_ пользовательского \_ выделения или освобождения MIDL пользователем \_ \_ .
ms.assetid: 9911649d-00e8-47d8-b512-7d9b185d1e09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 956acf6452c1a4e7d04afcd1da263439436e3bad
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104070348"
---
# <a name="stub-allocated-buffers"></a><span data-ttu-id="c957a-103">Буферы Stub-Allocated</span><span class="sxs-lookup"><span data-stu-id="c957a-103">Stub-Allocated Buffers</span></span>

<span data-ttu-id="c957a-104">Вместо того чтобы принудительно выполнять отдельный вызов для каждого узла дерева или графа, можно направлять заглушки для расчета размера данных и выделения и освобождения памяти, вызывая один вызов для [ \_ пользовательского \_ выделения](/windows/desktop/Midl/midl-user-allocate-1) или [ \_ \_ освобождения](/windows/desktop/Midl/midl-user-free-1)MIDL пользователем.</span><span class="sxs-lookup"><span data-stu-id="c957a-104">Rather than forcing a distinct call for each node of the tree or graph, you can direct the stubs to compute the size of the data and to allocate and free memory by making a single call to [midl\_user\_allocate](/windows/desktop/Midl/midl-user-allocate-1) or [midl\_user\_free](/windows/desktop/Midl/midl-user-free-1).</span></span> <span data-ttu-id="c957a-105">Атрибут ACF, **\[ выделяющий (все \_ узлы) \]** , направляет заглушки для выделения или освобождения всех узлов в одном вызове функций, предоставляемых пользователем — функции управления памятью.</span><span class="sxs-lookup"><span data-stu-id="c957a-105">The ACF attribute **\[allocate(all\_nodes)\]** directs the stubs to allocate or free all nodes in a single call to the user supplied–memory management functions.</span></span>

<span data-ttu-id="c957a-106">Например, приложение RPC может использовать следующую структуру данных в двоичном дереве:</span><span class="sxs-lookup"><span data-stu-id="c957a-106">For example, an RPC application might use the following binary tree data structure:</span></span>

``` syntax
/* IDL file fragment */
typedef struct _TREE_TYPE 
{
    short sNumber;
    struct _TREE_TYPE * pLeft;
    struct _TREE_TYPE * pRight;
} TREE_TYPE;

typedef TREE_TYPE * P_TREE_TYPE;
```

<span data-ttu-id="c957a-107">Атрибут ACF **\[ allocate (все \_ узлы) \]** , примененный к этому типу данных, отображается в объявлении **typedef** в ACF как:</span><span class="sxs-lookup"><span data-stu-id="c957a-107">The ACF attribute **\[allocate(all\_nodes)\]** applied to this data type appears in the **typedef** declaration in the ACF as:</span></span>

``` syntax
/* ACF file fragment */
typedef [allocate(all_nodes)] P_TREE_TYPE;
```

<span data-ttu-id="c957a-108">Атрибут **\[ выделения \]** может применяться только к типам указателей.</span><span class="sxs-lookup"><span data-stu-id="c957a-108">The **\[allocate\]** attribute can only be applied to pointer types.</span></span> <span data-ttu-id="c957a-109">Атрибут **\[ выделения \]** ACF является РАСШИРЕНИЕМ Майкрософт для устройства DCE IDL и, таким образом, недоступен при компиляции с параметром MIDL **/ОСФ** .</span><span class="sxs-lookup"><span data-stu-id="c957a-109">The **\[allocate\]** ACF attribute is a Microsoft extension to DCE IDL and, as such, is not available if you compile with the MIDL **/osf** switch.</span></span> <span data-ttu-id="c957a-110">Когда к типу указателя применяется **\[ выделение (все \_ узлы) \]** , суррогаты, созданные компилятором MIDL, проходят по указанной структуре данных для определения размера выделения.</span><span class="sxs-lookup"><span data-stu-id="c957a-110">When **\[allocate(all\_nodes)\]** is applied to a pointer type, the stubs generated by the MIDL compiler traverse the specified data structure to determine the allocation size.</span></span> <span data-ttu-id="c957a-111">Затем заглушки выполняют один вызов, чтобы выделить весь объем памяти, необходимый графу или дереву.</span><span class="sxs-lookup"><span data-stu-id="c957a-111">The stubs then make a single call to allocate the entire amount of memory needed by the graph or tree.</span></span> <span data-ttu-id="c957a-112">Клиентское приложение может освободить память гораздо эффективнее, делая один вызов для **пользователя MIDL \_ \_ свободным**.</span><span class="sxs-lookup"><span data-stu-id="c957a-112">A client application can free memory much more efficiently by making a single call to **midl\_user\_free**.</span></span> <span data-ttu-id="c957a-113">Однако при использовании выделения памяти для каждого узла обычно увеличивается производительность заглушки сервера, поскольку заглушки сервера часто могут использовать закрытую память, не требующую выделения памяти.</span><span class="sxs-lookup"><span data-stu-id="c957a-113">However, server-stub performance is generally increased when using node-by-node memory allocation because the server stubs can often use private memory that requires no allocations.</span></span>

<span data-ttu-id="c957a-114">Дополнительные сведения см. в разделе [распределение и освобождение узлов по](node-by-node-allocation-and-deallocation.md)узлам.</span><span class="sxs-lookup"><span data-stu-id="c957a-114">For additional information, see [Node-by-Node Allocation and Deallocation](node-by-node-allocation-and-deallocation.md).</span></span>

 

 