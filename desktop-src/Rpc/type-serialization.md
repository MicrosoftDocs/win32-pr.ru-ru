---
title: Сериализация типов
description: Компилятор MIDL создает до трех функций для каждого типа, к которому применяется атрибут \ Encoded \ или \ дешифровки \.
ms.assetid: 948f1dd7-c8b0-4fa0-88d8-9d122de52ba1
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4674617bc98c92dbc684a29d1a3c91ac6a7429e1
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104134178"
---
# <a name="type-serialization"></a>Сериализация типов

Компилятор MIDL создает до трех функций для каждого типа, к которому \[ [](/windows/desktop/Midl/encode) \] применяется атрибут кодирования или \[ [декодирования](/windows/desktop/Midl/decode) \] . Например, для определяемого пользователем типа с именем *MyType* компилятор создает код для \_ функций шифрования MyType, MyType \_ и MyType \_ алигнсизе. Для этих функций компилятор записывает прототипы в заглушку. h и исходный код в заглушку \_ к.к. Как правило, объект *MyType* можно закодировать с помощью MyType- \_ кодирования и декодировать объект из буфера, используя \_ расшифровку MyType. MyType \_ алигнсизе используется, если необходимо знать размер буфера упаковки перед его выделением.

Компилятор MIDL создает следующую функцию кодирования. Эта функция сериализует данные для объекта, на который указывает объект, а буфер извлекается в соответствии с методом, указанным в маркере. После записи сериализованных данных в буфер вы управляете буфером. Обратите внимание, что маркер наследует состояние от предыдущих вызовов, и буферы должны быть выравны 8.

Для неявного маркера:

``` syntax
void MyType_Encode (MyType __RPC_FAR * pObject);
```

Для явного маркера:

``` syntax
void MyType_Encode (handle_t Handle, MyType __RPC_FAR * pObject);
```

Следующая функция десериализует данные из хранилища приложения в объект, на который указывает объект. Вы предоставляете упакованный буфер в соответствии с методом, указанным в маркере. Обратите внимание, что маркер может наследовать состояние от предыдущих вызовов, а буферы должны быть выравны 8.

Для неявного маркера:

``` syntax
void MyType_Decode (MyType __RPC_FAR * pObject);
```

Для явного маркера:

``` syntax
void MyType_Decode (handle_t Handle, MyType __RPC_FAR * pObject);
```

Следующая функция возвращает размер в байтах, который включает экземпляр типа, а также все байты заполнения, необходимые для согласования данных. Это позволяет сериализовать набор экземпляров одного и того же или разных типов в буфер, обеспечивая соответствие данных для каждого объекта. В MyType \_ алигнсизе предполагается, что экземпляр, на который указывает объект, будет упакован в буфер, начинающийся с позиции, равной 8.

Для неявного маркера:

``` syntax
size_t MyType_AlignSize (MyType __RPC_FAR * pObject);
```

Для явного маркера:

``` syntax
size_t MyType_AlignSize (handle_t Handle, MyType __RPC_FAR * pObject);
```

Обратите внимание, что обе удаленные процедуры с неявными дескрипторами привязки и сериализованными типами с неявными дескрипторами сериализации используют одинаковую глобальную переменную дескриптор. Поэтому рекомендуется не смешивать типы сериализации и удаленные процедуры в интерфейсе с неявными дескрипторами. Дополнительные сведения см. в разделе явные и неявные [дескрипторы](implicit-versus-explicit-handles.md).

 

 