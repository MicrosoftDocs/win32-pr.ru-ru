---
title: Сериализация типов
description: Компилятор MIDL создает до трех функций для каждого типа, к которому применяется атрибут \ Encoded \ или \ дешифровки \.
ms.assetid: 948f1dd7-c8b0-4fa0-88d8-9d122de52ba1
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4674617bc98c92dbc684a29d1a3c91ac6a7429e1
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104134178"
---
# <a name="type-serialization"></a><span data-ttu-id="9dbe9-103">Сериализация типов</span><span class="sxs-lookup"><span data-stu-id="9dbe9-103">Type Serialization</span></span>

<span data-ttu-id="9dbe9-104">Компилятор MIDL создает до трех функций для каждого типа, к которому \[ [](/windows/desktop/Midl/encode) \] применяется атрибут кодирования или \[ [декодирования](/windows/desktop/Midl/decode) \] .</span><span class="sxs-lookup"><span data-stu-id="9dbe9-104">The MIDL compiler generates up to three functions for each type to which the \[ [encode](/windows/desktop/Midl/encode)\] or \[ [decode](/windows/desktop/Midl/decode)\] attribute is applied.</span></span> <span data-ttu-id="9dbe9-105">Например, для определяемого пользователем типа с именем *MyType* компилятор создает код для \_ функций шифрования MyType, MyType \_ и MyType \_ алигнсизе.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-105">For example, for a user-defined type named *MyType*, the compiler generates code for the MyType\_Encode, MyType\_Decode, and MyType\_AlignSize functions.</span></span> <span data-ttu-id="9dbe9-106">Для этих функций компилятор записывает прототипы в заглушку. h и исходный код в заглушку \_ к.к.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-106">For these functions, the compiler writes prototypes to Stub.h and source code to Stub\_c.c.</span></span> <span data-ttu-id="9dbe9-107">Как правило, объект *MyType* можно закодировать с помощью MyType- \_ кодирования и декодировать объект из буфера, используя \_ расшифровку MyType.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-107">Generally, you can encode a *MyType* object with MyType\_Encode and decode an object from the buffer using MyType\_Decode.</span></span> <span data-ttu-id="9dbe9-108">MyType \_ алигнсизе используется, если необходимо знать размер буфера упаковки перед его выделением.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-108">MyType\_AlignSize is used if you need to know the size of the marshaling buffer before allocating it.</span></span>

<span data-ttu-id="9dbe9-109">Компилятор MIDL создает следующую функцию кодирования.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-109">The following encoding function is generated by the MIDL compiler.</span></span> <span data-ttu-id="9dbe9-110">Эта функция сериализует данные для объекта, на который указывает объект, а буфер извлекается в соответствии с методом, указанным в маркере.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-110">This function serializes the data for the object pointed to by pObject, and the buffer is obtained according to the method specified in the handle.</span></span> <span data-ttu-id="9dbe9-111">После записи сериализованных данных в буфер вы управляете буфером.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-111">After writing the serialized data to the buffer, you control the buffer.</span></span> <span data-ttu-id="9dbe9-112">Обратите внимание, что маркер наследует состояние от предыдущих вызовов, и буферы должны быть выравны 8.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-112">Note that the handle inherits the status from the previous calls, and the buffers must be aligned at 8.</span></span>

<span data-ttu-id="9dbe9-113">Для неявного маркера:</span><span class="sxs-lookup"><span data-stu-id="9dbe9-113">For an implicit handle:</span></span>

``` syntax
void MyType_Encode (MyType __RPC_FAR * pObject);
```

<span data-ttu-id="9dbe9-114">Для явного маркера:</span><span class="sxs-lookup"><span data-stu-id="9dbe9-114">For an explicit handle:</span></span>

``` syntax
void MyType_Encode (handle_t Handle, MyType __RPC_FAR * pObject);
```

<span data-ttu-id="9dbe9-115">Следующая функция десериализует данные из хранилища приложения в объект, на который указывает объект.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-115">The following function deserializes the data from the application's storage into the object pointed to by pObject.</span></span> <span data-ttu-id="9dbe9-116">Вы предоставляете упакованный буфер в соответствии с методом, указанным в маркере.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-116">You supply a marshaled buffer according to the method specified in the handle.</span></span> <span data-ttu-id="9dbe9-117">Обратите внимание, что маркер может наследовать состояние от предыдущих вызовов, а буферы должны быть выравны 8.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-117">Note that the handle can inherit the status from the previous calls and the buffers must be aligned at 8.</span></span>

<span data-ttu-id="9dbe9-118">Для неявного маркера:</span><span class="sxs-lookup"><span data-stu-id="9dbe9-118">For an implicit handle:</span></span>

``` syntax
void MyType_Decode (MyType __RPC_FAR * pObject);
```

<span data-ttu-id="9dbe9-119">Для явного маркера:</span><span class="sxs-lookup"><span data-stu-id="9dbe9-119">For an explicit handle:</span></span>

``` syntax
void MyType_Decode (handle_t Handle, MyType __RPC_FAR * pObject);
```

<span data-ttu-id="9dbe9-120">Следующая функция возвращает размер в байтах, который включает экземпляр типа, а также все байты заполнения, необходимые для согласования данных.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-120">The following function returns a size, in bytes, that includes the type instance plus any padding bytes needed to align the data.</span></span> <span data-ttu-id="9dbe9-121">Это позволяет сериализовать набор экземпляров одного и того же или разных типов в буфер, обеспечивая соответствие данных для каждого объекта.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-121">This enables serializing a set of instances of the same or different types into a buffer while ensuring that the data for each object is appropriately aligned.</span></span> <span data-ttu-id="9dbe9-122">В MyType \_ алигнсизе предполагается, что экземпляр, на который указывает объект, будет упакован в буфер, начинающийся с позиции, равной 8.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-122">MyType\_AlignSize assumes that the instance pointed to by pObject will be marshaled into a buffer beginning at the offset aligned at 8.</span></span>

<span data-ttu-id="9dbe9-123">Для неявного маркера:</span><span class="sxs-lookup"><span data-stu-id="9dbe9-123">For an implicit handle:</span></span>

``` syntax
size_t MyType_AlignSize (MyType __RPC_FAR * pObject);
```

<span data-ttu-id="9dbe9-124">Для явного маркера:</span><span class="sxs-lookup"><span data-stu-id="9dbe9-124">For an explicit handle:</span></span>

``` syntax
size_t MyType_AlignSize (handle_t Handle, MyType __RPC_FAR * pObject);
```

<span data-ttu-id="9dbe9-125">Обратите внимание, что обе удаленные процедуры с неявными дескрипторами привязки и сериализованными типами с неявными дескрипторами сериализации используют одинаковую глобальную переменную дескриптор.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-125">Note that both remote procedures with implicit binding handles and serialized types with implicit serialization handles use the same global handle variable.</span></span> <span data-ttu-id="9dbe9-126">Поэтому рекомендуется не смешивать типы сериализации и удаленные процедуры в интерфейсе с неявными дескрипторами.</span><span class="sxs-lookup"><span data-stu-id="9dbe9-126">Therefore, it is advisable not to mix type serialization and remote procedures in an interface with implicit handles.</span></span> <span data-ttu-id="9dbe9-127">Дополнительные сведения см. в разделе явные и неявные [дескрипторы](implicit-versus-explicit-handles.md).</span><span class="sxs-lookup"><span data-stu-id="9dbe9-127">For details, see [Implicit Versus Explicit Handles](implicit-versus-explicit-handles.md).</span></span>

 

 