---
title: Разработка приложений RPC-Message Queuing
description: Чтобы воспользоваться преимуществами транспорта MSMQ в приложении RPC, необходимо крайне мало усилий.
ms.assetid: 1ea97df8-cdf5-43b8-88aa-9e8fa6ae845a
keywords:
- Удаленный вызов процедур RPC, задачи, разработка приложений очереди сообщений
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f3e51707c0a6903200e51dd35e50e998430c8eae
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104070510"
---
# <a name="developing-rpc-message-queuing-applications"></a><span data-ttu-id="36bc1-104">Разработка приложений RPC-Message Queuing</span><span class="sxs-lookup"><span data-stu-id="36bc1-104">Developing RPC-Message Queuing Applications</span></span>

<span data-ttu-id="36bc1-105">Чтобы воспользоваться преимуществами транспорта MSMQ в приложении RPC, необходимо крайне мало усилий.</span><span class="sxs-lookup"><span data-stu-id="36bc1-105">Very little effort is necessary to take advantage of the MSMQ transport in your RPC application.</span></span> <span data-ttu-id="36bc1-106">Для синхронного обмена сообщениями в качестве последовательности протокола необходимо указать только транспорт очереди сообщений ([**нкадг \_ MQ**](/windows/desktop/Midl/ncadg-mq)).</span><span class="sxs-lookup"><span data-stu-id="36bc1-106">For synchronous messaging you need only specify the message queue transport ([**ncadg\_mq**](/windows/desktop/Midl/ncadg-mq)) as the protocol sequence.</span></span> <span data-ttu-id="36bc1-107">Протокол **нкадг \_ MQ** поддерживает все стандартные функции датаграммы, кроме широковещательных вызовов.</span><span class="sxs-lookup"><span data-stu-id="36bc1-107">The **ncadg\_mq** protocol supports all of the standard datagram features except broadcasting calls.</span></span> <span data-ttu-id="36bc1-108">Кроме того, обратите внимание, что в настоящее время транспорт очереди сообщений не поддерживает динамические конечные точки.</span><span class="sxs-lookup"><span data-stu-id="36bc1-108">Also, note that currently the message-queue transport does not support dynamic endpoints.</span></span>

<span data-ttu-id="36bc1-109">Применив атрибут \[ [**Message**](/windows/desktop/Midl/message) \] к объявлениям удаленных процедур в IDL-файле, вы автоматически реализуете для этих вызовов очередь сообщений в асинхронном режиме.</span><span class="sxs-lookup"><span data-stu-id="36bc1-109">By applying the \[[**message**](/windows/desktop/Midl/message)\] attribute to remote procedure declarations in the IDL file, you automatically implement asynchronous-mode message queuing for those calls.</span></span> <span data-ttu-id="36bc1-110">Это позволяет клиентским и серверным приложениям управлять многими свойствами, связанными с сообщениями и очередями сообщений, в том числе:</span><span class="sxs-lookup"><span data-stu-id="36bc1-110">This makes it possible for the client and server applications to control many of the properties associated with messages and message queues, including:</span></span>

-   <span data-ttu-id="36bc1-111">Качество обслуживания</span><span class="sxs-lookup"><span data-stu-id="36bc1-111">Quality of service</span></span>
-   <span data-ttu-id="36bc1-112">Подтверждение получения</span><span class="sxs-lookup"><span data-stu-id="36bc1-112">Acknowledgment of receipt</span></span>
-   <span data-ttu-id="36bc1-113">Ведения журнала</span><span class="sxs-lookup"><span data-stu-id="36bc1-113">Journaling</span></span>
-   <span data-ttu-id="36bc1-114">Приоритет вызова</span><span class="sxs-lookup"><span data-stu-id="36bc1-114">Call priority</span></span>
-   <span data-ttu-id="36bc1-115">Сохраняемость очереди серверных процессов</span><span class="sxs-lookup"><span data-stu-id="36bc1-115">Persistence of Server Process Queue</span></span>

<span data-ttu-id="36bc1-116">Качество обслуживания — это усилия, которые транспорты делают для предоставления вызова серверному процессу.</span><span class="sxs-lookup"><span data-stu-id="36bc1-116">Quality of service is the effort that the transport will make to deliver the call to the server process.</span></span> <span data-ttu-id="36bc1-117">Экспресс-доставка помещается в очередь в памяти, поэтому она выполняется довольно быстро, но вызов будет потерян, если компьютер или сетевое подключение перестанет работать в неправильное время.</span><span class="sxs-lookup"><span data-stu-id="36bc1-117">An express delivery will be queued in memory, so it is fairly fast, but the call will be lost if a computer or network connection goes down at the wrong time.</span></span> <span data-ttu-id="36bc1-118">Восстанавливаемая доставка будет опубликована в файл на диске, пока он не будет доставлен, поэтому вызов не будет потерян даже в случае сбоя компьютера.</span><span class="sxs-lookup"><span data-stu-id="36bc1-118">A recoverable delivery will be posted to a disk file until it is delivered, so the call will not be lost, even in the face of a computer crash.</span></span> <span data-ttu-id="36bc1-119">Это обеспечит гарантированную доставку, но с учетом затрат на производительность при каждом обращении к диску.</span><span class="sxs-lookup"><span data-stu-id="36bc1-119">This gives guaranteed delivery, but at a cost in performance as each call is written to disk.</span></span>

<span data-ttu-id="36bc1-120">Можно также сообщить транспорту MSMQ о необходимости ожидания подтверждения того, что вызов достиг очереди назначения (сервера) перед возвратом.</span><span class="sxs-lookup"><span data-stu-id="36bc1-120">You can also tell the MSMQ transport to wait for acknowledgment that the call reached the destination (server) queue before returning.</span></span> <span data-ttu-id="36bc1-121">При выборе этого параметра клиент блокируется, пока сервер не подтвердит вызов. в противном случае управление возвращается клиенту сразу после выполнения вызова.</span><span class="sxs-lookup"><span data-stu-id="36bc1-121">Choosing this option blocks the client until the server acknowledges the call, otherwise control returns to the client immediately upon making the call.</span></span>

<span data-ttu-id="36bc1-122">С помощью ведения журнала вызовы могут записываться на диск.</span><span class="sxs-lookup"><span data-stu-id="36bc1-122">By using journaling, calls can be logged to disk.</span></span> <span data-ttu-id="36bc1-123">Если ведение журнала включено, каждый вызов заносится на диск в том виде, в котором он передается на следующий прыжок по пути к серверному процессу.</span><span class="sxs-lookup"><span data-stu-id="36bc1-123">If journaling is turned on, each call is logged to disk as it is transmitted to the next hop on its way to the server process.</span></span>

<span data-ttu-id="36bc1-124">Приоритет вызова можно использовать в сочетании с \[ [](/windows/desktop/Midl/message) \] атрибутом функции RPC Message, чтобы разрешить вызовы с более высоким приоритетом, чтобы иметь приоритет над вызовами с более низким приоритетом, даже если вызовы с высоким приоритетом поступают позже.</span><span class="sxs-lookup"><span data-stu-id="36bc1-124">Call priority can be used in conjunction with the RPC \[[**message**](/windows/desktop/Midl/message)\] function attribute to allow calls with higher priority to take precedence over calls with lower priority, even if the high priority calls arrive later.</span></span> <span data-ttu-id="36bc1-125">Приоритет вызова также будет работать в ограниченном режиме с помощью синхронного RPC, но синхронные вызовы RPC не могут выполняться так же, как асинхронные вызовы.</span><span class="sxs-lookup"><span data-stu-id="36bc1-125">Call priority will also work in a limited fashion with synchronous RPC, but synchronous RPC calls cannot stack up in the same manner as asynchronous calls.</span></span>

<span data-ttu-id="36bc1-126">Клиентский процесс управляет всеми указанными выше свойствами путем вызова [**рпкбиндингсетоптион**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetoption).</span><span class="sxs-lookup"><span data-stu-id="36bc1-126">The client process controls all of the above properties by calling [**RpcBindingSetOption**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetoption).</span></span> <span data-ttu-id="36bc1-127">После установки эти свойства остаются в силе до тех пор, пока они не будут изменены в другом вызове **рпкбиндингсетоптион**.</span><span class="sxs-lookup"><span data-stu-id="36bc1-127">Once set, these properties remain in effect until they are changed in another call to **RpcBindingSetOption**.</span></span>

<span data-ttu-id="36bc1-128">Процесс сервера RPC может управлять временем существования очереди получения.</span><span class="sxs-lookup"><span data-stu-id="36bc1-128">The RPC server process can control the lifetime of its receive queue.</span></span> <span data-ttu-id="36bc1-129">По умолчанию очередь удаляется при выходе из процесса сервера.</span><span class="sxs-lookup"><span data-stu-id="36bc1-129">By default the queue is deleted when the server process exits.</span></span> <span data-ttu-id="36bc1-130">Однако серверный процесс может использовать [**рпксерверусепротсекепекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex) при настройке конечной точки, чтобы позволить транспорту продолжать существование очереди и принимать запросы вызовов, даже если серверный процесс не запущен.</span><span class="sxs-lookup"><span data-stu-id="36bc1-130">However, the server process can use [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex) when setting up its endpoint to tell the transport to allow the queue to continue to exist and to accept call requests even when the server process is not running.</span></span> <span data-ttu-id="36bc1-131">В этом случае вызовы помещаются в очередь и выполняются позже, когда серверный процесс возвращается в режим «в сети».</span><span class="sxs-lookup"><span data-stu-id="36bc1-131">In this case, the calls are queued up and executed later, when the server process comes back online.</span></span>

> [!Note]  
> <span data-ttu-id="36bc1-132">При использовании асинхронных вызовов \[ [**сообщений**](/windows/desktop/Midl/message) \] в интерфейсе необходимо зарегистрировать интерфейс, вызвав [**рпксерверрегистериф**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverregisterif) или [**рпксерверрегистерифекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverregisterifex) перед вызовом [**рпксерверусепротсекепекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex)**(нкадг \_ MQ)**.</span><span class="sxs-lookup"><span data-stu-id="36bc1-132">If you are using asynchronous \[[**message**](/windows/desktop/Midl/message)\] calls in an interface, you must register the interface by calling [**RpcServerRegisterIf**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverregisterif) or [**RpcServerRegisterIfEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverregisterifex) before calling [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex)**(ncadg\_mq)**.</span></span> <span data-ttu-id="36bc1-133">После включения последовательности протоколов все вызовы, которые уже ожидают очередь для сервера, начнут быть считаны из очереди.</span><span class="sxs-lookup"><span data-stu-id="36bc1-133">Once you turn on the protocol sequence, any calls already waiting on the queue for the server will begin to be read off the queue.</span></span> <span data-ttu-id="36bc1-134">Если соответствующий интерфейс RPC не был зарегистрирован, вызовы завершатся ошибкой.</span><span class="sxs-lookup"><span data-stu-id="36bc1-134">If the corresponding RPC interface has not been registered, the calls will fail.</span></span> <span data-ttu-id="36bc1-135">Такая ситуация может возникнуть, если для удаленных вызовов процедур настроена постоянная конечная точка, работа сервера была завершена, а клиенты продолжают отсылать вызовы на сервер.</span><span class="sxs-lookup"><span data-stu-id="36bc1-135">This situation can happen if you have a setup a permanent endpoint for your remote procedure calls, the server has been shut down, and clients have continued to send calls to the server.</span></span> <span data-ttu-id="36bc1-136">Эти вызовы будут помещены в очередь в очереди, ожидая считывания после того, как сервер вернется в режим «в сети».</span><span class="sxs-lookup"><span data-stu-id="36bc1-136">These calls will be stacked up in the queue, waiting to be read once the server comes back online.</span></span>

 

<span data-ttu-id="36bc1-137">Дополнительные сведения см. в разделе [**рпкбиндингсетоптион**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetoption), [**рпксерверусепротсекепекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex)и \[ [**Message**](/windows/desktop/Midl/message) \] , [**нкадг \_ MQ**](/windows/desktop/Midl/ncadg-mq).</span><span class="sxs-lookup"><span data-stu-id="36bc1-137">For more information, see [**RpcBindingSetOption**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetoption), [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex), and \[[**message**](/windows/desktop/Midl/message)\], [**ncadg\_mq**](/windows/desktop/Midl/ncadg-mq).</span></span>

 

 