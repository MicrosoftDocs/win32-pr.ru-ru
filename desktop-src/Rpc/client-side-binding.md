---
title: Привязка на стороне клиента
description: Дескрипторы привязки состоят из последовательности протоколов, имени или адреса хост-компьютера серверной программы и конечной точки серверной программы. Поэтому клиентская программа должна получить или предоставить эти сведения для создания привязки.
ms.assetid: 0a3bed37-95c7-4f4a-9ed3-9d57f69db523
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f42ed5d2af21eff1091e0ba48718426bf17501e3
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "105672129"
---
# <a name="client-side-binding"></a><span data-ttu-id="c86c3-104">Привязка на стороне клиента</span><span class="sxs-lookup"><span data-stu-id="c86c3-104">Client-side Binding</span></span>

<span data-ttu-id="c86c3-105">Дескрипторы привязки состоят из последовательности протоколов, имени или адреса хост-компьютера серверной программы и конечной точки серверной программы.</span><span class="sxs-lookup"><span data-stu-id="c86c3-105">Binding handles are composed of a protocol sequence, the name or address of a server program host computer, and a server program endpoint.</span></span> <span data-ttu-id="c86c3-106">Поэтому клиентская программа должна получить или предоставить эти сведения для создания привязки.</span><span class="sxs-lookup"><span data-stu-id="c86c3-106">Therefore, your client program must obtain or provide this information to create a binding.</span></span>

<span data-ttu-id="c86c3-107">Если клиентская программа использует автоматические дескрипторы привязки, вам не нужно писать специальный исходный код для создания привязки или управления ей.</span><span class="sxs-lookup"><span data-stu-id="c86c3-107">If your client program uses automatic binding handles, you do not need to write special source code to create or manage the binding.</span></span> <span data-ttu-id="c86c3-108">Заглушка клиента вызывает функции RPC, необходимые для установления и обслуживания привязки.</span><span class="sxs-lookup"><span data-stu-id="c86c3-108">The client stub calls RPC functions required to establish and maintain the binding.</span></span> <span data-ttu-id="c86c3-109">Необходимо только указать, что клиент использует автоматические дескрипторы привязки в файле конфигурации приложения (ACF), и соответствующим образом разработать интерфейс.</span><span class="sxs-lookup"><span data-stu-id="c86c3-109">All you have to do is specify that your client uses automatic binding handles in the application configuration file (ACF), and design the interface accordingly.</span></span> <span data-ttu-id="c86c3-110">Дополнительные сведения см. в разделе [Автоматические дескрипторы привязки](automatic-binding-handles.md).</span><span class="sxs-lookup"><span data-stu-id="c86c3-110">For details, see [Automatic Binding Handles](automatic-binding-handles.md).</span></span>

<span data-ttu-id="c86c3-111">Предположим, например, что вы разработали клиентскую программу, которая называлась удаленными функциями отметки времени.</span><span class="sxs-lookup"><span data-stu-id="c86c3-111">Suppose, for example, that you were developing a client program that called remote time-stamping functions.</span></span> <span data-ttu-id="c86c3-112">В этом случае заглушки выполняют всю работу, и клиент должен включить созданный файл заголовка Auto. h, чтобы получить прототипы функций для удаленных процедур.</span><span class="sxs-lookup"><span data-stu-id="c86c3-112">Here, the stubs do all the work and the client only needs to include the generated header file Auto.h to obtain the function prototypes for the remote procedures.</span></span> <span data-ttu-id="c86c3-113">Клиентское приложение обращается к удаленным процедурам так же, как если бы они были вызваны локальными процедурами, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="c86c3-113">The client application calls to the remote procedures appear just as if they were calls to local procedures, as shown in the following example:</span></span>


```C++
/* auto handle client application (fragment) */
#include <windows.h>
#include <stdio.h>
#include <time.h>
#include "auto.h"    // header file generated by the MIDL compiler
 
 
void main(int argc, char **argv)
{
    time_t t1;
    time_t t2;
    char * pszTime;
    ...
 
    GetTime(&t1);  // GetTime is a remote procedure
    GetTime(&t2);
 
    pszTime = ctime(&t1);
    printf("time 1= %s\n", pszTime);
 
    pszTime = ctime(&t2);
    printf("time 2= %s\n", pszTime);
 
    Shutdown();    // Shutdown is a remote procedure
    exit(0);
}
```



<span data-ttu-id="c86c3-114">Как видно в предыдущем примере, клиентскому приложению не нужно явно вызывать функции библиотеки времени выполнения RPC.</span><span class="sxs-lookup"><span data-stu-id="c86c3-114">As you can see in the preceding example, the client application does not have to make any explicit calls to the RPC run-time library functions.</span></span> <span data-ttu-id="c86c3-115">Клиентская заглушка управляет ими.</span><span class="sxs-lookup"><span data-stu-id="c86c3-115">The client stub manages them.</span></span>

<span data-ttu-id="c86c3-116">Если приложение использует неявные или явные дескрипторы привязки, клиент должен получить сведения о привязке и вызвать функции RPC для создания дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="c86c3-116">If your application uses implicit or explicit binding handles, the client must obtain the binding information and call the RPC functions to create the handles.</span></span> <span data-ttu-id="c86c3-117">Место, откуда клиент получает сведения о привязке, зависит от требований приложения.</span><span class="sxs-lookup"><span data-stu-id="c86c3-117">Where the client obtains the binding information from depends on the requirements of your application.</span></span> <span data-ttu-id="c86c3-118">Программа установки, устанавливающая клиентское приложение, может хранить сведения о привязке в переменных среды, которые она создает.</span><span class="sxs-lookup"><span data-stu-id="c86c3-118">The setup program that installs your client application can store binding information in environment variables that it creates.</span></span> <span data-ttu-id="c86c3-119">Он также может сохранять сведения о привязке в файле конфигурации, относящемся к приложению.</span><span class="sxs-lookup"><span data-stu-id="c86c3-119">It can also save binding information in an application-specific configuration file.</span></span> <span data-ttu-id="c86c3-120">Так как сведения о привязке в переменных среды или файлах конфигурации обычно хранятся в виде строк, клиентское приложение должно преобразовать строку в привязку.</span><span class="sxs-lookup"><span data-stu-id="c86c3-120">Since binding information in environment variables or configuration files is usually stored as strings, your client application will need to convert the string to a binding.</span></span> <span data-ttu-id="c86c3-121">В средах Windows XP и 2000 сведения о привязке можно получить из Active Directory.</span><span class="sxs-lookup"><span data-stu-id="c86c3-121">In Windows XP/2000 environments, binding information can be retrieved from Active Directory.</span></span> <span data-ttu-id="c86c3-122">Дополнительные сведения см. [в разделе использование строковых привязок](finding-server-host-systems.md).</span><span class="sxs-lookup"><span data-stu-id="c86c3-122">For more information, see [Using String Bindings](finding-server-host-systems.md).</span></span>

<span data-ttu-id="c86c3-123">В большинстве сетей есть служба имен.</span><span class="sxs-lookup"><span data-stu-id="c86c3-123">Most networks have a name service.</span></span> <span data-ttu-id="c86c3-124">Серверные программы могут объявлять себя в базе данных службы имен.</span><span class="sxs-lookup"><span data-stu-id="c86c3-124">Server programs can advertise themselves in the name service database.</span></span> <span data-ttu-id="c86c3-125">Когда клиент начинает выполнение, он может получить сведения о его привязке из базы данных службы имен.</span><span class="sxs-lookup"><span data-stu-id="c86c3-125">When a client begins execution, it can obtain its binding information from the name service database.</span></span> <span data-ttu-id="c86c3-126">Дополнительные сведения см. [в разделе Импорт из баз данных службы имен](finding-server-host-systems.md).</span><span class="sxs-lookup"><span data-stu-id="c86c3-126">For details, see [Importing from Name Service Databases](finding-server-host-systems.md).</span></span>

<span data-ttu-id="c86c3-127">Шаги, необходимые для привязки с явными и неявно управляющими маркерами, обсуждаются в следующих разделах:</span><span class="sxs-lookup"><span data-stu-id="c86c3-127">The steps required for binding with implicit and explicit handles are discussed in the following topics:</span></span>

-   [<span data-ttu-id="c86c3-128">Выбор последовательности протокола</span><span class="sxs-lookup"><span data-stu-id="c86c3-128">Selecting a Protocol Sequence</span></span>](selecting-a-protocol-sequence.md)
-   [<span data-ttu-id="c86c3-129">Поиск систем узлов сервера</span><span class="sxs-lookup"><span data-stu-id="c86c3-129">Finding Server Host Systems</span></span>](finding-server-host-systems.md)
-   [<span data-ttu-id="c86c3-130">Поиск конечных точек</span><span class="sxs-lookup"><span data-stu-id="c86c3-130">Finding Endpoints</span></span>](finding-endpoints.md)

<span data-ttu-id="c86c3-131">Краткий обзор этих разделов см. в разделе [подключение клиента и сервера](connecting-the-client-and-the-server.md).</span><span class="sxs-lookup"><span data-stu-id="c86c3-131">For a brief overview of these topics, see [Connecting the Client and the Server](connecting-the-client-and-the-server.md).</span></span>

 

 




