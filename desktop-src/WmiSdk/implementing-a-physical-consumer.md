---
description: Физический потребитель — это COM-объект, реализующий интерфейс Ивбемунбаундобжектсинк.
ms.assetid: 497457dc-61ca-4527-89fd-2af0383de5e9
ms.tgt_platform: multiple
title: Реализация физического потребителя
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: af0a9530ed7a98ce19b3b39f2f5a1fe52f3b0631
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105712466"
---
# <a name="implementing-a-physical-consumer"></a><span data-ttu-id="f4dea-103">Реализация физического потребителя</span><span class="sxs-lookup"><span data-stu-id="f4dea-103">Implementing a Physical Consumer</span></span>

<span data-ttu-id="f4dea-104">Физический потребитель — это COM-объект, реализующий интерфейс [**ивбемунбаундобжектсинк**](/windows/desktop/api/Wbemprov/nn-wbemprov-iwbemunboundobjectsink) .</span><span class="sxs-lookup"><span data-stu-id="f4dea-104">A physical consumer is a COM object that implements the [**IWbemUnboundObjectSink**](/windows/desktop/api/Wbemprov/nn-wbemprov-iwbemunboundobjectsink) interface.</span></span> <span data-ttu-id="f4dea-105">Инструментарий WMI загружает физического потребителя и передает события через **ивбемунбаундобжектсинк** в ответ на одно или несколько событий, как определено соответствующим логическим потребителем.</span><span class="sxs-lookup"><span data-stu-id="f4dea-105">WMI loads your physical consumer and passes events through **IWbemUnboundObjectSink** in response to one or more events, as defined by the associated logical consumer.</span></span> <span data-ttu-id="f4dea-106">Постоянные потребители имеют особые требования к безопасности.</span><span class="sxs-lookup"><span data-stu-id="f4dea-106">Permanent consumers have special security requirements.</span></span> <span data-ttu-id="f4dea-107">Дополнительные сведения см. в разделе [Защита событий WMI](securing-wmi-events.md).</span><span class="sxs-lookup"><span data-stu-id="f4dea-107">For more information, see [Securing WMI Events](securing-wmi-events.md).</span></span>

<span data-ttu-id="f4dea-108">Следующая процедура описывает, как реализовать физического потребителя для постоянного потребителя событий.</span><span class="sxs-lookup"><span data-stu-id="f4dea-108">The following procedure describes how to implement a physical consumer for a permanent event consumer.</span></span>

<span data-ttu-id="f4dea-109">**Реализация физического потребителя для постоянного потребителя событий**</span><span class="sxs-lookup"><span data-stu-id="f4dea-109">**To implement a physical consumer for a permanent event consumer**</span></span>

1.  <span data-ttu-id="f4dea-110">Создайте COM-объект.</span><span class="sxs-lookup"><span data-stu-id="f4dea-110">Create a COM object.</span></span>

    <span data-ttu-id="f4dea-111">Необходимо реализовать физического потребителя в качестве локального или удаленного сервера с помощью протокола COM.</span><span class="sxs-lookup"><span data-stu-id="f4dea-111">You must implement a physical consumer as a local or remote server using the COM protocol.</span></span>

2.  <span data-ttu-id="f4dea-112">Определите, требуется ли поддержка синхронного или асинхронного уведомления о событиях.</span><span class="sxs-lookup"><span data-stu-id="f4dea-112">Determine if you want to support synchronous or asynchronous event notification.</span></span>

    <span data-ttu-id="f4dea-113">При асинхронном уведомлении о событиях поток отправки не связан с принимающим потоком.</span><span class="sxs-lookup"><span data-stu-id="f4dea-113">With asynchronous event notification, the sending thread is unrelated to the receiving thread.</span></span> <span data-ttu-id="f4dea-114">Таким образом, не блокируется ни WMI, ни поставщик событий, пока Инструментарий WMI доставляет уведомление любому потребителю, зарегистрированному для получения события.</span><span class="sxs-lookup"><span data-stu-id="f4dea-114">Therefore, neither WMI nor the event provider gets blocked while WMI delivers a notification to any consumer registered to receive the event.</span></span> <span data-ttu-id="f4dea-115">Недостатком асинхронной доставки является то, что переключение контекста происходит между моментом, когда поставщик создает событие, и временем получения события потребителем.</span><span class="sxs-lookup"><span data-stu-id="f4dea-115">The disadvantage to asynchronous delivery is that a context switch occurs between the time the provider produces the event and the time the consumer receives the event.</span></span> <span data-ttu-id="f4dea-116">Дополнительные сведения о работе в асинхронном режиме см. в разделе " [основы com](../com/guide.md) " в разделе "com" пакета средств разработки программного обеспечения Microsoft Windows (SDK).</span><span class="sxs-lookup"><span data-stu-id="f4dea-116">For more information about working asynchronously, see the [COM Fundamentals](../com/guide.md) topic in the COM section of the Microsoft Windows Software Development Kit (SDK).</span></span> <span data-ttu-id="f4dea-117">Дополнительные сведения о переключении контекста см. в разделе [Переключение контекста](../procthread/context-switches.md) в разделе библиотеки DLL, процессы и потоки Windows SDK.</span><span class="sxs-lookup"><span data-stu-id="f4dea-117">For more information about context switches, see the [Context Switches](../procthread/context-switches.md) topic in the DLLs, Processes, and Threads section of the Windows SDK.</span></span>

    > [!Note]  
    > <span data-ttu-id="f4dea-118">Поскольку обратный вызов приемника может не возвращаться на том же уровне проверки подлинности, что и клиент, рекомендуется использовать семисинчронаус вместо асинхронного взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="f4dea-118">Because the callback to the sink might not be returned at the same authentication level as the client requires, it is recommended that you use semisynchronous instead of asynchronous communication.</span></span> <span data-ttu-id="f4dea-119">Дополнительные сведения см. [в разделе вызов метода](calling-a-method.md).</span><span class="sxs-lookup"><span data-stu-id="f4dea-119">For more information, see [Calling a Method](calling-a-method.md).</span></span>

     

    <span data-ttu-id="f4dea-120">При синхронном уведомлении Инструментарий WMI доставляет уведомления в том же потоке, который используется поставщиком событий для доставки события в WMI.</span><span class="sxs-lookup"><span data-stu-id="f4dea-120">With synchronous notification, WMI delivers the notification on the same thread that the event provider used to deliver the event to WMI.</span></span> <span data-ttu-id="f4dea-121">В этом случае, когда поставщик событий отправляет уведомление, поставщик событий блокируется WMI до тех пор, пока Инструментарий WMI не доставляет уведомление.</span><span class="sxs-lookup"><span data-stu-id="f4dea-121">In this case, when an event provider sends a notification, the event provider is blocked by WMI until WMI delivers the notification.</span></span> <span data-ttu-id="f4dea-122">Использовать синхронное уведомление можно только в том случае, если потребитель работает очень быстро и может обработать событие в течение 100 микросекунд или меньше.</span><span class="sxs-lookup"><span data-stu-id="f4dea-122">Only if your consumer is extremely fast and can process an event in 100 microseconds or less should you consider supporting synchronous notification.</span></span> <span data-ttu-id="f4dea-123">Синхронные потребители, которые занимают слишком много времени для обработки событий, могут серьезно замедлять доставку событий всем остальным потребителям.</span><span class="sxs-lookup"><span data-stu-id="f4dea-123">Synchronous consumers that take too long to process events can seriously slow the delivery of events to all other consumers.</span></span> <span data-ttu-id="f4dea-124">Более того, они могут случайно заблокировать поставщик.</span><span class="sxs-lookup"><span data-stu-id="f4dea-124">Furthermore, they can inadvertently block the provider.</span></span> <span data-ttu-id="f4dea-125">Дополнительные сведения см. в разделе [Привязка фильтра событий к логическому потребителю](binding-an-event-filter-with-a-logical-consumer.md).</span><span class="sxs-lookup"><span data-stu-id="f4dea-125">For more information, see [Binding an Event Filter with a Logical Consumer](binding-an-event-filter-with-a-logical-consumer.md).</span></span>

3.  <span data-ttu-id="f4dea-126">Реализуйте функцию [**ивбемунбаундобжектсинк:: индикатетоконсумер**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) .</span><span class="sxs-lookup"><span data-stu-id="f4dea-126">Implement the [**IWbemUnboundObjectSink::IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) function.</span></span>

    <span data-ttu-id="f4dea-127">Инструментарий WMI использует функцию [**индикатетоконсумер**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) для передачи необходимых указателей и событий физическому потребителю как для синхронной, так и для асинхронной связи.</span><span class="sxs-lookup"><span data-stu-id="f4dea-127">WMI uses the [**IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) function to pass the necessary pointers and events to your physical consumer for both synchronous and asynchronous communications.</span></span> <span data-ttu-id="f4dea-128">Ваша реализация **индикатетоконсумер** должна содержать весь необходимый код для реагирования на событие.</span><span class="sxs-lookup"><span data-stu-id="f4dea-128">Your implementation of **IndicateToConsumer** should contain all of the necessary code to respond to an event.</span></span>

    <span data-ttu-id="f4dea-129">В отличие от временных потребителей событий, нет необходимости вызывать интерфейс [**ивбемлокатор**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) для связи с WMI.</span><span class="sxs-lookup"><span data-stu-id="f4dea-129">Unlike a temporary event consumer, you do not need to call the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface to contact WMI.</span></span> <span data-ttu-id="f4dea-130">Вместо этого инструментарий WMI находит указатель на потребителя с помощью поставщика потребителей событий.</span><span class="sxs-lookup"><span data-stu-id="f4dea-130">Instead, WMI locates a pointer to your consumer through the event consumer provider.</span></span> <span data-ttu-id="f4dea-131">Дополнительные сведения см. в разделе [написание поставщика объектов событий](writing-an-event-consumer-provider.md).</span><span class="sxs-lookup"><span data-stu-id="f4dea-131">For more information, see [Writing an Event Consumer Provider](writing-an-event-consumer-provider.md).</span></span>

    <span data-ttu-id="f4dea-132">Однако если вы хотите выполнить обратный вызов к инструментарию WMI, используйте интерфейсы [**ивбемлокатор**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) и [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) .</span><span class="sxs-lookup"><span data-stu-id="f4dea-132">However, if you wish to call back into WMI, use the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) and [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) interfaces.</span></span> <span data-ttu-id="f4dea-133">Традиционным способом подключения к WMI является процесс инициализации COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="f4dea-133">The traditional method for connecting to WMI is during the initialization process of your COM object.</span></span> <span data-ttu-id="f4dea-134">Дополнительные сведения см. [в разделе Создание приложения WMI или скрипта](creating-a-wmi-application-or-script.md).</span><span class="sxs-lookup"><span data-stu-id="f4dea-134">For more information, see [Creating a WMI Application or Script](creating-a-wmi-application-or-script.md).</span></span>

    <span data-ttu-id="f4dea-135">При реализации физического потребителя в качестве внутрипроцессного COM-сервера и подключения к WMI отдельно от процесса инициализации необходимо использовать идентификатор класса **CLSID \_ вбемадминистративелокатор** для доступа к интерфейсу [**ивбемлокатор**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) в вызове функции [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="f4dea-135">If you implement your physical consumer as an in-process COM server and connect to WMI separately from the initialization process, you must use the **CLSID\_WbemAdministrativeLocator** class identifier to access the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface in the call to [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span>

    <span data-ttu-id="f4dea-136">В следующем примере показано, как использовать идентификатор класса **CLSID \_ вбемадминистративелокатор** для доступа к интерфейсу [**ивбемлокатор**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) .</span><span class="sxs-lookup"><span data-stu-id="f4dea-136">The following example shows how to use the **CLSID\_WbemAdministrativeLocator** class identifier to access the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface.</span></span>

    ```C++
    IWbemLocator *pLoc = 0;

    DWORD dwRes = CoCreateInstance(CLSID_WbemAdministrativeLocator, 0, 
        CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pLoc);
    ```

    

    <span data-ttu-id="f4dea-137">Интерфейс [**ивбемлокатор**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) получает указатель исходного пространства имен на WMI на определенном компьютере узла.</span><span class="sxs-lookup"><span data-stu-id="f4dea-137">The [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface obtains the initial namespace pointer to WMI on a particular host computer.</span></span> <span data-ttu-id="f4dea-138">Сбой использования идентификатора **\_ вбемадминистративелокатор CLSID** в вызове [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) приводит к ошибке "доступ запрещен".</span><span class="sxs-lookup"><span data-stu-id="f4dea-138">Failure to use the **CLSID\_WbemAdministrativeLocator** identifier in the [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) call results in an "access denied" error.</span></span>

    <span data-ttu-id="f4dea-139">В обычных обстоятельствах Инструментарий WMI доставляет асинхронные события клиенту по одному за раз.</span><span class="sxs-lookup"><span data-stu-id="f4dea-139">Under usual circumstances, WMI delivers asynchronous events to the client one at a time.</span></span> <span data-ttu-id="f4dea-140">Однако если клиент не может получать асинхронные уведомления о событиях по мере поступления событий, Инструментарий WMI начинает автоматически выполнять пакетные события в одном вызове.</span><span class="sxs-lookup"><span data-stu-id="f4dea-140">However, if a client cannot receive asynchronous event notifications as fast as the events arrive, WMI starts to automatically batch events into a single call.</span></span> <span data-ttu-id="f4dea-141">Автоматическая пакетирование помогает в том случае, если время кругового пути является проблемой, как часто бывает в сценариях с высокой пропускной способностью.</span><span class="sxs-lookup"><span data-stu-id="f4dea-141">Automatic batching helps if the round-trip times are a problem, as is often the case in high-throughput scenarios.</span></span> <span data-ttu-id="f4dea-142">Однако Пакетная обработка не повышает производительность системы в случае сбоя клиента или пропускной способности сети.</span><span class="sxs-lookup"><span data-stu-id="f4dea-142">However, batching does not improve system performance if the client or the network bandwidth are at fault.</span></span>

 

 
