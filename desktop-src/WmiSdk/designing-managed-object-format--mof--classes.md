---
description: Поставщик WMI состоит из файла MOF-файл (MOF) и DLL-файла. MOF-файл определяет классы, для которых реализация поставщика предоставляет данные.
ms.assetid: 20ef6b88-2aaa-4e86-bc4a-bebc34069672
ms.tgt_platform: multiple
title: Разработка классов MOF-файл (MOF)
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 201f8c45f7a247fbca5695baa6dd440fc5dc323f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104265380"
---
# <a name="designing-managed-object-format-mof-classes"></a>Разработка классов MOF-файл (MOF)

[*Поставщик WMI*](gloss-p.md) состоит из файла MOF-файл (MOF) и DLL-файла. MOF-файл определяет классы, для которых реализация поставщика предоставляет данные.

Определения классов MOF компилируются программой [**mofcomp**](mofcomp.md) и хранятся в [*репозитории WMI*](gloss-w.md), также известном как репозиторий модель CIM (CIM). Менее распространенный способ создания классов заключается в использовании методов [API COM для WMI](com-api-for-wmi.md).

> [!Note]  
> Чтобы гарантировать, что все определения классов WMI для управляемых объектов будут восстановлены в [*репозитории WMI*](gloss-w.md) в случае сбоя и перезапуска WMI, используйте инструкцию препроцессора [**\# pragma автовосстановления**](pragma-autorecover.md) в MOF-файле.

 

В этом разделе обсуждаются следующие разделы:

-   [Определение объектов для управления](#defining-the-objects-to-manage)
-   [Определение свойств или методов](#defining-properties-or-methods)
-   [Связывание объектов друг с другом](#relating-objects-to-each-other)
-   [См. также](#related-topics)

## <a name="defining-the-objects-to-manage"></a>Определение объектов для управления

Определив часть организации для управления, определите объекты для управления. Определение должно включать необходимые данные и позволяет точно реализовать соответствующие бизнес-правила. Объекты можно определять на детализированном уровне, но лучше выбрать уровень детализации, содержащийся в определении, и необходимость предоставить достаточно подробное описание. Ярлыки на ранних этапах процесса могут сэкономить время, но в будущем это может привести к большей работе.

В руководстве по CIM на веб-сайте распределенной задачи управления (DMTF) содержится отличная информация о процессе разработки. Дополнительные сведения см. в разделе [www.DMTF.org](https://www.dmtf.org/).

При разработке и реализации структуры схемы учитывайте следующие факторы.

-   Квалификаторы

    Квалификаторы предоставляют сведения о том, как описывать классы, объекты, свойства, методы и параметры. они применяются к определениям классов и свойств. В коде MOF квалификаторы заключаются в квадратные скобки и могут включать \[ ключ \] или \[ связь \] . Дополнительные сведения см. в разделе Добавление квалификаторов [квалификатора](adding-a-qualifier.md) и [WMI](wmi-qualifiers.md).

-   Пространство имен

    Пространство имен — это логическая единица для группирования классов и объектов, управления областью и видимостью. Как правило, пространство имен содержит набор классов и объектов, представляющих управляемые объекты в определенной среде. Дополнительные сведения см. [в разделе Создание иерархий в WMI](creating-hierarchies-within-wmi.md).

-   Объект

    Смоделированный объект может быть физическим или логическим элементом схемы. Например, можно смоделировать физический диск, например жесткий диск, или логический диск, который может быть разделом на физическом диске. Проект, использующий класс для моделирования физического диска, а затем расширяет этот класс для моделирования логического диска, является более расширяемым, чем тот, который пытается создать отдельный класс для каждого типа диска.

-   Данные

    Данные могут быть динамическими или статическими. Если данные являются динамическими, необходимо создать для него поставщик класса.

    Чтобы разрешить пользователю изменять данные, необходимо определить, нужно ли, чтобы свойство можно было напрямую записывать или изменять только с помощью метода, который вызывает пользователь.

## <a name="defining-properties-or-methods"></a>Определение свойств или методов

Как правило, свойство класса WMI аналогично свойству в классе C++. Если единственными действиями, которые ваш код реализует для фрагмента данных, является получение значения или установка значения, то данные должны быть определены как свойство класса WMI.

Метод WMI обычно выполняет действие, которое изменяет состояние управляемого объекта. Например, если действием является включение или отключение операции аппаратного объекта, то, вероятно, предпочтительнее создать свойство для чтения и записи. Вы также можете создать свойство, отображающее состояние оборудования.

При создании класса или экземпляра можно включить комментарии. Используйте этот метод для документирования класса или объяснения методов программирования. Дополнительные сведения см. [в разделе Создание комментария](creating-a-comment.md). Кроме того, можно добавить данные, чтобы уточнить назначение объекта данных. Дополнительные сведения см. [в разделе Добавление квалификатора](adding-a-qualifier.md).

## <a name="relating-objects-to-each-other"></a>Связывание объектов друг с другом

Существует два способа связать объекты друг с другом: путем создания отдельных объектов и объекта связи, связывающего их, или путем внедрения одного объекта в другой. CIM не поддерживает внедренные объекты, поэтому для обеспечения совместимости с CIM необходимо использовать первый метод. Однако Инструментарий WMI поддерживает внедренные объекты, поэтому для представления связи между объектами используется любой из методов. Примеры внедренных объектов можно найти в [классах Win32](/windows/desktop/CIMWin32Prov/win32-provider). Например, в [**Win32 \_ SecurityDescriptor**](/previous-versions/windows/desktop/secrcw32prov/win32-securitydescriptor) есть внедренный объект [**\_ ACE Win32**](/previous-versions/windows/desktop/secrcw32prov/win32-ace), который имеет другой внедренный объект [**— \_ доверенное лицо Win32**](/previous-versions/windows/desktop/secrcw32prov/win32-trustee).

При принятии решения о том, как представлять отношения между объектами, учитывайте следующее.

-   Если экземпляр является полезным для себя, то Ассоциация работает лучше. Например, [**Win32 \_ Process**](/windows/desktop/CIMWin32Prov/win32-process) и [**Win32 \_ UserAccount**](/windows/desktop/CIMWin32Prov/win32-useraccount). Дополнительные сведения см. в разделе [объявление класса ассоциации](declaring-an-association-class.md).
-   Если экземпляр не существует за пределами родительского объекта, лучше подходит внедренный объект. Например, [**Win32 \_ SecurityDescriptor**](/previous-versions/windows/desktop/secrcw32prov/win32-securitydescriptor) и [**\_ ACE Win32**](/previous-versions/windows/desktop/secrcw32prov/win32-ace). Дополнительные сведения см. [в разделе внедрение объектов в класс](embedded-objects.md).

## <a name="related-topics"></a>См. также

<dl> <dt>

[Разработка поставщика WMI](developing-a-wmi-provider.md)
</dt> <dt>

[Предоставление данных инструментарию WMI](providing-data-to-wmi.md)
</dt> <dt>

[Типы данных MOF](mof-data-types.md)
</dt> </dl>

 

 
