---
description: После завершения концептуальной и логической моделей можно принимать решения о физической реализации приложения.
ms.assetid: 18c440f0-88c8-4738-9f29-c82772439b51
title: 'Физическая модель: архитектура приложения'
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5147241b460763b4218734344340291af5c423c2ee2e7a8ec9e485b30221d795
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118812219"
---
# <a name="the-physical-model-application-architecture"></a>Физическая модель: архитектура приложения

После завершения концептуальной и логической моделей можно принимать решения о физической реализации приложения. Чтобы создать физическую модель, необходимо понять, где должны располагаться различные службы приложения и как они должны быть реализованы. Определение места, где должны находиться различные службы, перед реализацией служб.

Одно из основных правил определения места существования различных служб: размещение компонента, где она используется. Если, например, компонент отображает сведения для базового клиента, он должен переключиться на компьютер пользователя. Если компонент проверяет сведения от базового клиента, он также должен находиться на компьютере базового клиента. Если компонент обновляет сведения в базе данных, он должен находиться на сервере базы данных.

Конечно, есть и другие соображения, которые делают исключения из этого правила. Проблемы с производительностью и безопасностью также могут зависеть от того, где находится компонент. Рассмотрим следующий пример.

-   Происходит ли частое изменение компонента, что усложняет распространение обновлений?
-   Будет ли компонент использоваться другими приложениями, такими как общий компонент проверки безопасности?
-   Создает ли компонент длительные вычисления или выполняет такие функции, как печать, которые можно разгрузить на сервер?
-   Можно ли улучшить безопасность компонента, поместив его на сервер?

Правильное размещение компонентов приложения также может изолировать команду разработчиков от дорогостоящих перекодирования при изменении системы или расположения данных. Например, размещение правил доступа к данным на уровне данных, а не в хранимых процедурах, упрощает изолированность приложения от зависимости от конкретной СУБД. Не только изменения являются ограниченными и тестируются подразделяется, но источники данных могут быть изменены, и данные могут быть распределены без фундаментального изменения приложения.

Наконец, Поиск компонентов должен воспользоваться преимуществами повышения эффективности системы. Это время и экономичное размещение бизнес-объектов в централизованных расположениях в сети. Объекты могут совместно использоваться приложениями, а модульное тестирование можно выполнить до развертывания каких бы то ни было компонентов. Затраты на обслуживание также можно уменьшить, так как изменения правил происходят только в одной точке.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Концептуальная модель: требования к приложениям](the-conceptual-model--application-requirements.md)
</dt> <dt>

[Логическая модель: определение приложения и планирование](the-logical-model--application-definition-and-planning.md)
</dt> </dl>

 

 



