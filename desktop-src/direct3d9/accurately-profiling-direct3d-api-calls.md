---
description: Если у вас есть функциональное приложение Microsoft Direct3D и вы хотите повысить его производительность, обычно используется средство профилирования на полке или пользовательский метод измерения, чтобы измерять время, затрачиваемое на выполнение одного или нескольких вызовов интерфейса прикладного программирования (API). Если вы сделали это, но получаете результаты по времени, которые отличаются от одной последовательности отрисовки к следующей, или если вы выполняете такую проверку, которая не удерживает фактических результатов эксперимента, приведенные ниже сведения помогут понять причину.
ms.assetid: f969be42-d541-4e8d-aec4-eb9508bcc7cf
title: Точное профилирование вызовов API Direct3D (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cdb6d60fcc1b3ace4112dbf7028d91e2c9c8b345
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "103807703"
---
# <a name="accurately-profiling-direct3d-api-calls-direct3d-9"></a><span data-ttu-id="f01cb-104">Точное профилирование вызовов API Direct3D (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="f01cb-104">Accurately Profiling Direct3D API Calls (Direct3D 9)</span></span>

-   [<span data-ttu-id="f01cb-105">Точное профилирование Direct3D сложно</span><span class="sxs-lookup"><span data-stu-id="f01cb-105">Accurately Profiling Direct3D Is Difficult</span></span>](#accurately-profiling-direct3d-is-difficult)
-   [<span data-ttu-id="f01cb-106">Как точно пропрофилировать последовательность визуализации Direct3D</span><span class="sxs-lookup"><span data-stu-id="f01cb-106">How to Accurately Profile a Direct3D Render Sequence</span></span>](#how-to-accurately-profile-a-direct3d-render-sequence)
-   [<span data-ttu-id="f01cb-107">Профилирование изменений состояния Direct3D</span><span class="sxs-lookup"><span data-stu-id="f01cb-107">Profiling Direct3D State Changes</span></span>](#profiling-direct3d-state-changes)
-   [<span data-ttu-id="f01cb-108">Сводка</span><span class="sxs-lookup"><span data-stu-id="f01cb-108">Summary</span></span>](#summary)
-   [<span data-ttu-id="f01cb-109">Приложение</span><span class="sxs-lookup"><span data-stu-id="f01cb-109">Appendix</span></span>](#appendix)

<span data-ttu-id="f01cb-110">Если у вас есть функциональное приложение Microsoft Direct3D и вы хотите повысить его производительность, обычно используется средство профилирования на полке или пользовательский метод измерения, чтобы измерять время, затрачиваемое на выполнение одного или нескольких вызовов интерфейса прикладного программирования (API).</span><span class="sxs-lookup"><span data-stu-id="f01cb-110">Once you have a functional Microsoft Direct3D application and you want to improve its performance, you generally use an off-the-shelf profiling tool or some custom measurement technique to measure the time it takes to execute one or more application programming interface (API) calls.</span></span> <span data-ttu-id="f01cb-111">Если вы сделали это, но получаете результаты по времени, которые отличаются от одной последовательности отрисовки к следующей, или если вы выполняете такую проверку, которая не удерживает фактических результатов эксперимента, приведенные ниже сведения помогут понять причину.</span><span class="sxs-lookup"><span data-stu-id="f01cb-111">If you have done this but are getting timing results that vary from one render sequence to the next, or you are making hypotheses that do not hold up to actual experiment results, the following information may help you to understand why.</span></span>

<span data-ttu-id="f01cb-112">Приведенные здесь сведения основаны на предположении, что у вас есть знания и опыт работы со следующими возможностями.</span><span class="sxs-lookup"><span data-stu-id="f01cb-112">The information provided here is based upon the assumption that you have knowledge of and experience with the following:</span></span>

-   <span data-ttu-id="f01cb-113">Программирование C/C++</span><span class="sxs-lookup"><span data-stu-id="f01cb-113">C/C++ programming</span></span>
-   <span data-ttu-id="f01cb-114">Программирование Direct3D API</span><span class="sxs-lookup"><span data-stu-id="f01cb-114">Direct3D API programming</span></span>
-   <span data-ttu-id="f01cb-115">Измерение времени API</span><span class="sxs-lookup"><span data-stu-id="f01cb-115">Measuring API timing</span></span>
-   <span data-ttu-id="f01cb-116">Видеоадаптер и его драйвер программного обеспечения</span><span class="sxs-lookup"><span data-stu-id="f01cb-116">The video card and its software driver</span></span>
-   <span data-ttu-id="f01cb-117">Возможные необъяснимые результаты из предыдущего процесса профилирования</span><span class="sxs-lookup"><span data-stu-id="f01cb-117">Possible unexplainable results from previous profiling experience</span></span>

## <a name="accurately-profiling-direct3d-is-difficult"></a><span data-ttu-id="f01cb-118">Точное профилирование Direct3D сложно</span><span class="sxs-lookup"><span data-stu-id="f01cb-118">Accurately Profiling Direct3D Is Difficult</span></span>

<span data-ttu-id="f01cb-119">Профилировщик сообщает о количестве времени, затраченном на каждый вызов API.</span><span class="sxs-lookup"><span data-stu-id="f01cb-119">A profiler reports on the amount of time spent in each API call.</span></span> <span data-ttu-id="f01cb-120">Это делается для повышения производительности путем поиска и настройки гиперобъектов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-120">This is done to improve performance by finding and tuning away hot spots.</span></span> <span data-ttu-id="f01cb-121">Существуют различные виды профилировщиков и методов профилирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-121">There are different kinds of profilers and profiling techniques.</span></span>

-   <span data-ttu-id="f01cb-122">Профилировщик с выборкой находится в неактивном состоянии, воздействующем на определенные интервалы времени на выборку (или на запись) выполняемых функций.</span><span class="sxs-lookup"><span data-stu-id="f01cb-122">A sampling profiler sits idle much of the time, awakening at specific intervals to sample (or to record) the functions being executed.</span></span> <span data-ttu-id="f01cb-123">Он возвращает процент времени, затраченного на каждый вызов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-123">It returns the percentage of time spent in each call.</span></span> <span data-ttu-id="f01cb-124">Как правило, профилирование с выборкой не очень негативно сказывается на работе приложения и оказывает минимальное влияние на нагрузку приложения.</span><span class="sxs-lookup"><span data-stu-id="f01cb-124">Generally, a sampling profiler is not very invasive to the application and has minimal impact on the overhead for the application.</span></span>
-   <span data-ttu-id="f01cb-125">Профилировщик инструментирования измеряет фактическое время, необходимое для возврата вызова.</span><span class="sxs-lookup"><span data-stu-id="f01cb-125">An instrumenting profiler measures the actual time it takes for a call to return.</span></span> <span data-ttu-id="f01cb-126">Для этого требуется компиляция начальных и системных разделителей в приложение.</span><span class="sxs-lookup"><span data-stu-id="f01cb-126">It requires compiling start and stop delimiters into an application.</span></span> <span data-ttu-id="f01cb-127">Инструментированный профилировщик сравнительно более неагрессивен для приложения, чем выборочный профилировщик.</span><span class="sxs-lookup"><span data-stu-id="f01cb-127">An instrumenting profiler is comparatively more invasive to an application than a sampling profiler.</span></span>
-   <span data-ttu-id="f01cb-128">Также можно использовать пользовательский метод профилирования с высокопроизводительным таймером.</span><span class="sxs-lookup"><span data-stu-id="f01cb-128">It is also possible to use a custom profiling technique with a high-performance timer.</span></span> <span data-ttu-id="f01cb-129">Это создает результаты очень похоже на инструментирование профилировщика.</span><span class="sxs-lookup"><span data-stu-id="f01cb-129">This produces results very much like an instrumenting profiler.</span></span>

<span data-ttu-id="f01cb-130">Тип профайлера или используемого метода профилирования является лишь частью задачи создания точных измерений.</span><span class="sxs-lookup"><span data-stu-id="f01cb-130">The type of profiler or profiling technique used is only part of the challenge of generating accurate measurements.</span></span>

<span data-ttu-id="f01cb-131">Профилирование дает ответы на вопросы, которые помогут вам в бюджетировании производительности.</span><span class="sxs-lookup"><span data-stu-id="f01cb-131">Profiling gives you answers that help you budget performance.</span></span> <span data-ttu-id="f01cb-132">Предположим, что в результате вызова API будет вычисляться среднее время выполнения цикла, равное 1000.</span><span class="sxs-lookup"><span data-stu-id="f01cb-132">For instance, suppose you know that an API call averages one thousand clock cycles to execute.</span></span> <span data-ttu-id="f01cb-133">Вы можете утверждать некоторые выводы о производительности, например следующие:</span><span class="sxs-lookup"><span data-stu-id="f01cb-133">You can assert some conclusions about performance such as the following:</span></span>

-   <span data-ttu-id="f01cb-134">ЦП с частотой 2 ГГц (который тратит 50% времени на отрисовку) ограничивается вызовом этого API 1 000 000 раз в секунду.</span><span class="sxs-lookup"><span data-stu-id="f01cb-134">A 2 GHz CPU (which spends 50 percent of its time rendering) is limited to calling this API 1 million times a second.</span></span>
-   <span data-ttu-id="f01cb-135">Для достижения 30 кадров в секунду Этот API нельзя вызывать более 33 000 раз в кадре.</span><span class="sxs-lookup"><span data-stu-id="f01cb-135">To achieve 30 frames per second, you cannot call this API more than 33,000 times per frame.</span></span>
-   <span data-ttu-id="f01cb-136">В кадре можно обрабатывать только объекты 3.3 кбит (при условии, что 10 из этих вызовов API для каждой последовательности отрисовки объекта).</span><span class="sxs-lookup"><span data-stu-id="f01cb-136">You can only render 3.3K objects per frame (assuming 10 of these API calls for each object's render sequence).</span></span>

<span data-ttu-id="f01cb-137">Иными словами, если у вас достаточно времени на вызов API, можно ответить на вопрос о бюджетировании, например число примитивов, которые могут быть отображены в интерактивном режиме.</span><span class="sxs-lookup"><span data-stu-id="f01cb-137">In other words, if you had sufficient time per API call, you could answer a budgeting question such as the number of primitives that can be rendered interactively.</span></span> <span data-ttu-id="f01cb-138">Но необработанные значения, возвращаемые инструментированным профилировщиком, не будут точно отвечать на вопросы о бюджетировании.</span><span class="sxs-lookup"><span data-stu-id="f01cb-138">But the raw numbers returned by an instrumenting profiler will not accurately answer the budgeting questions.</span></span> <span data-ttu-id="f01cb-139">Это связано с тем, что графический конвейер имеет сложные проблемы проектирования, такие как количество компонентов, которые должны выполнять работу, число процессоров, управляющих работой потоков между компонентами, и стратегии оптимизации, реализованные в среде выполнения, и в драйвере, предназначенном для повышения эффективности конвейера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-139">This is because the graphics pipeline has complex design issues such as the number of components that need to do work, the number of processors that control how the work flows between components, and optimization strategies implemented in the runtime and in a driver that are designed to make the pipeline more efficient.</span></span>

### <a name="each-api-call-goes-through-several-components"></a><span data-ttu-id="f01cb-140">Каждый вызов API проходит через несколько компонентов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-140">Each API Call Goes through Several Components</span></span>

<span data-ttu-id="f01cb-141">Каждый вызов обрабатывается несколькими компонентами по своему пути от приложения до видеоадаптера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-141">Each call is processed by several components on its way from the application to the video card.</span></span> <span data-ttu-id="f01cb-142">Например, рассмотрим следующую последовательность отрисовки, содержащую два вызова для рисования одного треугольника:</span><span class="sxs-lookup"><span data-stu-id="f01cb-142">For instance, consider the following render sequence containing two calls for drawing a single triangle:</span></span>


```
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
```



<span data-ttu-id="f01cb-143">На следующей концептуальной схеме показаны различные компоненты, с помощью которых должны проходить вызовы.</span><span class="sxs-lookup"><span data-stu-id="f01cb-143">The following conceptual diagram shows the different components through which the calls must pass.</span></span>

![Схема графических компонентов, которые проходят вызовы API](images/microbenchmarkinstructionflow2.png)

<span data-ttu-id="f01cb-145">Приложение вызывает Direct3D, который управляет сценой, обрабатывает взаимодействие с пользователем и определяет, как выполняется отрисовка.</span><span class="sxs-lookup"><span data-stu-id="f01cb-145">The application invokes Direct3D which controls the scene, handles user interactions, and determines how rendering is done.</span></span> <span data-ttu-id="f01cb-146">Вся эта работа указана в последовательности отрисовки, которая отправляется в среду выполнения с помощью вызовов API Direct3D.</span><span class="sxs-lookup"><span data-stu-id="f01cb-146">All of this work is specified in the render sequence, which is sent to the runtime using Direct3D API calls.</span></span> <span data-ttu-id="f01cb-147">Последовательность прорисовки практически не зависит от оборудования (т. е. вызовы API являются аппаратно независимыми, но приложение имеет знания о том, какие функции поддерживает видеоадаптер).</span><span class="sxs-lookup"><span data-stu-id="f01cb-147">The render sequence is virtually hardware independent (that is, the API calls are hardware independent but an application has knowledge of what features a video card supports).</span></span>

<span data-ttu-id="f01cb-148">Среда выполнения преобразует эти вызовы в независимый от устройства формат.</span><span class="sxs-lookup"><span data-stu-id="f01cb-148">The runtime converts these calls into a device-independent format.</span></span> <span data-ttu-id="f01cb-149">Среда выполнения обрабатывает все взаимодействие между приложением и драйвером, чтобы приложение выполнялось на более чем одном совместимом оборудовании (в зависимости от необходимых функций).</span><span class="sxs-lookup"><span data-stu-id="f01cb-149">The runtime handles all the communication between the application and the driver, so that an application will run on more than one compatible piece of hardware (depending on the features required).</span></span> <span data-ttu-id="f01cb-150">При измерении вызова функции инструментированный профилировщик измеряет время, затраченное на выполнение функции, а также время возвращения функции.</span><span class="sxs-lookup"><span data-stu-id="f01cb-150">When measuring a function call, an instrumenting profiler measures the time it spent in a function as well as the time for the function to return.</span></span> <span data-ttu-id="f01cb-151">Одно из ограничений инструментирования профилировщика состоит в том, что оно может не включать время, которое драйвер отправляет на видеокарту, а также время, когда видеоадаптер обрабатывает работу.</span><span class="sxs-lookup"><span data-stu-id="f01cb-151">One limitation of an instrumenting profiler is that it may not include the time it takes a driver to send the resulting work to the video card nor the time for the video card to process the work.</span></span> <span data-ttu-id="f01cb-152">Иными словами, профилировщику с инструментированием не удается присвоить атрибуту всю работу, связанную с каждым вызовом функции.</span><span class="sxs-lookup"><span data-stu-id="f01cb-152">In other words, an off-the-shelf instrumenting profiler fails to attribute all of the work associated with each function call.</span></span>

<span data-ttu-id="f01cb-153">Драйвер программного обеспечения использует сведения о видеоадаптере для преобразования аппаратно-независимых команд в последовательность команд видеоадаптера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-153">The software driver uses hardware specific knowledge about the video card to convert the device-independent commands into a sequence of video card commands.</span></span> <span data-ttu-id="f01cb-154">Драйверы также могут оптимизировать последовательность команд, отправляемых на видеоадаптер, чтобы визуализация на видеоадаптере была выполнена эффективно.</span><span class="sxs-lookup"><span data-stu-id="f01cb-154">Drivers may also optimize the sequence of commands that are sent to the video card, so that rendering on the video card is done efficiently.</span></span> <span data-ttu-id="f01cb-155">Эти оптимизации могут вызвать проблемы с профилированием, так как объем выполненной работы не так, как кажется (вам, возможно, потребуется разобраться с оптимизацией для их учета).</span><span class="sxs-lookup"><span data-stu-id="f01cb-155">These optimizations can cause profiling problems because the amount of work done is not what it appears to be (you may need to understand the optimizations to account for them).</span></span> <span data-ttu-id="f01cb-156">Драйвер, как правило, возвращает управление среде выполнения до того, как видеоадаптер завершит обработку всех команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-156">The driver typically returns control to the runtime before the video card has finished processing all the commands.</span></span>

<span data-ttu-id="f01cb-157">Видеоадаптер выполняет большую часть отрисовки, объединяя данные из буферов вершин и индексов, текстур, сведения о состоянии отрисовки и команды графики.</span><span class="sxs-lookup"><span data-stu-id="f01cb-157">The video card performs the majority of the rendering by combining data from the vertex and index buffers, textures, render state information, and the graphics commands.</span></span> <span data-ttu-id="f01cb-158">После завершения подготовки к просмотру видеоадаптера работа, созданная из последовательности отрисовки, завершена.</span><span class="sxs-lookup"><span data-stu-id="f01cb-158">When the video card finishes rendering, the work created from the render sequence is complete.</span></span>

<span data-ttu-id="f01cb-159">Каждый вызов API Direct3D должен обрабатываться каждым компонентом (средой выполнения, драйвером и видеоадаптером) для отрисовки любых данных.</span><span class="sxs-lookup"><span data-stu-id="f01cb-159">Each Direct3D API call must be processed by each component (the runtime, the driver, and the video card) to render anything.</span></span>

### <a name="there-is-more-than-one-processor-controlling-the-components"></a><span data-ttu-id="f01cb-160">Существует несколько процессоров, управляющих компонентами</span><span class="sxs-lookup"><span data-stu-id="f01cb-160">There Is More than One Processor Controlling the Components</span></span>

<span data-ttu-id="f01cb-161">Связь между этими компонентами еще более сложна, так как приложение, среда выполнения и драйвер управляются одним процессором, а видеоадаптер управляется отдельным процессором.</span><span class="sxs-lookup"><span data-stu-id="f01cb-161">The relationship between these components is even more complex, because the application, runtime, and the driver are controlled by one processor and the video card is controlled by a separate processor.</span></span> <span data-ttu-id="f01cb-162">На следующей схеме показаны два типа процессоров: Центральный вычислительный блок (ЦП) и графический процессор (GPU).</span><span class="sxs-lookup"><span data-stu-id="f01cb-162">The following diagram shows two kinds of processors: a central processing unit (CPU) and a graphics processing unit (GPU).</span></span>

![Схема ЦП и GPU и их компонентов](images/microbenchmarkprocessors.png)

<span data-ttu-id="f01cb-164">Системы PC Systems имеют по крайней мере один ЦП и один GPU, но могут иметь несколько из них или оба.</span><span class="sxs-lookup"><span data-stu-id="f01cb-164">PC systems have at least one CPU and one GPU, but can have more than one of either or both.</span></span> <span data-ttu-id="f01cb-165">Процессоры находятся на материнской плате, а графические процессоры расположены на материнской плате или на видеоадаптере.</span><span class="sxs-lookup"><span data-stu-id="f01cb-165">The CPUs are located on the motherboard, and the GPUs are located either on the motherboard or on the video card.</span></span> <span data-ttu-id="f01cb-166">Скорость ЦП определяется микросхемой часов на материнской плате, а скорость GPU определяется отдельной микросхемой.</span><span class="sxs-lookup"><span data-stu-id="f01cb-166">The speed of the CPU is determined by a clock chip on the motherboard, and the speed of the GPU is determined by a separate clock chip.</span></span> <span data-ttu-id="f01cb-167">Часы ЦП определяют скорость работы, выполняемую приложением, средой выполнения и драйвером.</span><span class="sxs-lookup"><span data-stu-id="f01cb-167">The CPU clock controls the speed of the work done by the application, the runtime, and the driver.</span></span> <span data-ttu-id="f01cb-168">Приложение отправляет работу на графический процессор через среду выполнения и драйвер.</span><span class="sxs-lookup"><span data-stu-id="f01cb-168">The application sends work to the GPU via the runtime and the driver.</span></span>

<span data-ttu-id="f01cb-169">ЦП и GPU обычно работают с разными скоростями, не зависящими друг от друга.</span><span class="sxs-lookup"><span data-stu-id="f01cb-169">The CPU and the GPU generally run at different speeds, independent of one another.</span></span> <span data-ttu-id="f01cb-170">GPU может реагировать на работу, как только будет доступна работа (предполагая, что GPU завершил обработку предыдущей работы).</span><span class="sxs-lookup"><span data-stu-id="f01cb-170">The GPU may respond to the work as soon as the work is available (assuming the GPU has finished processing previous work).</span></span> <span data-ttu-id="f01cb-171">Работа GPU выполняется параллельно с работой ЦП, выделенной изогнутой линией на рисунке выше.</span><span class="sxs-lookup"><span data-stu-id="f01cb-171">The GPU work is done in parallel with the CPU work as highlighted by the curved line in the figure above.</span></span> <span data-ttu-id="f01cb-172">Профилировщик обычно измеряет производительность ЦП, а не GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-172">A profiler generally measures the performance of the CPU, not the GPU.</span></span> <span data-ttu-id="f01cb-173">Это усложняет профилирование, поскольку измерения, выполняемые инструментированием профилировщика, включают время ЦП, но могут не включать время GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-173">This makes profiling challenging, because the measurements made by an instrumenting profiler include the CPU time but may not include the GPU time.</span></span>

<span data-ttu-id="f01cb-174">Назначение графического процессора заключается в том, чтобы отключать обработку от ЦП к процессору, специально разработанному для работы графики.</span><span class="sxs-lookup"><span data-stu-id="f01cb-174">The purpose of the GPU is to off-load processing from the CPU to a processor specifically designed for graphics work.</span></span> <span data-ttu-id="f01cb-175">На современных видеоадаптерах графический процессор заменяет большую часть работы по преобразованию и освещению в конвейере от ЦП до GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-175">On modern video cards, the GPU replaces much of the transform and lighting work in the pipeline from the CPU to the GPU.</span></span> <span data-ttu-id="f01cb-176">Это значительно сокращает нагрузку на ЦП, освобождая больше циклов ЦП для другой обработки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-176">This greatly reduces the CPU workload, leaving more CPU cycles available for other processing.</span></span> <span data-ttu-id="f01cb-177">Чтобы настроить графическое приложение для пиковой производительности, необходимо измерять производительность ЦП и GPU, а также распределять работу между двумя типами процессоров.</span><span class="sxs-lookup"><span data-stu-id="f01cb-177">To tune a graphical application for peak performance, you need to measure the performance of both the CPU and the GPU, and balance the work between the two types of processors.</span></span>

<span data-ttu-id="f01cb-178">В этом документе не рассматриваются темы, связанные с измерением производительности GPU или балансировкой работы между ЦП и GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-178">This document does not cover topics related to measuring the performance of the GPU or balancing the work between the CPU and the GPU.</span></span> <span data-ttu-id="f01cb-179">Если вы хотите лучше понять производительность GPU (или определенного видеоадаптера), посетите веб-сайт поставщика, чтобы найти дополнительные сведения о производительности GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-179">If you want to better understand the performance of a GPU (or a particular video card), visit the vendor's web site to look for more information about GPU performance.</span></span> <span data-ttu-id="f01cb-180">Вместо этого этот документ посвящен работе, выполняемой средой выполнения и драйвером, уменьшая объем работы GPU до незначительного объема.</span><span class="sxs-lookup"><span data-stu-id="f01cb-180">Instead, this document focuses on the work done by the runtime and the driver by reducing the GPU work to a negligible amount.</span></span> <span data-ttu-id="f01cb-181">Это, в части, основано на том, что приложения, на которых возникают проблемы с производительностью, обычно ограничены ЦП.</span><span class="sxs-lookup"><span data-stu-id="f01cb-181">This is, in part, based on experience that applications experiencing performance problems are generally CPU-limited.</span></span>

### <a name="runtime-and-driver-optimizations-can-mask-api-measurements"></a><span data-ttu-id="f01cb-182">Оптимизация среды выполнения и драйвера может маскировать измерения API</span><span class="sxs-lookup"><span data-stu-id="f01cb-182">Runtime and Driver Optimizations Can Mask API Measurements</span></span>

<span data-ttu-id="f01cb-183">В среде выполнения встроена оптимизация производительности, которая может привести к переполнению измерения отдельного вызова.</span><span class="sxs-lookup"><span data-stu-id="f01cb-183">The runtime has a performance optimization built into it that can overwhelm the measurement of an individual call.</span></span> <span data-ttu-id="f01cb-184">Ниже приведен пример сценария, демонстрирующий эту проблему.</span><span class="sxs-lookup"><span data-stu-id="f01cb-184">Here's an example scenario that demonstrates this problem.</span></span> <span data-ttu-id="f01cb-185">Рассмотрим следующую последовательность визуализации:</span><span class="sxs-lookup"><span data-stu-id="f01cb-185">Consider the following render sequence:</span></span>


```
  BeginScene();
    ...
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
    ...
  EndScene();
  Present();
```



<span data-ttu-id="f01cb-186">Пример 1. простая последовательность отображения</span><span class="sxs-lookup"><span data-stu-id="f01cb-186">Example 1: Simple Render Sequence</span></span>

<span data-ttu-id="f01cb-187">Просмотрев результаты двух вызовов в последовательности отрисовки, инструментированный профилировщик может вернуть результаты, аналогичные приведенным ниже.</span><span class="sxs-lookup"><span data-stu-id="f01cb-187">Looking at the results for the two calls in the render sequence, an instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture       : 100
Number of cycles for DrawPrimitive    : 950,500
```



<span data-ttu-id="f01cb-188">Профилировщик возвращает количество циклов ЦП, необходимых для обработки работы, связанной с каждым вызовом (Помните, что графический процессор не включен в эти числа, так как GPU еще не начал работать над этими командами).</span><span class="sxs-lookup"><span data-stu-id="f01cb-188">The profiler returns the number of CPU cycles required to process the work associated with each call (remember that the GPU isn't included in these numbers because the GPU hasn't started working on these commands yet).</span></span> <span data-ttu-id="f01cb-189">Поскольку [**IDirect3DDevice9::D равпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) требуется почти миллион циклов для обработки, можно заключить, что он не очень эффективен.</span><span class="sxs-lookup"><span data-stu-id="f01cb-189">Because [**IDirect3DDevice9::DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) required almost a million cycles to process, you could conclude that it is not very efficient.</span></span> <span data-ttu-id="f01cb-190">Тем не менее вы вскоре узнаете, почему это заключение неверно и как можно создать результаты, которые можно использовать для бюджетирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-190">However, you'll soon see why this conclusion is incorrect and how you can generate results that can be used for budgeting.</span></span>

### <a name="measuring-state-changes-requires-careful-render-sequences"></a><span data-ttu-id="f01cb-191">Измерение изменений состояния требует тщательного отображения последовательностей</span><span class="sxs-lookup"><span data-stu-id="f01cb-191">Measuring State Changes Requires Careful Render Sequences</span></span>

<span data-ttu-id="f01cb-192">Все вызовы, кроме [**IDirect3DDevice9::D равпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**дравиндекседпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive)или [**clear**](/windows/desktop/api) (например, [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**сетвертексдекларатион**](/windows/desktop/api)и [**сетрендерстате**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) создают изменение состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-192">All calls other than [**IDirect3DDevice9::DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), or [**Clear**](/windows/desktop/api) (such as [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**SetVertexDeclaration**](/windows/desktop/api), and [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) produce a state change.</span></span> <span data-ttu-id="f01cb-193">Каждое изменение состояния задает состояние конвейера, которое определяет, как будет выполняться подготовка к просмотру.</span><span class="sxs-lookup"><span data-stu-id="f01cb-193">Each state change sets pipeline state that controls how rendering will be done.</span></span>

<span data-ttu-id="f01cb-194">Оптимизации в среде выполнения и (или) драйвере предназначены для ускорения подготовки к просмотру путем уменьшения объема требуемой работы.</span><span class="sxs-lookup"><span data-stu-id="f01cb-194">Optimizations in the runtime and/or the driver are designed to speed up rendering by reducing the amount of work required.</span></span> <span data-ttu-id="f01cb-195">Ниже приведены две оптимизации изменения состояния, которые могут засоряла средние значения профиля:</span><span class="sxs-lookup"><span data-stu-id="f01cb-195">The following are a couple of state change optimizations that may pollute profile averages:</span></span>

-   <span data-ttu-id="f01cb-196">Драйвер (или среда выполнения) может сохранить изменение состояния в локальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="f01cb-196">A driver (or the runtime) could save a state change as a local state.</span></span> <span data-ttu-id="f01cb-197">Так как драйвер может работать в "ленивом" алгоритме (откладывать работу до абсолютной необходимости), работа, связанная с некоторыми изменениями состояния, может быть отложена.</span><span class="sxs-lookup"><span data-stu-id="f01cb-197">Because the driver could operate in a "lazy" algorithm (postponing work until it is absolutely necessary), work associated with some state changes could get delayed.</span></span>
-   <span data-ttu-id="f01cb-198">Среда выполнения (или драйвер) может удалять изменения состояния путем оптимизации.</span><span class="sxs-lookup"><span data-stu-id="f01cb-198">The runtime (or a driver) may remove state changes by optimizing.</span></span> <span data-ttu-id="f01cb-199">Примером этого может быть удаление избыточного изменения состояния, которое отключает освещение, так как освещение ранее было отключено.</span><span class="sxs-lookup"><span data-stu-id="f01cb-199">An example of this might be to remove a redundant state change that disables lighting because lighting has previously been disabled.</span></span>

<span data-ttu-id="f01cb-200">Нет никаких бесполезностей для просмотра последовательности отрисовки и выполнения изменений состояния, которые будут задавать «грязный» бит и откладывать работу, или просто будут удалены при оптимизации.</span><span class="sxs-lookup"><span data-stu-id="f01cb-200">There is no foolproof way to look at a render sequence and conclude which state changes will set a dirty bit and defer work, or will simply be removed by optimization.</span></span> <span data-ttu-id="f01cb-201">Даже если вы могли бы определять оптимизированные изменения состояния в сегодняшней среде выполнения или драйвере, то, скорее всего, будет обновляться среда выполнения завтрашнего дня или драйвер.</span><span class="sxs-lookup"><span data-stu-id="f01cb-201">Even if you could identify optimized state changes in today's runtime or driver, tomorrow's runtime or driver is likely to be updated.</span></span> <span data-ttu-id="f01cb-202">Вы также не знакомы с предыдущим состоянием, поэтому трудно определить избыточные изменения состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-202">You also don't readily know what the previous state was so it is difficult to identify redundant state changes.</span></span> <span data-ttu-id="f01cb-203">Единственным способом проверки затрат на изменение состояния является измерение последовательности отрисовки, включающей изменения состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-203">The only way to verify the cost of a state change is to measure the render sequence that includes the state changes.</span></span>

<span data-ttu-id="f01cb-204">Как видите, сложность, вызванная наличием нескольких процессоров, команд, обрабатываемых более чем одним компонентом, и оптимизации, встроенные в компоненты, затрудняют прогнозирование.</span><span class="sxs-lookup"><span data-stu-id="f01cb-204">As you can see, the complications caused by having multiple processors, commands being processed by more than one component, and optimizations built into the components make profiling difficult to predict.</span></span> <span data-ttu-id="f01cb-205">В следующем разделе будут рассмотрены все проблемы, связанные с профилированием.</span><span class="sxs-lookup"><span data-stu-id="f01cb-205">In the next section, each of these profiling challenges will be addressed.</span></span> <span data-ttu-id="f01cb-206">Примеры последовательностей визуализации Direct3D будут показаны с использованием сопутствующих методик измерения.</span><span class="sxs-lookup"><span data-stu-id="f01cb-206">Sample Direct3D render sequences will be shown, with the accompanying measurement techniques.</span></span> <span data-ttu-id="f01cb-207">С помощью этих знаний вы сможете создавать точные и повторяемые измерения для отдельных вызовов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-207">With this knowledge, you will be able to generate accurate, repeatable measurements on individual calls.</span></span>

## <a name="how-to-accurately-profile-a-direct3d-render-sequence"></a><span data-ttu-id="f01cb-208">Как точно пропрофилировать последовательность визуализации Direct3D</span><span class="sxs-lookup"><span data-stu-id="f01cb-208">How to Accurately Profile a Direct3D Render Sequence</span></span>

<span data-ttu-id="f01cb-209">Теперь, когда некоторые проблемы профилирования были выделены, в этом разделе будут показаны методы, которые помогут создать измерения профиля, которые можно использовать для бюджетирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-209">Now that some of the profiling challenges have been highlighted, this section will show you techniques that will help you generate profile measurements that can be used for budgeting.</span></span> <span data-ttu-id="f01cb-210">Точные, повторяемые измерения профилирования возможны, если вы понимаете связь между компонентами, управляемыми ЦП, и как избежать оптимизации производительности, реализованной средой выполнения и драйвером.</span><span class="sxs-lookup"><span data-stu-id="f01cb-210">Accurate, repeatable profiling measurements are possible if you understand the relationship between the components controlled by the CPU, and how to avoid performance optimizations implemented by the runtime and the driver.</span></span>

<span data-ttu-id="f01cb-211">Для начала необходимо точно измерять время выполнения одного вызова API.</span><span class="sxs-lookup"><span data-stu-id="f01cb-211">To begin, you need to be able to accurately measure the execution time of a single API call.</span></span>

### <a name="pick-an-accurate-measurement-tool-like-queryperformancecounter"></a><span data-ttu-id="f01cb-212">Выберите точный инструмент измерения, например QueryPerformanceCounter</span><span class="sxs-lookup"><span data-stu-id="f01cb-212">Pick an Accurate Measurement Tool Like QueryPerformanceCounter</span></span>

<span data-ttu-id="f01cb-213">Операционная система Microsoft Windows включает в себя таймер высокого разрешения, который можно использовать для измерения времени, затраченного на высокое разрешение.</span><span class="sxs-lookup"><span data-stu-id="f01cb-213">The Microsoft Windows operating system includes a high-resolution timer that can be used to measure high-resolution elapsed times.</span></span> <span data-ttu-id="f01cb-214">Текущее значение одного такого таймера можно вернуть с помощью [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter).</span><span class="sxs-lookup"><span data-stu-id="f01cb-214">The current value of one such timer can be returned using [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter).</span></span> <span data-ttu-id="f01cb-215">После вызова **QueryPerformanceCounter** для возврата начальных и системных значений разница между двумя значениями может быть преобразована в фактическое затраченное время (в секундах) с помощью **QueryPerformanceCounter**.</span><span class="sxs-lookup"><span data-stu-id="f01cb-215">After invoking **QueryPerformanceCounter** to return start and stop values, the difference between the two values can be converted to the actual elapsed time (in seconds) using **QueryPerformanceCounter**.</span></span>

<span data-ttu-id="f01cb-216">Преимущества использования [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) в том, что они доступны в Windows и просты в использовании.</span><span class="sxs-lookup"><span data-stu-id="f01cb-216">The advantages of using [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) are that it is available in Windows and it is easy to use.</span></span> <span data-ttu-id="f01cb-217">Просто заключите вызовы в вызов **QueryPerformanceCounter** и сохраните значения Start и останавливают.</span><span class="sxs-lookup"><span data-stu-id="f01cb-217">Simply surround the calls with a **QueryPerformanceCounter** call and save the start and stop values.</span></span> <span data-ttu-id="f01cb-218">Поэтому в этом документе показано, как использовать **QueryPerformanceCounter** для профилирования времени выполнения, аналогично тому, как средство профилирования профилировщика будет его измерять.</span><span class="sxs-lookup"><span data-stu-id="f01cb-218">Therefore, this paper will demonstrate how to use **QueryPerformanceCounter** to profile execution times, similar to the way an instrumenting profiler would measure it.</span></span> <span data-ttu-id="f01cb-219">Ниже приведен пример, демонстрирующий внедрение **QueryPerformanceCounter** в исходный код:</span><span class="sxs-lookup"><span data-stu-id="f01cb-219">Here's an example that shows how to embed **QueryPerformanceCounter** in your source code:</span></span>


```
  BeginScene();
    ...
    // Start profiling
    LARGE_INTEGER start, stop, freq;
    QueryPerformanceCounter(&start);

    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1); 

    QueryPerformanceCounter(&stop);
    stop.QuadPart -= start.QuadPart;
    QueryPerformanceFrequency(&freq);
    // Stop profiling
    ...
  EndScene();
  Present();
```



<span data-ttu-id="f01cb-220">Пример 2. Реализация пользовательского профилирования с помощью QPC</span><span class="sxs-lookup"><span data-stu-id="f01cb-220">Example 2: Custom Profiling Implementation with QPC</span></span>

<span data-ttu-id="f01cb-221">Запуск и завершение — это два больших целых числа, которые будут содержать значения Start и остановки, возвращаемые высокопроизводительным таймером.</span><span class="sxs-lookup"><span data-stu-id="f01cb-221">start and stop are two large integers that will hold the start and stop values returned by the high-performance timer.</span></span> <span data-ttu-id="f01cb-222">Обратите внимание, что QueryPerformanceCounter (&Start) вызывается непосредственно перед [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и QueryPerformanceCounter (&остановкой) вызывается сразу после [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="f01cb-222">Notice that QueryPerformanceCounter(&start) is called just before [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and QueryPerformanceCounter(&stop) is called just after [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="f01cb-223">После получения значения для параметра Куериперформанцефрекуенци вызывается метод, возвращающий freq, который является частотой таймера с высоким разрешением.</span><span class="sxs-lookup"><span data-stu-id="f01cb-223">After getting the stop value, QueryPerformanceFrequency is called to return freq, which is the frequency of the high-resolution timer.</span></span> <span data-ttu-id="f01cb-224">В этом гипотетическом примере предположим, что вы получаете следующие результаты для Start, останавливаюте и FREQ:</span><span class="sxs-lookup"><span data-stu-id="f01cb-224">In this hypothetical example, suppose you get the following results for start, stop, and freq:</span></span>



| <span data-ttu-id="f01cb-225">Локальная переменная</span><span class="sxs-lookup"><span data-stu-id="f01cb-225">Local Variable</span></span> | <span data-ttu-id="f01cb-226">Число тактов</span><span class="sxs-lookup"><span data-stu-id="f01cb-226">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="f01cb-227">start</span><span class="sxs-lookup"><span data-stu-id="f01cb-227">start</span></span>          | <span data-ttu-id="f01cb-228">1792998845094</span><span class="sxs-lookup"><span data-stu-id="f01cb-228">1792998845094</span></span>   |
| <span data-ttu-id="f01cb-229">stop</span><span class="sxs-lookup"><span data-stu-id="f01cb-229">stop</span></span>           | <span data-ttu-id="f01cb-230">1792998845102</span><span class="sxs-lookup"><span data-stu-id="f01cb-230">1792998845102</span></span>   |
| <span data-ttu-id="f01cb-231">FREQ</span><span class="sxs-lookup"><span data-stu-id="f01cb-231">freq</span></span>           | <span data-ttu-id="f01cb-232">3579545</span><span class="sxs-lookup"><span data-stu-id="f01cb-232">3579545</span></span>         |



 

<span data-ttu-id="f01cb-233">Эти значения можно преобразовать в число циклов, требуемых для выполнения вызовов API следующим образом:</span><span class="sxs-lookup"><span data-stu-id="f01cb-233">You could convert these values to the number of cycles it takes to execute the API calls like this:</span></span>


```
# ticks = (stop - start) = 1792998845102 - 1792998845094 = 8 ticks

# cycles = CPU speed * number of ticks / QPF
# 4568   = 2 GHz      * 8              / 3,579,545
```



<span data-ttu-id="f01cb-234">Иными словами, для обработки [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) на этом компьютере с тактовой частотой 2 ГГц требуется около 4568 тактов процессора.</span><span class="sxs-lookup"><span data-stu-id="f01cb-234">In other words, it takes about 4568 clock cycles to process [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) on this 2 GHz machine.</span></span> <span data-ttu-id="f01cb-235">Эти значения можно преобразовать в фактическое время, затраченное на выполнение всех вызовов, таких как:</span><span class="sxs-lookup"><span data-stu-id="f01cb-235">You could convert these values to the actual time it took to execute all the calls like this:</span></span>


```
(stop - start)/ freq = elapsed time
8 ticks / 3,579,545 = 2.2E-6 seconds or between 2 and 3 microseconds.
```



<span data-ttu-id="f01cb-236">Для использования QueryPerformanceCounter необходимо добавить в последовательность отображения начальные и останавливаемые измерения и использовать Куериперформанцефрекуенци для преобразования разницы (количества тактов) в число циклов ЦП или в фактическое время.</span><span class="sxs-lookup"><span data-stu-id="f01cb-236">Using QueryPerformanceCounter requires that you add start and stop measurements to your render sequence and use QueryPerformanceFrequency to convert the difference (number of ticks) to the number of CPU cycles or to actual time.</span></span> <span data-ttu-id="f01cb-237">Определение метода измерения — хороший запуск для разработки пользовательской реализации профилирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-237">Identifying the measurement technique is a good start for developing a custom profiling implementation.</span></span> <span data-ttu-id="f01cb-238">Но прежде чем начать делать измерения, необходимо знать, как работать с видеоадаптером.</span><span class="sxs-lookup"><span data-stu-id="f01cb-238">But before you jump in and start making measurements, you need to know how to deal with the video card.</span></span>

### <a name="focus-on-cpu-measurements"></a><span data-ttu-id="f01cb-239">Сосредоточьтесь на измерениях ЦП</span><span class="sxs-lookup"><span data-stu-id="f01cb-239">Focus on CPU Measurements</span></span>

<span data-ttu-id="f01cb-240">Как упоминалось ранее, ЦП и GPU работают параллельно для обработки работы, создаваемой вызовами API.</span><span class="sxs-lookup"><span data-stu-id="f01cb-240">As stated earlier, the CPU and the GPU work in parallel to process the work generated by the API calls.</span></span> <span data-ttu-id="f01cb-241">Реальное приложение требует профилирования обоих типов процессоров, чтобы определить, ограничено ли приложение процессором или GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-241">A real world application requires profiling both types of processors to find out if your application is CPU-limited or GPU-limited.</span></span> <span data-ttu-id="f01cb-242">Так как производительность GPU зависит от поставщика, в этом документе будет очень сложно выдать результаты, охватывающие множество доступных видеоадаптеров.</span><span class="sxs-lookup"><span data-stu-id="f01cb-242">Since GPU performance is vendor specific, it would be very challenging to produce results in this paper that cover the variety of video cards available.</span></span>

<span data-ttu-id="f01cb-243">Вместо этого в этом документе основное внимание уделяется профилированию работы, выполняемой ЦП, с помощью пользовательского метода измерения работы среды выполнения и драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-243">Instead, this paper will focus only on profiling the work performed by the CPU by using a custom technique for measuring the runtime and driver work.</span></span> <span data-ttu-id="f01cb-244">Работа GPU будет снижена до незначительного размера, чтобы результаты ЦП были более видны.</span><span class="sxs-lookup"><span data-stu-id="f01cb-244">The GPU work will be reduced to an insignificant amount, so that CPU results are more visible.</span></span> <span data-ttu-id="f01cb-245">Одним из преимуществ такого подхода является то, что этот метод дает результаты в приложении, которое можно сопоставить с вашими измерениями.</span><span class="sxs-lookup"><span data-stu-id="f01cb-245">One benefit of this approach is that this technique yields results in the Appendix that you should be able to correlate with your measurements.</span></span> <span data-ttu-id="f01cb-246">Чтобы сократить объем работ, требуемый для видеоадаптера, на незначительный уровень, просто Сократите работу по отрисовке до минимально возможной суммы.</span><span class="sxs-lookup"><span data-stu-id="f01cb-246">To reduce the work required by the video card to an insignificant level, simply reduce the rendering work to the least amount possible.</span></span> <span data-ttu-id="f01cb-247">Это можно сделать, ограничивая вызовы рисования для отрисовки одного треугольника, и можно дополнительно ограничить, чтобы каждый треугольник содержал только один пиксель.</span><span class="sxs-lookup"><span data-stu-id="f01cb-247">This can be accomplished by limiting draw calls to render a single triangle, and can be further constrained so that each triangle only contains one pixel.</span></span>

<span data-ttu-id="f01cb-248">Единица измерения, используемая в этом документе для измерения объема работы ЦП, зависит от количества тактов процессора, а не от фактического времени.</span><span class="sxs-lookup"><span data-stu-id="f01cb-248">The unit of measure used in this paper for measuring CPU work will be the number of CPU clock cycles rather than actual time.</span></span> <span data-ttu-id="f01cb-249">Циклы тактовой частоты ЦП имеют преимущество для более переносимых (для приложений с ограниченным доступом к ЦП), чем прошедшее время на компьютерах с разными скоростями ЦП.</span><span class="sxs-lookup"><span data-stu-id="f01cb-249">CPU clock cycles has the advantage that it is more portable (for CPU-limited applications) than actual elapsed time across machines with different CPU speeds.</span></span> <span data-ttu-id="f01cb-250">При необходимости это можно легко преобразовать в реальное время.</span><span class="sxs-lookup"><span data-stu-id="f01cb-250">This can easily be converted to actual time if desired.</span></span>

<span data-ttu-id="f01cb-251">В этом документе не рассматриваются темы, связанные с балансировкой рабочей нагрузки между ЦП и GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-251">This document does not cover topics related to balancing the work load between the CPU and the GPU.</span></span> <span data-ttu-id="f01cb-252">Помните, что цель этого документа — не измерять общую производительность приложения, но чтобы продемонстрировать, как точно измерять время, затрачиваемое средой выполнения и драйвером для обработки вызовов API.</span><span class="sxs-lookup"><span data-stu-id="f01cb-252">Remember, the goal of this paper is not to measure the overall performance of an application, but to show you how to accurately measure the time it takes the runtime and the driver to process API calls.</span></span> <span data-ttu-id="f01cb-253">С помощью этих точных измерений можно выполнять задачи по бюджетированию ЦП, чтобы понять определенные сценарии производительности.</span><span class="sxs-lookup"><span data-stu-id="f01cb-253">With these accurate measurements, you can take on the task of budgeting the CPU to understand certain performance scenarios.</span></span>

### <a name="controlling-runtime-and-driver-optimizations"></a><span data-ttu-id="f01cb-254">Управление оптимизацией среды выполнения и драйверов</span><span class="sxs-lookup"><span data-stu-id="f01cb-254">Controlling Runtime and Driver Optimizations</span></span>

<span data-ttu-id="f01cb-255">При обнаружении методики измерения и стратегии сокращения работы GPU необходимо понимать, какие оптимизации среда выполнения и драйвер получаются при профилировании.</span><span class="sxs-lookup"><span data-stu-id="f01cb-255">With a measurement technique identified, and a strategy for reducing GPU work, the next step is to understand the runtime and driver optimizations that get in the way when you are profiling.</span></span>

<span data-ttu-id="f01cb-256">Работу ЦП можно разделить на три сегмента: приложение работает, работа среды выполнения и драйвер работает.</span><span class="sxs-lookup"><span data-stu-id="f01cb-256">The CPU work can be divided into three buckets: the application work, the runtime work, and the driver work.</span></span> <span data-ttu-id="f01cb-257">Проигнорируйте работу приложения, так как она находится под контролем программиста.</span><span class="sxs-lookup"><span data-stu-id="f01cb-257">Ignore the application work since this is under programmer control.</span></span> <span data-ttu-id="f01cb-258">С точки зрения приложения среда выполнения и драйвер подобны черным прямоугольникам, так как приложение не контролирует то, что реализовано в них.</span><span class="sxs-lookup"><span data-stu-id="f01cb-258">From the application's standpoint, the runtime and the driver are like black boxes, as the application has no control over what is implemented in them.</span></span> <span data-ttu-id="f01cb-259">Ключом является понимание методов оптимизации, которые могут быть реализованы в среде выполнения и драйвере.</span><span class="sxs-lookup"><span data-stu-id="f01cb-259">The key is to understand the optimization techniques that may be implemented in the runtime and the driver.</span></span> <span data-ttu-id="f01cb-260">Если вы не понимаете эти оптимизации, очень просто перейти к неправильному завершению работы ЦП на основе измерений профиля.</span><span class="sxs-lookup"><span data-stu-id="f01cb-260">If you don't understand these optimizations, it is very easy to jump to the wrong conclusion about the amount of work the CPU is doing based on the profile measurements.</span></span> <span data-ttu-id="f01cb-261">В частности, существует две темы, которые называются буфером команд и что можно сделать для маскировки профилирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-261">In particular, there are two topics related to something called the command buffer and what it can do to obfuscate profiling.</span></span> <span data-ttu-id="f01cb-262">К ним относятся следующие.</span><span class="sxs-lookup"><span data-stu-id="f01cb-262">These topics are:</span></span>

-   <span data-ttu-id="f01cb-263">Оптимизация среды выполнения с помощью буфера команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-263">Runtime optimization with the Command Buffer.</span></span> <span data-ttu-id="f01cb-264">Буфер команд — это оптимизация среды выполнения, которая сокращает влияние перехода режима на режимы.</span><span class="sxs-lookup"><span data-stu-id="f01cb-264">The command buffer is a runtime optimization that reduces the impact of a mode transition.</span></span> <span data-ttu-id="f01cb-265">Сведения об управлении временем перехода режима см. в разделе [Управление буфером команд](#controlling-the-command-buffer).</span><span class="sxs-lookup"><span data-stu-id="f01cb-265">To control the timing of the mode transition, see [Controlling the Command Buffer](#controlling-the-command-buffer).</span></span>
-   <span data-ttu-id="f01cb-266">Отрицание временных последствий буфера команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-266">Negating the timing effects of the Command Buffer.</span></span> <span data-ttu-id="f01cb-267">Прошедшее время перехода режима может оказать значительное влияние на измерения профилирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-267">The elapsed time of a mode transition can have a big impact on profiling measurements.</span></span> <span data-ttu-id="f01cb-268">Стратегия для этого заключается в том, чтобы [сделать последовательность отрисовки значительной по сравнению с переходом режима](#make-the-render-sequence-large-compared-to-the-mode-transition).</span><span class="sxs-lookup"><span data-stu-id="f01cb-268">The strategy for this is to [Make the Render Sequence Large Compared to the Mode Transition](#make-the-render-sequence-large-compared-to-the-mode-transition).</span></span>

### <a name="controlling-the-command-buffer"></a><span data-ttu-id="f01cb-269">Управление буфером команд</span><span class="sxs-lookup"><span data-stu-id="f01cb-269">Controlling the Command Buffer</span></span>

<span data-ttu-id="f01cb-270">Когда приложение выполняет вызов API, среда выполнения преобразует вызов API в независимый от устройства формат (который мы вызываем команду) и сохраняет его в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-270">When an application makes an API call, the runtime converts the API call to a device-independent format (which we will call a command), and stores it in the command buffer.</span></span> <span data-ttu-id="f01cb-271">Буфер команд добавляется на следующую схему.</span><span class="sxs-lookup"><span data-stu-id="f01cb-271">The command buffer is added to the following diagram.</span></span>

![Схема компонентов ЦП, включая буфер команд](images/microbenchmarkcommandbuffer2.png)

<span data-ttu-id="f01cb-273">Каждый раз, когда приложение выполняет другой вызов API, среда выполнения повторяет эту последовательность и добавляет еще одну команду в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-273">Each time the application makes another API call, the runtime repeats this sequence and adds another command to the command buffer.</span></span> <span data-ttu-id="f01cb-274">В некоторый момент времени среда выполнения очищает буфер (отправляя команды в драйвер).</span><span class="sxs-lookup"><span data-stu-id="f01cb-274">At some point, the runtime empties the buffer (sending the commands to the driver).</span></span> <span data-ttu-id="f01cb-275">В Windows XP очистка буфера команд приводит к переключению режима работы операционной системы из среды выполнения (выполняется в пользовательском режиме) на драйвер (работающий в режиме ядра), как показано на следующей схеме.</span><span class="sxs-lookup"><span data-stu-id="f01cb-275">In Windows XP, emptying the command buffer causes a mode transition as the operating system switches from the runtime (running in user mode) to the driver (running in kernel mode), as shown in the following diagram.</span></span>

-   <span data-ttu-id="f01cb-276">Пользовательский режим — непривилегированный процессорный режим, который выполняет код приложения.</span><span class="sxs-lookup"><span data-stu-id="f01cb-276">user mode - The non-privileged processor mode that executes application code.</span></span> <span data-ttu-id="f01cb-277">Приложения пользовательского режима не могут получить доступ к системным данным, за исключением системных служб.</span><span class="sxs-lookup"><span data-stu-id="f01cb-277">User-mode applications cannot gain access to system data except through system services.</span></span>
-   <span data-ttu-id="f01cb-278">режим ядра — привилегированный процессорный режим, в котором выполняется код для руководителей под управлением Windows.</span><span class="sxs-lookup"><span data-stu-id="f01cb-278">kernel mode - The privileged processor mode in which Windows-based executive code runs.</span></span> <span data-ttu-id="f01cb-279">Драйвер или поток, работающий в режиме ядра, имеет доступ ко всей системной памяти, прямой доступ к оборудованию и инструкциям ЦП для выполнения операций ввода-вывода с оборудованием.</span><span class="sxs-lookup"><span data-stu-id="f01cb-279">A driver or thread running in kernel mode has access to all system memory, direct access to hardware, and the CPU instructions to perform I/O with the hardware.</span></span>

![схема переходов между пользовательским режимом и режимом ядра](images/microbenchmarkcommandbuffer3.png)

<span data-ttu-id="f01cb-281">Переход происходит каждый раз, когда ЦП переключается от пользователя в режим ядра (и наоборот), а необходимое количество циклов — по сравнению с отдельным вызовом API.</span><span class="sxs-lookup"><span data-stu-id="f01cb-281">The transition happens each time the CPU switches from user to kernel mode (and vice versa) and the number of cycles it requires is large compared to an individual API call.</span></span> <span data-ttu-id="f01cb-282">Если среда выполнения отправила каждый вызов API к драйверу при его вызове, каждый вызов API получит стоимость перехода в режим.</span><span class="sxs-lookup"><span data-stu-id="f01cb-282">If the runtime sent each API call to the driver when it was invoked, every API call would incur the cost of a mode transition.</span></span>

<span data-ttu-id="f01cb-283">Вместо этого буфер команд представляет собой оптимизацию среды выполнения, предназначенную для уменьшения эффективных затрат на переход в режим.</span><span class="sxs-lookup"><span data-stu-id="f01cb-283">Instead, the command buffer is a runtime optimization designed to reduce the effective cost of the mode transition.</span></span> <span data-ttu-id="f01cb-284">Буфер команд помещает в очередь множество команд драйвера при подготовке к переходу в одном режиме.</span><span class="sxs-lookup"><span data-stu-id="f01cb-284">The command buffer queues many driver commands in preparation for a single mode transition.</span></span> <span data-ttu-id="f01cb-285">Когда среда выполнения добавляет команду в буфер команд, управление возвращается в приложение.</span><span class="sxs-lookup"><span data-stu-id="f01cb-285">When the runtime adds a command to the command buffer, control is returned to the application.</span></span> <span data-ttu-id="f01cb-286">Профилировщик не может знать, что команды драйвера, вероятно, еще не были отправлены в драйвер.</span><span class="sxs-lookup"><span data-stu-id="f01cb-286">A profiler has no way of knowing that the driver commands have probably not even been sent to the driver yet.</span></span> <span data-ttu-id="f01cb-287">В результате результаты, возвращаемые профилировщиком для инструментирования от полки, являются недопустимыми, так как они измеряют работу среды выполнения, но не связаны с работой драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-287">As a result, the numbers returned by an off-the-shelf instrumenting profiler are misleading since it measures the runtime work but not the associated driver work.</span></span>

### <a name="profile-results-without-a-mode-transition"></a><span data-ttu-id="f01cb-288">Результаты профилирования без перехода в режим</span><span class="sxs-lookup"><span data-stu-id="f01cb-288">Profile Results without a Mode Transition</span></span>

<span data-ttu-id="f01cb-289">С помощью последовательности отрисовки из примера 2 ниже приведены некоторые типичные измерения времени, иллюстрирующие величину перехода в режим режима.</span><span class="sxs-lookup"><span data-stu-id="f01cb-289">Using the render sequence from example 2, here are some typical timing measurements that illustrate the magnitude of a mode transition.</span></span> <span data-ttu-id="f01cb-290">При условии, что вызовы [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) не приводят к переходу в режим, то профилировщик с инструментированием от полки может возвращать примерно такие результаты:</span><span class="sxs-lookup"><span data-stu-id="f01cb-290">Assuming that [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) calls do not cause a mode transition, an off-the-shelf instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
```



<span data-ttu-id="f01cb-291">Каждое из этих чисел — время, затрачиваемое средой выполнения на добавление этих вызовов в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-291">Each of these numbers are the amount of time it takes for the runtime to add these calls to the command buffer.</span></span> <span data-ttu-id="f01cb-292">Поскольку переход в режим отсутствует, драйвер еще не выполнил никаких действий.</span><span class="sxs-lookup"><span data-stu-id="f01cb-292">Since there is no mode transition, the driver has not done any work yet.</span></span> <span data-ttu-id="f01cb-293">Результаты работы профилировщика являются точными, но они не измеряют всю работу, которую последовательность визуализации в конечном итоге приведет к выполнению ЦП.</span><span class="sxs-lookup"><span data-stu-id="f01cb-293">The profiler results are accurate, but they do not measure all of the work that the render sequence will eventually cause the CPU to perform.</span></span>

### <a name="profile-results-with-a-mode-transition"></a><span data-ttu-id="f01cb-294">Профилирование результатов с переходом режима</span><span class="sxs-lookup"><span data-stu-id="f01cb-294">Profile Results with a Mode Transition</span></span>

<span data-ttu-id="f01cb-295">Теперь посмотрим, что происходит в том же примере, когда происходит переход в режим.</span><span class="sxs-lookup"><span data-stu-id="f01cb-295">Now, look at what happens for the same example when a mode transition occurs.</span></span> <span data-ttu-id="f01cb-296">На этот раз предположим, что [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) приводят к переходу в режим.</span><span class="sxs-lookup"><span data-stu-id="f01cb-296">This time, assume [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) cause a mode transition.</span></span> <span data-ttu-id="f01cb-297">Опять же, профилировщик с инструментированием от полки может вернуть результаты, аналогичные приведенным ниже.</span><span class="sxs-lookup"><span data-stu-id="f01cb-297">Once again, an off-the-shelf instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture           : 98 
Number of cycles for DrawPrimitive        : 946,900
```



<span data-ttu-id="f01cb-298">Время, измеряемое для [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) , равно тому же, но значительное увеличение количества времени, затраченного на [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , связано с переходом в режим.</span><span class="sxs-lookup"><span data-stu-id="f01cb-298">The time measured for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about the same, however, the dramatic increase in the amount of time spent in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is due to the mode transition.</span></span> <span data-ttu-id="f01cb-299">Вот что происходит:</span><span class="sxs-lookup"><span data-stu-id="f01cb-299">Here's what is happening:</span></span>

1.  <span data-ttu-id="f01cb-300">Предположим, что буфер команд содержит место для одной команды перед началом последовательности отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-300">Assume the command buffer has room for one command before our render sequence starts.</span></span>
2.  <span data-ttu-id="f01cb-301">[**Сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) преобразуется в независимый от устройства формат и добавляется в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-301">[**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is converted to a device-independent format and added to the command buffer.</span></span> <span data-ttu-id="f01cb-302">В этом сценарии этот вызов заполняет буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-302">In this scenario, this call fills the command buffer.</span></span>
3.  <span data-ttu-id="f01cb-303">Среда выполнения пытается добавить [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) в буфер команд, но не может, так как заполнена.</span><span class="sxs-lookup"><span data-stu-id="f01cb-303">The runtime tries to add [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) to the command buffer but cannot, because it is full.</span></span> <span data-ttu-id="f01cb-304">Вместо этого среда выполнения очищает буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-304">Instead, the runtime empties the command buffer.</span></span> <span data-ttu-id="f01cb-305">Это приводит к переходу в режим ядра.</span><span class="sxs-lookup"><span data-stu-id="f01cb-305">This causes the kernel-mode transition.</span></span> <span data-ttu-id="f01cb-306">Предположим, что переход занимает около 5000 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-306">Assume the transition takes about 5000 cycles.</span></span> <span data-ttu-id="f01cb-307">На этот раз тратится время, потраченное на **дравпримитиве**.</span><span class="sxs-lookup"><span data-stu-id="f01cb-307">This time contributes to time spent in **DrawPrimitive**.</span></span>
4.  <span data-ttu-id="f01cb-308">Затем драйвер обрабатывает работу, связанную со всеми командами, которые были очищены из буфера команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-308">The driver then processes the work associated with all the commands that were emptied from the command buffer.</span></span> <span data-ttu-id="f01cb-309">Предположим, что время драйвера для обработки команд, почти заполненных буфером команд, составляет примерно 935 000 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-309">Assume that the driver time to process the commands that nearly filled the command buffer is about 935,000 cycles.</span></span> <span data-ttu-id="f01cb-310">Предположим, что работа драйвера, связанная с [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) , составляет около 2750 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-310">Assume that the driver work associated with [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about 2750 cycles.</span></span> <span data-ttu-id="f01cb-311">На этот раз тратится время, потраченное на [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="f01cb-311">This time contributes to time spent in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span>
5.  <span data-ttu-id="f01cb-312">Когда драйвер завершает свою работу, переход пользовательского режима возвращает управление среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="f01cb-312">When the driver finishes its work, the user-mode transition returns control to the runtime.</span></span> <span data-ttu-id="f01cb-313">Буфер команд теперь пуст.</span><span class="sxs-lookup"><span data-stu-id="f01cb-313">The command buffer is now empty.</span></span> <span data-ttu-id="f01cb-314">Предположим, что переход занимает около 5000 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-314">Assume the transition takes about 5000 cycles.</span></span>
6.  <span data-ttu-id="f01cb-315">Последовательность отрисовки завершается путем преобразования [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) и ее добавления в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-315">The render sequence finishes by converting [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) and adding it to the command buffer.</span></span> <span data-ttu-id="f01cb-316">Предположим, что это займет около 900 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-316">Assume this takes about 900 cycles.</span></span> <span data-ttu-id="f01cb-317">На этот раз тратится время, потраченное на **дравпримитиве**.</span><span class="sxs-lookup"><span data-stu-id="f01cb-317">This time contributes to time spent in **DrawPrimitive**.</span></span>

<span data-ttu-id="f01cb-318">Обобщая результаты, вы увидите следующее:</span><span class="sxs-lookup"><span data-stu-id="f01cb-318">Summarizing the results, you see:</span></span>


```
DrawPrimitive = kernel-transition + driver work    + user-transition + runtime work
DrawPrimitive = 5000              + 935,000 + 2750 + 5000            + 900
DrawPrimitive = 947,950  
```



<span data-ttu-id="f01cb-319">Точно так же, как измерение для [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) без перехода в режим (900 циклов), измерение для **дравпримитиве** с переходом режима (947 950 циклов) является точным, но бесполезным в плане работы ЦП при бюджетировании.</span><span class="sxs-lookup"><span data-stu-id="f01cb-319">Just like the measurement for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) without the mode transition (900 cycles), the measurement for **DrawPrimitive** with the mode transition (947,950 cycles) is accurate but useless in terms of budgeting CPU work.</span></span> <span data-ttu-id="f01cb-320">Результат содержит правильную работу среды выполнения, драйвер работает для [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), драйвер работает для всех команд, предшествующих **сеттекстуре**, и режимов перехода в два режима.</span><span class="sxs-lookup"><span data-stu-id="f01cb-320">The result contains the correct runtime work, the driver work for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), the driver work for any commands that preceded **SetTexture**, and two mode transitions.</span></span> <span data-ttu-id="f01cb-321">Однако в измерении отсутствует работа драйвера **дравпримитиве** .</span><span class="sxs-lookup"><span data-stu-id="f01cb-321">However, the measurement is missing the **DrawPrimitive** driver work.</span></span>

<span data-ttu-id="f01cb-322">Переход режима может произойти в ответ на любой вызов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-322">A mode transition could happen in response to any call.</span></span> <span data-ttu-id="f01cb-323">Это зависит от того, что ранее было в буфере команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-323">It depends on what was previously in the command buffer.</span></span> <span data-ttu-id="f01cb-324">Необходимо управлять переходом режима, чтобы понять, какой объем работы ЦП (среда выполнения и драйвер) связан с каждым вызовом.</span><span class="sxs-lookup"><span data-stu-id="f01cb-324">You need to control the mode transition to understand how much CPU work (runtime and driver) is associated with each call.</span></span> <span data-ttu-id="f01cb-325">Для этого необходим механизм управления буфером команд и временем перехода в режим.</span><span class="sxs-lookup"><span data-stu-id="f01cb-325">To do that, you need a mechanism for controlling the command buffer and the timing of the mode transition.</span></span>

### <a name="the-query-mechanism"></a><span data-ttu-id="f01cb-326">Механизм запросов</span><span class="sxs-lookup"><span data-stu-id="f01cb-326">The Query Mechanism</span></span>

<span data-ttu-id="f01cb-327">Механизм запросов в Microsoft Direct3D 9 был разработан таким образом, чтобы среда выполнения выполняла запрос GPU для выполнения и возвращала определенные данные из GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-327">The query mechanism in Microsoft Direct3D 9 was designed to allow the runtime to query the GPU for progress and return certain data from the GPU.</span></span> <span data-ttu-id="f01cb-328">При профилировании, если работа GPU сведена к минимальным последствиям для снижения производительности, вы можете вернуть состояние из графического процессора, чтобы помочь измерять работу драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-328">While profiling, if the GPU work is minimized so that it has a negligible impact on performance, you can return status from the GPU to help measure the driver work.</span></span> <span data-ttu-id="f01cb-329">В конце концов, работа драйвера будет завершена, когда GPU просмотрел команды драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-329">After all, the driver work is complete when the GPU has seen the driver commands.</span></span> <span data-ttu-id="f01cb-330">Кроме того, механизм запросов может быть коаксед для управления двумя характеристиками буфера команд, которые важны для профилирования: когда буфер команд очищается и сколько работы находится в буфере.</span><span class="sxs-lookup"><span data-stu-id="f01cb-330">Additionally, the query mechanism can be coaxed into controlling two command buffer characteristics that are important to profiling: when the command buffer empties and how much work is in the buffer.</span></span>

<span data-ttu-id="f01cb-331">Вот та же последовательность отрисовки, использующая механизм запросов:</span><span class="sxs-lookup"><span data-stu-id="f01cb-331">Here's the same render sequence using the query mechanism:</span></span>


```
// 1. Create an event query from the current device
IDirect3DQuery9* pEvent;
m_pD3DDevice->CreateQuery(D3DQUERYTYPE_EVENT, &pEvent);

// 2. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 3. Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

// 4. Start profiling
LARGE_INTEGER start, stop;
QueryPerformanceCounter(&start);

// 5. Invoke the API calls to be profiled.
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);

// 6. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 7. Force the driver to execute the commands from the command buffer.
// Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
    
// 8. End profiling
QueryPerformanceCounter(&stop);
```



<span data-ttu-id="f01cb-332">Пример 3. Использование запроса для управления буфером команд</span><span class="sxs-lookup"><span data-stu-id="f01cb-332">Example 3: Using a Query to Control the Command Buffer</span></span>

<span data-ttu-id="f01cb-333">Ниже приведено более подробное описание каждой из этих строк кода.</span><span class="sxs-lookup"><span data-stu-id="f01cb-333">Here is a more detailed explanation of each of these lines of code:</span></span>

1.  <span data-ttu-id="f01cb-334">Создайте запрос события, создав объект запроса с \_ событием D3DQUERYTYPE.</span><span class="sxs-lookup"><span data-stu-id="f01cb-334">Create an event query by creating a query object with D3DQUERYTYPE\_EVENT.</span></span>
2.  <span data-ttu-id="f01cb-335">Добавьте маркер события запроса в буфер команд, вызвав вызываемую [**ошибку**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE \_ End**](d3dissue-end.md)).</span><span class="sxs-lookup"><span data-stu-id="f01cb-335">Add a query event marker to the command buffer by calling [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE\_END**](d3dissue-end.md)).</span></span> <span data-ttu-id="f01cb-336">Этот маркер сообщает драйверу о том, что GPU завершает выполнение команд, предшествующих маркеру.</span><span class="sxs-lookup"><span data-stu-id="f01cb-336">This marker tells the driver to track when the GPU finishes executing whatever commands preceded the marker.</span></span>
3.  <span data-ttu-id="f01cb-337">Первый вызов очищает буфер команд, так как вызов [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) с [**D3DGETDATA \_ flush**](d3dgetdata-flush.md) приводит к очистке буфера команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-337">The first call empties the command buffer because calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md) forces the command buffer to be emptied.</span></span> <span data-ttu-id="f01cb-338">Каждый последующий вызов выполняет проверку графического процессора, чтобы увидеть, когда он завершает обработку всех команд буфера работы.</span><span class="sxs-lookup"><span data-stu-id="f01cb-338">Each subsequent call is checking the GPU to see when it finishes processing all the command-buffer work.</span></span> <span data-ttu-id="f01cb-339">Этот цикл не возвращает \_ ОК, пока GPU не простаивает.</span><span class="sxs-lookup"><span data-stu-id="f01cb-339">This loop does not return S\_OK until the GPU is idle.</span></span>
4.  <span data-ttu-id="f01cb-340">Пример времени начала.</span><span class="sxs-lookup"><span data-stu-id="f01cb-340">Sample the start time.</span></span>
5.  <span data-ttu-id="f01cb-341">Вызов API, для которого выполняется профилирование.</span><span class="sxs-lookup"><span data-stu-id="f01cb-341">Invoke the API calls being profiled.</span></span>
6.  <span data-ttu-id="f01cb-342">Добавьте второй маркер события запроса в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-342">Add a second query event marker to the command buffer.</span></span> <span data-ttu-id="f01cb-343">Этот маркер будет использоваться для отслеживания завершения вызовов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-343">This marker will be used to track the completion of the calls.</span></span>
7.  <span data-ttu-id="f01cb-344">Первый вызов очищает буфер команд, так как вызов [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) с [**D3DGETDATA \_ flush**](d3dgetdata-flush.md) приводит к очистке буфера команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-344">The first call empties the command buffer because calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md) forces the command buffer to be emptied.</span></span> <span data-ttu-id="f01cb-345">Когда GPU заканчивает обработку всех команд для работы с буфером, метод **GetData** возвращает \_ ОК, а цикл завершается из-за бездействия GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-345">When the GPU finishes processing all the command-buffer work, **GetData** returns S\_OK, and the loop is exited because the GPU is idle.</span></span>
8.  <span data-ttu-id="f01cb-346">Пример времени окончания.</span><span class="sxs-lookup"><span data-stu-id="f01cb-346">Sample the stop time.</span></span>

<span data-ttu-id="f01cb-347">Ниже приведены результаты, измеряемые с помощью QueryPerformanceCounter и Куериперформанцефрекуенци:</span><span class="sxs-lookup"><span data-stu-id="f01cb-347">Here are the results measured with QueryPerformanceCounter and QueryPerformanceFrequency:</span></span>



| <span data-ttu-id="f01cb-348">Локальная переменная</span><span class="sxs-lookup"><span data-stu-id="f01cb-348">Local Variable</span></span> | <span data-ttu-id="f01cb-349">Число тактов</span><span class="sxs-lookup"><span data-stu-id="f01cb-349">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="f01cb-350">start</span><span class="sxs-lookup"><span data-stu-id="f01cb-350">start</span></span>          | <span data-ttu-id="f01cb-351">1792998845060</span><span class="sxs-lookup"><span data-stu-id="f01cb-351">1792998845060</span></span>   |
| <span data-ttu-id="f01cb-352">stop</span><span class="sxs-lookup"><span data-stu-id="f01cb-352">stop</span></span>           | <span data-ttu-id="f01cb-353">1792998845090</span><span class="sxs-lookup"><span data-stu-id="f01cb-353">1792998845090</span></span>   |
| <span data-ttu-id="f01cb-354">FREQ</span><span class="sxs-lookup"><span data-stu-id="f01cb-354">freq</span></span>           | <span data-ttu-id="f01cb-355">3579545</span><span class="sxs-lookup"><span data-stu-id="f01cb-355">3579545</span></span>         |



 

<span data-ttu-id="f01cb-356">Повторное преобразование тактов в циклы (на компьютере с тактовой частотой 2 ГГц):</span><span class="sxs-lookup"><span data-stu-id="f01cb-356">Converting ticks to cycles once again (on a 2 GHz machine):</span></span>


```
# ticks  = (stop - start) = 1792998845090 - 1792998845060 = 30 ticks
# cycles = CPU speed * number of ticks / QPF
# 16,450 = 2 GHz      * 30             / 3,579,545
```



<span data-ttu-id="f01cb-357">Ниже приведена разбивка количества циклов на один вызов:</span><span class="sxs-lookup"><span data-stu-id="f01cb-357">Here is the breakdown of the number of cycles per call:</span></span>


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
Number of cycles for Issue                : 200
Number of cycles for GetData              : 16,450
```



<span data-ttu-id="f01cb-358">Механизм запросов позволял нам управлять средой выполнения и измеряемой работой драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-358">The query mechanism has allowed us to control the runtime and the driver work that is being measured.</span></span> <span data-ttu-id="f01cb-359">Чтобы понять каждое из этих чисел, выполните следующие действия в ответ на каждый из вызовов API, а также предполагаемое время:</span><span class="sxs-lookup"><span data-stu-id="f01cb-359">To understand each of these numbers, here's what is happening in response to each of the API calls, along with the estimated timings:</span></span>

1.  <span data-ttu-id="f01cb-360">Первый вызов очищает буфер команд путем вызова метода [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) с [**D3DGETDATA \_ flush**](d3dgetdata-flush.md).</span><span class="sxs-lookup"><span data-stu-id="f01cb-360">The first call empties the command buffer by calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md).</span></span> <span data-ttu-id="f01cb-361">Когда GPU заканчивает обработку всех команд для работы с буфером, метод **GetData** возвращает \_ ОК, а цикл завершается из-за бездействия GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-361">When the GPU finishes processing all the command-buffer work, **GetData** returns S\_OK, and the loop is exited because the GPU is idle.</span></span>
2.  <span data-ttu-id="f01cb-362">Последовательность отрисовки начинается с преобразования [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) в независимый от устройства формат и его добавления в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-362">The render sequence starts by converting [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) to a device-independent format and adding it to the command buffer.</span></span> <span data-ttu-id="f01cb-363">Предположим, что это займет около 100 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-363">Assume this takes about 100 cycles.</span></span>
3.  <span data-ttu-id="f01cb-364">[**Дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) преобразуется и добавляется в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-364">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is converted and added to the command buffer.</span></span> <span data-ttu-id="f01cb-365">Предположим, что это займет около 900 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-365">Assume this takes about 900 cycles.</span></span>
4.  <span data-ttu-id="f01cb-366">[**Ошибка**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) добавляет маркер запроса в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-366">[**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) adds a query marker to the command buffer.</span></span> <span data-ttu-id="f01cb-367">Предположим, что это займет около 200 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-367">Assume this takes about 200 cycles.</span></span>
5.  <span data-ttu-id="f01cb-368">Метод [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) вызывает очистку буфера команд, что приводит к принудительному переходу в режиме ядра.</span><span class="sxs-lookup"><span data-stu-id="f01cb-368">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) causes the command buffer to be emptied which forces the kernel-mode transition.</span></span> <span data-ttu-id="f01cb-369">Предположим, что это займет около 5000 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-369">Assume this takes about 5000 cycles.</span></span>
6.  <span data-ttu-id="f01cb-370">Затем драйвер обрабатывает работу, связанную со всеми четырьмя вызовами.</span><span class="sxs-lookup"><span data-stu-id="f01cb-370">The driver then processes the work associated with all four calls.</span></span> <span data-ttu-id="f01cb-371">Предположим, что время драйвера для обработки [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) составляет около 2964 циклов, [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) составляет около 3600 циклов, [**выдается**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) около 200 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-371">Assume that the driver time to process [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about 2964 cycles, [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is about 3600 cycles, [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) is about 200 cycles.</span></span> <span data-ttu-id="f01cb-372">Поэтому общее время драйвера для всех четырех команд составляет примерно 6450 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-372">So the total driver time for all four commands is about 6450 cycles.</span></span>
    > [!Note]  
    > <span data-ttu-id="f01cb-373">Драйвер также потребует немного времени для просмотра состояния GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-373">The driver also takes a little time to see what the status of the GPU is.</span></span> <span data-ttu-id="f01cb-374">Поскольку работа GPU является тривиальной, графический процессор уже должен быть выполнен.</span><span class="sxs-lookup"><span data-stu-id="f01cb-374">Because the GPU work is trivial, the GPU should be done already.</span></span> <span data-ttu-id="f01cb-375">Метод [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) возвратит S \_ ОК в зависимости от вероятности завершения GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-375">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) will return S\_OK based on the likelihood that the GPU is finished.</span></span>

     

7.  <span data-ttu-id="f01cb-376">Когда драйвер завершает свою работу, переход пользовательского режима возвращает управление среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="f01cb-376">When the driver finishes its work, the user-mode transition returns control to the runtime.</span></span> <span data-ttu-id="f01cb-377">Буфер команд теперь пуст.</span><span class="sxs-lookup"><span data-stu-id="f01cb-377">The command buffer is now empty.</span></span> <span data-ttu-id="f01cb-378">Предположим, что это займет около 5000 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-378">Assume this takes about 5000 cycles.</span></span>

<span data-ttu-id="f01cb-379">К числу для [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) относятся:</span><span class="sxs-lookup"><span data-stu-id="f01cb-379">The numbers for [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) include:</span></span>


```
GetData = kernel-transition + driver work + user-transition
GetData = 5000              + 6450        + 5000           
GetData = 16,450  

driver work = SetTexture + DrawPrimitive + Issue = 
driver work = 2964       + 3600          + 200   = 6450 cycles 
```



<span data-ttu-id="f01cb-380">Механизм запросов, используемый в сочетании с QueryPerformanceCounter, измеряет всю работу ЦП.</span><span class="sxs-lookup"><span data-stu-id="f01cb-380">The query mechanism used in combination with QueryPerformanceCounter measures all of the CPU work.</span></span> <span data-ttu-id="f01cb-381">Это делается с помощью сочетания маркеров запросов и сравнения состояния запросов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-381">This is done with a combination of query markers, and query status comparisons.</span></span> <span data-ttu-id="f01cb-382">Для управления объемом работы в буфере используются маркеры запроса запуска и завершения, добавленные в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-382">Start and stop query markers added to the command buffer are used to control how much work is in the buffer.</span></span> <span data-ttu-id="f01cb-383">В ожидании, пока не будет возвращен правильный код возврата, начальное измерение будет выполнено непосредственно перед началом чистой последовательности отрисовки, а измерение «завершение» будет выполнено сразу после того, как драйвер завершит работу, связанную с содержимым буфера команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-383">By waiting until the right return code is returned, the start measurement is made just before a clean render sequence starts, and the stop measurement is made just after the driver has finished the work associated with the command buffer contents.</span></span> <span data-ttu-id="f01cb-384">Это эффективно захватывает работу ЦП, выполняемую средой выполнения, а также драйвером.</span><span class="sxs-lookup"><span data-stu-id="f01cb-384">This effectively captures the CPU work done by the runtime as well as the driver.</span></span>

<span data-ttu-id="f01cb-385">Теперь, когда вы узнаете о буфере команд и о том, что он может иметь при профилировании, следует иметь в курсе несколько других условий, которые могут вызвать очистку буфера команд средой выполнения.</span><span class="sxs-lookup"><span data-stu-id="f01cb-385">Now that you know about the command buffer and the effect it can have on profiling, you should know that there are a few other conditions that can cause the runtime to empty the command buffer.</span></span> <span data-ttu-id="f01cb-386">Их необходимо отслеживать в последовательностях рендеринга.</span><span class="sxs-lookup"><span data-stu-id="f01cb-386">You need to watch out for these in your render sequences.</span></span> <span data-ttu-id="f01cb-387">Некоторые из этих условий выполняются в ответ на вызовы API, а другие — в ответ на изменения ресурсов в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="f01cb-387">Some of these conditions are in response to API calls, others are in response to resource changes in the runtime.</span></span> <span data-ttu-id="f01cb-388">Любое из следующих условий приведет к переходу в режим:</span><span class="sxs-lookup"><span data-stu-id="f01cb-388">Any of the following conditions will cause a mode transition:</span></span>

-   <span data-ttu-id="f01cb-389">Когда один из методов блокировки ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) вызывается в буфере вершин, буфере индекса или текстуре (при определенных условиях с определенными флагами).</span><span class="sxs-lookup"><span data-stu-id="f01cb-389">When one of the lock methods ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) is called on a vertex buffer, index buffer, or texture (under certain conditions with certain flags).</span></span>
-   <span data-ttu-id="f01cb-390">При создании буфера устройства или вершин, буфер индекса или текстуры.</span><span class="sxs-lookup"><span data-stu-id="f01cb-390">When a device or vertex buffer, index buffer, or texture is created.</span></span>
-   <span data-ttu-id="f01cb-391">Когда буфер устройства или вершина, буфер или текстура уничтожаются в последнем выпуске.</span><span class="sxs-lookup"><span data-stu-id="f01cb-391">When a device or vertex buffer, index buffer, or texture is destroyed by the last release.</span></span>
-   <span data-ttu-id="f01cb-392">При вызове [**валидатедевице**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) .</span><span class="sxs-lookup"><span data-stu-id="f01cb-392">When [**ValidateDevice**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) is called.</span></span>
-   <span data-ttu-id="f01cb-393">При его [**наличии**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) вызывается.</span><span class="sxs-lookup"><span data-stu-id="f01cb-393">When [**Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) is called.</span></span>
-   <span data-ttu-id="f01cb-394">При заполнении буфера команд.</span><span class="sxs-lookup"><span data-stu-id="f01cb-394">When the command buffer fills up.</span></span>
-   <span data-ttu-id="f01cb-395">Когда метод [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) вызывается с D3DGETDATA \_ Flush.</span><span class="sxs-lookup"><span data-stu-id="f01cb-395">When [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) is called with D3DGETDATA\_FLUSH.</span></span>

<span data-ttu-id="f01cb-396">Следите за этими условиями в последовательностях рендеринга.</span><span class="sxs-lookup"><span data-stu-id="f01cb-396">Be careful to watch for these conditions in your render sequences.</span></span> <span data-ttu-id="f01cb-397">Каждый раз, когда добавляется переход в режим, в измерения профилирования будут добавлены 10 000 циклов работы драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-397">Every time a mode transition is added, 10,000 cycles of driver work will be added to your profiling measurements.</span></span> <span data-ttu-id="f01cb-398">Кроме того, буфер команд не имеет статического размера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-398">In addition, the command buffer is not statically sized.</span></span> <span data-ttu-id="f01cb-399">Среда выполнения может изменить размер буфера в ответ на объем работы, создаваемый приложением.</span><span class="sxs-lookup"><span data-stu-id="f01cb-399">The runtime may change the buffer's size in response to the amount of work that is being generated by the application.</span></span> <span data-ttu-id="f01cb-400">Это еще одна оптимизация, зависящая от последовательности отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-400">This is yet another optimization that is dependent on a render sequence.</span></span>

<span data-ttu-id="f01cb-401">Поэтому будьте внимательны при переходе в режим управления во время профилирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-401">So be careful to control mode transitions during profiling.</span></span> <span data-ttu-id="f01cb-402">Механизм запросов предлагает надежный метод для очистки буфера команд, чтобы можно было управлять временем перехода в режим, а также объемом работы, которую содержит буфер.</span><span class="sxs-lookup"><span data-stu-id="f01cb-402">The query mechanism offers a robust method for emptying the command buffer so that you can control the timing of the mode transition as well as the amount of work the buffer contains.</span></span> <span data-ttu-id="f01cb-403">Однако даже этот метод можно улучшить, уменьшая время перехода в режим, чтобы сделать его несущественным в отношении измеряемого результата.</span><span class="sxs-lookup"><span data-stu-id="f01cb-403">However, even this technique can be improved by reducing the mode transition time to make it insignificant with respect to the measured result.</span></span>

### <a name="make-the-render-sequence-large-compared-to-the-mode-transition"></a><span data-ttu-id="f01cb-404">Сделать последовательность отрисовки значительной по сравнению с переходом режима</span><span class="sxs-lookup"><span data-stu-id="f01cb-404">Make the Render Sequence Large Compared to the Mode Transition</span></span>

<span data-ttu-id="f01cb-405">В предыдущем примере переключение режима ядра и коммутатора пользовательского режима потребляют около 10 000 циклов, не имеющих никаких действий со средой выполнения и драйвером.</span><span class="sxs-lookup"><span data-stu-id="f01cb-405">In the previous example, the kernel-mode switch and the user-mode switch consume about 10,000 cycles that have nothing to do with runtime and driver work.</span></span> <span data-ttu-id="f01cb-406">Так как переход режима встроен в операционную систему, его нельзя уменьшить до нуля.</span><span class="sxs-lookup"><span data-stu-id="f01cb-406">Since the mode transition is built into the operating system, it cannot be reduced to zero.</span></span> <span data-ttu-id="f01cb-407">Чтобы обеспечить незначительное переключение режима, последовательность отрисовки должна быть скорректирована таким образом, чтобы драйвер и среда выполнения работали в порядке, отличном от переключения режима.</span><span class="sxs-lookup"><span data-stu-id="f01cb-407">To make the mode transition insignificant, the render sequence needs to adjusted so that the driver and runtime work are an order of magnitude larger than the mode switches.</span></span> <span data-ttu-id="f01cb-408">Вы можете попытаться выполнить вычитание для удаления переходов, но амортизация на более крупную стоимость последовательности визуализации более надежна.</span><span class="sxs-lookup"><span data-stu-id="f01cb-408">You could try to do a subtraction to remove the transitions, but amortizing the cost over a much larger render sequence cost is more reliable.</span></span>

<span data-ttu-id="f01cb-409">Стратегия уменьшения переходов в режиме, пока не становится несущественной, заключается в добавлении цикла в последовательность отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-409">The strategy for reducing the mode transition until it becomes insignificant is to add a loop to the render sequence.</span></span> <span data-ttu-id="f01cb-410">Например, рассмотрим результаты профилирования, если добавляется цикл, который повторяет последовательность отрисовки 1500 раз:</span><span class="sxs-lookup"><span data-stu-id="f01cb-410">For example, let look at the profiling results if a loop is added that will repeat the render sequence 1500 times:</span></span>


```
// Initialize the array with two textures, same size, same format
IDirect3DTexture* texArray[2];

CreateQuery(D3DQUERYTYPE_EVENT, pEvent);
pEvent->Issue(D3DISSUE_END);
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

LARGE_INTEGER start, stop;
// Now start counting because the video card is ready
QueryPerformanceCounter(&start);

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  SetTexture(taxArray[i%2]);
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

pEvent->Issue(D3DISSUE_END);

while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
QueryPerformanceCounter(&stop);
```



<span data-ttu-id="f01cb-411">Пример 4. Добавление цикла в последовательность отрисовки</span><span class="sxs-lookup"><span data-stu-id="f01cb-411">Example 4: Add a Loop to the Render Sequence</span></span>

<span data-ttu-id="f01cb-412">Ниже приведены результаты, измеряемые с помощью QueryPerformanceCounter и Куериперформанцефрекуенци:</span><span class="sxs-lookup"><span data-stu-id="f01cb-412">Here are the results measured with QueryPerformanceCounter and QueryPerformanceFrequency:</span></span>



| <span data-ttu-id="f01cb-413">Локальная переменная</span><span class="sxs-lookup"><span data-stu-id="f01cb-413">Local Variable</span></span> | <span data-ttu-id="f01cb-414">Число ТИКС</span><span class="sxs-lookup"><span data-stu-id="f01cb-414">Number of Tics</span></span> |
|----------------|----------------|
| <span data-ttu-id="f01cb-415">start</span><span class="sxs-lookup"><span data-stu-id="f01cb-415">start</span></span>          | <span data-ttu-id="f01cb-416">1792998845000</span><span class="sxs-lookup"><span data-stu-id="f01cb-416">1792998845000</span></span>  |
| <span data-ttu-id="f01cb-417">stop</span><span class="sxs-lookup"><span data-stu-id="f01cb-417">stop</span></span>           | <span data-ttu-id="f01cb-418">1792998847084</span><span class="sxs-lookup"><span data-stu-id="f01cb-418">1792998847084</span></span>  |
| <span data-ttu-id="f01cb-419">FREQ</span><span class="sxs-lookup"><span data-stu-id="f01cb-419">freq</span></span>           | <span data-ttu-id="f01cb-420">3579545</span><span class="sxs-lookup"><span data-stu-id="f01cb-420">3579545</span></span>        |



 

<span data-ttu-id="f01cb-421">Использование QueryPerformanceCounter Measures 2 840 тактов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-421">Using QueryPerformanceCounter measures 2,840 ticks now.</span></span> <span data-ttu-id="f01cb-422">Преобразование тактов в циклы аналогично тому, что мы уже показали:</span><span class="sxs-lookup"><span data-stu-id="f01cb-422">Converting ticks to cycles is the same as we have already shown:</span></span>


```
# ticks  = (stop - start) = 1792998847084 - 1792998845000 = 2840 ticks
# cycles    = machine speed * number of ticks / QPF
# 6,900,000 = 2 GHz          * 2840           / 3,579,545
```



<span data-ttu-id="f01cb-423">Иными словами, для обработки вызовов 1500 в цикле подготовки требуется около 6 900 000 циклов на этом компьютере с тактовой частотой 2 ГГц.</span><span class="sxs-lookup"><span data-stu-id="f01cb-423">In other words, it takes about 6.9 million cycles on this 2 GHz machine to process the 1500 calls in the render loop.</span></span> <span data-ttu-id="f01cb-424">Из 6 900 000 циклов, время в режимах переходов составляет примерно 10 000, поэтому теперь результаты профиля почти полностью измеряют работу, связанную с [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="f01cb-424">Of the 6.9 million cycles, the amount of time in the mode transitions is approximately 10k, so now the profile results are almost entirely measuring work associated with [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span>

<span data-ttu-id="f01cb-425">Обратите внимание, что для примера кода требуется массив из двух текстур.</span><span class="sxs-lookup"><span data-stu-id="f01cb-425">Notice that the code sample requires an array of two textures.</span></span> <span data-ttu-id="f01cb-426">Чтобы избежать оптимизации среды выполнения, которая приведет к удалению [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) , если при каждом вызове задается один и тот же указатель текстуры, просто используйте массив из двух текстур.</span><span class="sxs-lookup"><span data-stu-id="f01cb-426">To avoid a runtime optimization that would remove [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) if it sets the same texture pointer every time it is called, simply use an array of two textures.</span></span> <span data-ttu-id="f01cb-427">Таким образом, при каждом проходе через цикл изменяется указатель текстуры, и выполняется полная работа, связанная с **сеттекстуре** .</span><span class="sxs-lookup"><span data-stu-id="f01cb-427">That way, each time through the loop, the texture pointer changes, and the full work associated with **SetTexture** is performed.</span></span> <span data-ttu-id="f01cb-428">Убедитесь, что обе текстуры имеют одинаковый размер и формат, поэтому другие состояния не изменятся при выполнении текстуры.</span><span class="sxs-lookup"><span data-stu-id="f01cb-428">Be sure that both textures are the same size and format, so that no other state will change when the texture does.</span></span>

<span data-ttu-id="f01cb-429">Теперь у вас есть методика для профилирования Direct3D.</span><span class="sxs-lookup"><span data-stu-id="f01cb-429">And now you have a technique for profiling Direct3D.</span></span> <span data-ttu-id="f01cb-430">Он основывается на счетчике высокой производительности (QueryPerformanceCounter), чтобы записать число тактов, затрачиваемых ЦП на обработку работы.</span><span class="sxs-lookup"><span data-stu-id="f01cb-430">It relies on the high performance counter (QueryPerformanceCounter) to record the number of ticks it takes the CPU to process work.</span></span> <span data-ttu-id="f01cb-431">Работа тщательно контролируется, чтобы стать средой выполнения и драйвером, связанными с вызовами API с помощью механизма запросов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-431">The work is carefully controlled to be the runtime and driver work associated with API calls using the query mechanism.</span></span> <span data-ttu-id="f01cb-432">Запрос предоставляет два средства управления: сначала очистите буфер команд до начала последовательности отрисовки, а второй — после завершения работы GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-432">A query provides two means of control: first to empty the command buffer before the render sequence starts, and secondly to return when the GPU work is finished.</span></span>

<span data-ttu-id="f01cb-433">На данный момент в этой статье был показан способ профилирования последовательности отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-433">So far, this paper has shown how to profile a render sequence.</span></span> <span data-ttu-id="f01cb-434">Каждая последовательность отрисовки была довольно простой, содержащая один вызов [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) и вызов [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) .</span><span class="sxs-lookup"><span data-stu-id="f01cb-434">Each render sequence has been fairly simple, containing a single [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) call and a [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) call.</span></span> <span data-ttu-id="f01cb-435">Это было сделано для того, чтобы сосредоточиться на буфере команд и использовании механизма запросов для управления им.</span><span class="sxs-lookup"><span data-stu-id="f01cb-435">This was done to focus on the command buffer and the use of the query mechanism to control it.</span></span> <span data-ttu-id="f01cb-436">Ниже приведена краткая сводка по профилированию произвольной последовательности визуализации.</span><span class="sxs-lookup"><span data-stu-id="f01cb-436">Here is a brief summary of how to profile an arbitrary render sequence:</span></span>

-   <span data-ttu-id="f01cb-437">Используйте высокопроизводительный счетчик, такой как QueryPerformanceCounter, для измерения времени, затрачиваемого на обработку каждого вызова API.</span><span class="sxs-lookup"><span data-stu-id="f01cb-437">Use a high performance counter like QueryPerformanceCounter to measure the time it takes to process each API call.</span></span> <span data-ttu-id="f01cb-438">Используйте Куериперформанцефрекуенци и тактовую частоту ЦП, чтобы преобразовать это значение в число циклов ЦП на вызов API.</span><span class="sxs-lookup"><span data-stu-id="f01cb-438">Use QueryPerformanceFrequency and the CPU clock rate to convert this to the number of CPU cycles per API call.</span></span>
-   <span data-ttu-id="f01cb-439">Сократите объем работы GPU за счет отрисовки списков треугольников, где каждый треугольник содержит один пиксель.</span><span class="sxs-lookup"><span data-stu-id="f01cb-439">Minimize the amount of GPU work by rendering triangle lists, where each triangle contains one pixel.</span></span>
-   <span data-ttu-id="f01cb-440">Используйте механизм запросов, чтобы очистить буфер команд перед последовательностью отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-440">Use the query mechanism to empty the command buffer before the render sequence.</span></span> <span data-ttu-id="f01cb-441">Это гарантирует, что при профилировании будет захвачен правильный объем работы среды выполнения и драйвера, связанный с последовательностью отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-441">This guarantees that profiling will capturing the correct amount of runtime and driver work associated with the render sequence.</span></span>
-   <span data-ttu-id="f01cb-442">Управление объемом работы, добавляемой в буфер команд с маркерами событий запросов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-442">Control the amount of work added to the command buffer with query event markers.</span></span> <span data-ttu-id="f01cb-443">Этот же запрос обнаруживает, когда GPU завершает свою работу.</span><span class="sxs-lookup"><span data-stu-id="f01cb-443">This same query detects when the GPU finishes its work.</span></span> <span data-ttu-id="f01cb-444">Поскольку работа GPU является тривиальной, это практически эквивалентно измерению времени завершения работы драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-444">Since the GPU work is trivial, this is virtually equivalent to measuring when the driver work is completed.</span></span>

<span data-ttu-id="f01cb-445">Все эти методы используются для профилирования изменений состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-445">All of these techniques are used to profile state changes.</span></span> <span data-ttu-id="f01cb-446">Если вы прочитали и поняли, как управлять буфером команд и успешно завершили базовые измерения в [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), вы можете добавлять изменения состояния в последовательности отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-446">Assuming that you have read and understood how to control the command buffer, and have successfully completed baseline measurements on [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), you are ready to add state changes to your render sequences.</span></span> <span data-ttu-id="f01cb-447">При добавлении изменений состояния в последовательность отрисовки необходимо выполнить несколько дополнительных задач по профилированию.</span><span class="sxs-lookup"><span data-stu-id="f01cb-447">There are a few additional profiling challenges when adding state changes to a render sequence.</span></span> <span data-ttu-id="f01cb-448">Если вы собираетесь добавить изменения состояния в последовательности отрисовки, не забудьте перейти к следующему разделу.</span><span class="sxs-lookup"><span data-stu-id="f01cb-448">If you intend to add state changes to your render sequences, be sure to continue into the next section.</span></span>

## <a name="profiling-direct3d-state-changes"></a><span data-ttu-id="f01cb-449">Профилирование изменений состояния Direct3D</span><span class="sxs-lookup"><span data-stu-id="f01cb-449">Profiling Direct3D State Changes</span></span>

<span data-ttu-id="f01cb-450">Direct3D использует много состояний рендеринга для управления практически всеми аспектами конвейера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-450">Direct3D uses many render states to control almost every aspect of the pipeline.</span></span> <span data-ttu-id="f01cb-451">API-интерфейсы, которые вызывают изменение состояния, включают в себя любую функцию или метод, отличные от \* примитивов рисования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-451">The APIs that cause state changes include any function or method other than the Draw\*Primitive calls.</span></span>

<span data-ttu-id="f01cb-452">Изменения состояния очень сложны, так как вы не можете увидеть стоимость изменения состояния без подготовки к просмотру.</span><span class="sxs-lookup"><span data-stu-id="f01cb-452">State changes are tricky because you may not be able to see the cost of a state change without rendering.</span></span> <span data-ttu-id="f01cb-453">Это результат неактивного алгоритма, который используется драйвером и графическим процессором для откладывание работы до тех пор, пока она не будет полностью завершена.</span><span class="sxs-lookup"><span data-stu-id="f01cb-453">This is a result of the lazy algorithm that the driver and the GPU use to defer work until it absolutely has to be done.</span></span> <span data-ttu-id="f01cb-454">Как правило, для измерения одного изменения состояния необходимо выполнить следующие действия.</span><span class="sxs-lookup"><span data-stu-id="f01cb-454">In general, you should follow these steps to measure a single state change:</span></span>

1.  <span data-ttu-id="f01cb-455">Сначала Profile [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) .</span><span class="sxs-lookup"><span data-stu-id="f01cb-455">Profile [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) first.</span></span>
2.  <span data-ttu-id="f01cb-456">Добавьте одно изменение состояния в последовательность отрисовки и пропрофилировать новую последовательность.</span><span class="sxs-lookup"><span data-stu-id="f01cb-456">Add one state change to the render sequence and profile the new sequence.</span></span>
3.  <span data-ttu-id="f01cb-457">Вычтите разность между двумя последовательностями, чтобы получить затраты на изменение состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-457">Subtract the difference between the two sequences to get the cost of the state change.</span></span>

<span data-ttu-id="f01cb-458">Естественно, все, что вы узнали об использовании механизма запросов и помещаете последовательность отрисовки в цикле, чтобы инвертировать затраты на переход в режим по-прежнему.</span><span class="sxs-lookup"><span data-stu-id="f01cb-458">Naturally, everything you have learned about using the query mechanism and putting the render sequence in a loop to negate the cost of the mode transition still applies.</span></span>

### <a name="profiling-a-simple-state-change"></a><span data-ttu-id="f01cb-459">Профилирование простого изменения состояния</span><span class="sxs-lookup"><span data-stu-id="f01cb-459">Profiling a Simple State Change</span></span>

<span data-ttu-id="f01cb-460">Начиная с последовательности отрисовки, содержащей [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), ниже приведена последовательность кода для измерения затрат на добавление [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):</span><span class="sxs-lookup"><span data-stu-id="f01cb-460">Starting with a render sequence that contains [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), here is the code sequence for measuring the cost of adding [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):</span></span>


```
// Get the start counter value as shown in Example 4 

// Initialize a texture array as shown in Example 4
IDirect3DTexture* texArray[2];

// Render sequence loop 
for(int i = 0; i < 1500; i++)
{
  SetTexture(0, texArray[i%2];
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

// Get the stop counter value as shown in Example 4 
```



<span data-ttu-id="f01cb-461">Пример 5. измерение одного вызова API изменения состояния</span><span class="sxs-lookup"><span data-stu-id="f01cb-461">Example 5: Measuring One State Change API Call</span></span>

<span data-ttu-id="f01cb-462">Обратите внимание, что цикл содержит два вызова, [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="f01cb-462">Notice that the loop contains two calls, [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="f01cb-463">Последовательность визуализации выполняет циклы 1500 раз и формирует результаты, аналогичные приведенным ниже.</span><span class="sxs-lookup"><span data-stu-id="f01cb-463">The render sequence loops 1500 times and generates results similar to these:</span></span>



| <span data-ttu-id="f01cb-464">Локальная переменная</span><span class="sxs-lookup"><span data-stu-id="f01cb-464">Local Variable</span></span> | <span data-ttu-id="f01cb-465">Число ТИКС</span><span class="sxs-lookup"><span data-stu-id="f01cb-465">Number of Tics</span></span> |
|----------------|----------------|
| <span data-ttu-id="f01cb-466">start</span><span class="sxs-lookup"><span data-stu-id="f01cb-466">start</span></span>          | <span data-ttu-id="f01cb-467">1792998860000</span><span class="sxs-lookup"><span data-stu-id="f01cb-467">1792998860000</span></span>  |
| <span data-ttu-id="f01cb-468">stop</span><span class="sxs-lookup"><span data-stu-id="f01cb-468">stop</span></span>           | <span data-ttu-id="f01cb-469">1792998870260</span><span class="sxs-lookup"><span data-stu-id="f01cb-469">1792998870260</span></span>  |
| <span data-ttu-id="f01cb-470">FREQ</span><span class="sxs-lookup"><span data-stu-id="f01cb-470">freq</span></span>           | <span data-ttu-id="f01cb-471">3579545</span><span class="sxs-lookup"><span data-stu-id="f01cb-471">3579545</span></span>        |



 

<span data-ttu-id="f01cb-472">Преобразование тактов в циклы после повторного получения:</span><span class="sxs-lookup"><span data-stu-id="f01cb-472">Converting ticks to cycles once again yields:</span></span>


```
# ticks  = (stop - start) = 1792998870260 - 1792998860000 = 10,260 ticks
# cycles    = machine speed * number of ticks / QPF
5,775,000   = 2 GHz          * 10,260         / 3,579,545
```



<span data-ttu-id="f01cb-473">Деление на число итераций в цикле дает следующее:</span><span class="sxs-lookup"><span data-stu-id="f01cb-473">Dividing by the number of iterations in the loop yields:</span></span>


```
5,775,000 cycles / 1500 iterations = 3850 cycles for one iteration
```



<span data-ttu-id="f01cb-474">Каждая итерация цикла содержит изменение состояния и вызов Draw.</span><span class="sxs-lookup"><span data-stu-id="f01cb-474">Each iteration of the loop contains a state change and a draw call.</span></span> <span data-ttu-id="f01cb-475">Вычитание результата последовательности отрисовки [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) оставляет:</span><span class="sxs-lookup"><span data-stu-id="f01cb-475">Subtracting out the result of the [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) render sequence leaves:</span></span>


```
3850 - 1100 = 2750 cycles for SetTexture
```



<span data-ttu-id="f01cb-476">Среднее число циклов для добавления [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) к этой последовательности отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-476">This is the average number of cycles to add [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) to this render sequence.</span></span> <span data-ttu-id="f01cb-477">Этот же метод можно применить к другим изменениям состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-477">This same technique can be applied to other state changes.</span></span>

<span data-ttu-id="f01cb-478">Почему [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) называется простым изменением состояния?</span><span class="sxs-lookup"><span data-stu-id="f01cb-478">Why is [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) called a simple state change?</span></span> <span data-ttu-id="f01cb-479">Так как заданное состояние ограничено, так что конвейер выполняет тот же объем работы при каждом изменении состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-479">Because the state that is being set is constrained so that the pipeline does the same amount of work each time the state is changed.</span></span> <span data-ttu-id="f01cb-480">Ограничение обеих текстур одинакового размера и формата гарантирует одинаковый объем работы для каждого вызова **сеттекстуре** .</span><span class="sxs-lookup"><span data-stu-id="f01cb-480">Constraining both textures to the same size and format assures the same amount of work for each **SetTexture** call.</span></span>

### <a name="profiling-a-state-change-that-needs-to-be-toggled"></a><span data-ttu-id="f01cb-481">Профилирование изменения состояния, которое необходимо переключить</span><span class="sxs-lookup"><span data-stu-id="f01cb-481">Profiling a State Change that Needs to Be Toggled</span></span>

<span data-ttu-id="f01cb-482">Существуют другие изменения состояния, которые приводят к изменению объема работы, выполняемой графическим конвейером, для каждой итерации цикла отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-482">There are other state changes that cause the amount of work performed by the graphics pipeline to change for every iteration of the render loop.</span></span> <span data-ttu-id="f01cb-483">Например, если включено z-тестирование, каждый цвет пикселя обновляет целевой объект отрисовки только после того, как значение z нового пикселя будет проверено относительно z-значения существующего пикселя.</span><span class="sxs-lookup"><span data-stu-id="f01cb-483">For example, if z-testing is enabled, each pixel color updates a render target only after the new pixel's z value is tested against the z-value for the existing pixel.</span></span> <span data-ttu-id="f01cb-484">Если z-тестирование отключено, этот тест не выполняется, и выходные данные записываются гораздо быстрее.</span><span class="sxs-lookup"><span data-stu-id="f01cb-484">If z-testing is disabled, this per-pixel test is not done and the output is written much faster.</span></span> <span data-ttu-id="f01cb-485">Включение или отключение состояния z-тестирования значительно изменяет объем работы (ЦП и GPU) во время подготовки к просмотру.</span><span class="sxs-lookup"><span data-stu-id="f01cb-485">Enabling or disabling the z-test state dramatically changes the amount of work done (by the CPU as well as the GPU) during rendering.</span></span>

<span data-ttu-id="f01cb-486">[**Сетрендерстате**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) требует определенного состояния отрисовки и значения состояния для включения или отключения z-тестирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-486">[**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) requires a particular render state and a state value to enable or disable z-testing.</span></span> <span data-ttu-id="f01cb-487">Определенное значение состояния вычисляется во время выполнения, чтобы определить, сколько работы необходимо.</span><span class="sxs-lookup"><span data-stu-id="f01cb-487">The particular state value is evaluated at runtime to determine how much work is necessary.</span></span> <span data-ttu-id="f01cb-488">Трудно измерить это изменение состояния в цикле подготовки к просмотру и по-прежнему выполнить предварительное условие состояния конвейера, чтобы оно было переключено.</span><span class="sxs-lookup"><span data-stu-id="f01cb-488">It is difficult to measure this state change in a render loop and still precondition the pipeline state so that it switches.</span></span> <span data-ttu-id="f01cb-489">Единственное решение — переключить изменение состояния во время последовательности отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-489">The only solution is to toggle the state change during the render sequence.</span></span>

<span data-ttu-id="f01cb-490">Например, метод профилирования должен повторяться дважды следующим образом:</span><span class="sxs-lookup"><span data-stu-id="f01cb-490">For example, the profiling technique needs to be repeated twice as follows:</span></span>

1.  <span data-ttu-id="f01cb-491">Начните с профилирования последовательности отрисовки [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) .</span><span class="sxs-lookup"><span data-stu-id="f01cb-491">Start by profiling the [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) render sequence.</span></span> <span data-ttu-id="f01cb-492">Вызовите этот базовый уровень.</span><span class="sxs-lookup"><span data-stu-id="f01cb-492">Call this the baseline.</span></span>
2.  <span data-ttu-id="f01cb-493">Профилирование второй последовательности отрисовки, которая переключает изменение состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-493">Profile a second render sequence that toggles the state change.</span></span> <span data-ttu-id="f01cb-494">Цикл визуализации последовательности содержит:</span><span class="sxs-lookup"><span data-stu-id="f01cb-494">The render sequence loop contains:</span></span>
    -   <span data-ttu-id="f01cb-495">Изменение состояния для установки состояния в состояние "false".</span><span class="sxs-lookup"><span data-stu-id="f01cb-495">A state change to set the state into a "false" condition.</span></span>
    -   <span data-ttu-id="f01cb-496">[**Дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , как и исходная последовательность.</span><span class="sxs-lookup"><span data-stu-id="f01cb-496">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) just like the original sequence.</span></span>
    -   <span data-ttu-id="f01cb-497">Изменение состояния для задания состояния "true".</span><span class="sxs-lookup"><span data-stu-id="f01cb-497">A state change to set the state into a "true" condition.</span></span>
    -   <span data-ttu-id="f01cb-498">Второй [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) для принудительного реализации второго изменения состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-498">A second [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) to force the second state change to be realized.</span></span>
3.  <span data-ttu-id="f01cb-499">Найдите разницу между двумя последовательностями отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-499">Find the difference between the two render sequences.</span></span> <span data-ttu-id="f01cb-500">Это делается следующим образом.</span><span class="sxs-lookup"><span data-stu-id="f01cb-500">This is done by:</span></span>
    -   <span data-ttu-id="f01cb-501">Умножьте базовую последовательность [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) на 2, так как в новой последовательности есть два вызова **дравпримитиве** .</span><span class="sxs-lookup"><span data-stu-id="f01cb-501">Multiply the baseline [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) sequence by 2 because there are two **DrawPrimitive** calls in the new sequence.</span></span>
    -   <span data-ttu-id="f01cb-502">Вычтите результат новой последовательности из исходной последовательности.</span><span class="sxs-lookup"><span data-stu-id="f01cb-502">Subtract the result of the new sequence from the original sequence.</span></span>
    -   <span data-ttu-id="f01cb-503">Разделите результат на 2, чтобы получить среднюю стоимость как "false", так и "истинное" изменение состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-503">Divide the result by 2 to get the average cost of both the "false" and the "true" state change.</span></span>

<span data-ttu-id="f01cb-504">При использовании метода цикла, используемого в последовательности отрисовки, стоимость изменения состояния конвейера должна измеряться путем переключения состояния с "true" на "false" и наоборот для каждой итерации в последовательности отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-504">With the looping technique used in the render sequence, the cost of changing pipeline state needs to be measured by toggling the state from a "true" to a "false" condition and vice versa, for each iteration in the render sequence.</span></span> <span data-ttu-id="f01cb-505">Значение "true" и "false" здесь не являются литералами, это просто означает, что состояние должно быть задано в противоположных условиях.</span><span class="sxs-lookup"><span data-stu-id="f01cb-505">The meaning of "true" and "false" here are not literal, this simply means that the state needs to be set into opposing conditions.</span></span> <span data-ttu-id="f01cb-506">Это приводит к измерению изменений состояния во время профилирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-506">This causes both state changes to be measured during profiling.</span></span> <span data-ttu-id="f01cb-507">Конечно, все, что вы узнали об использовании механизма запросов и помещаете последовательность отрисовки в цикле, чтобы инвертировать затраты на переход в режим по-прежнему.</span><span class="sxs-lookup"><span data-stu-id="f01cb-507">Of course everything you have learned about using the query mechanism and putting the render sequence in a loop to negate the cost of the mode transition still applies.</span></span>

<span data-ttu-id="f01cb-508">Например, ниже приведена последовательность кода для измерения стоимости переключения или отключения z-тестирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-508">For example, here is the code sequence for measuring the cost of toggling z-testing on or off:</span></span>


```
// Get the start counter value as shown in Example 4 

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the "false" condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Set the pipeline state to the "true" condition
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}

// Get the stop counter value as shown in Example 4 
```



<span data-ttu-id="f01cb-509">Пример 5. измерение изменения состояния переключения</span><span class="sxs-lookup"><span data-stu-id="f01cb-509">Example 5: Measuring a Toggling State Change</span></span>

<span data-ttu-id="f01cb-510">Цикл переключает состояние, выполняя два вызова [**сетрендерстате**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) .</span><span class="sxs-lookup"><span data-stu-id="f01cb-510">The loop toggles the state by executing two [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) calls.</span></span> <span data-ttu-id="f01cb-511">Первый вызов **сетрендерстате** отключает z-тестирование, а второй **сетрендерстате** включает z-тестирование.</span><span class="sxs-lookup"><span data-stu-id="f01cb-511">The first **SetRenderState** call disables z-testing and the second **SetRenderState** enables z-testing.</span></span> <span data-ttu-id="f01cb-512">За каждым **сетрендерстате** следует [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , чтобы работа, связанная с изменением состояния, была обработана драйвером вместо того, чтобы задавать «грязный» бит в драйвере.</span><span class="sxs-lookup"><span data-stu-id="f01cb-512">Each **SetRenderState** is followed by [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) so that the work associated with the state change is processed by the driver instead of only setting a dirty bit in the driver.</span></span>

<span data-ttu-id="f01cb-513">Эти числа являются разумными для этой последовательности отображения:</span><span class="sxs-lookup"><span data-stu-id="f01cb-513">These numbers are reasonable for this render sequence:</span></span>



| <span data-ttu-id="f01cb-514">Локальная переменная</span><span class="sxs-lookup"><span data-stu-id="f01cb-514">Local Variable</span></span> | <span data-ttu-id="f01cb-515">Число тактов</span><span class="sxs-lookup"><span data-stu-id="f01cb-515">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="f01cb-516">start</span><span class="sxs-lookup"><span data-stu-id="f01cb-516">start</span></span>          | <span data-ttu-id="f01cb-517">1792998845000</span><span class="sxs-lookup"><span data-stu-id="f01cb-517">1792998845000</span></span>   |
| <span data-ttu-id="f01cb-518">stop</span><span class="sxs-lookup"><span data-stu-id="f01cb-518">stop</span></span>           | <span data-ttu-id="f01cb-519">1792998861740</span><span class="sxs-lookup"><span data-stu-id="f01cb-519">1792998861740</span></span>   |
| <span data-ttu-id="f01cb-520">FREQ</span><span class="sxs-lookup"><span data-stu-id="f01cb-520">freq</span></span>           | <span data-ttu-id="f01cb-521">3579545</span><span class="sxs-lookup"><span data-stu-id="f01cb-521">3579545</span></span>         |



 

<span data-ttu-id="f01cb-522">Преобразование тактов в циклы после повторного получения:</span><span class="sxs-lookup"><span data-stu-id="f01cb-522">Converting ticks to cycles once again yields:</span></span>


```
# ticks  = (stop - start) = 1792998861740 - 1792998845000 = 15,120 ticks
# cycles    = machine speed * number of ticks / QPF
 9,300,000  = 2 GHz          * 16,740         / 3,579,545
```



<span data-ttu-id="f01cb-523">Деление на число итераций в цикле дает следующее:</span><span class="sxs-lookup"><span data-stu-id="f01cb-523">Dividing by the number of iterations in the loop yields:</span></span>


```
9,300,000 cycles / 1500 iterations = 6200 cycles for one iteration
```



<span data-ttu-id="f01cb-524">Каждая итерация цикла содержит два изменения состояния и два вызова Draw.</span><span class="sxs-lookup"><span data-stu-id="f01cb-524">Each iteration of the loop contains two state changes and two draw calls.</span></span> <span data-ttu-id="f01cb-525">Вычитание вызовов Draw (при условии, что 1100 циклов) оставляет:</span><span class="sxs-lookup"><span data-stu-id="f01cb-525">Subtracting out the draw calls (assuming 1100 cycles) leaves:</span></span>


```
6200 - 1100 - 1100 = 4000 cycles for both state changes
```



<span data-ttu-id="f01cb-526">Среднее число циклов для обоих изменений состояния, поэтому среднее время каждого изменения состояния:</span><span class="sxs-lookup"><span data-stu-id="f01cb-526">This is the average number of cycles for both state changes so the average time for each state change is:</span></span>


```
4000 / 2  = 2000 cycles for each state change
```



<span data-ttu-id="f01cb-527">Таким образом, среднее число циклов для включения или отключения z-тестирования составляет 2000 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-527">Therefore, the average number of cycles to enable or disable z-testing is 2000 cycles.</span></span> <span data-ttu-id="f01cb-528">Стоит отметить, что QueryPerformanceCounter измеряет z-включение половины времени и z отключает половину времени.</span><span class="sxs-lookup"><span data-stu-id="f01cb-528">It is worth noting that QueryPerformanceCounter is measuring z-enable half the time and z-disable half of the time.</span></span> <span data-ttu-id="f01cb-529">Этот метод фактически измеряет среднее значение обоих изменений состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-529">This technique actually measures the average of both state changes.</span></span> <span data-ttu-id="f01cb-530">Иными словами, вы измеряете время переключения состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-530">In other words, you are measuring the time to toggle a state.</span></span> <span data-ttu-id="f01cb-531">Используя этот метод, вы не можете узнать, эквивалентны ли значения времени включения и отключения, так как вы измеряете среднее арифметическое обоих этих методов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-531">Using this technique, you have no way of knowing if the enable and disable times are equivalent since you have measured the average of both of them.</span></span> <span data-ttu-id="f01cb-532">Тем не менее, это разумное число, которое будет использоваться при бюджетировании переключения состояния в качестве приложения, которое вызывает это изменение состояния, это может сделать это только путем переключения этого состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-532">Nevertheless, this is a reasonable number to use when budgeting a toggling state as an application that causes this state change can only do so by toggling this state.</span></span>

<span data-ttu-id="f01cb-533">Итак, теперь вы можете применить эти методы и пропрофилировать все необходимые изменения состояния, верно?</span><span class="sxs-lookup"><span data-stu-id="f01cb-533">So now you can apply these techniques and profile all the state changes you want, right?</span></span> <span data-ttu-id="f01cb-534">Пока нет.</span><span class="sxs-lookup"><span data-stu-id="f01cb-534">Not quite.</span></span> <span data-ttu-id="f01cb-535">По-прежнему необходимо соблюдать осторожность при оптимизации, которые предназначены для уменьшения объема работы, которую необходимо выполнить.</span><span class="sxs-lookup"><span data-stu-id="f01cb-535">You still need to be careful about optimizations that are designed to reduce the amount of work that needs to be done.</span></span> <span data-ttu-id="f01cb-536">Существует два типа оптимизации, которые следует учитывать при проектировании последовательностей отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-536">There are two types of optimizations that you should be aware of when designing your render sequences.</span></span>

### <a name="watch-out-for-state-change-optimizations"></a><span data-ttu-id="f01cb-537">Выследите за оптимизацией изменения состояния</span><span class="sxs-lookup"><span data-stu-id="f01cb-537">Watch Out for State Change Optimizations</span></span>

<span data-ttu-id="f01cb-538">В предыдущем разделе показано, как выполнять профилирование обоих видов изменений состояния: простое изменение состояния, которое ограничивается созданием одинакового объема работы для каждой итерации, и изменением состояния, которое значительно изменяет объем работы.</span><span class="sxs-lookup"><span data-stu-id="f01cb-538">The previous section show how to profile both kinds of state changes: a simple state change that is constrained to generate the same amount of work for each iteration, and a toggling state change that dramatically changes the amount of work done.</span></span> <span data-ttu-id="f01cb-539">Что произойдет, если выполнить предыдущую последовательность отрисовки и добавить в нее еще одно изменение состояния?</span><span class="sxs-lookup"><span data-stu-id="f01cb-539">What happens if you take the previous render sequence and add another state change to it?</span></span> <span data-ttu-id="f01cb-540">Например, в этом примере берется последовательность отрисовки z>-Enable, а в нее добавляется сравнение z-Func:</span><span class="sxs-lookup"><span data-stu-id="f01cb-540">For instance, this example takes the z>-enable render sequence and adds a z-func comparison to it:</span></span>


```
// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZFUNC, D3DCMP_NEVER);

  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}
```



<span data-ttu-id="f01cb-541">Состояние «z-Func» задает уровень сравнения при записи в z-буфер (между z-значением текущего пикселя и z-значением пикселя в буфере глубины).</span><span class="sxs-lookup"><span data-stu-id="f01cb-541">The z-func state sets the comparison level when writing to the z-buffer (between the z-value of a current pixel with the z-value of a pixel in the depth buffer).</span></span> <span data-ttu-id="f01cb-542">D3DCMP \_ никогда не выключает сравнение z-тестирования, в то время как D3DCMP \_ всегда устанавливает сравнение, выполняемое при каждом выполнении z-тестирования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-542">D3DCMP\_NEVER turns off the z-testing comparison while D3DCMP\_ALWAYS sets the comparison to happen every time z-testing is done.</span></span>

<span data-ttu-id="f01cb-543">Профилирование одного из этих изменений состояния в последовательности отрисовки с помощью [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) приводит к следующим результатам:</span><span class="sxs-lookup"><span data-stu-id="f01cb-543">Profiling either one of these state changes in a render sequence with [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) generates results similar to these:</span></span>



| <span data-ttu-id="f01cb-544">Изменение одного состояния</span><span class="sxs-lookup"><span data-stu-id="f01cb-544">Single State Change</span></span> | <span data-ttu-id="f01cb-545">Среднее число циклов</span><span class="sxs-lookup"><span data-stu-id="f01cb-545">Average Number of Cycles</span></span> |
|---------------------|--------------------------|
| <span data-ttu-id="f01cb-546">\_Только D3DRS зенабле</span><span class="sxs-lookup"><span data-stu-id="f01cb-546">D3DRS\_ZENABLE only</span></span> | <span data-ttu-id="f01cb-547">2000</span><span class="sxs-lookup"><span data-stu-id="f01cb-547">2000</span></span>                     |



 

<span data-ttu-id="f01cb-548">или</span><span class="sxs-lookup"><span data-stu-id="f01cb-548">or</span></span>



| <span data-ttu-id="f01cb-549">Изменение одного состояния</span><span class="sxs-lookup"><span data-stu-id="f01cb-549">Single State Change</span></span> | <span data-ttu-id="f01cb-550">Среднее число циклов</span><span class="sxs-lookup"><span data-stu-id="f01cb-550">Average Number of Cycles</span></span> |
|---------------------|--------------------------|
| <span data-ttu-id="f01cb-551">\_Только D3DRS зфунк</span><span class="sxs-lookup"><span data-stu-id="f01cb-551">D3DRS\_ZFUNC only</span></span>   | <span data-ttu-id="f01cb-552">600</span><span class="sxs-lookup"><span data-stu-id="f01cb-552">600</span></span>                      |



 

<span data-ttu-id="f01cb-553">Но при профилировании как D3DRS \_ зенабле, так и D3DRS \_ зфунк в одной и той же последовательности рендеринга, вы увидите примерно такие результаты:</span><span class="sxs-lookup"><span data-stu-id="f01cb-553">But, if you profile both D3DRS\_ZENABLE and D3DRS\_ZFUNC in the same render sequence you could see results like these:</span></span>



| <span data-ttu-id="f01cb-554">Оба изменения состояния</span><span class="sxs-lookup"><span data-stu-id="f01cb-554">Both State Changes</span></span>            | <span data-ttu-id="f01cb-555">Среднее число циклов</span><span class="sxs-lookup"><span data-stu-id="f01cb-555">Average Number of Cycles</span></span> |
|-------------------------------|--------------------------|
| <span data-ttu-id="f01cb-556">D3DRS \_ зенабле + D3DRS \_ зфунк</span><span class="sxs-lookup"><span data-stu-id="f01cb-556">D3DRS\_ZENABLE + D3DRS\_ZFUNC</span></span> | <span data-ttu-id="f01cb-557">2000</span><span class="sxs-lookup"><span data-stu-id="f01cb-557">2000</span></span>                     |



 

<span data-ttu-id="f01cb-558">Результат может быть равен сумме циклов 2000 и 600 (или 2600), так как драйвер выполняет всю работу, связанную с заданием обоих состояний рендеринга.</span><span class="sxs-lookup"><span data-stu-id="f01cb-558">You could expect the result to be to be the sum of 2000 and 600 (or 2600) cycles because the driver is doing all the work associated with setting both render states.</span></span> <span data-ttu-id="f01cb-559">Вместо этого среднее значение составляет 2000 циклов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-559">Instead, the average is 2000 cycles.</span></span>

<span data-ttu-id="f01cb-560">Этот результат отражает оптимизацию изменения состояния, реализованную в среде выполнения, драйвере или GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-560">This result reflects a state change optimization implemented in the runtime, the driver, or the GPU.</span></span> <span data-ttu-id="f01cb-561">В этом случае драйвер может увидеть первый [**сетрендерстате**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) и задать "грязное" состояние, которое откладывает работу до последующего.</span><span class="sxs-lookup"><span data-stu-id="f01cb-561">In this case, the driver could see the first [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) and set a dirty state which would postpone the work until later.</span></span> <span data-ttu-id="f01cb-562">Когда драйвер видит второй **сетрендерстате**, одно и то же состояние "грязного" может быть установлено избыточно, и та же работа будет отложена один раз.</span><span class="sxs-lookup"><span data-stu-id="f01cb-562">When the driver sees the second **SetRenderState**, the same dirty state could be redundantly set and the same work would be postponed once again.</span></span> <span data-ttu-id="f01cb-563">При вызове [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) работа, связанная с «грязным» состоянием, в итоге обрабатывается.</span><span class="sxs-lookup"><span data-stu-id="f01cb-563">When [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is called, the work associated with the dirty state is finally processed.</span></span> <span data-ttu-id="f01cb-564">Драйвер выполняет работу один раз, что означает, что первые два изменения состояния фактически консолидируются драйвером.</span><span class="sxs-lookup"><span data-stu-id="f01cb-564">The driver executes the work one time, which means that the first two state changes are effectively consolidated by the driver.</span></span> <span data-ttu-id="f01cb-565">Аналогичным образом, третье и четвертое изменения состояния фактически консолидируются драйвером в одно изменение состояния при вызове второй **дравпримитиве** .</span><span class="sxs-lookup"><span data-stu-id="f01cb-565">Similarly, the third and fourth state changes are effectively consolidated by the driver into a single state change when the second **DrawPrimitive** is called.</span></span> <span data-ttu-id="f01cb-566">В итоге драйвер и GPU обрабатывают одно изменение состояния для каждого вызова Draw.</span><span class="sxs-lookup"><span data-stu-id="f01cb-566">The net result is that the driver and the GPU process a single state change for each draw call.</span></span>

<span data-ttu-id="f01cb-567">Это хороший пример оптимизации, зависящей от последовательности.</span><span class="sxs-lookup"><span data-stu-id="f01cb-567">This is a good example of a sequence-dependent driver optimization.</span></span> <span data-ttu-id="f01cb-568">Драйвер отложенной работы дважды настраивает состояние "грязный", а затем выполняет работу один раз, чтобы очистить "грязное" состояние.</span><span class="sxs-lookup"><span data-stu-id="f01cb-568">The driver postponed work twice by setting a dirty state, and then performed the work once to clear the dirty state.</span></span> <span data-ttu-id="f01cb-569">Это хороший пример улучшения эффективности, который может быть выполнен, когда работа откладывается до абсолютной необходимости.</span><span class="sxs-lookup"><span data-stu-id="f01cb-569">This is a good example of the kind of efficiency improvement that can take place when work is deferred until absolutely necessary.</span></span>

<span data-ttu-id="f01cb-570">Как узнать, какие изменения состояния задают состояние "грязное", и, следовательно, откладывать работу до последующего?</span><span class="sxs-lookup"><span data-stu-id="f01cb-570">How do you know which state changes set a dirty state internally and therefore postpone work until later?</span></span> <span data-ttu-id="f01cb-571">Только путем тестирования последовательностей отрисовки (или общения с модулями записи драйверов).</span><span class="sxs-lookup"><span data-stu-id="f01cb-571">Only by testing render sequences (or talking to driver writers).</span></span> <span data-ttu-id="f01cb-572">Драйверы обновляются и периодически улучшаются, поэтому список оптимизаций не является статическим.</span><span class="sxs-lookup"><span data-stu-id="f01cb-572">Drivers are updated and improved periodically so the list of optimizations is not static.</span></span> <span data-ttu-id="f01cb-573">Существует только один способ абсолютно знать, какие затраты на изменение состояния в данной последовательности отрисовки находятся на конкретном наборе оборудования. и это необходимо для измерения.</span><span class="sxs-lookup"><span data-stu-id="f01cb-573">There is only one way to absolutely know what a state change costs in a given render sequence, on a particular set of hardware; and that is to measure it.</span></span>

### <a name="watch-out-for-drawprimitive-optimizations"></a><span data-ttu-id="f01cb-574">Просмотр оптимизаций для Дравпримитиве</span><span class="sxs-lookup"><span data-stu-id="f01cb-574">Watch Out for DrawPrimitive Optimizations</span></span>

<span data-ttu-id="f01cb-575">Помимо оптимизации изменения состояния, среда выполнения попытается оптимизировать число вызовов Draw, которые драйвер должен обработать.</span><span class="sxs-lookup"><span data-stu-id="f01cb-575">In addition to state change optimizations, the runtime will attempt to optimize the number of draw calls that the driver has to process.</span></span> <span data-ttu-id="f01cb-576">Например, рассмотрим обратную передачу вызовов Draw:</span><span class="sxs-lookup"><span data-stu-id="f01cb-576">For example, consider these back to back draw calls:</span></span>


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 3); // Draw 3 primitives, vertices 0 - 8
DrawPrimitive(D3DPT_TRIANGLELIST, 9, 4); // Draw 4 primitives, vertices 9 - 20
```



<span data-ttu-id="f01cb-577">Пример 5A: два вызова Draw</span><span class="sxs-lookup"><span data-stu-id="f01cb-577">Example 5a: Two Draw Calls</span></span>

<span data-ttu-id="f01cb-578">Эта последовательность содержит два вызова Draw, которые среда выполнения будет объединять в один вызов, эквивалентный следующему:</span><span class="sxs-lookup"><span data-stu-id="f01cb-578">This sequence contains two draw calls, which the runtime will consolidate into a single call equivalent to:</span></span>


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 7); // Draw 7 primitives, vertices 0 - 20
```



<span data-ttu-id="f01cb-579">Пример 5b: одиночный Объединенный вызов Draw</span><span class="sxs-lookup"><span data-stu-id="f01cb-579">Example 5b: A Single Concatenated Draw Call</span></span>

<span data-ttu-id="f01cb-580">Среда выполнения объединит оба этих конкретного вызова Draw в один вызов, что сокращает скорость работы драйвера на 50%, так как драйвер теперь должен обрабатывать только один вызов Draw.</span><span class="sxs-lookup"><span data-stu-id="f01cb-580">The runtime will concatenate both of these particular draw calls into a single call, which reduces the driver work by 50 percent because the driver will now only need to process one draw call.</span></span>

<span data-ttu-id="f01cb-581">Как правило, среда выполнения объединяет два или более обратных вызова [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , когда:</span><span class="sxs-lookup"><span data-stu-id="f01cb-581">In general, the runtime will concatenate two or more back-to-back [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) calls when:</span></span>

1.  <span data-ttu-id="f01cb-582">Тип-примитив — это список треугольников (D3DPT \_ трианглелист).</span><span class="sxs-lookup"><span data-stu-id="f01cb-582">The primitive type is a triangle list (D3DPT\_TRIANGLELIST).</span></span>
2.  <span data-ttu-id="f01cb-583">Каждый последовательный вызов [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) должен ссылаться на последовательные вершины в буфере вершин.</span><span class="sxs-lookup"><span data-stu-id="f01cb-583">Each successive [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) call must reference consecutive vertices within the vertex buffer.</span></span>

<span data-ttu-id="f01cb-584">Аналогично, верные условия объединения двух или более обратных вызовов [**дравиндекседпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) :</span><span class="sxs-lookup"><span data-stu-id="f01cb-584">Similarly, the right conditions for concatenating two or more back-to-back [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) calls are:</span></span>

1.  <span data-ttu-id="f01cb-585">Тип-примитив — это список треугольников (D3DPT \_ трианглелист).</span><span class="sxs-lookup"><span data-stu-id="f01cb-585">The primitive type is a triangle list (D3DPT\_TRIANGLELIST).</span></span>
2.  <span data-ttu-id="f01cb-586">Каждый последовательный вызов [**дравиндекседпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) должен последовательно ссылаться на последовательные индексы в буфере индекса.</span><span class="sxs-lookup"><span data-stu-id="f01cb-586">Each successive [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) call must sequential reference consecutive indices within the index buffer.</span></span>
3.  <span data-ttu-id="f01cb-587">Каждый последовательный вызов [**дравиндекседпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) должен использовать одно и то же значение для басевертексиндекс.</span><span class="sxs-lookup"><span data-stu-id="f01cb-587">Each successive [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) call must use the same value for BaseVertexIndex.</span></span>

<span data-ttu-id="f01cb-588">Чтобы предотвратить объединение во время профилирования, измените последовательность отрисовки так, чтобы тип-примитив не был списком треугольников, или измените последовательность отрисовки таким образом, чтобы не существовали обратные вызовы Draw, использующие последовательные вершины (или индексы).</span><span class="sxs-lookup"><span data-stu-id="f01cb-588">To prevent concatenation during profiling, modify the render sequence so that the primitive type is not a triangle list, or modify the render sequence so that there are no back-to-back draw calls that use consecutive vertices (or indices).</span></span> <span data-ttu-id="f01cb-589">В частности, среда выполнения также объединяет вызовы Draw, которые отвечают обоим следующим условиям:</span><span class="sxs-lookup"><span data-stu-id="f01cb-589">More specifically, the runtime will also concatenate draw calls that meet both of the following conditions:</span></span>

-   <span data-ttu-id="f01cb-590">Если предыдущий вызов — [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), то при следующем вызове Draw:</span><span class="sxs-lookup"><span data-stu-id="f01cb-590">When the previous call is [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), if the next draw call:</span></span>
    -   <span data-ttu-id="f01cb-591">использует список треугольников и</span><span class="sxs-lookup"><span data-stu-id="f01cb-591">uses a triangle list, AND</span></span>
    -   <span data-ttu-id="f01cb-592">Указывает Стартвертекс = Previous Стартвертекс + предыдущее Примитивекаунт \* 3</span><span class="sxs-lookup"><span data-stu-id="f01cb-592">specifies the StartVertex = previous StartVertex + previous PrimitiveCount \* 3</span></span>
-   <span data-ttu-id="f01cb-593">При использовании [**дравиндекседпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive)при следующем вызове Draw:</span><span class="sxs-lookup"><span data-stu-id="f01cb-593">When using [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), if the next draw call:</span></span>
    -   <span data-ttu-id="f01cb-594">использует список треугольников и</span><span class="sxs-lookup"><span data-stu-id="f01cb-594">uses a triangle list, AND</span></span>
    -   <span data-ttu-id="f01cb-595">Указывает значение StartIndex = предыдущий StartIndex + Previous Примитивекаунт \* 3, а</span><span class="sxs-lookup"><span data-stu-id="f01cb-595">specifies the StartIndex = previous StartIndex + previous PrimitiveCount \* 3, AND</span></span>
    -   <span data-ttu-id="f01cb-596">Указывает Басевертексиндекс = Previous Басевертексиндекс</span><span class="sxs-lookup"><span data-stu-id="f01cb-596">specifies the BaseVertexIndex = previous BaseVertexIndex</span></span>

<span data-ttu-id="f01cb-597">Ниже приведен более тонкий пример объединения вызовов Draw, который легко заметить при профилировании.</span><span class="sxs-lookup"><span data-stu-id="f01cb-597">Here is a more subtle example of draw call concatenation that is easy to overlook when you are profiling.</span></span> <span data-ttu-id="f01cb-598">Предположим, что последовательность визуализации выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="f01cb-598">Assume the render sequence looks like this:</span></span>


```
  for(int i = 0; i < 1500; i++)
  {
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



<span data-ttu-id="f01cb-599">Пример 5C: одно изменение состояния и один вызов Draw</span><span class="sxs-lookup"><span data-stu-id="f01cb-599">Example 5c: One State Change and One Draw Call</span></span>

<span data-ttu-id="f01cb-600">Цикл проходит через треугольники 1500, устанавливая текстуру и рисуя каждый треугольник.</span><span class="sxs-lookup"><span data-stu-id="f01cb-600">The loop iterates through 1500 triangles, setting a texture and drawing each triangle.</span></span> <span data-ttu-id="f01cb-601">Этот цикл визуализации занимает примерно 2750 циклов для циклов [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и 1100 для [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , как показано в предыдущих разделах.</span><span class="sxs-lookup"><span data-stu-id="f01cb-601">This render loop takes approximately 2750 cycles for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and 1100 cycles for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) as shown in previous sections.</span></span> <span data-ttu-id="f01cb-602">Можно интуитивно ожидать, что перемещение **сеттекстуре** за пределы цикла подготовки к просмотру должно уменьшить объем работы, выполненной драйвером, на 1500 \* 2750 тактов, то есть объем работы, связанный с вызовом **сеттекстуре** 1500 раз.</span><span class="sxs-lookup"><span data-stu-id="f01cb-602">You might intuitively expect that moving **SetTexture** outside the render loop should reduce the amount of work done by the driver by 1500 \* 2750 cycles, which is the amount of work associated with calling **SetTexture** 1500 times.</span></span> <span data-ttu-id="f01cb-603">Фрагмент кода будет выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="f01cb-603">The code snippet would look like this:</span></span>


```
  SetTexture(...); // Set the state outside the loop
  for(int i = 0; i < 1500; i++)
  {
//    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



<span data-ttu-id="f01cb-604">Пример: 5D. пример 5C с изменением состояния вне цикла</span><span class="sxs-lookup"><span data-stu-id="f01cb-604">Example 5d: Example 5c with the State Change Outside the Loop</span></span>

<span data-ttu-id="f01cb-605">Перемещение [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) за пределы цикла подготовки к просмотру сокращает объем работы, связанный с **сеттекстуре** , так как он вызывается один раз вместо 1500 раз.</span><span class="sxs-lookup"><span data-stu-id="f01cb-605">Moving [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) outside the render loop does reduce the amount of work associated with **SetTexture** since it is called once instead of 1500 times.</span></span> <span data-ttu-id="f01cb-606">Менее очевидный дополнительный результат заключается в том, что работа для [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) также сокращается с 1500 вызовов до 1, так как удовлетворяются все условия объединения вызовов Draw.</span><span class="sxs-lookup"><span data-stu-id="f01cb-606">A less obvious secondary effect is that the work for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is also reduced from 1500 calls to 1 call because all of the conditions for concatenating draw calls are satisfied.</span></span> <span data-ttu-id="f01cb-607">При обработке последовательности отрисовки среда выполнения будет обрабатывать 1500 вызовов одного вызова драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-607">When the render sequence is processed, the runtime will process 1500 calls into a single driver call.</span></span> <span data-ttu-id="f01cb-608">При перемещении этой одной строки кода объем работы драйвера значительно уменьшился:</span><span class="sxs-lookup"><span data-stu-id="f01cb-608">By moving this one line of code, the amount of driver work has been reduced dramatically:</span></span>


```
total work done = runtime + driver work

Example 5c: with SetTexture in the loop:
runtime work = 1500 SetTextures + 1500 DrawPrimitives 
driver  work = 1500 SetTextures + 1500 DrawPrimitives 

Example 5d: with SetTexture outside of the loop:
runtime work = 1 SetTexture + 1 DrawPrimitive + 1499 Concatenated DrawPrimitives 
driver  work = 1 SetTexture + 1 DrawPrimitive 
```



<span data-ttu-id="f01cb-609">Эти результаты являются полностью верными, но в контексте исходного вопроса они являются ошибочными.</span><span class="sxs-lookup"><span data-stu-id="f01cb-609">These results are entirely correct, but are very misleading in the context of the original question.</span></span> <span data-ttu-id="f01cb-610">Оптимизация вызова Draw привела к значительному уменьшению объема работы драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-610">The draw call optimization has caused the amount of driver work to be dramatically reduced.</span></span> <span data-ttu-id="f01cb-611">Это распространенная проблема при пользовательском профилировании.</span><span class="sxs-lookup"><span data-stu-id="f01cb-611">This is a common problem when doing custom profiling.</span></span> <span data-ttu-id="f01cb-612">При устранении вызовов из последовательности прорисовки необходимо избегать объединения вызовов Draw.</span><span class="sxs-lookup"><span data-stu-id="f01cb-612">When eliminating calls from a render sequence, be careful to avoid draw call concatenation.</span></span> <span data-ttu-id="f01cb-613">На самом деле, этот сценарий является мощным примером улучшения производительности драйвера, которое может реализовать эта оптимизация среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="f01cb-613">In fact, this scenario is a powerful example of the amount of improvement in driver performance possible by this runtime optimization.</span></span>

<span data-ttu-id="f01cb-614">Итак, теперь вы умеете измерять изменения состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-614">So now you know how to measure state changes.</span></span> <span data-ttu-id="f01cb-615">Начните с профилирования [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="f01cb-615">Start by profiling [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="f01cb-616">Затем добавьте каждое дополнительное изменение состояния в последовательность (в некоторых случаях — Добавление одного вызова, а в других случаях — добавление двух вызовов) и измерение разницы между двумя последовательностями.</span><span class="sxs-lookup"><span data-stu-id="f01cb-616">Then add each additional state change to the sequence (in some cases adding one call and in other cases adding two calls) and measure the difference between the two sequences.</span></span> <span data-ttu-id="f01cb-617">Результаты можно преобразовать в такты или циклы или время.</span><span class="sxs-lookup"><span data-stu-id="f01cb-617">You can convert the results to ticks or cycles or time.</span></span> <span data-ttu-id="f01cb-618">Точно так же, как измерение последовательностей визуализации с помощью QueryPerformanceCounter, измерение отдельных изменений состояния основывается на механизме запросов для управления буфером команд и помещении изменений состояния в цикл, чтобы свести к сведению влияние переходов в режиме.</span><span class="sxs-lookup"><span data-stu-id="f01cb-618">Just like measuring render sequences with QueryPerformanceCounter, measuring individual state changes relies on the query mechanism to control the command buffer, and putting the state changes in a loop to minimize the impact of the mode transitions.</span></span> <span data-ttu-id="f01cb-619">Этот метод измеряет стоимость переключения состояния, так как профилировщик Возвращает среднее значение включения и отключения состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-619">This technique measures the cost of toggling a state, since the profiler returns the average of enabling and disabling the state.</span></span>

<span data-ttu-id="f01cb-620">С помощью этой возможности можно приступить к созданию произвольных последовательностей отрисовки и правильному измерению связанной работы среды выполнения и драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-620">With this capability, you can start generating arbitrary rendering sequences and accurately measuring the associated runtime and driver work.</span></span> <span data-ttu-id="f01cb-621">Эти числа можно использовать для ответа на вопросы о бюджетировании, такие как «сколько других вызовов» можно сделать в последовательности отрисовки, сохраняя разумную частоту кадров, предоставляя сценарии с ограниченным использованием ЦП.</span><span class="sxs-lookup"><span data-stu-id="f01cb-621">The numbers can then be used to answer budgeting questions like "how many more of these calls" can be made in the render sequence while still maintaining a reasonable frame rate, assuming CPU-limited scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="f01cb-622">Сводка</span><span class="sxs-lookup"><span data-stu-id="f01cb-622">Summary</span></span>

<span data-ttu-id="f01cb-623">В этом документе показано, как управлять буфером команд, чтобы можно было точно выполнить профилирование отдельных вызовов.</span><span class="sxs-lookup"><span data-stu-id="f01cb-623">This paper demonstrates how to control the command buffer so that individual calls can be accurately profiled.</span></span> <span data-ttu-id="f01cb-624">Числа профилирования могут создаваться в тактах, циклах или в абсолютном времени.</span><span class="sxs-lookup"><span data-stu-id="f01cb-624">The profiling numbers can be generated in ticks, cycles, or absolute time.</span></span> <span data-ttu-id="f01cb-625">Они представляют объем работы среды выполнения и драйвера, связанный с каждым вызовом API.</span><span class="sxs-lookup"><span data-stu-id="f01cb-625">They represent the amount of runtime and driver work associated with each API call.</span></span>

<span data-ttu-id="f01cb-626">Начните с профилирования вызова рисования \* примитива в последовательности отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-626">Start by profiling a Draw\*Primitive call in a render sequence.</span></span> <span data-ttu-id="f01cb-627">Запомните самое главное:</span><span class="sxs-lookup"><span data-stu-id="f01cb-627">Remember to:</span></span>

1.  <span data-ttu-id="f01cb-628">Используйте QueryPerformanceCounter для измерения числа тактов на вызов API.</span><span class="sxs-lookup"><span data-stu-id="f01cb-628">Use QueryPerformanceCounter to measure the number of ticks per API call.</span></span> <span data-ttu-id="f01cb-629">При необходимости используйте Куериперформанцефрекуенци для преобразования результатов в циклы или время.</span><span class="sxs-lookup"><span data-stu-id="f01cb-629">Use QueryPerformanceFrequency to convert the results to cycles or time if you like.</span></span>
2.  <span data-ttu-id="f01cb-630">Используйте механизм запросов, чтобы очистить буфер команд перед запуском.</span><span class="sxs-lookup"><span data-stu-id="f01cb-630">Use the query mechanism to empty the command buffer before starting.</span></span>
3.  <span data-ttu-id="f01cb-631">Включите последовательность отрисовки в цикл, чтобы уменьшить влияние перехода на режим.</span><span class="sxs-lookup"><span data-stu-id="f01cb-631">Include the render sequence in a loop to minimize the impact of the mode transition.</span></span>
4.  <span data-ttu-id="f01cb-632">Используйте механизм запросов для измерения времени завершения работы GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-632">Use the query mechanism to measure when the GPU has completed its work.</span></span>
5.  <span data-ttu-id="f01cb-633">Следите за сцеплением среды выполнения, которое может оказать значительное влияние на объем выполненной работы.</span><span class="sxs-lookup"><span data-stu-id="f01cb-633">Watch out for runtime concatenation that will have a major impact on the amount of work done.</span></span>

<span data-ttu-id="f01cb-634">Это дает базовую производительность для [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , которую можно использовать для построения из.</span><span class="sxs-lookup"><span data-stu-id="f01cb-634">This gives you a baseline performance for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) that can be used to build from.</span></span> <span data-ttu-id="f01cb-635">Для профилирования одного изменения состояния выполните следующие дополнительные советы.</span><span class="sxs-lookup"><span data-stu-id="f01cb-635">To profile one state change, follow these additional tips:</span></span>

1.  <span data-ttu-id="f01cb-636">Добавление изменения состояния в известный профиль последовательности отрисовки новая последовательность.</span><span class="sxs-lookup"><span data-stu-id="f01cb-636">Add the state change to a known render sequence profile the new sequence.</span></span> <span data-ttu-id="f01cb-637">Так как тестирование выполняется в цикле, для этого необходимо дважды установить состояние в противоположные значения (например, включить и отключить для экземпляра).</span><span class="sxs-lookup"><span data-stu-id="f01cb-637">Since the testing is done in a loop, this requires setting the state twice into opposite values (like enable and disable for instance).</span></span>
2.  <span data-ttu-id="f01cb-638">Сравните разность времени цикла между двумя последовательностями.</span><span class="sxs-lookup"><span data-stu-id="f01cb-638">Compare the difference in cycle times between the two sequences.</span></span>
3.  <span data-ttu-id="f01cb-639">Для изменений состояния, которые значительно изменяют конвейер (например, [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), вычтите разность между двумя последовательностями, чтобы получить время на изменение состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-639">For state changes that significantly change the pipeline (like [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), subtract the difference between the two sequences to get the time for state change.</span></span>
4.  <span data-ttu-id="f01cb-640">Для изменений состояния, которые значительно изменяют конвейер (и поэтому требует переключения состояний, таких как [**сетрендерстате**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)), вычтите разность между последовательностями отрисовки и делением на 2.</span><span class="sxs-lookup"><span data-stu-id="f01cb-640">For state changes that significantly change the pipeline (and therefore require toggling states like [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)), subtract the difference between the render sequences and divide by 2.</span></span> <span data-ttu-id="f01cb-641">Будет создано среднее количество циклов для каждого изменения состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-641">This will generate the average number of cycles for each state change.</span></span>

<span data-ttu-id="f01cb-642">Но будьте внимательны при оптимизации, которые приводят к непредвиденным результатам при профилировании.</span><span class="sxs-lookup"><span data-stu-id="f01cb-642">But be careful of optimizations that cause unexpected results when profiling.</span></span> <span data-ttu-id="f01cb-643">Оптимизации изменения состояния могут задавать "грязные" состояния, что приводит к отложению работы.</span><span class="sxs-lookup"><span data-stu-id="f01cb-643">State change optimizations may set dirty states which causes work to be deferred.</span></span> <span data-ttu-id="f01cb-644">Это может привести к тому, что результаты профиля не так очевидны, как ожидалось.</span><span class="sxs-lookup"><span data-stu-id="f01cb-644">This can cause profile results which are not as intuitive as expected.</span></span> <span data-ttu-id="f01cb-645">Сцепленные вызовы функций значительно снижают работу драйверов, что может привести к неверному получению.</span><span class="sxs-lookup"><span data-stu-id="f01cb-645">Draw calls that are concatenated will dramatically reduce driver work which can lead to misleading conclusions.</span></span> <span data-ttu-id="f01cb-646">Тщательно запланированные последовательности рендеринга используются для предотвращения изменения состояния и объединения вызовов рисования.</span><span class="sxs-lookup"><span data-stu-id="f01cb-646">Carefully planned render sequences are used to prevent state change and draw call concatenations from occurring.</span></span> <span data-ttu-id="f01cb-647">Хитрость заключается в предотвращении оптимизации во время профилирования, чтобы создаваемые вами числа были приемлемыми по числу бюджетных операций.</span><span class="sxs-lookup"><span data-stu-id="f01cb-647">The trick is to prevent the optimizations from happening during profiling so that the numbers you generate are reasonable budgeting numbers.</span></span>

> [!Note]  
> <span data-ttu-id="f01cb-648">Дублирование этой стратегии профилирования в приложении без механизма запросов усложняется.</span><span class="sxs-lookup"><span data-stu-id="f01cb-648">Duplicating this profiling strategy in an application without the query mechanism is more difficult.</span></span> <span data-ttu-id="f01cb-649">До Direct3D 9 единственным предсказуемым способом очистки буфера команд является блокировка активной поверхности (например, целевого объекта прорисовки) для ожидания простоя GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-649">Prior to Direct3D 9 the only predictable way to empty the command buffer is to lock an active surface (such as a render target) to wait until the GPU is idle.</span></span> <span data-ttu-id="f01cb-650">Это обусловлено тем, что блокировка поверхности заставляет среду выполнения очищать буфер команд в случае, если в буфере есть команды отрисовки, которые должны обновить поверхность до того, как она будет заблокирована.</span><span class="sxs-lookup"><span data-stu-id="f01cb-650">This is because locking a surface forces the runtime to empty the command buffer in case there are any rendering commands in the buffer that should update the surface before it gets locked, in addition to waiting for the GPU to finish.</span></span> <span data-ttu-id="f01cb-651">Этот метод работает, хотя он более незаметно для использования механизма запросов, представленного в Direct3D 9.</span><span class="sxs-lookup"><span data-stu-id="f01cb-651">This technique is functional, although it is more obtrusive that using the query mechanism introduced in Direct3D 9.</span></span>

 

## <a name="appendix"></a><span data-ttu-id="f01cb-652">Приложение</span><span class="sxs-lookup"><span data-stu-id="f01cb-652">Appendix</span></span>

<span data-ttu-id="f01cb-653">Числа в этой таблице представляют собой диапазон приближений к объему работы среды выполнения и драйвера, связанной с каждым из этих изменений состояния.</span><span class="sxs-lookup"><span data-stu-id="f01cb-653">The numbers in this table are a range of approximations for the amount of runtime and driver work associated with each of these state changes.</span></span> <span data-ttu-id="f01cb-654">Приблизительные значения основываются на фактических измерениях, сделанных в драйверах, с использованием методов, показанных в документе.</span><span class="sxs-lookup"><span data-stu-id="f01cb-654">The approximations are based on actual measurements made on drivers using the techniques shown in the paper.</span></span> <span data-ttu-id="f01cb-655">Эти числа были созданы с помощью среды выполнения Direct3D 9 и зависят от драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-655">These numbers were generated using the Direct3D 9 runtime and are driver-dependent.</span></span>

<span data-ttu-id="f01cb-656">Методики, описанные в этом документе, предназначены для измерения работы среды выполнения и драйвера.</span><span class="sxs-lookup"><span data-stu-id="f01cb-656">The techniques in this paper are designed to measure runtime and driver work.</span></span> <span data-ttu-id="f01cb-657">Как правило, нецелесообразно предоставлять результаты, соответствующие производительности ЦП и GPU, в каждом приложении, так как это потребует исчерпывающего массива последовательностей отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-657">In general, it is impractical to provide results that match the performance of the CPU and the GPU in every application as this would require an exhaustive array of render sequences.</span></span> <span data-ttu-id="f01cb-658">Кроме того, особенно сложно протестировать производительность GPU, так как он сильно зависит от настройки состояния в конвейере перед последовательностью отрисовки.</span><span class="sxs-lookup"><span data-stu-id="f01cb-658">In addition, it is particularly difficult to benchmark performance of the GPU because it is highly dependent on the state setup in the pipeline before the render sequence.</span></span> <span data-ttu-id="f01cb-659">Например, Включение альфа-смешения практически не влияет на объем необходимых ресурсов ЦП, но может оказать значительное влияние на объем работы, выполненный GPU.</span><span class="sxs-lookup"><span data-stu-id="f01cb-659">For instance, enabling alpha blending does little to affect the amount of CPU work necessary, but can have a big impact on the amount of work done by the GPU.</span></span> <span data-ttu-id="f01cb-660">Таким образом, методы в этой статье ограничивают работу GPU до минимально возможного объема, ограничивая объем данных, которые необходимо визуализировать.</span><span class="sxs-lookup"><span data-stu-id="f01cb-660">Therefore, the techniques in this paper constrain the GPU work to the minimum amount possible by limiting the amount of data that needs to be rendered.</span></span> <span data-ttu-id="f01cb-661">Это означает, что числа в таблице наиболее полно соответствуют результатам, полученным от приложений, которые ограничены ЦП (в отличие от приложения, ограниченного графическим процессором).</span><span class="sxs-lookup"><span data-stu-id="f01cb-661">This means that the numbers in the table will most closely match the results attained from applications that are CPU limited (as opposed to an application that is limited by the GPU).</span></span>

<span data-ttu-id="f01cb-662">Рекомендуется использовать методы, представленные для того, чтобы охватить наиболее важные сценарии и конфигурации.</span><span class="sxs-lookup"><span data-stu-id="f01cb-662">You are encouraged to use the techniques presented to cover the scenarios and configurations most important to you.</span></span> <span data-ttu-id="f01cb-663">Значения в таблице можно использовать для сравнения с создаваемыми числами.</span><span class="sxs-lookup"><span data-stu-id="f01cb-663">The values in the table can be used to compare with the numbers you generate.</span></span> <span data-ttu-id="f01cb-664">Поскольку каждый драйвер зависит друг от друга, единственный способ создать результаты профилирования можно с помощью сценариев.</span><span class="sxs-lookup"><span data-stu-id="f01cb-664">Since each driver varies, the only way to generate the actual numbers you will see is to generate profiling results using your scenarios.</span></span>



| <span data-ttu-id="f01cb-665">Вызов API</span><span class="sxs-lookup"><span data-stu-id="f01cb-665">API Call</span></span>                             | <span data-ttu-id="f01cb-666">Среднее число циклов</span><span class="sxs-lookup"><span data-stu-id="f01cb-666">Average number of Cycles</span></span> |
|--------------------------------------|--------------------------|
| <span data-ttu-id="f01cb-667">сетвертексдекларатион</span><span class="sxs-lookup"><span data-stu-id="f01cb-667">SetVertexDeclaration</span></span>                 | <span data-ttu-id="f01cb-668">6500-11250</span><span class="sxs-lookup"><span data-stu-id="f01cb-668">6500 - 11250</span></span>             |
| <span data-ttu-id="f01cb-669">сетфвф</span><span class="sxs-lookup"><span data-stu-id="f01cb-669">SetFVF</span></span>                               | <span data-ttu-id="f01cb-670">6400-11200</span><span class="sxs-lookup"><span data-stu-id="f01cb-670">6400 - 11200</span></span>             |
| <span data-ttu-id="f01cb-671">сетвертексшадер</span><span class="sxs-lookup"><span data-stu-id="f01cb-671">SetVertexShader</span></span>                      | <span data-ttu-id="f01cb-672">3000-12100</span><span class="sxs-lookup"><span data-stu-id="f01cb-672">3000 - 12100</span></span>             |
| <span data-ttu-id="f01cb-673">сетпикселшадер</span><span class="sxs-lookup"><span data-stu-id="f01cb-673">SetPixelShader</span></span>                       | <span data-ttu-id="f01cb-674">6300-7000</span><span class="sxs-lookup"><span data-stu-id="f01cb-674">6300 - 7000</span></span>              |
| <span data-ttu-id="f01cb-675">спекуларенабле</span><span class="sxs-lookup"><span data-stu-id="f01cb-675">SPECULARENABLE</span></span>                       | <span data-ttu-id="f01cb-676">1900-11200</span><span class="sxs-lookup"><span data-stu-id="f01cb-676">1900 - 11200</span></span>             |
| <span data-ttu-id="f01cb-677">сетрендертаржет</span><span class="sxs-lookup"><span data-stu-id="f01cb-677">SetRenderTarget</span></span>                      | <span data-ttu-id="f01cb-678">6000-6250</span><span class="sxs-lookup"><span data-stu-id="f01cb-678">6000 - 6250</span></span>              |
| <span data-ttu-id="f01cb-679">Сетпикселшадерконстант (1 константа)</span><span class="sxs-lookup"><span data-stu-id="f01cb-679">SetPixelShaderConstant (1 Constant)</span></span>  | <span data-ttu-id="f01cb-680">1500-9000</span><span class="sxs-lookup"><span data-stu-id="f01cb-680">1500 - 9000</span></span>              |
| <span data-ttu-id="f01cb-681">нормализенормалс</span><span class="sxs-lookup"><span data-stu-id="f01cb-681">NORMALIZENORMALS</span></span>                     | <span data-ttu-id="f01cb-682">2200-8100</span><span class="sxs-lookup"><span data-stu-id="f01cb-682">2200 - 8100</span></span>              |
| <span data-ttu-id="f01cb-683">Досветлить</span><span class="sxs-lookup"><span data-stu-id="f01cb-683">LightEnable</span></span>                          | <span data-ttu-id="f01cb-684">1300-9000</span><span class="sxs-lookup"><span data-stu-id="f01cb-684">1300 - 9000</span></span>              |
| <span data-ttu-id="f01cb-685">сетстреамсаурце</span><span class="sxs-lookup"><span data-stu-id="f01cb-685">SetStreamSource</span></span>                      | <span data-ttu-id="f01cb-686">3700-5800</span><span class="sxs-lookup"><span data-stu-id="f01cb-686">3700 - 5800</span></span>              |
| <span data-ttu-id="f01cb-687">СВЕТ</span><span class="sxs-lookup"><span data-stu-id="f01cb-687">LIGHTING</span></span>                             | <span data-ttu-id="f01cb-688">1700-7500</span><span class="sxs-lookup"><span data-stu-id="f01cb-688">1700 - 7500</span></span>              |
| <span data-ttu-id="f01cb-689">диффусематериалсаурце</span><span class="sxs-lookup"><span data-stu-id="f01cb-689">DIFFUSEMATERIALSOURCE</span></span>                | <span data-ttu-id="f01cb-690">900-8300</span><span class="sxs-lookup"><span data-stu-id="f01cb-690">900 - 8300</span></span>               |
| <span data-ttu-id="f01cb-691">амбиентматериалсаурце</span><span class="sxs-lookup"><span data-stu-id="f01cb-691">AMBIENTMATERIALSOURCE</span></span>                | <span data-ttu-id="f01cb-692">900-8200</span><span class="sxs-lookup"><span data-stu-id="f01cb-692">900 - 8200</span></span>               |
| <span data-ttu-id="f01cb-693">колорвертекс</span><span class="sxs-lookup"><span data-stu-id="f01cb-693">COLORVERTEX</span></span>                          | <span data-ttu-id="f01cb-694">800-7800</span><span class="sxs-lookup"><span data-stu-id="f01cb-694">800 - 7800</span></span>               |
| <span data-ttu-id="f01cb-695">сетлигхт</span><span class="sxs-lookup"><span data-stu-id="f01cb-695">SetLight</span></span>                             | <span data-ttu-id="f01cb-696">2200-5100</span><span class="sxs-lookup"><span data-stu-id="f01cb-696">2200 - 5100</span></span>              |
| <span data-ttu-id="f01cb-697">сеттрансформ</span><span class="sxs-lookup"><span data-stu-id="f01cb-697">SetTransform</span></span>                         | <span data-ttu-id="f01cb-698">3200-3750</span><span class="sxs-lookup"><span data-stu-id="f01cb-698">3200 - 3750</span></span>              |
| <span data-ttu-id="f01cb-699">сетиндицес</span><span class="sxs-lookup"><span data-stu-id="f01cb-699">SetIndices</span></span>                           | <span data-ttu-id="f01cb-700">900-5600</span><span class="sxs-lookup"><span data-stu-id="f01cb-700">900 - 5600</span></span>               |
| <span data-ttu-id="f01cb-701">ШУМА</span><span class="sxs-lookup"><span data-stu-id="f01cb-701">AMBIENT</span></span>                              | <span data-ttu-id="f01cb-702">1150-4800</span><span class="sxs-lookup"><span data-stu-id="f01cb-702">1150 - 4800</span></span>              |
| <span data-ttu-id="f01cb-703">сеттекстуре</span><span class="sxs-lookup"><span data-stu-id="f01cb-703">SetTexture</span></span>                           | <span data-ttu-id="f01cb-704">2500-3100</span><span class="sxs-lookup"><span data-stu-id="f01cb-704">2500 - 3100</span></span>              |
| <span data-ttu-id="f01cb-705">спекуларматериалсаурце</span><span class="sxs-lookup"><span data-stu-id="f01cb-705">SPECULARMATERIALSOURCE</span></span>               | <span data-ttu-id="f01cb-706">900-4600</span><span class="sxs-lookup"><span data-stu-id="f01cb-706">900 - 4600</span></span>               |
| <span data-ttu-id="f01cb-707">емиссивематериалсаурце</span><span class="sxs-lookup"><span data-stu-id="f01cb-707">EMISSIVEMATERIALSOURCE</span></span>               | <span data-ttu-id="f01cb-708">900-4500</span><span class="sxs-lookup"><span data-stu-id="f01cb-708">900 - 4500</span></span>               |
| <span data-ttu-id="f01cb-709">сетматериал</span><span class="sxs-lookup"><span data-stu-id="f01cb-709">SetMaterial</span></span>                          | <span data-ttu-id="f01cb-710">1000-3700</span><span class="sxs-lookup"><span data-stu-id="f01cb-710">1000 - 3700</span></span>              |
| <span data-ttu-id="f01cb-711">зенабле</span><span class="sxs-lookup"><span data-stu-id="f01cb-711">ZENABLE</span></span>                              | <span data-ttu-id="f01cb-712">700-3900</span><span class="sxs-lookup"><span data-stu-id="f01cb-712">700 - 3900</span></span>               |
| <span data-ttu-id="f01cb-713">WRAP0</span><span class="sxs-lookup"><span data-stu-id="f01cb-713">WRAP0</span></span>                                | <span data-ttu-id="f01cb-714">1600-2700</span><span class="sxs-lookup"><span data-stu-id="f01cb-714">1600 - 2700</span></span>              |
| <span data-ttu-id="f01cb-715">минфилтер</span><span class="sxs-lookup"><span data-stu-id="f01cb-715">MINFILTER</span></span>                            | <span data-ttu-id="f01cb-716">1700-2500</span><span class="sxs-lookup"><span data-stu-id="f01cb-716">1700 - 2500</span></span>              |
| <span data-ttu-id="f01cb-717">магфилтер</span><span class="sxs-lookup"><span data-stu-id="f01cb-717">MAGFILTER</span></span>                            | <span data-ttu-id="f01cb-718">1700-2400</span><span class="sxs-lookup"><span data-stu-id="f01cb-718">1700 - 2400</span></span>              |
| <span data-ttu-id="f01cb-719">Сетвертексшадерконстант (1 константа)</span><span class="sxs-lookup"><span data-stu-id="f01cb-719">SetVertexShaderConstant (1 Constant)</span></span> | <span data-ttu-id="f01cb-720">1000-2700</span><span class="sxs-lookup"><span data-stu-id="f01cb-720">1000 - 2700</span></span>              |
| <span data-ttu-id="f01cb-721">колороп</span><span class="sxs-lookup"><span data-stu-id="f01cb-721">COLOROP</span></span>                              | <span data-ttu-id="f01cb-722">1500-2100</span><span class="sxs-lookup"><span data-stu-id="f01cb-722">1500 - 2100</span></span>              |
| <span data-ttu-id="f01cb-723">COLORARG2</span><span class="sxs-lookup"><span data-stu-id="f01cb-723">COLORARG2</span></span>                            | <span data-ttu-id="f01cb-724">1300-2000</span><span class="sxs-lookup"><span data-stu-id="f01cb-724">1300 - 2000</span></span>              |
| <span data-ttu-id="f01cb-725">COLORARG1</span><span class="sxs-lookup"><span data-stu-id="f01cb-725">COLORARG1</span></span>                            | <span data-ttu-id="f01cb-726">1300-1980</span><span class="sxs-lookup"><span data-stu-id="f01cb-726">1300 - 1980</span></span>              |
| <span data-ttu-id="f01cb-727">куллмоде</span><span class="sxs-lookup"><span data-stu-id="f01cb-727">CULLMODE</span></span>                             | <span data-ttu-id="f01cb-728">500-2570</span><span class="sxs-lookup"><span data-stu-id="f01cb-728">500 - 2570</span></span>               |
| <span data-ttu-id="f01cb-729">ВЫРЕЗАЯ</span><span class="sxs-lookup"><span data-stu-id="f01cb-729">CLIPPING</span></span>                             | <span data-ttu-id="f01cb-730">500-2550</span><span class="sxs-lookup"><span data-stu-id="f01cb-730">500 - 2550</span></span>               |
| <span data-ttu-id="f01cb-731">дравиндекседпримитиве</span><span class="sxs-lookup"><span data-stu-id="f01cb-731">DrawIndexedPrimitive</span></span>                 | <span data-ttu-id="f01cb-732">1200-1400</span><span class="sxs-lookup"><span data-stu-id="f01cb-732">1200 - 1400</span></span>              |
| <span data-ttu-id="f01cb-733">аддрессв</span><span class="sxs-lookup"><span data-stu-id="f01cb-733">ADDRESSV</span></span>                             | <span data-ttu-id="f01cb-734">1090-1500</span><span class="sxs-lookup"><span data-stu-id="f01cb-734">1090 - 1500</span></span>              |
| <span data-ttu-id="f01cb-735">аддрессу</span><span class="sxs-lookup"><span data-stu-id="f01cb-735">ADDRESSU</span></span>                             | <span data-ttu-id="f01cb-736">1070-1500</span><span class="sxs-lookup"><span data-stu-id="f01cb-736">1070 - 1500</span></span>              |
| <span data-ttu-id="f01cb-737">дравпримитиве</span><span class="sxs-lookup"><span data-stu-id="f01cb-737">DrawPrimitive</span></span>                        | <span data-ttu-id="f01cb-738">1050-1150</span><span class="sxs-lookup"><span data-stu-id="f01cb-738">1050 - 1150</span></span>              |
| <span data-ttu-id="f01cb-739">сргбтекстуре</span><span class="sxs-lookup"><span data-stu-id="f01cb-739">SRGBTEXTURE</span></span>                          | <span data-ttu-id="f01cb-740">150-1500</span><span class="sxs-lookup"><span data-stu-id="f01cb-740">150 - 1500</span></span>               |
| <span data-ttu-id="f01cb-741">стенЦилмаск</span><span class="sxs-lookup"><span data-stu-id="f01cb-741">STENCILMASK</span></span>                          | <span data-ttu-id="f01cb-742">570-700</span><span class="sxs-lookup"><span data-stu-id="f01cb-742">570 - 700</span></span>                |
| <span data-ttu-id="f01cb-743">стенЦилзфаил</span><span class="sxs-lookup"><span data-stu-id="f01cb-743">STENCILZFAIL</span></span>                         | <span data-ttu-id="f01cb-744">500-800</span><span class="sxs-lookup"><span data-stu-id="f01cb-744">500 - 800</span></span>                |
| <span data-ttu-id="f01cb-745">стенЦилреф</span><span class="sxs-lookup"><span data-stu-id="f01cb-745">STENCILREF</span></span>                           | <span data-ttu-id="f01cb-746">550-700</span><span class="sxs-lookup"><span data-stu-id="f01cb-746">550 - 700</span></span>                |
| <span data-ttu-id="f01cb-747">алфабленденабле</span><span class="sxs-lookup"><span data-stu-id="f01cb-747">ALPHABLENDENABLE</span></span>                     | <span data-ttu-id="f01cb-748">550-700</span><span class="sxs-lookup"><span data-stu-id="f01cb-748">550 - 700</span></span>                |
| <span data-ttu-id="f01cb-749">стенЦилфунк</span><span class="sxs-lookup"><span data-stu-id="f01cb-749">STENCILFUNC</span></span>                          | <span data-ttu-id="f01cb-750">560-680</span><span class="sxs-lookup"><span data-stu-id="f01cb-750">560 - 680</span></span>                |
| <span data-ttu-id="f01cb-751">стенЦилвритемаск</span><span class="sxs-lookup"><span data-stu-id="f01cb-751">STENCILWRITEMASK</span></span>                     | <span data-ttu-id="f01cb-752">520-700</span><span class="sxs-lookup"><span data-stu-id="f01cb-752">520 - 700</span></span>                |
| <span data-ttu-id="f01cb-753">стенЦилфаил</span><span class="sxs-lookup"><span data-stu-id="f01cb-753">STENCILFAIL</span></span>                          | <span data-ttu-id="f01cb-754">500-750</span><span class="sxs-lookup"><span data-stu-id="f01cb-754">500 - 750</span></span>                |
| <span data-ttu-id="f01cb-755">зфунк</span><span class="sxs-lookup"><span data-stu-id="f01cb-755">ZFUNC</span></span>                                | <span data-ttu-id="f01cb-756">510-700</span><span class="sxs-lookup"><span data-stu-id="f01cb-756">510 - 700</span></span>                |
| <span data-ttu-id="f01cb-757">звритинабле</span><span class="sxs-lookup"><span data-stu-id="f01cb-757">ZWRITEENABLE</span></span>                         | <span data-ttu-id="f01cb-758">520-680</span><span class="sxs-lookup"><span data-stu-id="f01cb-758">520 - 680</span></span>                |
| <span data-ttu-id="f01cb-759">стенЦиленабле</span><span class="sxs-lookup"><span data-stu-id="f01cb-759">STENCILENABLE</span></span>                        | <span data-ttu-id="f01cb-760">540-650</span><span class="sxs-lookup"><span data-stu-id="f01cb-760">540 - 650</span></span>                |
| <span data-ttu-id="f01cb-761">стенЦилпасс</span><span class="sxs-lookup"><span data-stu-id="f01cb-761">STENCILPASS</span></span>                          | <span data-ttu-id="f01cb-762">560-630</span><span class="sxs-lookup"><span data-stu-id="f01cb-762">560 - 630</span></span>                |
| <span data-ttu-id="f01cb-763">сркбленд</span><span class="sxs-lookup"><span data-stu-id="f01cb-763">SRCBLEND</span></span>                             | <span data-ttu-id="f01cb-764">500-685</span><span class="sxs-lookup"><span data-stu-id="f01cb-764">500 - 685</span></span>                |
| <span data-ttu-id="f01cb-765">Двусторонняя \_ \_ стенЦилмоде</span><span class="sxs-lookup"><span data-stu-id="f01cb-765">Two\_Sided\_StencilMODE</span></span>              | <span data-ttu-id="f01cb-766">450-590</span><span class="sxs-lookup"><span data-stu-id="f01cb-766">450 - 590</span></span>                |
| <span data-ttu-id="f01cb-767">алфатестенабле</span><span class="sxs-lookup"><span data-stu-id="f01cb-767">ALPHATESTENABLE</span></span>                      | <span data-ttu-id="f01cb-768">470-525</span><span class="sxs-lookup"><span data-stu-id="f01cb-768">470 - 525</span></span>                |
| <span data-ttu-id="f01cb-769">алфареф</span><span class="sxs-lookup"><span data-stu-id="f01cb-769">ALPHAREF</span></span>                             | <span data-ttu-id="f01cb-770">460-530</span><span class="sxs-lookup"><span data-stu-id="f01cb-770">460 - 530</span></span>                |
| <span data-ttu-id="f01cb-771">алфафунк</span><span class="sxs-lookup"><span data-stu-id="f01cb-771">ALPHAFUNC</span></span>                            | <span data-ttu-id="f01cb-772">450-540</span><span class="sxs-lookup"><span data-stu-id="f01cb-772">450 - 540</span></span>                |
| <span data-ttu-id="f01cb-773">дестбленд</span><span class="sxs-lookup"><span data-stu-id="f01cb-773">DESTBLEND</span></span>                            | <span data-ttu-id="f01cb-774">475-510</span><span class="sxs-lookup"><span data-stu-id="f01cb-774">475 - 510</span></span>                |
| <span data-ttu-id="f01cb-775">колорвритинабле</span><span class="sxs-lookup"><span data-stu-id="f01cb-775">COLORWRITEENABLE</span></span>                     | <span data-ttu-id="f01cb-776">465-515</span><span class="sxs-lookup"><span data-stu-id="f01cb-776">465 - 515</span></span>                |
| <span data-ttu-id="f01cb-777">\_СТЕНЦИЛФАИЛ CCW</span><span class="sxs-lookup"><span data-stu-id="f01cb-777">CCW\_STENCILFAIL</span></span>                     | <span data-ttu-id="f01cb-778">340-560</span><span class="sxs-lookup"><span data-stu-id="f01cb-778">340 - 560</span></span>                |
| <span data-ttu-id="f01cb-779">\_СТЕНЦИЛПАСС CCW</span><span class="sxs-lookup"><span data-stu-id="f01cb-779">CCW\_STENCILPASS</span></span>                     | <span data-ttu-id="f01cb-780">340-545</span><span class="sxs-lookup"><span data-stu-id="f01cb-780">340 - 545</span></span>                |
| <span data-ttu-id="f01cb-781">\_СТЕНЦИЛЗФАИЛ CCW</span><span class="sxs-lookup"><span data-stu-id="f01cb-781">CCW\_STENCILZFAIL</span></span>                    | <span data-ttu-id="f01cb-782">330-495</span><span class="sxs-lookup"><span data-stu-id="f01cb-782">330 - 495</span></span>                |
| <span data-ttu-id="f01cb-783">сЦиссортестенабле</span><span class="sxs-lookup"><span data-stu-id="f01cb-783">SCISSORTESTENABLE</span></span>                    | <span data-ttu-id="f01cb-784">375-440</span><span class="sxs-lookup"><span data-stu-id="f01cb-784">375 - 440</span></span>                |
| <span data-ttu-id="f01cb-785">\_СТЕНЦИЛФУНК CCW</span><span class="sxs-lookup"><span data-stu-id="f01cb-785">CCW\_STENCILFUNC</span></span>                     | <span data-ttu-id="f01cb-786">250-480</span><span class="sxs-lookup"><span data-stu-id="f01cb-786">250 - 480</span></span>                |
| <span data-ttu-id="f01cb-787">сетсЦиссоррект</span><span class="sxs-lookup"><span data-stu-id="f01cb-787">SetScissorRect</span></span>                       | <span data-ttu-id="f01cb-788">150-340</span><span class="sxs-lookup"><span data-stu-id="f01cb-788">150 - 340</span></span>                |



 

## <a name="related-topics"></a><span data-ttu-id="f01cb-789">См. также</span><span class="sxs-lookup"><span data-stu-id="f01cb-789">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f01cb-790">Дополнительные разделы</span><span class="sxs-lookup"><span data-stu-id="f01cb-790">Advanced Topics</span></span>](advanced-topics.md)
</dt> </dl>

 

 
