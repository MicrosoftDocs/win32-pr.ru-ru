---
description: При отрисовке двумерных выходных данных с помощью предварительно преобразованных вершин необходимо соблюдать осторожность, чтобы каждая область шаг текселя правильно соответствовала одной области пикселя, в противном случае может произойти искажение текстур.
ms.assetid: 6faeb1e3-ea6e-4cb1-a1e6-2a9a81b4c0c7
title: Прямое сопоставление пикселей текстуры с пикселами (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5f86e9d05acff402128ddb83fc97898ff6a21d7c
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104262407"
---
# <a name="directly-mapping-texels-to-pixels-direct3d-9"></a>Прямое сопоставление пикселей текстуры с пикселами (Direct3D 9)

При отрисовке двумерных выходных данных с помощью предварительно преобразованных вершин необходимо соблюдать осторожность, чтобы каждая область шаг текселя правильно соответствовала одной области пикселя, в противном случае может произойти искажение текстур. Изменяя основные принципы процесса, который используется Direct3D для растрирования и текстурирования треугольников, можно убедиться, что приложение Direct3D правильно отображает 2D-выходные данные.

![Иллюстрация экрана разрешения 6x6](images/maptex-fig1.png)

На предыдущей диаграмме показаны пиксели, смоделированные как квадраты. Однако в реальности Пиксели — это точки, а не квадраты. Каждый квадрат на предыдущей схеме указывает область, освещенную пикселю, но пиксель всегда является точкой в центре квадрата. Это различие, хотя и кажется небольшим, очень важно. На следующей схеме показана более высокая иллюстрация того же отображения.

![Иллюстрация экрана, состоящего из пикселей](images/maptex-fig2.png)

На предыдущей схеме каждый физический пиксель отображается правильно в качестве точки в центре каждой ячейки. Координата экранного пространства (0, 0) расположена непосредственно в левом верхнем углу и, следовательно, в центре верхней левой ячейки. Таким образом, левый верхний угол отображается в (-0,5,-0,5), так как он равен 0,5 ячейки слева и 0,5 ячейки вверх от верхнего левого пикселя. Direct3D выполнит четыре угла с углами в (0, 0) и (4, 4), как показано на следующем рисунке.

![Иллюстрация нерастрового изображения с четырьмя значениями (0, 0) и (4, 4)](images/maptex-fig3.png)

На предыдущем рисунке показано, где математические четыре приводятся к отображению, но не показывают, что четыре будут выглядеть, как только Direct3D преобразует его и отправляет на экран. На самом деле, Растровое изображение невозможно заполнить четырьмя, как показано, так как края четырех не совпадают с границами между ячейками в пикселях. Иными словами, поскольку каждый пиксель может отображать только один цвет, каждая ячейка пикселя заполняется только одним цветом. Если отрисовка отображалась в точности так, как показано, то в точках с четырьмя краями должно отобразиться два различных цвета: синий, где покрывается только фон.

Вместо этого для графического оборудования устанавливается определение пикселов, которые должны быть приблизительны на четыре. Этот процесс называется растрирование и подробно описан в [правилах растрирования (Direct3D 9)](rasterization-rules.md). В этом конкретном случае растровое восданное изображение показано на следующем рисунке.

![Иллюстрация нетекстурной нерисованной части (от 0, 0) до (4, 4)](images/maptex-fig4.png)

Обратите внимание, что четыре, передаваемые Direct3D, имеют углы в (0, 0) и (4, 4), но растровые выходные данные (на предыдущем рисунке) имеют углы в (-0.5,-0,5) и (3,5, 3,5). Сравните два приведенных выше рисунка с различиями в отрисовке. Видно, что отображаемые на самом деле изображения имеют правильный размер, но были смещены на 0,5 ячеек в направлениях x и y. Тем не менее, за исключением многофакторной выборки, это лучшее приближение к четырем. (Дополнительные сведения о множественной выборки см. в [примере антипсевдонима](https://msdn.microsoft.com/library/Ee415231(v=VS.85).aspx) .) Имейте в виду, что если средство программной прорисовки заполнило каждую ячейку с четырьмя перекрестными крестиками, результирующая область будет иметь размер 5 x 5 вместо требуемых 4 x 4.

Если предполагается, что экранные координаты поступают в верхний левый угол сетки отображения вместо верхнего левого пикселя, четыре будут выглядеть точно так, как ожидалось. Тем не менее, разница становится ясной, когда для Quad задается текстура. На следующем рисунке показана текстура 4 x 4, которая будет напрямую сопоставлена с четырьмя.

![Иллюстрация текстуры 4x4](images/maptex-fig5.png)

Так как текстура имеет 4 x 4 пикселей текстуры, а четыре – 4 x 4 пикселя, то, возможно, вы, вероятно, предполагалось, что все, что может показаться, выглядит точно так же, как текстура, независимо от расположения на экране, где нарисована Quad Однако это не так. даже небольшие изменения в положении влияют на отображение текстуры. На следующем рисунке показано, как четыре между (0, 0) и (4, 4) отображаются после растрирования и текстурирования.

![Иллюстрация восрисованной четырехъядерной части (0, 0) и (4, 4)](images/maptex-fig6.png)

На предыдущем рисунке показана Текстурная прорисовка (с режимом линейной фильтрации и режимом адресации в виде вектора) с наложенным растровым контуром. В оставшейся части этой статьи объясняется, почему выходные данные выглядят так, как это делается вместо текстуры, но для тех, кто хочет решить это решение: края входных данных должны находиться на границах линий между ячейками. Путем простого сдвига координат x и y на единицу-0,5, шаг текселя ячейки будут полностью раскрывать пикселные ячейки, а четыре могут быть вполне воссозданы на экране. (Последнее изображение в этом разделе показывает четыре по исправленным координатам.)

Сведения о том, почему растровые выходные данные имеют незначительное сходство с текстурой ввода, напрямую связаны с тем, как Direct3D решает и выбирает текстуры. Далее предполагается, что вы хорошо понимаете [пространство координат текстуры](texture-coordinates.md) и [билинейнойную фильтрацию текстур](bilinear-texture-filtering.md).

Вернемся к нашему исследованию странного вывода пикселов, имеет смысл отследить выходной цвет обратно в шейдер пикселей: построитель текстуры вызывается для каждого пикселя, выделенного как часть растровой фигуры. Сплошной синий объект, изображенный на предыдущем рисунке, может иметь особенно простой шейдер:


```
float4 SolidBluePS() : COLOR
{ 
    return float4( 0, 0, 1, 1 );
} 
```



Для четырехъядерного построителя текстуры необходимо немного изменить:


```
texture MyTexture;

sampler MySampler = 
sampler_state 
{ 
    Texture = <MyTexture>;
    MinFilter = Linear;
    MagFilter = Linear;
    AddressU = Clamp;
    AddressV = Clamp;
};

float4 TextureLookupPS( float2 vTexCoord : TEXCOORD0 ) : COLOR
{
    return tex2D( MySampler, vTexCoord );
} 
```



Этот код предполагает, что текстура 4 x 4 хранится в Митекстуре. Как показано ниже, образец текстуры Мисамплер настроен на выполнение фильтрации билинейной на Митекстуре. Построитель текстуры вызывается один раз для каждого растрового пикселя, и каждый раз, когда возвращенный цвет представляет собой образец цвета текстуры в Втекскурд. Каждый раз при вызове шейдера пикселей аргумент Втекскурд устанавливается в координаты текстуры в этом пикселе. Это означает, что шейдер запрашивает образец текстуры для фильтрованного цвета текстуры в определенном месте пикселя, как описано на следующем рисунке.

![Иллюстрация расположения выборки для координат текстуры](images/maptex-fig7.png)

Текстура (показана наложенная) выводится непосредственно в положениях пикселов (показанных в виде черных точек). Растровые координаты не зависят от растрирования (они остаются в проектируемом пространстве исходного экрана). Черные точки показывают, где находятся пикселы растрирования. Координаты текстуры на каждом пикселе легко определяются путем интерполяции координат, хранящихся на каждой вершине: пиксель в (0, 0) совпадает с вершиной в (0, 0); Таким образом, координаты текстуры в этом пикселе представляют собой просто координаты текстуры, хранящиеся на этой вершине, UV (0,0, 0,0). Для пикселя в (3, 1) для интерполяции используются UV (0,75, 0,25), так как этот пиксель расположен в трех четвертях от ширины текстуры и одна четвертая из ее высоты. Эти интерполяции координат передаются в шейдер пикселей.

Пикселей текстуры не выровнять с пикселями в этом примере; Каждый пиксель (и, следовательно, каждая точка выборки) располагается в углу четырех пикселей текстуры. Так как для режима фильтрации задано значение линейная, в этом образце будут средниеся цвета четырех пикселей текстуры, совместно использующих этот угол. Это объясняется тем, почему пиксел, ожидаемый красным, на деле состоит из трех четвертых оттенков серого и 1-Четвертый красный, пиксел, который должен быть зеленым, — половина серого плюс один четвертый красный плюс один четвертый зеленый и т. д.

Чтобы устранить эту проблему, все, что необходимо сделать, правильно соотнесение к пикселям, на которые она будет растрирования, и таким образом правильно соотнести пикселей текстуры с пикселами. На следующем рисунке показаны результаты рисования одних и тех же четырех чисел (-0,5,-0,5) и (3,5, 3,5), которые являются четырехъядерными.

![Рисунок с изображением четырех, которые соответствуют растровым четырем](images/maptex-fig8.png)

На предыдущем рисунке показано, что четыре (показанные от (-0,5,-0,5) до (3,5, 3,5)) точно соответствуют растровой области.

## <a name="summary"></a>Сводка

В целом, Пиксели и пикселей текстуры фактически являются точками, а не сплошными блоками. Область экрана находится в левом верхнем углу, но Координата текстуры начинается в левом верхнего угла сетки текстуры. Что важнее всего, не забывайте вычитать единицы 0,5 из компонентов x и y положений вершин при работе с преобразованным экранным пространством для правильного совмещения пикселей текстуры с пикселами.

Следующий код представляет собой пример смещения вершин в 256 на 256 квадрата для правильного отображения в преобразованном экране текстуры 256 by 256.


```C++
//define FVF with vertex values in transformed screen space
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)

struct CUSTOMVERTEX
{
    FLOAT x, y, z, rhw; // position
    FLOAT tu, tv;       // texture coordinates
};

//unadjusted vertex values
float left = 0.0f;
float right = 255.0f;
float top = 0.0f;
float bottom = 255.0f;


//256 by 256 rectangle matching 256 by 256 texture
CUSTOMVERTEX vertices[] =
{
    { left,  top,    0.5f, 1.0f, 0.0f, 0.0f}, // x, y, z, rhw, u, v
    { right, top,    0.5f, 1.0f, 1.0f, 0.0f},
    { right, bottom, 0.5f, 1.0f, 1.0f, 1.0f},
    { left,  top,    0.5f, 1.0f, 0.0f, 0.0f},
    { right, bottom, 0.5f, 1.0f, 1.0f, 1.0f},
    { left,  bottom, 0.5f, 1.0f, 0.0f, 1.0f},
    
};
```




```C++
//adjust all the vertices to correctly line up texels with pixels 
for (int i=0; i<6; i++)
{
    vertices[i].x -= 0.5f;
    vertices[i].y -= 0.5f;
}
```



## <a name="related-topics"></a>См. также

<dl> <dt>

[Координаты текстуры](texture-coordinates.md)
</dt> </dl>

 

 



