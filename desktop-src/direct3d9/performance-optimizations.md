---
description: Все разработчики, создающие приложения в режиме реального времени, использующие трехмерную график, связаны с оптимизацией производительности. В этом разделе приводятся рекомендации по повышению производительности кода.
ms.assetid: 074f848e-4a42-48a2-adf7-4026b8967413
title: Оптимизация производительности (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4d42be994522f0d83e36387b1a5866b3eee10df3
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104494271"
---
# <a name="performance-optimizations-direct3d-9"></a><span data-ttu-id="bffa1-104">Оптимизация производительности (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="bffa1-104">Performance Optimizations (Direct3D 9)</span></span>

<span data-ttu-id="bffa1-105">Все разработчики, создающие приложения в режиме реального времени, использующие трехмерную график, связаны с оптимизацией производительности.</span><span class="sxs-lookup"><span data-stu-id="bffa1-105">Every developer who creates real-time applications that use 3D graphics is concerned about performance optimization.</span></span> <span data-ttu-id="bffa1-106">В этом разделе приводятся рекомендации по повышению производительности кода.</span><span class="sxs-lookup"><span data-stu-id="bffa1-106">This section provides guidelines for getting the best performance from your code.</span></span>

-   [<span data-ttu-id="bffa1-107">Общие советы по повышению производительности</span><span class="sxs-lookup"><span data-stu-id="bffa1-107">General Performance Tips</span></span>](#general-performance-tips)
-   [<span data-ttu-id="bffa1-108">Базы данных и отбор</span><span class="sxs-lookup"><span data-stu-id="bffa1-108">Databases and Culling</span></span>](#databases-and-culling)
-   [<span data-ttu-id="bffa1-109">Пакетные примитивы</span><span class="sxs-lookup"><span data-stu-id="bffa1-109">Batching Primitives</span></span>](#batching-primitives)
-   [<span data-ttu-id="bffa1-110">Советы по освещению</span><span class="sxs-lookup"><span data-stu-id="bffa1-110">Lighting Tips</span></span>](#lighting-tips)
-   [<span data-ttu-id="bffa1-111">Размер текстуры</span><span class="sxs-lookup"><span data-stu-id="bffa1-111">Texture Size</span></span>](#texture-size)
-   [<span data-ttu-id="bffa1-112">Преобразования матрицы</span><span class="sxs-lookup"><span data-stu-id="bffa1-112">Matrix Transforms</span></span>](#matrix-transforms)
-   [<span data-ttu-id="bffa1-113">Использование динамических текстур</span><span class="sxs-lookup"><span data-stu-id="bffa1-113">Using Dynamic Textures</span></span>](#using-dynamic-textures)
-   [<span data-ttu-id="bffa1-114">Использование динамических буферов вершин и индексов</span><span class="sxs-lookup"><span data-stu-id="bffa1-114">Using Dynamic Vertex and Index Buffers</span></span>](#using-dynamic-vertex-and-index-buffers)
-   [<span data-ttu-id="bffa1-115">Использование сеток</span><span class="sxs-lookup"><span data-stu-id="bffa1-115">Using Meshes</span></span>](#using-meshes)
-   [<span data-ttu-id="bffa1-116">Производительность буфера Z</span><span class="sxs-lookup"><span data-stu-id="bffa1-116">Z-Buffer Performance</span></span>](#z-buffer-performance)

## <a name="general-performance-tips"></a><span data-ttu-id="bffa1-117">Общие советы по повышению производительности</span><span class="sxs-lookup"><span data-stu-id="bffa1-117">General Performance Tips</span></span>

-   <span data-ttu-id="bffa1-118">Очистить только при необходимости.</span><span class="sxs-lookup"><span data-stu-id="bffa1-118">Clear only when you must.</span></span>
-   <span data-ttu-id="bffa1-119">Сократите изменения состояния и сгруппируйте изменения в оставшейся области.</span><span class="sxs-lookup"><span data-stu-id="bffa1-119">Minimize state changes and group the remaining state changes.</span></span>
-   <span data-ttu-id="bffa1-120">Если это возможно, используйте небольшие текстуры.</span><span class="sxs-lookup"><span data-stu-id="bffa1-120">Use smaller textures, if you can do so.</span></span>
-   <span data-ttu-id="bffa1-121">Рисование объектов в сцене с начала до конца.</span><span class="sxs-lookup"><span data-stu-id="bffa1-121">Draw objects in your scene from front to back.</span></span>
-   <span data-ttu-id="bffa1-122">Используйте ленты треугольников вместо списков и вентиляторов.</span><span class="sxs-lookup"><span data-stu-id="bffa1-122">Use triangle strips instead of lists and fans.</span></span> <span data-ttu-id="bffa1-123">Для оптимальной производительности кэша вершин разместите полосы для повторного использования вершин треугольников быстрее, а не позже.</span><span class="sxs-lookup"><span data-stu-id="bffa1-123">For optimal vertex cache performance, arrange strips to reuse triangle vertices sooner, rather than later.</span></span>
-   <span data-ttu-id="bffa1-124">Аккуратное снижение специальных эффектов, требующих непропорционального использования системных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="bffa1-124">Gracefully degrade special effects that require a disproportionate share of system resources.</span></span>
-   <span data-ttu-id="bffa1-125">Постоянно тестируйте производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="bffa1-125">Constantly test your application's performance.</span></span>
-   <span data-ttu-id="bffa1-126">Уменьшение параметров буфера вершин.</span><span class="sxs-lookup"><span data-stu-id="bffa1-126">Minimize vertex buffer switches.</span></span>
-   <span data-ttu-id="bffa1-127">По возможности используйте статические буферы вершин.</span><span class="sxs-lookup"><span data-stu-id="bffa1-127">Use static vertex buffers where possible.</span></span>
-   <span data-ttu-id="bffa1-128">Используйте один большой статический буфер вершин на ФВФ для статических объектов, а не по одному на каждый объект.</span><span class="sxs-lookup"><span data-stu-id="bffa1-128">Use one large static vertex buffer per FVF for static objects, rather than one per object.</span></span>
-   <span data-ttu-id="bffa1-129">Если приложению требуется произвольный доступ к буферу вершин в памяти AGP, выберите размер формата вершин, кратный 32 байт.</span><span class="sxs-lookup"><span data-stu-id="bffa1-129">If your application needs random access into the vertex buffer in AGP memory, choose a vertex format size that is a multiple of 32 bytes.</span></span> <span data-ttu-id="bffa1-130">В противном случае выберите наименьший подходящий формат.</span><span class="sxs-lookup"><span data-stu-id="bffa1-130">Otherwise, select the smallest appropriate format.</span></span>
-   <span data-ttu-id="bffa1-131">Рисование с помощью индексированных примитивов.</span><span class="sxs-lookup"><span data-stu-id="bffa1-131">Draw using indexed primitives.</span></span> <span data-ttu-id="bffa1-132">Это может обеспечить более эффективное кэширование вершин в оборудовании.</span><span class="sxs-lookup"><span data-stu-id="bffa1-132">This can allow for more efficient vertex caching within hardware.</span></span>
-   <span data-ttu-id="bffa1-133">Если формат буфера глубины содержит канал набора элементов, всегда снимайте каналы глубины и шаблона одновременно.</span><span class="sxs-lookup"><span data-stu-id="bffa1-133">If the depth buffer format contains a stencil channel, always clear the depth and stencil channels at the same time.</span></span>
-   <span data-ttu-id="bffa1-134">По возможности объедините инструкцию шейдера и выходные данные.</span><span class="sxs-lookup"><span data-stu-id="bffa1-134">Combine the shader instruction and the data output where possible.</span></span> <span data-ttu-id="bffa1-135">Пример:</span><span class="sxs-lookup"><span data-stu-id="bffa1-135">For example:</span></span>
    ```
    // Rather than doing a multiply and add, and then output the data with 
    //   two instructions:
    mad r2, r1, v0, c0
    mov oD0, r2

    // Combine both in a single instruction, because this eliminates an  
    //   additional register copy.
    mad oD0, r1, v0, c0 
    ```

    

## <a name="databases-and-culling"></a><span data-ttu-id="bffa1-136">Базы данных и отбор</span><span class="sxs-lookup"><span data-stu-id="bffa1-136">Databases and Culling</span></span>

<span data-ttu-id="bffa1-137">Создание надежной базы данных объектов в мире — это ключевая высокая производительность в Direct3D.</span><span class="sxs-lookup"><span data-stu-id="bffa1-137">Building a reliable database of the objects in your world is key to excellent performance in Direct3D.</span></span> <span data-ttu-id="bffa1-138">Это важнее, чем усовершенствования растрирования или оборудования.</span><span class="sxs-lookup"><span data-stu-id="bffa1-138">It is more important than improvements to rasterization or hardware.</span></span>

<span data-ttu-id="bffa1-139">Вы должны поддерживать наименьшее количество многоугольников, которое можно управлять.</span><span class="sxs-lookup"><span data-stu-id="bffa1-139">You should maintain the lowest polygon count you can possibly manage.</span></span> <span data-ttu-id="bffa1-140">Проектирование с небольшим количеством многоугольников путем создания моделей с низким многоугольником с начала.</span><span class="sxs-lookup"><span data-stu-id="bffa1-140">Design for a low polygon count by building low-polygon models from the start.</span></span> <span data-ttu-id="bffa1-141">Добавьте многоугольники, если это возможно, не снижая производительность в процессе разработки.</span><span class="sxs-lookup"><span data-stu-id="bffa1-141">Add polygons if you can do so without sacrificing performance later in the development process.</span></span> <span data-ttu-id="bffa1-142">Помните, что самые быстрые многоугольники — это те, которые не рисуются.</span><span class="sxs-lookup"><span data-stu-id="bffa1-142">Remember, the fastest polygons are the ones you don't draw.</span></span>

## <a name="batching-primitives"></a><span data-ttu-id="bffa1-143">Пакетные примитивы</span><span class="sxs-lookup"><span data-stu-id="bffa1-143">Batching Primitives</span></span>

<span data-ttu-id="bffa1-144">Чтобы обеспечить наилучшую производительность отрисовки во время выполнения, попробуйте работать с примитивами в пакетах и обеспечить минимально возможное количество изменений состояния визуализации.</span><span class="sxs-lookup"><span data-stu-id="bffa1-144">To get the best rendering performance during execution, try to work with primitives in batches and keep the number of render-state changes as low as possible.</span></span> <span data-ttu-id="bffa1-145">Например, если у вас есть объект с двумя текстурами, сгруппируйте треугольники, использующие первую текстуру, и следуйте им, чтобы изменить текстуру с помощью нужного состояния рендеринга.</span><span class="sxs-lookup"><span data-stu-id="bffa1-145">For example, if you have an object with two textures, group the triangles that use the first texture and follow them with the necessary render state to change the texture.</span></span> <span data-ttu-id="bffa1-146">Затем сгруппируйте все треугольники, которые используют вторую текстуру.</span><span class="sxs-lookup"><span data-stu-id="bffa1-146">Then group all the triangles that use the second texture.</span></span> <span data-ttu-id="bffa1-147">Простейшая аппаратная поддержка Direct3D вызвана пакетами состояний отрисовки и пакетами примитивов через слой абстрагирования оборудования (HAL).</span><span class="sxs-lookup"><span data-stu-id="bffa1-147">The simplest hardware support for Direct3D is called with batches of render states and batches of primitives through the hardware abstraction layer (HAL).</span></span> <span data-ttu-id="bffa1-148">Чем более эффективно Пакетная обработка инструкций, тем меньше вызовов HAL выполняется во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="bffa1-148">The more effectively the instructions are batched, the fewer HAL calls are performed during execution.</span></span>

## <a name="lighting-tips"></a><span data-ttu-id="bffa1-149">Советы по освещению</span><span class="sxs-lookup"><span data-stu-id="bffa1-149">Lighting Tips</span></span>

<span data-ttu-id="bffa1-150">Так как источники света добавляют стоимость за вершину к каждому отображаемому кадру, производительность может значительно повыситься, так как они используются в приложении.</span><span class="sxs-lookup"><span data-stu-id="bffa1-150">Because lights add a per-vertex cost to each rendered frame, you can improve performance significantly by being careful about how you use them in your application.</span></span> <span data-ttu-id="bffa1-151">Большинство из следующих советов являются производными от мА, «самый быстрый код — это код, который никогда не вызывается».</span><span class="sxs-lookup"><span data-stu-id="bffa1-151">Most of the following tips derive from the maxim, "the fastest code is code that is never called."</span></span>

-   <span data-ttu-id="bffa1-152">Используйте как можно меньше источников освещения.</span><span class="sxs-lookup"><span data-stu-id="bffa1-152">Use as few light sources as possible.</span></span> <span data-ttu-id="bffa1-153">Чтобы увеличить общий уровень освещения, например, используйте внешний свет вместо добавления нового источника света.</span><span class="sxs-lookup"><span data-stu-id="bffa1-153">To increase the overall lighting level, for example, use the ambient light instead of adding a new light source.</span></span>
-   <span data-ttu-id="bffa1-154">Направленный свет более эффективен, чем световые индикаторы или прожекторы.</span><span class="sxs-lookup"><span data-stu-id="bffa1-154">Directional lights are more efficient than point lights or spotlights.</span></span> <span data-ttu-id="bffa1-155">Для направленного освещения направление света фиксировано, и его не нужно рассчитывать на основе вершин.</span><span class="sxs-lookup"><span data-stu-id="bffa1-155">For directional lights, the direction to the light is fixed and doesn't need to be calculated on a per-vertex basis.</span></span>
-   <span data-ttu-id="bffa1-156">Прожекторы могут оказаться более эффективными, чем световые источники света, так как быстро вычисляется область за пределами света.</span><span class="sxs-lookup"><span data-stu-id="bffa1-156">Spotlights can be more efficient than point lights, because the area outside the cone of light is calculated quickly.</span></span> <span data-ttu-id="bffa1-157">Является ли прожектор более эффективным или не зависит от того, какая часть сцены освещена фокусом.</span><span class="sxs-lookup"><span data-stu-id="bffa1-157">Whether spotlights are more efficient or not depends on how much of your scene is lit by the spotlight.</span></span>
-   <span data-ttu-id="bffa1-158">Используйте параметр Range, чтобы ограничить свет только частями сцены, которые необходимы для освещения.</span><span class="sxs-lookup"><span data-stu-id="bffa1-158">Use the range parameter to limit your lights to only the parts of the scene you need to illuminate.</span></span> <span data-ttu-id="bffa1-159">Все типы освещения завершают работу довольно рано, если они выходят за пределы диапазона.</span><span class="sxs-lookup"><span data-stu-id="bffa1-159">All the light types exit fairly early when they are out of range.</span></span>
-   <span data-ttu-id="bffa1-160">Отраженные блики почти вдвое изменяют стоимость освещения.</span><span class="sxs-lookup"><span data-stu-id="bffa1-160">Specular highlights almost double the cost of a light.</span></span> <span data-ttu-id="bffa1-161">Используйте их только при необходимости.</span><span class="sxs-lookup"><span data-stu-id="bffa1-161">Use them only when you must.</span></span> <span data-ttu-id="bffa1-162">Задайте \_ для состояния отрисовки D3DRS спекуларенабле значение 0 (по умолчанию), если это возможно.</span><span class="sxs-lookup"><span data-stu-id="bffa1-162">Set the D3DRS\_SPECULARENABLE render state to 0, the default value, whenever possible.</span></span> <span data-ttu-id="bffa1-163">При определении материалов необходимо установить значение отраженной мощности равным нулю, чтобы отключить отраженные блики для этого материала. просто установить для отраженного цвета значение 0, 0, 0 — недостаточно.</span><span class="sxs-lookup"><span data-stu-id="bffa1-163">When defining materials, you must set the specular power value to zero to turn off specular highlights for that material; just setting the specular color to 0,0,0 is not enough.</span></span>

## <a name="texture-size"></a><span data-ttu-id="bffa1-164">Размер текстуры</span><span class="sxs-lookup"><span data-stu-id="bffa1-164">Texture Size</span></span>

<span data-ttu-id="bffa1-165">Производительность сопоставления текстур сильно зависит от скорости памяти.</span><span class="sxs-lookup"><span data-stu-id="bffa1-165">Texture-mapping performance is heavily dependent on the speed of memory.</span></span> <span data-ttu-id="bffa1-166">Существует несколько способов увеличить производительность кэша текстур приложения.</span><span class="sxs-lookup"><span data-stu-id="bffa1-166">There are a number of ways to maximize the cache performance of your application's textures.</span></span>

-   <span data-ttu-id="bffa1-167">Используйте небольшие текстуры.</span><span class="sxs-lookup"><span data-stu-id="bffa1-167">Keep the textures small.</span></span> <span data-ttu-id="bffa1-168">Чем меньше текстуры, тем выше вероятность их поддержки в дополнительном кэше основного ЦП.</span><span class="sxs-lookup"><span data-stu-id="bffa1-168">The smaller the textures are, the better chance they have of being maintained in the main CPU's secondary cache.</span></span>
-   <span data-ttu-id="bffa1-169">Не изменяйте текстуры для отдельных примитивов.</span><span class="sxs-lookup"><span data-stu-id="bffa1-169">Do not change the textures on a per-primitive basis.</span></span> <span data-ttu-id="bffa1-170">Постарайтесь, чтобы многоугольники были сгруппированы по порядку используемых им текстур.</span><span class="sxs-lookup"><span data-stu-id="bffa1-170">Try to keep polygons grouped in order of the textures they use.</span></span>
-   <span data-ttu-id="bffa1-171">При возможности используйте квадратные текстуры.</span><span class="sxs-lookup"><span data-stu-id="bffa1-171">Use square textures whenever possible.</span></span> <span data-ttu-id="bffa1-172">Текстуры, размеры которых являются 256x256, являются самым быстрым.</span><span class="sxs-lookup"><span data-stu-id="bffa1-172">Textures whose dimensions are 256x256 are the fastest.</span></span> <span data-ttu-id="bffa1-173">Например, если ваше приложение использует четыре текстуры 128x128, попробуйте убедиться, что они используют одну и ту же палитру и размещают их в одной 256x256ной текстуре.</span><span class="sxs-lookup"><span data-stu-id="bffa1-173">If your application uses four 128x128 textures, for example, try to ensure that they use the same palette and place them all into one 256x256 texture.</span></span> <span data-ttu-id="bffa1-174">Этот метод также сокращает объем перекачки текстур.</span><span class="sxs-lookup"><span data-stu-id="bffa1-174">This technique also reduces the amount of texture swapping.</span></span> <span data-ttu-id="bffa1-175">Конечно, не следует использовать текстуры 256x256, если приложение не требует интенсивного текстурирования, поскольку, как уже упоминалось, текстуры должны быть максимально маленькими.</span><span class="sxs-lookup"><span data-stu-id="bffa1-175">Of course, you should not use 256x256 textures unless your application requires that much texturing because, as mentioned, textures should be kept as small as possible.</span></span>

## <a name="matrix-transforms"></a><span data-ttu-id="bffa1-176">Преобразования матрицы</span><span class="sxs-lookup"><span data-stu-id="bffa1-176">Matrix Transforms</span></span>

<span data-ttu-id="bffa1-177">Direct3D использует установленные вами мировую матрицу и видовую матрицу для конфигурирования нескольких внутренних структур данных.</span><span class="sxs-lookup"><span data-stu-id="bffa1-177">Direct3D uses the world and view matrices that you set to configure several internal data structures.</span></span> <span data-ttu-id="bffa1-178">Каждый раз, когда вы устанавливаете новую мировую или видовую матрицу, система пересчитывает соответствующие внутренние структуры.</span><span class="sxs-lookup"><span data-stu-id="bffa1-178">Each time you set a new world or view matrix, the system recalculates the associated internal structures.</span></span> <span data-ttu-id="bffa1-179">Частое задание этих матриц, например тысячи раз в кадре, — это вычисление длительного времени.</span><span class="sxs-lookup"><span data-stu-id="bffa1-179">Setting these matrices frequently - for example, thousands of times per frame - is computationally time-consuming.</span></span> <span data-ttu-id="bffa1-180">Свести к минимуму количество необходимых вычислений можно путем конкатенации мировой и видовой матриц в мировую-видовую матрицу, задать ее в качестве мировой матрицы, а затем установить видовую матрицу в единичную.</span><span class="sxs-lookup"><span data-stu-id="bffa1-180">You can minimize the number of required calculations by concatenating your world and view matrices into a world-view matrix that you set as the world matrix, and then setting the view matrix to the identity.</span></span> <span data-ttu-id="bffa1-181">Сохраняйте кэшированные копии отдельных мировых и видовых матриц, чтобы вы могли изменять, объединять и сбрасывать мировую матрицу по необходимости.</span><span class="sxs-lookup"><span data-stu-id="bffa1-181">Keep cached copies of individual world and view matrices so that you can modify, concatenate, and reset the world matrix as needed.</span></span> <span data-ttu-id="bffa1-182">Для ясности в этой документации примеры Direct3D редко используют эту оптимизацию.</span><span class="sxs-lookup"><span data-stu-id="bffa1-182">For clarity in this documentation, Direct3D samples rarely employ this optimization.</span></span>

## <a name="using-dynamic-textures"></a><span data-ttu-id="bffa1-183">Использование динамических текстур</span><span class="sxs-lookup"><span data-stu-id="bffa1-183">Using Dynamic Textures</span></span>

<span data-ttu-id="bffa1-184">Чтобы узнать, поддерживает ли драйвер динамические текстуры, установите \_ флаг D3DCAPS2 динамиктекстурес в структуре [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) .</span><span class="sxs-lookup"><span data-stu-id="bffa1-184">To find out if the driver supports dynamic textures, check the D3DCAPS2\_DYNAMICTEXTURES flag of the [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) structure.</span></span>

<span data-ttu-id="bffa1-185">При работе с динамическими текстурами учитывайте следующие моменты.</span><span class="sxs-lookup"><span data-stu-id="bffa1-185">Keep the following things in mind when working with dynamic textures.</span></span>

-   <span data-ttu-id="bffa1-186">Они не могут управляться.</span><span class="sxs-lookup"><span data-stu-id="bffa1-186">They cannot be managed.</span></span> <span data-ttu-id="bffa1-187">Например, пул не может быть \_ управляемым D3DPOOL.</span><span class="sxs-lookup"><span data-stu-id="bffa1-187">For example, their pool cannot be D3DPOOL\_MANAGED.</span></span>
-   <span data-ttu-id="bffa1-188">Динамические текстуры могут быть заблокированы, даже если они создаются в D3DPOOL \_ по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="bffa1-188">Dynamic textures can be locked, even if they are created in D3DPOOL\_DEFAULT.</span></span>
-   <span data-ttu-id="bffa1-189">D3DLOCK \_ Discard — допустимый флаг блокировки для динамических текстур.</span><span class="sxs-lookup"><span data-stu-id="bffa1-189">D3DLOCK\_DISCARD is a valid lock flag for dynamic textures.</span></span>

<span data-ttu-id="bffa1-190">Рекомендуется создать только одну динамическую текстуру для каждого формата и, возможно, для каждого размера.</span><span class="sxs-lookup"><span data-stu-id="bffa1-190">It is a good idea to create only one dynamic texture per format and possibly per size.</span></span> <span data-ttu-id="bffa1-191">Динамические MIP-карты, Кубы и тома не рекомендуются из-за дополнительных затрат на блокировку каждого уровня.</span><span class="sxs-lookup"><span data-stu-id="bffa1-191">Dynamic mipmaps, cubes, and volumes are not recommended because of the additional overhead in locking every level.</span></span> <span data-ttu-id="bffa1-192">Для MIP-карты D3DLOCK \_ Discard допускается только на верхнем уровне.</span><span class="sxs-lookup"><span data-stu-id="bffa1-192">For mipmaps, D3DLOCK\_DISCARD is allowed only on the top level.</span></span> <span data-ttu-id="bffa1-193">Все уровни отбрасываются путем блокировки только верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="bffa1-193">All levels are discarded by locking just the top level.</span></span> <span data-ttu-id="bffa1-194">Это поведение одинаково для томов и кубов.</span><span class="sxs-lookup"><span data-stu-id="bffa1-194">This behavior is the same for volumes and cubes.</span></span> <span data-ttu-id="bffa1-195">Для кубов верхний уровень и лицевая стороны 0 заблокированы.</span><span class="sxs-lookup"><span data-stu-id="bffa1-195">For cubes, the top level and face 0 are locked.</span></span>

<span data-ttu-id="bffa1-196">В следующем псевдокоде показан пример использования динамической текстуры.</span><span class="sxs-lookup"><span data-stu-id="bffa1-196">The following pseudocode shows an example of using a dynamic texture.</span></span>


```
DrawProceduralTexture(pTex)
{
    // pTex should not be very small because overhead of 
    //   calling driver every D3DLOCK_DISCARD will not 
    //   justify the performance gain. Experimentation is encouraged.
    pTex->Lock(D3DLOCK_DISCARD);
    <Overwrite *entire* texture>
    pTex->Unlock();
    pDev->SetTexture();
    pDev->DrawPrimitive();
}
```



## <a name="using-dynamic-vertex-and-index-buffers"></a><span data-ttu-id="bffa1-197">Использование динамических буферов вершин и индексов</span><span class="sxs-lookup"><span data-stu-id="bffa1-197">Using Dynamic Vertex and Index Buffers</span></span>

<span data-ttu-id="bffa1-198">Блокировка статического буфера вершин во время использования буфером графическим процессором может существенно пострадает от производительности.</span><span class="sxs-lookup"><span data-stu-id="bffa1-198">Locking a static vertex buffer while the graphics processor is using the buffer can have a significant performance penalty.</span></span> <span data-ttu-id="bffa1-199">Вызов блокировки должен ожидать, пока графический процессор не закончит считывание данных вершин или индексов из буфера, прежде чем он сможет вернуться к вызывающему приложению, выполняя значительную задержку.</span><span class="sxs-lookup"><span data-stu-id="bffa1-199">The lock call must wait until the graphics processor is finished reading vertex or index data from the buffer before it can return to the calling application, a significant delay.</span></span> <span data-ttu-id="bffa1-200">Блокировка и последующее отображение из статического буфера несколько раз в кадре также не позволяет графическому процессору выводить команды отрисовки, так как перед возвратом указателя блокировки должны быть завершены команды.</span><span class="sxs-lookup"><span data-stu-id="bffa1-200">Locking and then rendering from a static buffer several times per frame also prevents the graphics processor from buffering rendering commands, since it must finish commands before returning the lock pointer.</span></span> <span data-ttu-id="bffa1-201">Без буферизованных команд графический процессор остается неактивным до тех пор, пока приложение не завершит заполнение буфера вершин или буфера индексов и выдаст команду подготовки к просмотру.</span><span class="sxs-lookup"><span data-stu-id="bffa1-201">Without buffered commands, the graphics processor remains idle until after the application is finished filling the vertex buffer or index buffer and issues a rendering command.</span></span>

<span data-ttu-id="bffa1-202">В идеале данные вершин или индексов никогда не изменяются, однако это не всегда возможно.</span><span class="sxs-lookup"><span data-stu-id="bffa1-202">Ideally the vertex or index data would never change, however this is not always possible.</span></span> <span data-ttu-id="bffa1-203">Существует множество ситуаций, в которых приложению необходимо изменять данные вершин или индексов для каждого кадра, возможно даже несколько раз в кадре.</span><span class="sxs-lookup"><span data-stu-id="bffa1-203">There are many situations where the application needs to change vertex or index data every frame, perhaps even multiple times per frame.</span></span> <span data-ttu-id="bffa1-204">В таких ситуациях буфер вершин или индекс должен быть создан с помощью D3DUSAGE \_ dynamic.</span><span class="sxs-lookup"><span data-stu-id="bffa1-204">For these situations, the vertex or index buffer should be created with D3DUSAGE\_DYNAMIC.</span></span> <span data-ttu-id="bffa1-205">Этот флаг использования вызывает оптимизацию Direct3D для часто выполняемых операций блокировки.</span><span class="sxs-lookup"><span data-stu-id="bffa1-205">This usage flag causes Direct3D to optimize for frequent lock operations.</span></span> <span data-ttu-id="bffa1-206">D3DUSAGE \_ dynamic полезен только в том случае, если буфер заблокирован часто. данные, которые остаются постоянными, должны размещаться в статическом буфере вершин или индексе.</span><span class="sxs-lookup"><span data-stu-id="bffa1-206">D3DUSAGE\_DYNAMIC is only useful when the buffer is locked frequently; data that remains constant should be placed in a static vertex or index buffer.</span></span>

<span data-ttu-id="bffa1-207">Для получения улучшения производительности при использовании динамических буферов вершин приложение должно вызывать [**IDirect3DVertexBuffer9:: Lock**](/windows/desktop/api) или [**IDirect3DIndexBuffer9:: Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) с соответствующими флагами.</span><span class="sxs-lookup"><span data-stu-id="bffa1-207">To receive a performance improvement when using dynamic vertex buffers, the application must call [**IDirect3DVertexBuffer9::Lock**](/windows/desktop/api) or [**IDirect3DIndexBuffer9::Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) with the appropriate flags.</span></span> <span data-ttu-id="bffa1-208">D3DLOCK \_ Discard указывает, что приложению не нужно сохранить в буфере старые данные вершин или индексов.</span><span class="sxs-lookup"><span data-stu-id="bffa1-208">D3DLOCK\_DISCARD indicates that the application does not need to keep the old vertex or index data in the buffer.</span></span> <span data-ttu-id="bffa1-209">Если графический процессор все еще использует буфер при вызове Lock с D3DLOCK \_ Discard, вместо старых данных буфера возвращается указатель на новый регион памяти.</span><span class="sxs-lookup"><span data-stu-id="bffa1-209">If the graphics processor is still using the buffer when lock is called with D3DLOCK\_DISCARD, a pointer to a new region of memory is returned instead of the old buffer data.</span></span> <span data-ttu-id="bffa1-210">Это позволяет графическому процессору продолжать использовать старые данные, пока приложение поместит данные в новый буфер.</span><span class="sxs-lookup"><span data-stu-id="bffa1-210">This allows the graphics processor to continue using the old data while the application places data in the new buffer.</span></span> <span data-ttu-id="bffa1-211">В приложении не требуется дополнительное управление памятью; Старый буфер повторно используется или уничтожается автоматически после завершения работы графического процессора.</span><span class="sxs-lookup"><span data-stu-id="bffa1-211">No additional memory management is required in the application; the old buffer is reused or destroyed automatically when the graphics processor is finished with it.</span></span> <span data-ttu-id="bffa1-212">Обратите внимание, что блокировка буфера с D3DLOCK \_ Discard всегда отбрасывает весь буфер, указывая ненулевое смещение или поле с ограниченным размером, не сохраняет сведения в разблокированных областях буфера.</span><span class="sxs-lookup"><span data-stu-id="bffa1-212">Note that locking a buffer with D3DLOCK\_DISCARD always discards the entire buffer, specifying a nonzero offset or limited size field does not preserve information in unlocked areas of the buffer.</span></span>

<span data-ttu-id="bffa1-213">Бывают случаи, когда объем данных, которые приложение должно хранить на блокировку, небольшой, например добавление четырех вершин для отрисовки спрайта.</span><span class="sxs-lookup"><span data-stu-id="bffa1-213">There are cases where the amount of data the application needs to store per lock is small, such as adding four vertices to render a sprite.</span></span> <span data-ttu-id="bffa1-214">D3DLOCK \_ нуверврите указывает, что приложение не будет перезаписывать данные, уже используемые в динамическом буфере.</span><span class="sxs-lookup"><span data-stu-id="bffa1-214">D3DLOCK\_NOOVERWRITE indicates that the application will not overwrite data already in use in the dynamic buffer.</span></span> <span data-ttu-id="bffa1-215">Вызов блокировки вернет указатель на старые данные, позволяя приложению добавлять новые данные в неиспользуемые области вершин или буфера индекса.</span><span class="sxs-lookup"><span data-stu-id="bffa1-215">The lock call will return a pointer to the old data, allowing the application to add new data in unused regions of the vertex or index buffer.</span></span> <span data-ttu-id="bffa1-216">Приложение не должно изменять вершины или индексы, используемые в операции рисования, так как они по-прежнему используются графическим процессором.</span><span class="sxs-lookup"><span data-stu-id="bffa1-216">The application should not modify vertices or indices used in a draw operation as they might still be in use by the graphics processor.</span></span> <span data-ttu-id="bffa1-217">Приложение должно использовать D3DLOCK \_ Discard после заполнения динамического буфера для получения нового региона памяти, удаляя старые данные вершин или индексы после завершения работы графического процессора.</span><span class="sxs-lookup"><span data-stu-id="bffa1-217">The application should then use D3DLOCK\_DISCARD after the dynamic buffer is full to receive a new region of memory, discarding the old vertex or index data after the graphics processor is finished.</span></span>

<span data-ttu-id="bffa1-218">Механизм асинхронных запросов удобен для определения того, используются ли вершины графическим процессором.</span><span class="sxs-lookup"><span data-stu-id="bffa1-218">The asynchronous query mechanism is useful to determine if vertices are still in use by the graphics processor.</span></span> <span data-ttu-id="bffa1-219">Выдайте запрос типа Event D3DQUERYTYPE \_ после последнего вызова дравпримитиве, использующего вершины.</span><span class="sxs-lookup"><span data-stu-id="bffa1-219">Issue a query of type D3DQUERYTYPE\_EVENT after the last DrawPrimitive call that uses the vertices.</span></span> <span data-ttu-id="bffa1-220">Вершины больше не используются, если [**IDirect3DQuery9:: GetData**](/windows/desktop/api) возвращает значение S \_ ОК.</span><span class="sxs-lookup"><span data-stu-id="bffa1-220">The vertices are no longer in use when [**IDirect3DQuery9::GetData**](/windows/desktop/api) returns S\_OK.</span></span> <span data-ttu-id="bffa1-221">Блокировка буфера с D3DLOCK \_ Discard или без флагов всегда гарантирует, что вершины будут правильно синхронизированы с графическим процессором, однако использование блокировки без флагов приведет к снижению производительности, описанному выше.</span><span class="sxs-lookup"><span data-stu-id="bffa1-221">Locking a buffer with D3DLOCK\_DISCARD or no flags will always guarantee the vertices are synchronized properly with the graphics processor, however using lock without flags will incur the performance penalty described earlier.</span></span> <span data-ttu-id="bffa1-222">Другие вызовы API, такие как [**IDirect3DDevice9:: бегинсцене**](/windows/desktop/api), [**IDirect3DDevice9:: ендсцене**](/windows/desktop/api)и [**IDirect3DDevice9::P**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) повторной отправки, не гарантируют, что графический процессор завершает работу с вершинами.</span><span class="sxs-lookup"><span data-stu-id="bffa1-222">Other API calls such as [**IDirect3DDevice9::BeginScene**](/windows/desktop/api), [**IDirect3DDevice9::EndScene**](/windows/desktop/api), and [**IDirect3DDevice9::Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) do not guarantee the graphics processor is finished using vertices.</span></span>

<span data-ttu-id="bffa1-223">Ниже приведены способы использования динамических буферов и правильных флагов блокировки.</span><span class="sxs-lookup"><span data-stu-id="bffa1-223">Below are ways to use dynamic buffers and the proper lock flags.</span></span>


```
    // USAGE STYLE 1
    // Discard the entire vertex buffer and refill with thousands of vertices.
    // Might contain multiple objects and/or require multiple DrawPrimitive 
    //   calls separated by state changes, etc.
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // Discard and refill the used portion of the vertex buffer.
    CONST DWORD dwLockFlags = D3DLOCK_DISCARD;
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( 0, 0, &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, nNumberOfVertices/3)
```




```
    // USAGE STYLE 2
    // Reusing one vertex buffer for multiple objects
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // No overwrite will be used if the vertices can fit into 
    //   the space remaining in the vertex buffer.
    DWORD dwLockFlags = D3DLOCK_NOOVERWRITE;
    
    // Check to see if the entire vertex buffer has been used up yet.
    if( m_nNextVertexData > m_nSizeOfVB - nSizeOfData )
    {
        // No space remains. Start over from the beginning 
        //   of the vertex buffer.
        dwLockFlags = D3DLOCK_DISCARD;
        m_nNextVertexData = 0;
    }
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( (UINT)m_nNextVertexData, nSizeOfData, 
               &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 
               m_nNextVertexData/m_nVertexStride, nNumberOfVertices/3)
 
    // Advance to the next position in the vertex buffer.
    m_nNextVertexData += nSizeOfData;
```



## <a name="using-meshes"></a><span data-ttu-id="bffa1-224">Использование сеток</span><span class="sxs-lookup"><span data-stu-id="bffa1-224">Using Meshes</span></span>

<span data-ttu-id="bffa1-225">Можно оптимизировать сетки с помощью индексированных треугольников Direct3D вместо проиндексированных лент треугольников.</span><span class="sxs-lookup"><span data-stu-id="bffa1-225">You can optimize meshes by using Direct3D indexed triangles instead of indexed triangle strips.</span></span> <span data-ttu-id="bffa1-226">Оборудование обнаружит, что 95 процентов последовательных треугольников фактически формируют полосы и соответствующим образом корректирует их.</span><span class="sxs-lookup"><span data-stu-id="bffa1-226">The hardware will discover that 95 percent of successive triangles actually form strips and adjust accordingly.</span></span> <span data-ttu-id="bffa1-227">Многие драйверы делают это для старого оборудования также.</span><span class="sxs-lookup"><span data-stu-id="bffa1-227">Many drivers do this for older hardware also.</span></span>

<span data-ttu-id="bffa1-228">Объекты сетки D3DX могут иметь каждый треугольник или лицо с меткой DWORD, называемое атрибутом этого лица.</span><span class="sxs-lookup"><span data-stu-id="bffa1-228">D3DX mesh objects can have each triangle, or face, tagged with a DWORD, called the attribute of that face.</span></span> <span data-ttu-id="bffa1-229">Семантика DWORD определяется пользователем.</span><span class="sxs-lookup"><span data-stu-id="bffa1-229">The semantics of the DWORD are user-defined.</span></span> <span data-ttu-id="bffa1-230">Они используются D3DX для классификации сетки на подмножества.</span><span class="sxs-lookup"><span data-stu-id="bffa1-230">They are used by D3DX to classify the mesh into subsets.</span></span> <span data-ttu-id="bffa1-231">Приложение устанавливает атрибуты для отдельных лиц с помощью вызова [**ID3DXMesh:: локкаттрибутебуффер**](id3dxmesh--lockattributebuffer.md) .</span><span class="sxs-lookup"><span data-stu-id="bffa1-231">The application sets per-face attributes using the [**ID3DXMesh::LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) call.</span></span> <span data-ttu-id="bffa1-232">Метод [**ID3DXMesh:: optimize**](id3dxmesh--optimize.md) имеет параметр для группирования вершин сетки и граней в атрибутах с помощью \_ параметра D3DXMESHOPT аттрсорт.</span><span class="sxs-lookup"><span data-stu-id="bffa1-232">The [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) method has an option to group the mesh vertices and faces on attributes using the D3DXMESHOPT\_ATTRSORT option.</span></span> <span data-ttu-id="bffa1-233">Когда это будет сделано, объект сетки вычисляет таблицу атрибутов, которую приложение может получить, вызвав [**ID3DXBaseMesh:: жетаттрибутетабле**](id3dxbasemesh--getattributetable.md).</span><span class="sxs-lookup"><span data-stu-id="bffa1-233">When this is done, the mesh object calculates an attribute table that can be obtained by the application by calling [**ID3DXBaseMesh::GetAttributeTable**](id3dxbasemesh--getattributetable.md).</span></span> <span data-ttu-id="bffa1-234">Этот вызов возвращает 0, если сетка не отсортирована по атрибутам.</span><span class="sxs-lookup"><span data-stu-id="bffa1-234">This call returns 0 if the mesh is not sorted by attributes.</span></span> <span data-ttu-id="bffa1-235">Приложение не может установить таблицу атрибутов, так как она создается методом **ID3DXMesh:: optimize** .</span><span class="sxs-lookup"><span data-stu-id="bffa1-235">There is no way for an application to set an attribute table because it is generated by the **ID3DXMesh::Optimize** method.</span></span> <span data-ttu-id="bffa1-236">Атрибут Sort чувствителен к данным, поэтому, если приложение знает, что сетка имеет сортировку по атрибутам, ей по-прежнему нужно вызывать **ID3DXMesh:: optimize** для создания таблицы атрибутов.</span><span class="sxs-lookup"><span data-stu-id="bffa1-236">The attribute sort is data sensitive, so if the application knows that a mesh is attribute sorted, it still needs to call **ID3DXMesh::Optimize** to generate the attribute table.</span></span>

<span data-ttu-id="bffa1-237">В следующих разделах описываются различные атрибуты сетки.</span><span class="sxs-lookup"><span data-stu-id="bffa1-237">The following topics describe the different attributes of a mesh.</span></span>

### <a name="attribute-id"></a><span data-ttu-id="bffa1-238">Идентификатор атрибута</span><span class="sxs-lookup"><span data-stu-id="bffa1-238">Attribute ID</span></span>

<span data-ttu-id="bffa1-239">Идентификатор атрибута — это значение, связывающее группу лиц с группой атрибутов.</span><span class="sxs-lookup"><span data-stu-id="bffa1-239">An attribute id is a value that associates a group of faces with an attribute group.</span></span> <span data-ttu-id="bffa1-240">Этот идентификатор описывает, какое подмножество фрагментов [**ID3DXBaseMesh::D равсубсет**](id3dxbasemesh--drawsubset.md) должно рисовать.</span><span class="sxs-lookup"><span data-stu-id="bffa1-240">This id describes which subset of faces [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) should draw.</span></span> <span data-ttu-id="bffa1-241">Идентификаторы атрибутов указываются для граней в буфере атрибута.</span><span class="sxs-lookup"><span data-stu-id="bffa1-241">Attribute ids are specified for the faces in the attribute buffer.</span></span> <span data-ttu-id="bffa1-242">Фактические значения идентификаторов атрибутов могут быть любыми, которые помещаются в 32 бит, но часто используется 0 – n, где n — число атрибутов.</span><span class="sxs-lookup"><span data-stu-id="bffa1-242">The actual values of the attribute ids can be anything that fits in 32 bits, but it is common to use 0 to n where n is the number of attributes.</span></span>

### <a name="attribute-buffer"></a><span data-ttu-id="bffa1-243">Буфер атрибутов</span><span class="sxs-lookup"><span data-stu-id="bffa1-243">Attribute Buffer</span></span>

<span data-ttu-id="bffa1-244">Буфер атрибутов — это массив DWORD (по одному на каждый элемент), указывающий, к какой группе атрибутов принадлежит каждая грань.</span><span class="sxs-lookup"><span data-stu-id="bffa1-244">The attribute buffer is an array of DWORDs (one per face) that specifies which attribute group each face belongs in.</span></span> <span data-ttu-id="bffa1-245">Этот буфер инициализируется нулем при создании сетки, но либо заполняется подсистемой загрузки, либо должен быть заполнен пользователем, если требуется более одного атрибута с идентификатором 0.</span><span class="sxs-lookup"><span data-stu-id="bffa1-245">This buffer is initialized to zero on creation of a mesh, but is either filled by the load routines or must be filled by the user if more than one attribute with id 0 is desired.</span></span> <span data-ttu-id="bffa1-246">Этот буфер содержит сведения, используемые для сортировки сетки на основе атрибутов в [**ID3DXMesh:: optimize**](id3dxmesh--optimize.md).</span><span class="sxs-lookup"><span data-stu-id="bffa1-246">This buffer contains the information that is used to sort the mesh based on attributes in [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md).</span></span> <span data-ttu-id="bffa1-247">Если таблица атрибутов отсутствует, [**ID3DXBaseMesh::D равсубсет**](id3dxbasemesh--drawsubset.md) просматривает этот буфер, чтобы выбрать грани данного атрибута для рисования.</span><span class="sxs-lookup"><span data-stu-id="bffa1-247">If no attribute table is present, [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) scans this buffer to select the faces of the given attribute to draw.</span></span>

### <a name="attribute-table"></a><span data-ttu-id="bffa1-248">Таблица атрибутов</span><span class="sxs-lookup"><span data-stu-id="bffa1-248">Attribute Table</span></span>

<span data-ttu-id="bffa1-249">Таблица атрибутов — это структура, принадлежащая и обслуживаемая сеткой.</span><span class="sxs-lookup"><span data-stu-id="bffa1-249">The attribute table is a structure owned and maintained by the mesh.</span></span> <span data-ttu-id="bffa1-250">Единственный способ создания одного из них — вызвать [**ID3DXMesh:: optimize**](id3dxmesh--optimize.md) с атрибутом Sort или более надежную оптимизацию.</span><span class="sxs-lookup"><span data-stu-id="bffa1-250">The only way for one to be generated is by calling [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) with attribute sorting or stronger optimization enabled.</span></span> <span data-ttu-id="bffa1-251">Таблица атрибутов используется для быстрого запуска одного простого вызова Draw в [**ID3DXBaseMesh::D равсубсет**](id3dxbasemesh--drawsubset.md).</span><span class="sxs-lookup"><span data-stu-id="bffa1-251">The attribute table is used to quickly initiate a single draw primitive call to [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md).</span></span> <span data-ttu-id="bffa1-252">Единственным другим применением является то, что в таких сетках также поддерживается эта структура, поэтому можно увидеть, какие грани и вершины активны на текущем уровне детализации.</span><span class="sxs-lookup"><span data-stu-id="bffa1-252">The only other use is that progressing meshes also maintain this structure, so it is possible to see what faces and vertices are active at the current level of detail.</span></span>

## <a name="z-buffer-performance"></a><span data-ttu-id="bffa1-253">Производительность буфера Z</span><span class="sxs-lookup"><span data-stu-id="bffa1-253">Z-Buffer Performance</span></span>

<span data-ttu-id="bffa1-254">Приложения могут работать быстрее при использовании z-буферизации и текстурирования за счет отрисовки сцен от передней части к задней.</span><span class="sxs-lookup"><span data-stu-id="bffa1-254">Applications can increase performance when using z-buffering and texturing by ensuring that scenes are rendered from front to back.</span></span> <span data-ttu-id="bffa1-255">Текстурированные примитивы с z-буферизацией предварительно проверяются в сравнении с z-буфером на основе строк развертки.</span><span class="sxs-lookup"><span data-stu-id="bffa1-255">Textured z-buffered primitives are pretested against the z-buffer on a scan line basis.</span></span> <span data-ttu-id="bffa1-256">Если строка развертки скрыта ранее отрисованным полигоном, система быстро и эффективно отклоняет ее.</span><span class="sxs-lookup"><span data-stu-id="bffa1-256">If a scan line is hidden by a previously rendered polygon, the system rejects it quickly and efficiently.</span></span> <span data-ttu-id="bffa1-257">Z-буферизация может повысить производительность, но этот метод особо эффективен при многократном отображении одних и тех же пикселей в сцене.</span><span class="sxs-lookup"><span data-stu-id="bffa1-257">Z-buffering can improve performance, but the technique is most useful when a scene draws the same pixels more than once.</span></span> <span data-ttu-id="bffa1-258">Точные расчеты в этом случае сделать сложно, но можно добиться довольно точного приближения.</span><span class="sxs-lookup"><span data-stu-id="bffa1-258">This is difficult to calculate exactly, but you can often make a close approximation.</span></span> <span data-ttu-id="bffa1-259">Если одни и те же пиксели отображаются менее двух раз, максимальную производительность можно обеспечить путем отключения z-буферизации и отрисовки сцены от задней части к передней.</span><span class="sxs-lookup"><span data-stu-id="bffa1-259">If the same pixels are drawn less than twice, you can achieve the best performance by turning z-buffering off and rendering the scene from back to front.</span></span>

## <a name="related-topics"></a><span data-ttu-id="bffa1-260">См. также</span><span class="sxs-lookup"><span data-stu-id="bffa1-260">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="bffa1-261">Советы по программированию</span><span class="sxs-lookup"><span data-stu-id="bffa1-261">Programming Tips</span></span>](programming-tips.md)
</dt> </dl>

 

 
