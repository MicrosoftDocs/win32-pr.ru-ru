---
description: Программирование DirectX с помощью COM.
title: Программирование DirectX с помощью COM
ms.topic: article
ms.date: 01/29/2019
ms.openlocfilehash: 67fc7a35f42439e1a9eeef1b2895d88dc0dbf5d4
ms.sourcegitcommit: f712e5fed19d6afe2762a77ffcdf8b5977f85901
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/26/2021
ms.locfileid: "103999797"
---
# <a name="programming-directx-with-com"></a><span data-ttu-id="e7d1c-103">Программирование DirectX с помощью COM</span><span class="sxs-lookup"><span data-stu-id="e7d1c-103">Programming DirectX with COM</span></span>

<span data-ttu-id="e7d1c-104">Модель COM — объектно-ориентированная модель программирования, используемая несколькими технологиями, включая основную часть поверхности API DirectX.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-104">The Microsoft Component Object Model (COM) is an object-oriented programming model used by several technologies, including the bulk of the DirectX API surface.</span></span> <span data-ttu-id="e7d1c-105">По этой причине вы (как разработчик DirectX) неизбежно используете COM при программировании DirectX.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-105">For that reason, you (as a DirectX developer) inevitably use COM when you program DirectX.</span></span>

> [!NOTE]
> <span data-ttu-id="e7d1c-106">В разделе Использование [COM-компонентов с + +/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) показано, как использовать API-интерфейсы DirectX (и любой интерфейс API COM) с помощью [c++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-106">The topic [Consume COM components with C++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) shows how to consume DirectX APIs (and any COM API, for that matter) by using [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span></span> <span data-ttu-id="e7d1c-107">Это далеко не самая удобная и рекомендуемая для использования технология.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-107">That's by far the most convenient and recommended technology to use.</span></span>

<span data-ttu-id="e7d1c-108">Кроме того, можно использовать необработанный COM, и именно этот раздел посвящен.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-108">Alternatively, you can use raw COM, and that's what this topic is about.</span></span> <span data-ttu-id="e7d1c-109">Вам потребуются основные сведения о принципах и методиках программирования, участвующих в использовании COM-интерфейсов API.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-109">You'll need a basic understanding of the principles and programming techniques involved in consuming COM APIs.</span></span> <span data-ttu-id="e7d1c-110">Хотя у COM есть репутация для сложной и сложной модели, программирование COM, необходимое большинству приложений DirectX, — это просто.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-110">Although COM has a reputation for being difficult and complex, the COM programming required by most DirectX applications is straightforward.</span></span> <span data-ttu-id="e7d1c-111">Это связано с тем, что вы используете COM-объекты, предоставляемые DirectX.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-111">In part, this is because you'll be consuming the COM objects provided by DirectX.</span></span> <span data-ttu-id="e7d1c-112">Вам не нужно создавать собственные COM-объекты, которые, как правило, возникают в сложности.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-112">There's no need for you to author your own COM objects, which is typically where the complexity arises.</span></span>

## <a name="com-component-overview"></a><span data-ttu-id="e7d1c-113">Общие сведения о компоненте COM</span><span class="sxs-lookup"><span data-stu-id="e7d1c-113">COM component overview</span></span>

<span data-ttu-id="e7d1c-114">COM-объект — это, по сути, инкапсулированный компонент функций, который может использоваться приложениями для выполнения одной или нескольких задач.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-114">A COM object is essentially an encapsulated component of functionality that can be used by applications to perform one or more tasks.</span></span> <span data-ttu-id="e7d1c-115">Для развертывания один или несколько компонентов COM упаковываются в двоичный файл, называемый COM-сервером. чаще, чем DLL.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-115">For deployment, one or more COM components are packaged into a binary called a COM server; more often than not a DLL.</span></span>

<span data-ttu-id="e7d1c-116">Традиционная библиотека DLL экспортирует бесплатные функции.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-116">A traditional DLL exports free functions.</span></span> <span data-ttu-id="e7d1c-117">Сервер COM может выполнять те же действия.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-117">A COM server can do the same.</span></span> <span data-ttu-id="e7d1c-118">Но COM-компоненты внутри COM-сервера предоставляют интерфейсы COM и методы членов, принадлежащие этим интерфейсам.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-118">But the COM components inside the COM server expose COM interfaces and member methods belonging to those interfaces.</span></span> <span data-ttu-id="e7d1c-119">Приложение создает экземпляры COM-компонентов, извлекает из них интерфейсы и вызывает методы для этих интерфейсов, чтобы воспользоваться преимуществами функций, реализованных в COM-компонентах.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-119">Your application creates instances of COM components, retrieves interfaces from them, and calls methods on those interfaces in order to benefit from the features implemented in the COM components.</span></span>

<span data-ttu-id="e7d1c-120">На практике это похоже на вызов методов в обычном объекте C++.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-120">In practice, this feels similar to calling methods on a regular C++ object.</span></span> <span data-ttu-id="e7d1c-121">Но есть некоторые различия.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-121">But there are some differences.</span></span>

- <span data-ttu-id="e7d1c-122">COM-объект обеспечивает более строгое инкапсуляцию, чем объект C++.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-122">A COM object enforces stricter encapsulation than a C++ object does.</span></span> <span data-ttu-id="e7d1c-123">Вы не можете просто создать объект, а затем вызвать любой открытый метод.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-123">You can't just create the object, and then call any public method.</span></span> <span data-ttu-id="e7d1c-124">Вместо этого открытые методы COM-компонента группируются в один или несколько COM-интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-124">Instead, a COM component's public methods are grouped into one or more COM interfaces.</span></span> <span data-ttu-id="e7d1c-125">Чтобы вызвать метод, необходимо создать объект и получить из объекта интерфейс, реализующий метод.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-125">To call a method, you create the object and retrieve from the object the interface that implements the method.</span></span> <span data-ttu-id="e7d1c-126">Интерфейс обычно реализует связанный набор методов, которые предоставляют доступ к определенной функции объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-126">An interface typically implements a related set of methods that provide access to a particular feature of the object.</span></span> <span data-ttu-id="e7d1c-127">Например, интерфейс [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) представляет виртуальный графический адаптер и содержит методы, позволяющие создавать ресурсы, например и многие другие связанные с адаптером задачи.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-127">For example, the [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) interface represents a virtual graphics adapter, and it contains methods that enable you create resources, for example, and many other adapter-related tasks.</span></span>
- <span data-ttu-id="e7d1c-128">Объект COM не создается таким же образом, как и объект C++.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-128">A COM object is not created in the same way as a C++ object.</span></span> <span data-ttu-id="e7d1c-129">Существует несколько способов создания COM-объекта, но все они содержат методы, относящиеся к COM.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-129">There are several ways to create a COM object, but all involve COM-specific techniques.</span></span> <span data-ttu-id="e7d1c-130">API DirectX включает множество вспомогательных функций и методов, упрощающих создание большинства COM-объектов DirectX.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-130">The DirectX API includes a variety of helper functions and methods that simplify creating most of the DirectX COM objects.</span></span>
- <span data-ttu-id="e7d1c-131">Для управления временем существования COM-объекта необходимо использовать методы, относящиеся к COM.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-131">You must use COM-specific techniques to control the lifetime of a COM object.</span></span>
- <span data-ttu-id="e7d1c-132">COM-сервер (как правило, DLL) не нужно загружать явным образом.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-132">The COM server (typically a DLL) doesn't need to be explicitly loaded.</span></span> <span data-ttu-id="e7d1c-133">Кроме того, не нужно ссылаться на статическую библиотеку, чтобы использовать COM-компонент.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-133">Nor do you link to a static library in order to use a COM component.</span></span> <span data-ttu-id="e7d1c-134">Каждый компонент COM имеет уникальный зарегистрированный идентификатор (глобальный уникальный идентификатор или GUID), который используется приложением для идентификации COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-134">Each COM component has a unique registered identifier (a globally-unique identifier, or GUID), which your application uses to identify the COM object.</span></span> <span data-ttu-id="e7d1c-135">Приложение определяет компонент, и среда выполнения COM автоматически загружает правильную DLL-сервер COM.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-135">Your application identifies the component, and the COM runtime automatically loads the correct COM server DLL.</span></span>
- <span data-ttu-id="e7d1c-136">COM — это двоичная спецификация.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-136">COM is a binary specification.</span></span> <span data-ttu-id="e7d1c-137">Объекты COM могут быть написаны и доступны на различных языках.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-137">COM objects can be written in and accessed from a variety of languages.</span></span> <span data-ttu-id="e7d1c-138">Вам не нужно ничего знать о исходном коде объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-138">You don't need to know anything about the object's source code.</span></span> <span data-ttu-id="e7d1c-139">Например, Visual Basic приложения обычно используют COM-объекты, написанные на C++.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-139">For example, Visual Basic applications routinely use COM objects that were written in C++.</span></span>

## <a name="component-object-and-interface"></a><span data-ttu-id="e7d1c-140">Компонент, объект и интерфейс</span><span class="sxs-lookup"><span data-stu-id="e7d1c-140">Component, object, and interface</span></span>

<span data-ttu-id="e7d1c-141">Важно понимать различие между компонентами, объектами и интерфейсами.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-141">It's important to understand the distinction between components, objects, and interfaces.</span></span> <span data-ttu-id="e7d1c-142">В случайном использовании может слышаться компонент или объект, на который ссылается имя основного интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-142">In casual usage, you may hear a component or object referred to by the name of its principal interface.</span></span> <span data-ttu-id="e7d1c-143">Однако условия не взаимозаменяемы.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-143">But the terms are not interchangeable.</span></span> <span data-ttu-id="e7d1c-144">Компонент может реализовывать любое количество интерфейсов; объект является экземпляром компонента.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-144">A component can implement any number of interfaces; and an object is an instance of a component.</span></span> <span data-ttu-id="e7d1c-145">Например, хотя все компоненты должны реализовывать [**интерфейс IUnknown**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), они обычно реализуют по крайней мере один дополнительный интерфейс и могут реализовывать множество.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-145">For example, while all components must implement the [**IUnknown interface**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), they normally implement at least one additional interface, and they might implement many.</span></span>

<span data-ttu-id="e7d1c-146">Чтобы использовать определенный метод интерфейса, необходимо не только создать экземпляр объекта, но и получить от него нужный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-146">To use a particular interface method, you must not only instantiate an object, you must also obtain the correct interface from it.</span></span>

<span data-ttu-id="e7d1c-147">Кроме того, один интерфейс может реализовывать несколько компонентов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-147">In addition, more than one component might implement the same interface.</span></span> <span data-ttu-id="e7d1c-148">Интерфейс — это группа методов, которые выполняют логически связанный набор операций.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-148">An interface is a group of methods that perform a logically-related set of operations.</span></span> <span data-ttu-id="e7d1c-149">В определении интерфейса указывается только синтаксис методов и их общие функциональные возможности.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-149">The interface definition specifies only the syntax of the methods and their general functionality.</span></span> <span data-ttu-id="e7d1c-150">Любой COM-компонент, который должен поддерживать определенный набор операций, может сделать это путем реализации подходящего интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-150">Any COM component that needs to support a particular set of operations can do so by implementing a suitable interface.</span></span> <span data-ttu-id="e7d1c-151">Некоторые интерфейсы являются очень специализированными и реализуются только одним компонентом. другие полезны в различных обстоятельствах и реализуются многими компонентами.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-151">Some interfaces are highly specialized, and are implemented only by a single component; others are useful in a variety of circumstances, and are implemented by many components.</span></span>

<span data-ttu-id="e7d1c-152">Если компонент реализует интерфейс, он должен поддерживать каждый метод в определении интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-152">If a component implements an interface, it must support every method in the interface definition.</span></span> <span data-ttu-id="e7d1c-153">Иными словами, необходимо иметь возможность вызывать любой метод и быть уверенным, что он существует.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-153">In other words, you must be able to call any method and be confident that it exists.</span></span> <span data-ttu-id="e7d1c-154">Однако сведения о реализации конкретного метода могут отличаться от одного компонента к другому.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-154">However, the details of how a particular method is implemented may vary from one component to another.</span></span> <span data-ttu-id="e7d1c-155">Например, различные компоненты могут использовать разные алгоритмы для получения окончательного результата.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-155">For example, different components may use different algorithms to arrive at the final result.</span></span> <span data-ttu-id="e7d1c-156">Также нет никакой гарантии, что метод будет поддерживаться нетривиальным образом.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-156">There is also no guarantee that a method will be supported in a nontrivial way.</span></span> <span data-ttu-id="e7d1c-157">Иногда компонент реализует часто используемый интерфейс, но он должен поддерживать только подмножество методов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-157">Sometimes, a component implements a commonly-used interface, but it needs to support only a subset of the methods.</span></span> <span data-ttu-id="e7d1c-158">Вы по-прежнему сможете успешно вызывать оставшиеся методы, но они возвращают [**HRESULT**](#hresult-values) (стандартный тип com, представляющий код результата), содержащий значение **E_NOTIMPL**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-158">You will still be able to call the remaining methods successfully, but they will return an [**HRESULT**](#hresult-values) (which is a standard COM type representing a result code) containing the value **E_NOTIMPL**.</span></span> <span data-ttu-id="e7d1c-159">Чтобы увидеть, как интерфейс реализуется каким-либо конкретным компонентом, обратитесь к его документации.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-159">You should refer to its documentation to see how an interface is implemented by any particular component.</span></span>

<span data-ttu-id="e7d1c-160">В стандарте COM необходимо, чтобы определение интерфейса не изменялось после его публикации.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-160">The COM standard requires that an interface definition must not change once it has been published.</span></span> <span data-ttu-id="e7d1c-161">Автор не может, например, добавить новый метод в существующий интерфейс.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-161">The author cannot, for example, add a new method to an existing interface.</span></span> <span data-ttu-id="e7d1c-162">Вместо этого автор должен создать новый интерфейс.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-162">The author must instead create a new interface.</span></span> <span data-ttu-id="e7d1c-163">Хотя не существует ограничений на то, какие методы должны быть в этом интерфейсе, обычно используется интерфейс следующего поколения, включающий все методы старого интерфейса, а также все новые методы.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-163">While there are no restrictions on what methods must be in that interface, a common practice is to have the next-generation interface include all the of the old interface's methods, plus any new methods.</span></span>

<span data-ttu-id="e7d1c-164">Интерфейс должен иметь несколько поколений.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-164">It's not unusual for an interface to have several generations.</span></span> <span data-ttu-id="e7d1c-165">Как правило, все поколения выполняют по сути одну и ту же общую задачу, но они различаются в конкретных случаях.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-165">Typically, all generations perform essentially the same overall task, but they're different in specifics.</span></span> <span data-ttu-id="e7d1c-166">Часто COM-компонент реализует каждое текущее и прежнее поколение журнала преобразований определенного интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-166">Often, a COM component implements every current and prior generation of a given interface's lineage.</span></span> <span data-ttu-id="e7d1c-167">Это позволяет старым приложениям продолжать использовать более старые интерфейсы объектов, тогда как новые приложения могут использовать преимущества новых интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-167">Doing so allows older applications to continue using the object's older interfaces, while newer applications can take advantage of the features of the newer interfaces.</span></span> <span data-ttu-id="e7d1c-168">Как правило, неспусковая группа интерфейсов имеет одно и то же имя, а также целое число, указывающее на поколение.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-168">Typically, a descent group of interfaces all have the same name, plus an integer that indicates the generation.</span></span> <span data-ttu-id="e7d1c-169">Например, если исходный интерфейс назывался **IMyInterface** (что подразумевает поколение 1), то следующие два поколения будут называться **IMyInterface2** и **IMyInterface3**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-169">For example, if the original interface were named **IMyInterface** (implying generation 1), then the next two generations would be called **IMyInterface2** and **IMyInterface3**.</span></span> <span data-ttu-id="e7d1c-170">В случае с интерфейсами DirectX последовательные поколения обычно именуются по номеру версии DirectX.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-170">In the case of DirectX interfaces, successive generations are typically named for the version number of DirectX.</span></span>

## <a name="guids"></a><span data-ttu-id="e7d1c-171">Идентификаторы GUID</span><span class="sxs-lookup"><span data-stu-id="e7d1c-171">GUIDs</span></span>

<span data-ttu-id="e7d1c-172">Идентификаторы GUID являются ключевой частью модели программирования COM.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-172">GUIDs are a key part of the COM programming model.</span></span> <span data-ttu-id="e7d1c-173">Как правило, идентификатор GUID представляет собой 128-разрядную структуру.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-173">At its most basic, a GUID is a 128-bit structure.</span></span> <span data-ttu-id="e7d1c-174">Однако идентификаторы GUID создаются таким образом, чтобы гарантировать, что два идентификатора GUID не совпадают.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-174">However, GUIDs are created in such a way as to guarantee that no two GUIDs are the same.</span></span> <span data-ttu-id="e7d1c-175">Модель COM широко использует GUID для двух основных целей.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-175">COM uses GUIDs extensively for two primary purposes.</span></span>

- <span data-ttu-id="e7d1c-176">Для уникальной идентификации конкретного COM-компонента.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-176">To uniquely identify a particular COM component.</span></span> <span data-ttu-id="e7d1c-177">Идентификатор GUID, назначенный для идентификации COM-компонента, называется идентификатором класса (CLSID), а при необходимости создания экземпляра связанного COM-компонента используется CLSID.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-177">A GUID that is assigned to identify a COM component is called a class identifier (CLSID), and you use a CLSID when you want to create an instance of the associated COM component.</span></span>
- <span data-ttu-id="e7d1c-178">Для уникальной идентификации конкретного COM-интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-178">To uniquely identify a particular COM interface.</span></span> <span data-ttu-id="e7d1c-179">Идентификатор GUID, назначенный для идентификации COM-интерфейса, называется идентификатором интерфейса (IID) и используется IID при запросе определенного интерфейса из экземпляра компонента (объекта).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-179">A GUID that is assigned to identify a COM interface is called an interface identifier (IID), and you use an IID when you request a particular interface from an instance of a component (an object).</span></span> <span data-ttu-id="e7d1c-180">IID интерфейса будет одинаковым, независимо от того, какой компонент реализует интерфейс.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-180">An interface's IID will be the same, regardless of which component implements the interface.</span></span>

<span data-ttu-id="e7d1c-181">Для удобства документация DirectX обычно ссылается на компоненты и интерфейсы по описательным именам (например, **ID3D12Device**), а не по идентификаторам GUID.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-181">For convenience, the DirectX documentation normally refers to components and interfaces by their descriptive names (for example, **ID3D12Device**) rather than by their GUIDs.</span></span> <span data-ttu-id="e7d1c-182">В контексте документации DirectX неоднозначность отсутствует.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-182">Within the context of the DirectX documentation, there is no ambiguity.</span></span> <span data-ttu-id="e7d1c-183">Технически возможно, что сторонним разработчикам нужно создать интерфейс с описательным именем **ID3D12Device** (для правильной работы он должен иметь другой идентификатор IID).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-183">It's technically possible for a third-party to author an interface with the descriptive name **ID3D12Device** (it would need to have a different IID in order to be valid).</span></span> <span data-ttu-id="e7d1c-184">Тем не менее, в интересах ясности не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-184">In the interest of clarity, though, we don't recommend that.</span></span>

<span data-ttu-id="e7d1c-185">Таким образом, единственным однозначным способом обращения к конкретному объекту или интерфейсу является его идентификатор GUID.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-185">So, the only unambiguous way to refer to a particular object or interface is by its GUID.</span></span>

<span data-ttu-id="e7d1c-186">Хотя идентификатор GUID является структурой, идентификатор GUID часто выражается в эквивалентной строковой форме.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-186">Although a GUID is a structure, a GUID is often expressed in equivalent string form.</span></span> <span data-ttu-id="e7d1c-187">Общий формат строкового формата GUID состоит из 32 шестнадцатеричных цифр в формате 8-4-4-4-12.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-187">The general format of the string form of a GUID is 32 hexadecimal digits, in the format 8-4-4-4-12.</span></span> <span data-ttu-id="e7d1c-188">То есть {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}, где каждый символ x соответствует шестнадцатеричной цифре.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-188">That is, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, where each x corresponds to a hexadecimal digit.</span></span> <span data-ttu-id="e7d1c-189">Например, строка идентификатора IID для интерфейса **ID3D12Device** имеет вид {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-189">For example, the string form of the IID for the **ID3D12Device** interface is {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span></span>

<span data-ttu-id="e7d1c-190">Поскольку фактический идентификатор GUID несколько неловкий для использования и легкого ввода в заблуждение, обычно также предоставляется эквивалентное имя.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-190">Because the actual GUID is somewhat clumsy to use and easy to mistype, an equivalent name is usually provided as well.</span></span> <span data-ttu-id="e7d1c-191">В коде можно использовать это имя вместо фактической структуры при вызове функций, например при передаче аргумента для `riid` параметра в [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-191">In your code, you can use this name instead of the actual structure when you call functions, for example when you pass an argument for the `riid` parameter to [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span></span> <span data-ttu-id="e7d1c-192">Особое соглашение об именовании заключается в начале IID_ или CLSID_ описательного имени интерфейса или объекта соответственно.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-192">The customary naming convention is to prepend either IID_ or CLSID_ to the descriptive name of the interface or object, respectively.</span></span> <span data-ttu-id="e7d1c-193">Например, имя IID интерфейса **ID3D12Device** — IID_ID3D12Device.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-193">For example, the name of the **ID3D12Device** interface's IID is IID_ID3D12Device.</span></span>

> [!NOTE]
> <span data-ttu-id="e7d1c-194">Приложения DirectX должны быть связаны с ``dxguid.lib`` и, ``uuid.lib`` чтобы предоставить определения для различных идентификаторов GUID интерфейса и класса.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-194">DirectX applications should link with ``dxguid.lib`` and ``uuid.lib`` to provide definitions for the various interface and class GUIDs.</span></span> <span data-ttu-id="e7d1c-195">Visual C++ и другие компиляторы поддерживают расширение языка оператора **__uuidof** , но также поддерживается явная компоновка в стиле C с этими библиотеками ссылок и полностью Переносимая.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-195">Visual C++ and other compilers support the **__uuidof** operator language extension, but explicit C-style linkage with these link libraries is also supported and fully portable.</span></span>

## <a name="hresult-values"></a><span data-ttu-id="e7d1c-196">Значения HRESULT</span><span class="sxs-lookup"><span data-stu-id="e7d1c-196">HRESULT values</span></span>

<span data-ttu-id="e7d1c-197">Большинство методов COM возвращают 32-разрядное целое число с именем **HRESULT**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-197">Most COM methods return a 32-bit integer called an **HRESULT**.</span></span> <span data-ttu-id="e7d1c-198">В большинстве методов значение HRESULT по сути представляет собой структуру, которая содержит два основных фрагмента информации.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-198">With most methods, the HRESULT is essentially a structure that contains two primary pieces of information.</span></span>
- <span data-ttu-id="e7d1c-199">Завершился ли метод успешно или неудачно.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-199">Whether the method succeeded or failed.</span></span>
- <span data-ttu-id="e7d1c-200">Более подробные сведения о результате операции, выполняемой методом.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-200">More detailed information about the outcome of the operation performed by the method.</span></span>

<span data-ttu-id="e7d1c-201">Некоторые методы возвращают значение **HRESULT** из стандартного набора, определенного в `Winerror.h` .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-201">Some methods return a **HRESULT** value from the standard set defined in `Winerror.h`.</span></span> <span data-ttu-id="e7d1c-202">Однако метод может возвращать пользовательское значение **HRESULT** с более специализированной информацией.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-202">However, a method is free to return a custom **HRESULT** value with more specialized information.</span></span> <span data-ttu-id="e7d1c-203">Эти значения обычно задокументированы на странице справки по методу.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-203">These values are normally documented on the method's reference page.</span></span>

<span data-ttu-id="e7d1c-204">Список значений **HRESULT** , найденных на странице справочника по методу, часто является подмножеством возможных значений, которые могут быть возвращены.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-204">The list of **HRESULT** values that you find on a method's reference page is often only a subset of the possible values that may be returned.</span></span> <span data-ttu-id="e7d1c-205">В списке обычно рассматриваются только те значения, которые относятся к методу, а также стандартные значения, имеющие определенное значение для конкретного метода.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-205">The list typically covers only those values that are specific to the method, as well as those standard values that have some method-specific meaning.</span></span> <span data-ttu-id="e7d1c-206">Следует предположить, что метод может возвращать множество стандартных значений **HRESULT** , даже если они не задокументированы явным образом.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-206">You should assume that a method may return a variety of standard **HRESULT** values, even if they're not explicitly documented.</span></span>

<span data-ttu-id="e7d1c-207">Хотя значения **HRESULT** часто используются для возврата сведений об ошибках, их не следует рассматривать как коды ошибок.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-207">While **HRESULT** values are often used to return error information, you should not think of them as error codes.</span></span> <span data-ttu-id="e7d1c-208">Тот факт, что бит, указывающий на успех или неудачу, хранится отдельно от битов, содержащих подробные сведения, позволяет значениям **HRESULT** иметь любое количество успешных и неудачных кодов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-208">The fact that the bit that indicates success or failure is stored separately from the bits that contain the detailed information allows **HRESULT** values to have any number of success and failure codes.</span></span> <span data-ttu-id="e7d1c-209">По соглашению имена кодов успешного выполнения имеют префикс S_ и коды сбоев, E_.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-209">By convention, the names of success codes are prefixed by S_ and failure codes by E_.</span></span> <span data-ttu-id="e7d1c-210">Например, два наиболее часто используемых кода — это S_OK и E_FAIL, которые указывают на простое или неудачное выполнение соответственно.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-210">For example, the two most commonly used codes are S_OK and E_FAIL, which indicate simple success or failure, respectively.</span></span>

<span data-ttu-id="e7d1c-211">Тот факт, что методы COM могут возвращать различные коды успеха или сбоя, означает, что необходимо соблюдать осторожность при проверке значения **HRESULT** .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-211">The fact that COM methods may return a variety of success or failure codes means that you have to be careful how you test the **HRESULT** value.</span></span> <span data-ttu-id="e7d1c-212">Например, рассмотрим гипотетический метод с документированными возвращаемыми значениями S_OK в случае успеха и E_FAIL в противном случае.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-212">For example, consider a hypothetical method with documented return values of S_OK if successful and E_FAIL if not.</span></span> <span data-ttu-id="e7d1c-213">Однако помните, что метод может также возвращать другие коды ошибок или успешности.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-213">However, remember that the method may also return other failure or success codes.</span></span> <span data-ttu-id="e7d1c-214">В следующем фрагменте кода показана опасность использования простого теста, где `hr` содержит значение **HRESULT** , возвращаемое методом.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-214">The following code fragment illustrates the danger of using a simple test, where `hr` contains the **HRESULT** value returned by the method.</span></span>

```cpp
if (hr == E_FAIL)
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="e7d1c-215">При условии, что в случае сбоя этот метод возвращает только E_FAIL (а не какой-либо другой код ошибки), этот тест работает.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-215">As long as, in the failure case, this method only ever return E_FAIL (and not some other failure code), then this test works.</span></span> <span data-ttu-id="e7d1c-216">Однако более реалистичным является реализация определенного метода для возврата набора конкретных кодов ошибок, возможно E_NOTIMPL или E_INVALIDARG.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-216">However, it's more realistic that a given method is implemented to return a set of specific failure codes, perhaps E_NOTIMPL or E_INVALIDARG.</span></span> <span data-ttu-id="e7d1c-217">В приведенном выше коде эти значения будут неправильно интерпретированы как успешные.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-217">With the code above, those values would be incorrectly interpreted as a success.</span></span>

<span data-ttu-id="e7d1c-218">Если требуются подробные сведения о результатах вызова метода, необходимо протестировать каждое соответствующее значение **HRESULT** .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-218">If you need detailed information about the outcome of the method call, you need to test each relevant **HRESULT** value.</span></span> <span data-ttu-id="e7d1c-219">Тем не менее может быть интересно, что метод завершился успешно или неудачно.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-219">However, you may be interested only in whether the method succeeded or failed.</span></span> <span data-ttu-id="e7d1c-220">Надежный способ проверить, указывает ли значение **HRESULT** об успешном или неудачном завершении, — передать значение в один из следующих макросов, определенных в файле Winerror. h.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-220">A robust way to test whether an **HRESULT** value indicates success or failure is to pass the value to the one of the following macros, defined in Winerror.h.</span></span>

- <span data-ttu-id="e7d1c-221">`SUCCEEDED`Макрос возвращает значение true для кода успешного выполнения и значение false для кода сбоя.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-221">The `SUCCEEDED` macro returns TRUE for a success code, and FALSE for a failure code.</span></span>
- <span data-ttu-id="e7d1c-222">`FAILED`Макрос возвращает значение true для кода ошибки и false для кода успешного выполнения.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-222">The `FAILED` macro returns TRUE for a failure code, and FALSE for a success code.</span></span>

<span data-ttu-id="e7d1c-223">Таким образом, можно исправить предыдущий фрагмент кода с помощью `FAILED` макроса, как показано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-223">So, you can fix the preceding code fragment by using the `FAILED` macro, as shown in the following code.</span></span>

```cpp
if (FAILED(hr))
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="e7d1c-224">Этот исправленный фрагмент кода правильно обрабатывает E_NOTIMPL и E_INVALIDARG как сбои.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-224">This corrected code fragment properly treats E_NOTIMPL and E_INVALIDARG as failures.</span></span>

<span data-ttu-id="e7d1c-225">Хотя большинство методов COM возвращают структурированные значения **HRESULT** , небольшое число использует значение **HRESULT** для возврата простого целого числа.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-225">Although most COM methods return structured **HRESULT** values, a small number use the **HRESULT** to return a simple integer.</span></span> <span data-ttu-id="e7d1c-226">Неявно эти методы всегда выполняются успешно.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-226">Implicitly, these methods are always successful.</span></span> <span data-ttu-id="e7d1c-227">Если **значение HRESULT** этой сортировки передается в макрос успешного выполнения, макрос всегда возвращает значение true.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-227">If you pass an **HRESULT** of this sort to the SUCCEEDED macro, then the macro always returns TRUE.</span></span> <span data-ttu-id="e7d1c-228">Примером часто вызываемого метода, который не возвращает **значение HRESULT** , является метод **IUnknown:: Release** , возвращающий ulong.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-228">An example of a commonly-called method that doesn't return an **HRESULT** is the **IUnknown::Release** method, which returns a ULONG.</span></span> <span data-ttu-id="e7d1c-229">Этот метод уменьшает значение счетчика ссылок объекта на единицу и возвращает текущее число ссылок.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-229">This method decrements an object's reference count by one and returns the current reference count.</span></span> <span data-ttu-id="e7d1c-230">Обсуждение подсчета ссылок см. в разделе [Управление временем жизни COM-объекта](#managing-a-com-objects-lifetime) .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-230">See [Managing a COM object's lifetime](#managing-a-com-objects-lifetime) for a discussion of reference counting.</span></span>

## <a name="the-address-of-a-pointer"></a><span data-ttu-id="e7d1c-231">Адрес указателя</span><span class="sxs-lookup"><span data-stu-id="e7d1c-231">The address of a pointer</span></span>

<span data-ttu-id="e7d1c-232">Если вы просматриваете несколько страниц со ссылками на COM-методы, возможно, вы заработаете примерно следующим образом.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-232">If you view a few COM method reference pages, you'll probably run across something like the following.</span></span>

```cpp
HRESULT D3D12CreateDevice(
  IUnknown          *pAdapter,
  D3D_FEATURE_LEVEL MinimumFeatureLevel,
  REFIID            riid,
  void              **ppDevice
);
```

<span data-ttu-id="e7d1c-233">Хотя обычные указатели хорошо знакомы любому разработчику C/C++, COM часто использует дополнительный уровень косвенного обращения.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-233">While a normal pointer is quite familiar to any C/C++ developer, COM often uses an additional level of indirection.</span></span> <span data-ttu-id="e7d1c-234">Второй уровень косвенного обращения обозначен двумя звездочками, `**` после объявления типа, а имя переменной обычно имеет префикс `pp` .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-234">This second level of indirection is indicated by two asterisks, `**`, following the type declaration, and the variable name typically has a prefix of `pp`.</span></span> <span data-ttu-id="e7d1c-235">Для приведенной выше функции `ppDevice` параметр обычно называется адресом указателя на void.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-235">For the function above, the `ppDevice` parameter is typically referred to as the address of a pointer to a void.</span></span> <span data-ttu-id="e7d1c-236">На практике в этом примере `ppDevice` — это адрес указателя на интерфейс **ID3D12Device** .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-236">In practice, in this example, `ppDevice` is the address of a pointer to an **ID3D12Device** interface.</span></span>

<span data-ttu-id="e7d1c-237">В отличие от объекта C++, доступ к методам COM-объекта напрямую не осуществляется.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-237">Unlike a C++ object, you don't access a COM object's methods directly.</span></span> <span data-ttu-id="e7d1c-238">Вместо этого необходимо получить указатель на интерфейс, предоставляющий метод.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-238">Instead, you must obtain a pointer to an interface that exposes the method.</span></span> <span data-ttu-id="e7d1c-239">Для вызова метода используется практически тот же синтаксис, что и при вызове указателя на метод C++.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-239">To invoke the method, you use essentially the same syntax as you would to invoke a pointer to a C++ method.</span></span> <span data-ttu-id="e7d1c-240">Например, чтобы вызвать метод **IMyInterface::D осомесинг** , используйте следующий синтаксис.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-240">For example, to invoke the **IMyInterface::DoSomething** method, you would use the following syntax.</span></span>

```cpp
IMyInterface * pMyIface = nullptr;
...
pMyIface->DoSomething(...);
```

<span data-ttu-id="e7d1c-241">Необходимость второго уровня косвенного обращения обусловлена тем, что вы не создаете указатели на интерфейсы напрямую.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-241">The need for a second level of indirection comes from the fact that you don't create interface pointers directly.</span></span> <span data-ttu-id="e7d1c-242">Необходимо вызвать один из множества методов, например метод **D3D12CreateDevice** , показанный выше.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-242">You must call one of a variety of methods, such as the **D3D12CreateDevice** method shown above.</span></span> <span data-ttu-id="e7d1c-243">Чтобы использовать такой метод для получения указателя на интерфейс, необходимо объявить переменную как указатель на нужный интерфейс, а затем передать адрес этой переменной методу.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-243">To use such a method to obtain an interface pointer, you declare a variable as a pointer to the desired interface, and then you pass the address of that variable to the method.</span></span> <span data-ttu-id="e7d1c-244">Иными словами, вы передаете адрес указателя на метод.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-244">In other words, you pass the address of a pointer to the method.</span></span> <span data-ttu-id="e7d1c-245">Когда метод возвращает значение, переменная указывает на запрашиваемый интерфейс, и вы можете использовать этот указатель для вызова любого из методов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-245">When the method returns, the variable points to the requested interface, and you can use that pointer to call any of the interface's methods.</span></span>

```cpp
IDXGIAdapter * pIDXGIAdapter = nullptr;
...
ID3D12Device * pD3D12Device = nullptr;
HRESULT hr = ::D3D12CreateDevice(
    pIDXGIAdapter,
    D3D_FEATURE_LEVEL_11_0,
    IID_ID3D12Device,
    &pD3D12Device);
if (FAILED(hr)) return E_FAIL;

// Now use pD3D12Device in the form pD3D12Device->MethodName(...);
```

## <a name="creating-a-com-object"></a><span data-ttu-id="e7d1c-246">Создание COM-объекта</span><span class="sxs-lookup"><span data-stu-id="e7d1c-246">Creating a COM object</span></span>

<span data-ttu-id="e7d1c-247">Существует несколько способов создания COM-объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-247">There are several ways to create a COM object.</span></span> <span data-ttu-id="e7d1c-248">Это два наиболее часто используемых в программировании DirectX.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-248">These are the two most commonly used in DirectX programming.</span></span>

- <span data-ttu-id="e7d1c-249">Косвенно, путем вызова метода или функции DirectX, которая создает объект.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-249">Indirectly, by calling a DirectX method or function that creates the object for you.</span></span> <span data-ttu-id="e7d1c-250">Метод создает объект и возвращает интерфейс для объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-250">The method creates the object, and returns an interface on the object.</span></span> <span data-ttu-id="e7d1c-251">При таком способе создания объекта иногда можно указать, какой интерфейс следует вернуть, а также в других случаях.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-251">When you create an object this way, sometimes you can specify which interface should be returned, other times the interface is implied.</span></span> <span data-ttu-id="e7d1c-252">В приведенном выше примере кода показано, как косвенно создать COM-объект устройства Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-252">The code example above shows how to indirectly create a Direct3D 12 device COM object.</span></span>
- <span data-ttu-id="e7d1c-253">Напрямую, передав CLSID объекта в [**функцию CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-253">Directly, by passing the object's CLSID to the [**CoCreateInstance function**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span> <span data-ttu-id="e7d1c-254">Функция создает экземпляр объекта и возвращает указатель на заданный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-254">The function creates an instance of the object, and it returns a pointer to an interface that you specify.</span></span>

<span data-ttu-id="e7d1c-255">Один раз перед созданием COM-объектов необходимо инициализировать COM, вызвав [**функцию CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-255">One time, before you create any COM objects, you must initialize COM by calling the [**CoInitializeEx function**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="e7d1c-256">Если объекты создаются косвенно, то эта задача обрабатывается методом создания объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-256">If you're creating objects indirectly, then the object creation method handles this task.</span></span> <span data-ttu-id="e7d1c-257">Но если необходимо создать объект с помощью **CoCreateInstance**, необходимо явно вызвать метод **CoInitializeEx** .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-257">But, if you need to create an object with **CoCreateInstance**, then you must call **CoInitializeEx** explicitly.</span></span> <span data-ttu-id="e7d1c-258">Когда все будет готово, COM должен быть инициализирован путем вызова метода [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-258">When you're finished, COM must be uninitialized by calling [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span></span> <span data-ttu-id="e7d1c-259">При вызове **CoInitializeEx** необходимо сопоставить его с вызовом **CoUninitialize**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-259">If you make a call to **CoInitializeEx** then you must match it with a call to **CoUninitialize**.</span></span> <span data-ttu-id="e7d1c-260">Как правило, приложения, которым требуется явная инициализация COM, делают это в подпрограмме запуска, и они отменяют инициализацию COM в своей подпрограмме очистки.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-260">Typically, applications that need to explicitly initialize COM do so in their startup routine, and they uninitialize COM in their cleanup routine.</span></span>

<span data-ttu-id="e7d1c-261">Чтобы создать новый экземпляр COM-объекта с помощью **CoCreateInstance**, необходимо иметь CLSID объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-261">To create a new instance of a COM object with **CoCreateInstance**, you must have the object's CLSID.</span></span> <span data-ttu-id="e7d1c-262">Если этот CLSID является общедоступным, он будет найден в справочной документации или в соответствующем файле заголовка.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-262">If this CLSID is publicly available, you will find it in the reference documentation or the appropriate header file.</span></span> <span data-ttu-id="e7d1c-263">Если CLSID не является общедоступным, вы не сможете создать объект напрямую.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-263">If the CLSID is not publicly available, then you can't create the object directly.</span></span>

<span data-ttu-id="e7d1c-264">Функция **CoCreateInstance** имеет пять параметров.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-264">The **CoCreateInstance** function has five parameters.</span></span> <span data-ttu-id="e7d1c-265">Для COM-объектов, которые будут использоваться с DirectX, обычно можно задать параметры следующим образом.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-265">For the COM objects you will be using with DirectX, you can normally set the parameters as follows.</span></span>

<span data-ttu-id="e7d1c-266">*рклсид* Присвойте этому объекту идентификатор CLSID объекта, который требуется создать.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-266">*rclsid* Set this to the CLSID of the object that you want to create.</span></span>

<span data-ttu-id="e7d1c-267">*пункаутер* Задайте для значение `nullptr` .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-267">*pUnkOuter* Set to `nullptr`.</span></span> <span data-ttu-id="e7d1c-268">Этот параметр используется только при статистической обработке объектов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-268">This parameter is used only if you are aggregating objects.</span></span> <span data-ttu-id="e7d1c-269">Обсуждение агрегата COM выходит за рамки данного раздела.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-269">A discussion of COM aggregation is outside the scope of this topic.</span></span>

<span data-ttu-id="e7d1c-270">*двклсконтекст* Задайте значение CLSCTX_INPROC_SERVER.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-270">*dwClsContext* Set to CLSCTX_INPROC_SERVER.</span></span> <span data-ttu-id="e7d1c-271">Этот параметр указывает, что объект реализован в виде библиотеки DLL и выполняется как часть процесса приложения.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-271">This setting indicates that the object is implemented as a DLL and runs as part of your application's process.</span></span>

<span data-ttu-id="e7d1c-272">*riid* Задайте идентификатор IID интерфейса, который необходимо вернуть.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-272">*riid* Set to the IID of the interface that you would like to have returned.</span></span> <span data-ttu-id="e7d1c-273">Функция создаст объект и вернет запрошенный указатель интерфейса в параметре ППВ.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-273">The function will create the object and return the requested interface pointer in the ppv parameter.</span></span>

<span data-ttu-id="e7d1c-274">*ППВ* Задайте для него адрес указателя, который будет задан интерфейсу, заданному `riid` при возврате функции.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-274">*ppv* Set this to the address of a pointer that will be set to the interface specified by `riid` when the function returns.</span></span> <span data-ttu-id="e7d1c-275">Эта переменная должна быть объявлена как указатель на запрашиваемый интерфейс, а ссылка на указатель в списке параметров должна быть приведена как (ЛПВОИД \*).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-275">This variable should be declared as a pointer to the requested interface, and the reference to the pointer in the parameter list should be cast as (LPVOID \*).</span></span>

<span data-ttu-id="e7d1c-276">Создание объекта, как правило, выполняется гораздо проще, как показано в приведенном выше примере кода.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-276">Creating an object indirectly is usually much simpler, as we saw in the code example above.</span></span> <span data-ttu-id="e7d1c-277">Вы передаете методу создания объекта адрес указателя интерфейса, а затем метод создает объект и возвращает указатель интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-277">You pass the object creation method the address of an interface pointer, and the method then creates the object and returns an interface pointer.</span></span> <span data-ttu-id="e7d1c-278">При прямом создании объекта, даже если не удается выбрать интерфейс, возвращаемый методом, часто можно указать множество вещей о том, как должен быть создан объект.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-278">When you create an object indirectly, even if you can't choose which interface the method returns, often you can still specify a variety of things about how the object should be created.</span></span>

<span data-ttu-id="e7d1c-279">Например, можно передать в **D3D12CreateDevice** значение, указывающее минимальный уровень компонента D3D, который должен поддерживать возвращаемое устройство, как показано в примере кода выше.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-279">For example, you can pass to **D3D12CreateDevice** a value specifying the minimum D3D feature level that the returned device should support, as shown in the code example above.</span></span>

## <a name="using-com-interfaces"></a><span data-ttu-id="e7d1c-280">Использование COM-интерфейсов</span><span class="sxs-lookup"><span data-stu-id="e7d1c-280">Using COM interfaces</span></span>

<span data-ttu-id="e7d1c-281">При создании COM-объекта метод создания возвращает указатель интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-281">When you create a COM object, the creation method returns an interface pointer.</span></span> <span data-ttu-id="e7d1c-282">Затем этот указатель можно использовать для доступа к любому методу интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-282">You can then use that pointer to access any of the interface's methods.</span></span> <span data-ttu-id="e7d1c-283">Синтаксис идентичен тому, который использовался с указателем на метод C++.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-283">The syntax is identical to that used with a pointer to a C++ method.</span></span>

## <a name="requesting-additional-interfaces"></a><span data-ttu-id="e7d1c-284">Запрос дополнительных интерфейсов</span><span class="sxs-lookup"><span data-stu-id="e7d1c-284">Requesting Additional Interfaces</span></span>

<span data-ttu-id="e7d1c-285">Во многих случаях указатель интерфейса, полученный из метода создания, может быть единственным, который вам нужен.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-285">In many cases, the interface pointer that you receive from the creation method may be the only one that you need.</span></span> <span data-ttu-id="e7d1c-286">Фактически, объект может экспортировать только один интерфейс, отличный от **IUnknown**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-286">In fact, it's relatively common for an object to export only one interface other than **IUnknown**.</span></span> <span data-ttu-id="e7d1c-287">Однако многие объекты экспортируют несколько интерфейсов, и вам могут потребоваться указатели на несколько из них.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-287">However, many objects export multiple interfaces, and you may need pointers to several of them.</span></span> <span data-ttu-id="e7d1c-288">Если требуется больше интерфейсов, чем тот, который был возвращен методом создания, нет необходимости создавать новый объект.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-288">If you need more interfaces than the one returned by the creation method, there's no need to create a new object.</span></span> <span data-ttu-id="e7d1c-289">Вместо этого запросите другой указатель интерфейса с помощью [**метода IUnknown:: QueryInterface**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-289">Instead, request another interface pointer by using the object's [**IUnknown::QueryInterface method**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)).</span></span>

<span data-ttu-id="e7d1c-290">При создании объекта с помощью **CoCreateInstance** можно запросить указатель интерфейса **IUnknown** , а затем вызвать **IUnknown:: QueryInterface** , чтобы запросить все необходимые интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-290">If you create your object with **CoCreateInstance**, then you can request an **IUnknown** interface pointer and then call **IUnknown::QueryInterface** to request every interface you need.</span></span> <span data-ttu-id="e7d1c-291">Однако этот подход неудобен, если нужен только один интерфейс, и он не работает вообще, если используется метод создания объекта, который не позволяет указать, какой именно указатель интерфейса должен быть возвращен.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-291">However, this approach is inconvenient if you need only a single interface, and it doesn't work at all if you use an object creation method that doesn't allow you to specify which interface pointer should be returned.</span></span> <span data-ttu-id="e7d1c-292">На практике обычно не требуется получать явный указатель **IUnknown** , так как все COM-интерфейсы расширяют интерфейс **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-292">In practice, you usually don't need to obtain an explicit **IUnknown** pointer, because all COM interfaces extend the **IUnknown** interface.</span></span>

<span data-ttu-id="e7d1c-293">Расширение интерфейса концептуально похоже на наследование от класса C++.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-293">Extending an interface is conceptually similar to inheriting from a C++ class.</span></span> <span data-ttu-id="e7d1c-294">Дочерний интерфейс предоставляет все методы родительского интерфейса, а также один или несколько его собственных методов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-294">The child interface exposes all of the parent interface's methods, plus one or more of its own.</span></span> <span data-ttu-id="e7d1c-295">Фактически, вы часто видите «Inherits from», а не «extends».</span><span class="sxs-lookup"><span data-stu-id="e7d1c-295">In fact, you will often see "inherits from" used instead of "extends".</span></span> <span data-ttu-id="e7d1c-296">Необходимо помнить, что наследование является внутренним по отношению к объекту.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-296">What you need to remember is that the inheritance is internal to the object.</span></span> <span data-ttu-id="e7d1c-297">Приложение не может наследовать или расширять интерфейс объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-297">Your application can't inherit from or extend an object's interface.</span></span> <span data-ttu-id="e7d1c-298">Однако можно использовать дочерний интерфейс для вызова любого из методов дочернего или родительского элемента.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-298">However, you can use the child interface to call any of the methods of the child or parent.</span></span>

<span data-ttu-id="e7d1c-299">Поскольку все интерфейсы являются дочерними элементами **IUnknown**, можно вызвать **QueryInterface** на любом из указателей интерфейса, которые уже имеются для объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-299">Because all interfaces are children of **IUnknown**, you can call **QueryInterface** on any of the interface pointers that you already have for the object.</span></span> <span data-ttu-id="e7d1c-300">При этом необходимо указать IID запрашиваемого интерфейса и адрес указателя, который будет содержать указатель интерфейса при возврате из метода.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-300">When you do so, you must provide the IID of the interface that you're requesting and the address of a pointer that will contain the interface pointer when the method returns.</span></span>

<span data-ttu-id="e7d1c-301">Например, следующий фрагмент кода вызывает **IDXGIFactory2:: креатесвапчаинфорхвнд** для создания основного объекта цепочки подкачки.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-301">For example, the following code fragment calls **IDXGIFactory2::CreateSwapChainForHwnd** to create a primary swap chain object.</span></span> <span data-ttu-id="e7d1c-302">Этот объект предоставляет несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-302">This object exposes several interfaces.</span></span> <span data-ttu-id="e7d1c-303">Метод **креатесвапчаинфорхвнд** возвращает интерфейс **IDXGISwapChain1** .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-303">The **CreateSwapChainForHwnd** method returns an **IDXGISwapChain1** interface.</span></span> <span data-ttu-id="e7d1c-304">Затем в следующем коде используется интерфейс **IDXGISwapChain1** для вызова **QueryInterface** для запроса интерфейса **IDXGISwapChain3** .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-304">The subsequent code then uses the **IDXGISwapChain1** interface to call **QueryInterface** to request an **IDXGISwapChain3** interface.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;
```

> [!NOTE]
> <span data-ttu-id="e7d1c-305">В C++ можно использовать ``IID_PPV_ARGS`` макрос, а не ЯВНЫЙ IID и указатель приведения: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));`` .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-305">In C++ you can make use of the ``IID_PPV_ARGS`` macro rather than the explicit IID and cast pointer: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));``.</span></span>
> <span data-ttu-id="e7d1c-306">Это часто используется для методов создания, а также для **QueryInterface**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-306">This is often used for creation methods as well as **QueryInterface**.</span></span> <span data-ttu-id="e7d1c-307">Дополнительные сведения см. в разделе [комбасеапи. h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-307">See [combaseapi.h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) for more information.</span></span>

## <a name="managing-a-com-objects-lifetime"></a><span data-ttu-id="e7d1c-308">Управление временем существования COM-объекта</span><span class="sxs-lookup"><span data-stu-id="e7d1c-308">Managing a COM object's lifetime</span></span>

<span data-ttu-id="e7d1c-309">При создании объекта система выделяет необходимые ресурсы памяти.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-309">When an object is created, the system allocates the necessary memory resources.</span></span> <span data-ttu-id="e7d1c-310">Если объект больше не нужен, он должен быть уничтожен.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-310">When an object is no longer needed, it should be destroyed.</span></span> <span data-ttu-id="e7d1c-311">Система может использовать эту память для других целей.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-311">The system can use that memory for other purposes.</span></span> <span data-ttu-id="e7d1c-312">С помощью объектов C++ можно управлять временем существования объекта непосредственно с помощью `new` операторов и `delete` в случаях, когда работа выполняется на этом уровне или с использованием стека и времени существования области.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-312">With C++ objects, you can control the object's lifetime directly with the `new` and `delete` operators in cases where you're operating at that level, or just by using the stack and scope lifetime.</span></span> <span data-ttu-id="e7d1c-313">COM не позволяет напрямую создавать или уничтожать объекты.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-313">COM doesn't enable you to directly create or destroy objects.</span></span> <span data-ttu-id="e7d1c-314">Причина этого заключается в том, что один и тот же объект может использоваться несколькими частями приложения или в некоторых случаях несколькими приложениями.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-314">The reason for this design is that the same object may be used by more than one part of your application or, in some cases, by more than one application.</span></span> <span data-ttu-id="e7d1c-315">Если одна из этих ссылок должна уничтожить объект, другие ссылки станут недействительными.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-315">If one of those references were to destroy the object, then the other references would become invalid.</span></span> <span data-ttu-id="e7d1c-316">Вместо этого COM использует систему подсчета ссылок для управления временем существования объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-316">Instead, COM uses a system of reference counting to control an object's lifetime.</span></span>

<span data-ttu-id="e7d1c-317">Число ссылок объекта — это количество запросов к одному из его интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-317">An object's reference count is the number of times one of its interfaces has been requested.</span></span> <span data-ttu-id="e7d1c-318">При каждом запросе интерфейса увеличивается число ссылок.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-318">Each time that an interface is requested, the reference count is incremented.</span></span> <span data-ttu-id="e7d1c-319">Приложение освобождает интерфейс, когда этот интерфейс больше не нужен, уменьшая число ссылок.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-319">An application releases an interface when that interface is no longer needed, decrementing the reference count.</span></span> <span data-ttu-id="e7d1c-320">Пока значение счетчика ссылок больше нуля, объект остается в памяти.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-320">As long as the reference count is greater than zero, the object remains in memory.</span></span> <span data-ttu-id="e7d1c-321">Когда счетчик ссылок достигает нуля, объект уничтожает сам себя.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-321">When the reference count reaches zero, the object destroys itself.</span></span> <span data-ttu-id="e7d1c-322">Вам не нужно ничего знать о счетчике ссылок объекта.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-322">You don't need to know anything about the reference count of an object.</span></span> <span data-ttu-id="e7d1c-323">Пока вы получаете и освобождаете интерфейсы объекта должным образом, у объекта будет соответствующее время существования.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-323">As long as you obtain and release an object's interfaces properly, the object will have the appropriate lifetime.</span></span>

<span data-ttu-id="e7d1c-324">Правильная обработка подсчета ссылок является ключевой частью программирования COM.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-324">Properly handling reference counting is a crucial part of COM programming.</span></span> <span data-ttu-id="e7d1c-325">В противном случае можно легко создать утечку памяти или сбой.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-325">Failure to do so can easily create a memory leak or a crash.</span></span> <span data-ttu-id="e7d1c-326">Одна из наиболее распространенных ошибок, которую делают программисты COM, не позволяет освободить интерфейс.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-326">One of the most common mistakes that COM programmers make is failing to release an interface.</span></span> <span data-ttu-id="e7d1c-327">В этом случае счетчик ссылок никогда не достигнет нуля, и объект остается в памяти неограниченно долго.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-327">When this happens, the reference count never reaches zero, and the object remains in memory indefinitely.</span></span>

> [!NOTE]
> <span data-ttu-id="e7d1c-328">Direct3D 10 или более поздней версии имеет немного измененные правила времени существования для объектов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-328">Direct3D 10 or later has slightly modified lifetime rules for objects.</span></span> <span data-ttu-id="e7d1c-329">В частности, объекты, производные от **ID3DxxDeviceChild** , никогда не наносят свое родительское устройство (т. е. Если **ID3DxxDevice** -владелец равен 0 refcount, то все дочерние объекты также становятся недействительными).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-329">In particular, objects that are derived from **ID3DxxDeviceChild** never outlive their parent device (that is, if the owning **ID3DxxDevice** hits a 0 refcount, then all child objects are immediately invalid as well).</span></span> <span data-ttu-id="e7d1c-330">Кроме того, при использовании методов **Set** для привязки объектов к конвейеру отрисовки эти ссылки не увеличивают число ссылок (то есть они являются слабыми ссылками).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-330">Also, when you use **Set** methods to bind objects to the render pipeline, these references don't increase the reference count (that is, they are weak references).</span></span> <span data-ttu-id="e7d1c-331">На практике этот подход лучше всего обрабатывать, гарантируя, что все дочерние объекты устройств полностью освобождаются до выпуска устройства.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-331">In practice, this is best handled by ensuring that you release all device child objects fully before you release the device.</span></span>

## <a name="incrementing-and-decrementing-the-reference-count"></a><span data-ttu-id="e7d1c-332">Увеличение и уменьшение счетчика ссылок</span><span class="sxs-lookup"><span data-stu-id="e7d1c-332">Incrementing and decrementing the reference count</span></span>

<span data-ttu-id="e7d1c-333">При получении нового указателя интерфейса число ссылок должно увеличиваться путем вызова метода [**IUnknown:: AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-333">Whenever you obtain a new interface pointer, the reference count must be incremented by a call to [**IUnknown::AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span></span> <span data-ttu-id="e7d1c-334">Однако приложению обычно не нужно вызывать этот метод.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-334">However, your application doesn't usually need to call this method.</span></span> <span data-ttu-id="e7d1c-335">Если получить указатель интерфейса путем вызова метода создания объекта или путем вызова **IUnknown:: QueryInterface**, то объект автоматически увеличит число ссылок.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-335">If you obtain an interface pointer by calling an object creation method, or by calling **IUnknown::QueryInterface**, then the object automatically increments the reference count.</span></span> <span data-ttu-id="e7d1c-336">Однако при создании указателя интерфейса другим способом, например при копировании существующего указателя, необходимо явно вызвать **IUnknown:: AddRef**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-336">However, if you create an interface pointer in some other way, such as copying an existing pointer, then you must explicitly call **IUnknown::AddRef**.</span></span> <span data-ttu-id="e7d1c-337">В противном случае при освобождении исходного указателя на интерфейс объект может быть уничтожен, несмотря на то, что может потребоваться использовать копию указателя.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-337">Otherwise, when you release the original interface pointer, the object may be destroyed even though you may still need to use the copy of the pointer.</span></span>

<span data-ttu-id="e7d1c-338">Необходимо освободить все указатели интерфейса, независимо от того, увеличился ли счетчик ссылок у вас или объектов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-338">You must release all interface pointers, regardless of whether you or the object incremented the reference count.</span></span> <span data-ttu-id="e7d1c-339">Если указатель интерфейса больше не нужен, вызовите [**IUnknown:: Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) , чтобы уменьшить число ссылок.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-339">When you no longer need an interface pointer, call [**IUnknown::Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) to decrement the reference count.</span></span> <span data-ttu-id="e7d1c-340">Распространенной практикой является инициализация всех указателей интерфейса на `nullptr` , а затем их возврат к `nullptr` моменту их освобождения.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-340">A common practice is to initialize all interface pointers to `nullptr`, and then to set them back to `nullptr` when they are released.</span></span> <span data-ttu-id="e7d1c-341">Это соглашение позволяет протестировать все указатели интерфейса в коде очистки.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-341">That convention allows you to test all interface pointers in your cleanup code.</span></span> <span data-ttu-id="e7d1c-342">Те, которые `nullptr` еще не активны, необходимо освободить перед завершением работы приложения.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-342">Those that are not `nullptr` are still active, and you need to release them before you terminate the application.</span></span>

<span data-ttu-id="e7d1c-343">Следующий фрагмент кода расширяет пример, показанный ранее, чтобы продемонстрировать способ управления подсчетом ссылок.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-343">The following code fragment extends the sample shown earlier to illustrate how to handle reference counting.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3Copy = nullptr;

// Make a copy of the IDXGISwapChain3 interface pointer.
// Call AddRef to increment the reference count and to ensure that
// the object is not destroyed prematurely.
pDXGISwapChain3Copy = pDXGISwapChain3;
pDXGISwapChain3Copy->AddRef();
...
// Cleanup code. Check to see whether the pointers are still active.
// If they are, then call Release to release the interface.
if (pDXGISwapChain1 != nullptr)
{
    pDXGISwapChain1->Release();
    pDXGISwapChain1 = nullptr;
}
if (pDXGISwapChain3 != nullptr)
{
    pDXGISwapChain3->Release();
    pDXGISwapChain3 = nullptr;
}
if (pDXGISwapChain3Copy != nullptr)
{
    pDXGISwapChain3Copy->Release();
    pDXGISwapChain3Copy = nullptr;
}
```

## <a name="com-smart-pointers"></a><span data-ttu-id="e7d1c-344">Интеллектуальные указатели COM</span><span class="sxs-lookup"><span data-stu-id="e7d1c-344">COM Smart Pointers</span></span>

<span data-ttu-id="e7d1c-345">Код на данный момент был явно вызван ``Release`` и ``AddRef`` для поддержания счетчиков ссылок с помощью методов **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-345">The code so far has explicitly called ``Release`` and ``AddRef`` to maintain the reference counts using **IUnknown** methods.</span></span> <span data-ttu-id="e7d1c-346">Этот шаблон требует тщательного подхода программиста к правильному поддержанию количества во всех возможных кодепасс.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-346">This pattern requires the programmer to be diligent in remembering to properly maintain the count in all possible codepaths.</span></span> <span data-ttu-id="e7d1c-347">Это может привести к сложной обработке ошибок, и при включенной обработке исключений C++ может быть особенно сложно реализовать.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-347">This can result in complicated error-handling, and with C++ exception handling enabled can be particularly difficult to implement.</span></span> <span data-ttu-id="e7d1c-348">Лучшим решением с C++ является использование [смарт-указателя](/cpp/cpp/smart-pointers-modern-cpp).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-348">A better solution with C++ is to make use of a [smart pointer](/cpp/cpp/smart-pointers-modern-cpp).</span></span>

* <span data-ttu-id="e7d1c-349">**WinRT:: com_ptr** — это интеллектуальный указатель, предоставляемый [проектами языка C++/WinRT](/uwp/cpp-ref-for-winrt/com-ptr).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-349">**winrt::com_ptr** is a smart pointer provided by the [C++/WinRT language projections](/uwp/cpp-ref-for-winrt/com-ptr).</span></span> <span data-ttu-id="e7d1c-350">Это рекомендуемый интеллектуальный указатель COM для использования в приложениях UWP.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-350">This is the recommended COM smart pointer to use for UWP apps.</span></span> <span data-ttu-id="e7d1c-351">Обратите внимание, что C++/WinRT требует C++ 17.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-351">Note that C++/WinRT requires C++17.</span></span>

* <span data-ttu-id="e7d1c-352">**Microsoft:: WRL:: ComPtr** — это интеллектуальный указатель, предоставляемый [библиотекой шаблонов среда выполнения Windows C++ (WRL)](/cpp/cppcx/wrl/comptr-class).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-352">**Microsoft::WRL::ComPtr** is a smart pointer provided by the [Windows Runtime C++ Template Library (WRL)](/cpp/cppcx/wrl/comptr-class).</span></span> <span data-ttu-id="e7d1c-353">Эта библиотека является "чистым" C++, поэтому ее можно использовать для среда выполнения Windows приложений (через C++/CX или C++/WinRT), а также для классических приложений Win32.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-353">This library is "pure" C++ so it can be utilized for Windows Runtime applications (via C++/CX or C++/WinRT) as well as classic Win32 desktop applications.</span></span> <span data-ttu-id="e7d1c-354">Этот интеллектуальный указатель также работает в более старых версиях Windows, которые не поддерживают API-интерфейсы среда выполнения Windows.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-354">This smart pointer also works on older versions of Windows that do not support the Windows Runtime APIs.</span></span> <span data-ttu-id="e7d1c-355">Для классических приложений Win32 можно использовать ``#include <wrl/client.h>`` для включения этого класса, а также при необходимости определять символ препроцессора ``__WRL_CLASSIC_COM_STRICT__`` .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-355">For Win32 desktop applications, you can use ``#include <wrl/client.h>`` to only include this class and optionally define the preprocessor symbol ``__WRL_CLASSIC_COM_STRICT__`` as well.</span></span> <span data-ttu-id="e7d1c-356">Дополнительные сведения см. в разделе [смарт-указатели COM, посещенные](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited)повторно.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-356">For more information, see [COM smart pointers revisited](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span></span>

* <span data-ttu-id="e7d1c-357">**CComPtr** — это интеллектуальный указатель, предоставляемый [библиотекой активных шаблонов (ATL)](/cpp/atl/reference/ccomptr-class).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-357">**CComPtr** is a smart pointer provided by the [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span></span> <span data-ttu-id="e7d1c-358">**Microsoft:: WRL:: ComPtr** является новой версией этой реализации, которая решает ряд незначительных проблем с использованием, поэтому использовать этот интеллектуальный указатель не рекомендуется для новых проектов.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-358">The **Microsoft::WRL::ComPtr** is a newer version of this implementation that addresses a number of subtle usage issues, so use of this smart pointer is not recommended for new projects.</span></span> <span data-ttu-id="e7d1c-359">Дополнительные сведения см. [в разделе Создание и использование CComPtr и CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span><span class="sxs-lookup"><span data-stu-id="e7d1c-359">For more information, see [How to create and use CComPtr and CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span></span>


## <a name="using-atl-with-directx-9"></a><span data-ttu-id="e7d1c-360">Использование ATL с DirectX 9</span><span class="sxs-lookup"><span data-stu-id="e7d1c-360">Using ATL with DirectX 9</span></span>

<span data-ttu-id="e7d1c-361">Чтобы использовать библиотеку активных шаблонов (ATL) с DirectX 9, необходимо переопределить интерфейсы для совместимости с библиотекой ATL.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-361">To use the Active Template Library (ATL) with DirectX 9, you must redefine the interfaces for ATL compatibility.</span></span> <span data-ttu-id="e7d1c-362">Это позволяет правильно использовать класс **CComQIPtr** для получения указателя на интерфейс.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-362">This allows you to properly use the **CComQIPtr** class to obtain a pointer to an interface.</span></span>

<span data-ttu-id="e7d1c-363">Вы узнаете, не переопределяйте ли интерфейсы для ATL, так как вы увидите следующее сообщение об ошибке.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-363">You'll know if you don't redefine the interfaces for ATL, because you'll see the following error message.</span></span>

```
[...]\atlmfc\include\atlbase.h(4704) :   error C2787: 'IDirectXFileData' : no GUID has been associated with this object
```

<span data-ttu-id="e7d1c-364">В следующем примере кода показано, как определить интерфейс Идиректксфиледата.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-364">The following code sample shows how to define the IDirectXFileData interface.</span></span>

```cpp
// Explicit declaration
struct __declspec(uuid("{3D82AB44-62DA-11CF-AB39-0020AF71E433}")) IDirectXFileData;

// Macro method
#define RT_IID(iid_, name_) struct __declspec(uuid(iid_)) name_
RT_IID("{1DD9E8DA-1C77-4D40-B0CF-98FEFDFF9512}", IDirectXFileData);
```

<span data-ttu-id="e7d1c-365">После переопределения интерфейса необходимо использовать метод **attach** для подключения интерфейса к указателю интерфейса, возвращаемому **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-365">After redefining the interface, you must use the **Attach** method to attach the interface to the interface pointer returned by **::Direct3DCreate9**.</span></span> <span data-ttu-id="e7d1c-366">В противном случае интерфейс **IDirect3D9** не будет правильно освобожден классом интеллектуального указателя.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-366">If you don't, then the **IDirect3D9** interface won't be properly released by the smart pointer class.</span></span>

<span data-ttu-id="e7d1c-367">Класс **CComPtr** внутренне вызывает **IUnknown:: AddRef** для указателя интерфейса при создании объекта и при назначении интерфейса классу **CComPtr** .</span><span class="sxs-lookup"><span data-stu-id="e7d1c-367">The **CComPtr** class internally calls **IUnknown::AddRef** on the interface pointer when the object is created and when an interface is assigned to the **CComPtr** class.</span></span> <span data-ttu-id="e7d1c-368">Чтобы избежать утечки указателя интерфейса, не вызывайте \* \* IUnknown:: AddRef в интерфейсе, возвращенном из **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-368">To avoid leaking the interface pointer, don't call \*\*IUnknown::AddRef on the interface returned from **::Direct3DCreate9**.</span></span>

<span data-ttu-id="e7d1c-369">Следующий код правильно освобождает интерфейс, не вызывая **IUnknown:: AddRef**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-369">The following code properly releases the interface without calling **IUnknown::AddRef**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d;
d3d.Attach(::Direct3DCreate9(D3D_SDK_VERSION));
```

<span data-ttu-id="e7d1c-370">Используйте предыдущий код.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-370">Use the previous code.</span></span> <span data-ttu-id="e7d1c-371">Не используйте следующий код, который вызывает **IUnknown:: AddRef** , а затем **IUnknown:: Release** и не освобождает ссылку, добавленную **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-371">Don't use the following code, which calls **IUnknown::AddRef** followed by **IUnknown::Release**, and doesn't release the reference added by **::Direct3DCreate9**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d = ::Direct3DCreate9(D3D_SDK_VERSION);
```

<span data-ttu-id="e7d1c-372">Обратите внимание, что это единственное место в Direct3D 9, где вам придется использовать метод **attach** таким образом.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-372">Note that this is the only place in Direct3D 9 where you'll have to use the **Attach** method in this manner.</span></span>

<span data-ttu-id="e7d1c-373">Дополнительные сведения о классах **CComPTR** и **CComQIPtr** см. в их определениях в `Atlbase.h` файле заголовка.</span><span class="sxs-lookup"><span data-stu-id="e7d1c-373">For more information about the **CComPTR** and **CComQIPtr** classes, see their definitions in the `Atlbase.h` header file.</span></span>
