---
description: Возможности видео
ms.assetid: 305bd009-f58e-4dcc-9b70-252de87dc86d
title: Возможности видео
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6287839b75bd5044644480c3abcc8248cc46dc0a
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104562556"
---
# <a name="video-capabilities"></a><span data-ttu-id="9deff-103">Возможности видео</span><span class="sxs-lookup"><span data-stu-id="9deff-103">Video Capabilities</span></span>

<span data-ttu-id="9deff-104">Метод [**иамстреамконфиг:: жетстреамкапс**](/windows/desktop/api/Strmif/nf-strmif-iamstreamconfig-getstreamcaps) предоставляет возможности видео в виде массивов пар " [**\_ \_ тип мультимедиа**](/windows/win32/api/strmif/ns-strmif-am_media_type) " и " [**\_ \_ Конфигурация \_ потока видео**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) ".</span><span class="sxs-lookup"><span data-stu-id="9deff-104">The [**IAMStreamConfig::GetStreamCaps**](/windows/desktop/api/Strmif/nf-strmif-iamstreamconfig-getstreamcaps) method presents video capabilities in an array of pairs of [**AM\_MEDIA\_TYPE**](/windows/win32/api/strmif/ns-strmif-am_media_type) and [**VIDEO\_STREAM\_CONFIG\_CAPS**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) structures.</span></span> <span data-ttu-id="9deff-105">Его можно использовать для предоставления всех форматов и разрешений, поддерживаемых на ПИН-коде, как описано ниже.</span><span class="sxs-lookup"><span data-stu-id="9deff-105">You can use this to expose all the formats and resolutions supported on a pin as discussed below.</span></span>

<span data-ttu-id="9deff-106">Примеры **жетстреамкапс** см. в статье [возможности](audio-capabilities.md)работы с аудио.</span><span class="sxs-lookup"><span data-stu-id="9deff-106">For audio-related examples of **GetStreamCaps**, see [Audio Capabilities](audio-capabilities.md).</span></span>

<span data-ttu-id="9deff-107">Предположим, что карта захвата поддерживает формат JPEG при любых разрешениях между 160 x 120 пикселей и 320 x 240 пикселей включительно.</span><span class="sxs-lookup"><span data-stu-id="9deff-107">Suppose your capture card supports JPEG format at all resolutions between 160 x 120 pixels and 320 x 240 pixels, inclusive.</span></span> <span data-ttu-id="9deff-108">Разница между поддерживаемыми разрешениями в данном случае заключается в том, что вы добавляете или вычитаете один пиксел из каждого поддерживаемого разрешения, чтобы получить следующее поддерживаемое разрешение.</span><span class="sxs-lookup"><span data-stu-id="9deff-108">The difference between supported resolutions is one in this case because you add or subtract one pixel from each supported resolution to get the next supported resolution.</span></span> <span data-ttu-id="9deff-109">Это различие в поддерживаемых разрешениях называется степенью гранулярности.</span><span class="sxs-lookup"><span data-stu-id="9deff-109">This difference in supported resolutions is called granularity.</span></span>

<span data-ttu-id="9deff-110">Предположим, что ваша карта также поддерживает размер 640 x 480.</span><span class="sxs-lookup"><span data-stu-id="9deff-110">Suppose your card also supports the size 640 x 480.</span></span> <span data-ttu-id="9deff-111">Ниже показано одно и то же разрешение и приведенный выше диапазон разрешений (все размеры находятся в диапазоне от 160 x 120 пикселей до 320 x 240 пикселей).</span><span class="sxs-lookup"><span data-stu-id="9deff-111">The following illustrates this single resolution and the above range of resolutions (all sizes between 160 x 120 pixels and 320 x 240 pixels).</span></span>

![разрешение от 160 x 120 до 320 x 240 пикселей, а также 640 x 480](images/strmcap1.png)

<span data-ttu-id="9deff-113">Кроме того, предположим, что он поддерживает 24-разрядный формат RGB при разрешении между 160 x 120 и 320 x 240, но с гранулярностью в 8.</span><span class="sxs-lookup"><span data-stu-id="9deff-113">Also, suppose it supports 24-bit color RGB format at resolutions between 160 x 120 and 320 x 240, but with a granularity of 8.</span></span> <span data-ttu-id="9deff-114">На следующем рисунке показаны некоторые допустимые размеры в этом случае.</span><span class="sxs-lookup"><span data-stu-id="9deff-114">The following illustration shows some of the valid sizes in this case.</span></span>

![разрешение от 160 x 120 до 320 до 240 с детализацией = 8](images/strmcap3.png)

<span data-ttu-id="9deff-116">Чтобы разместить его другим способом и вывести дополнительные разрешения, в списке допустимых разрешений будут использоваться следующие.</span><span class="sxs-lookup"><span data-stu-id="9deff-116">To put it another way, and listing more resolutions, the following are all among the list of valid resolutions.</span></span>

-   <span data-ttu-id="9deff-117">160 x 120</span><span class="sxs-lookup"><span data-stu-id="9deff-117">160 x 120</span></span>
-   <span data-ttu-id="9deff-118">168 x 120</span><span class="sxs-lookup"><span data-stu-id="9deff-118">168 x 120</span></span>
-   <span data-ttu-id="9deff-119">168 x 128</span><span class="sxs-lookup"><span data-stu-id="9deff-119">168 x 128</span></span>
-   <span data-ttu-id="9deff-120">176 x 128</span><span class="sxs-lookup"><span data-stu-id="9deff-120">176 x 128</span></span>
-   <span data-ttu-id="9deff-121">176 x 136</span><span class="sxs-lookup"><span data-stu-id="9deff-121">176 x 136</span></span>
-   <span data-ttu-id="9deff-122">... Дополнительные разрешения...</span><span class="sxs-lookup"><span data-stu-id="9deff-122">... additional resolutions ...</span></span>
-   <span data-ttu-id="9deff-123">312 x 232</span><span class="sxs-lookup"><span data-stu-id="9deff-123">312 x 232</span></span>
-   <span data-ttu-id="9deff-124">320 x 240</span><span class="sxs-lookup"><span data-stu-id="9deff-124">320 x 240</span></span>

<span data-ttu-id="9deff-125">Используйте **жетстреамкапс** для предоставления таких форматов и возможностей измерений, предлагая тип мультимедиа 320 x 240 JPEG (если это ваш размер по умолчанию или предпочтительный), с минимальными возможностями 160 x 120, максимальными возможностями 320 x 240 и степенью детализации 1.</span><span class="sxs-lookup"><span data-stu-id="9deff-125">Use **GetStreamCaps** to expose these color format and dimension capabilities by offering a media type of 320 x 240 JPEG (if that is your default or preferred size) coupled with minimum capabilities of 160 x 120, maximum capabilities of 320 x 240, and a granularity of 1.</span></span> <span data-ttu-id="9deff-126">Следующая пара, которую вы предоставляете с помощью **жетстреамкапс** , — это тип носителя 640 x 480 JPEG, связанный с минимумом 640 x 480 и не более 640 x 480 и степенью гранулярности 0.</span><span class="sxs-lookup"><span data-stu-id="9deff-126">The next pair you expose by using **GetStreamCaps** is a media type of 640 x 480 JPEG coupled with a minimum of 640 x 480 and a maximum of 640 x 480 and a granularity of 0.</span></span> <span data-ttu-id="9deff-127">Третья пара включает тип мультимедиа 320 x 240, 24-разрядный RGB с минимальными возможностями 160 x 120, максимальные возможности 320 x 240 и гранулярность 8.</span><span class="sxs-lookup"><span data-stu-id="9deff-127">The third pair includes a media type of 320 x 240, 24-bit RGB with minimum capabilities of 160 x 120, maximum capabilities of 320 x 240, and a granularity of 8.</span></span> <span data-ttu-id="9deff-128">Таким образом можно публиковать почти все форматы и возможности, которые может поддерживать ваша карта.</span><span class="sxs-lookup"><span data-stu-id="9deff-128">In this way you can publish almost every format and capability your card might support.</span></span> <span data-ttu-id="9deff-129">Приложение, которое должно иметь представление о том, какие форматы сжатия вы предоставляете, может получить все пары и создать список всех уникальных подтипов типов мультимедиа.</span><span class="sxs-lookup"><span data-stu-id="9deff-129">An application that must know what compression formats you provide can get all the pairs and make a list of all the unique subtypes of the media types.</span></span>

<span data-ttu-id="9deff-130">Фильтр получает источник типа мультимедиа и целевые прямоугольники из элементов **рксаурце** и **рктаржет** структуры [**видеоинфохеадер**](/previous-versions/windows/desktop/api/amvideo/ns-amvideo-videoinfoheader) соответственно.</span><span class="sxs-lookup"><span data-stu-id="9deff-130">A filter obtains its media type source and target rectangles from the [**VIDEOINFOHEADER**](/previous-versions/windows/desktop/api/amvideo/ns-amvideo-videoinfoheader) structure's **rcSource** and **rcTarget** members, respectively.</span></span> <span data-ttu-id="9deff-131">Фильтры не обязательно должны поддерживать исходный и целевой прямоугольники.</span><span class="sxs-lookup"><span data-stu-id="9deff-131">Filters do not have to support source and target rectangles.</span></span>

<span data-ttu-id="9deff-132">Прямоугольник обрезки, описанный в документации по [**иамстреамконфиг**](/windows/desktop/api/Strmif/nn-strmif-iamstreamconfig) , аналогичен прямоугольнику **рксаурце** структуры **видеоинфохеадер** для выходного контакта.</span><span class="sxs-lookup"><span data-stu-id="9deff-132">The cropping rectangle described throughout the [**IAMStreamConfig**](/windows/desktop/api/Strmif/nn-strmif-iamstreamconfig) documentation is the same as the **VIDEOINFOHEADER** structure's **rcSource** rectangle for the output pin.</span></span>

<span data-ttu-id="9deff-133">Прямоугольник вывода, описанный в документации по **иамстреамконфиг** , аналогичен элементам **бивидс** и **бихеигхт** структуры **битмапинфохеадер** (см. [DV-данные в формате AVI](dv-data-in-the-avi-file-format.md)).</span><span class="sxs-lookup"><span data-stu-id="9deff-133">The output rectangle described throughout the **IAMStreamConfig** documentation is the same as the **biWidth** and **biHeight** members of the output pin's **BITMAPINFOHEADER** structure (see [DV Data in the AVI File Format](dv-data-in-the-avi-file-format.md).).</span></span>

<span data-ttu-id="9deff-134">Если закрепление вывода фильтра подключено к типу мультимедиа с непустым исходным и целевым прямоугольниками, то фильтр необходим для растяжения исходного подпрямоугольника входного формата в целевой подпрямоугольник формата вывода.</span><span class="sxs-lookup"><span data-stu-id="9deff-134">If a filter's output pin is connected to a media type with nonempty source and target rectangles, then your filter is required to stretch the input format's source subrectangle into the output format's target subrectangle.</span></span> <span data-ttu-id="9deff-135">Исходный подпрямоугольник хранится в элементе **инпутсизе** структуры [**\_ CAPS в \_ конфигурации \_ потока видео**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) .</span><span class="sxs-lookup"><span data-stu-id="9deff-135">The source subrectangle is stored in the [**VIDEO\_STREAM\_CONFIG\_CAPS**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) structure's **InputSize** member.</span></span>

<span data-ttu-id="9deff-136">Например, рассмотрим следующий сценарий сжатия видео: входной образ имеет формат RGB и имеет размер 160 x 120 пикселей.</span><span class="sxs-lookup"><span data-stu-id="9deff-136">For example, consider the following video compressor scenario: The input image is in RGB format and has a size of 160 x 120 pixels.</span></span> <span data-ttu-id="9deff-137">Левый верхний угол исходного прямоугольника имеет координаты в координатах (20, 20), а правый нижний угол — в (30, 30).</span><span class="sxs-lookup"><span data-stu-id="9deff-137">The source rectangle's upper-left corner is at coordinate (20,20), and its lower-right corner is at (30,30).</span></span> <span data-ttu-id="9deff-138">Выходное изображение имеет формат MPEG и имеет размер 320 x 240.</span><span class="sxs-lookup"><span data-stu-id="9deff-138">The output image is in MPEG format with a size of 320 x 240.</span></span> <span data-ttu-id="9deff-139">Левый верхний угол прямоугольника находится в точке (0, 0), а правый нижний угол — в (100 100).</span><span class="sxs-lookup"><span data-stu-id="9deff-139">The target rectangle's upper-left corner is at (0,0) and its lower-right corner is at (100,100).</span></span> <span data-ttu-id="9deff-140">В этом случае фильтр должен взять 10 x 10 битов растрового изображения источника RGB 160 x 120 и заполнить верхнюю область 100 x 100 точечного рисунка 320 x 240, не затрагивая остальную часть точечного рисунка 320 x 240.</span><span class="sxs-lookup"><span data-stu-id="9deff-140">In this case, the filter should take a 10 x 10 piece of the 160 x 120 RGB source bitmap, and make it fill the top 100 x 100 area of a 320 x 240 bitmap, leaving the rest of the 320 x 240 bitmap untouched.</span></span> <span data-ttu-id="9deff-141">Этот сценарий показан на следующем рисунке.</span><span class="sxs-lookup"><span data-stu-id="9deff-141">The following illustration shows this scenario.</span></span>

![растяжение подпрямоугольника](images/strmcap4.png)

<span data-ttu-id="9deff-143">Фильтр может не поддерживать это и может не подключаться к типу мультимедиа, где **рксаурце** и **рктаржет** не являются пустыми.</span><span class="sxs-lookup"><span data-stu-id="9deff-143">A filter might not support this and can fail to connect with a media type where **rcSource** and **rcTarget** are not empty.</span></span>

<span data-ttu-id="9deff-144">Структура **видеоинфохеадер** предоставляет сведения о возможностях скорости передачи данных в фильтре.</span><span class="sxs-lookup"><span data-stu-id="9deff-144">The **VIDEOINFOHEADER** structure exposes information about a filter's data rate capabilities.</span></span> <span data-ttu-id="9deff-145">Например, предположим, что вы подключились к следующему фильтру с определенным типом мультимедиа (напрямую или с помощью типа мультимедиа, переданного функцией [**кмедиатипе:: сетформат**](cmediatype-setformat.md) ).</span><span class="sxs-lookup"><span data-stu-id="9deff-145">For example, suppose you connected your output pin to the next filter with a certain media type (either directly or by using the media type passed by the [**CMediaType::SetFormat**](cmediatype-setformat.md) function).</span></span> <span data-ttu-id="9deff-146">Взгляните на элемент **двбитрате** этой структуры формата **видеоинфохеадер** , чтобы узнать, в какой скорости данных следует сжимать видео.</span><span class="sxs-lookup"><span data-stu-id="9deff-146">Look at the **dwBitRate** member of that media type's **VIDEOINFOHEADER** format structure to see what data rate you should compress the video to.</span></span> <span data-ttu-id="9deff-147">Если умножить количество единиц времени на кадр в **авгтимеперфраме** структуры **видеоинфохеадер** на скорость передачи данных в элементе **двбитрате** и разделить на 10 000 000 (количество единиц в секунду), можно определить, сколько байт каждого кадра должно быть.</span><span class="sxs-lookup"><span data-stu-id="9deff-147">If you multiply the number of units of time per frame in the **VIDEOINFOHEADER** structure's **AvgTimePerFrame** member by the data rate in the **dwBitRate** member and divide by 10,000,000 (the number of units per second), you can figure out how many bytes each frame should be.</span></span> <span data-ttu-id="9deff-148">Вы можете создать рамку меньшего размера, но не больше ее.</span><span class="sxs-lookup"><span data-stu-id="9deff-148">You can produce a smaller sized frame, but never a larger one.</span></span> <span data-ttu-id="9deff-149">Чтобы определить частоту кадров для видеокомпрессора или фильтра записи, используйте **авгтимеперфраме** из типа носителя выходного контакта.</span><span class="sxs-lookup"><span data-stu-id="9deff-149">To determine the frame rate for a video compressor or for a capture filter, use **AvgTimePerFrame** from your output pin's media type.</span></span>

 

 



