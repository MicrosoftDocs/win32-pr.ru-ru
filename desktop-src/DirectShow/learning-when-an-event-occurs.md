---
description: Обучение При возникновении события
ms.assetid: 4e44089b-676b-4220-9721-54ddf56bf760
title: Обучение При возникновении события
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 58696055bdf1e3cbf3cf36c4db4ae2258bda334956fcaa14f33eda96db249773
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118397220"
---
# <a name="learning-when-an-event-occurs"></a>Обучение При возникновении события

для обработки DirectShow событий приложению необходим способ выяснить, когда события ожидают в очереди. диспетчер Graphа фильтров предоставляет два способа:

-   **Уведомление окна:** фильтр Graph Manager отправляет определяемое пользователем сообщение Windows в окно приложения при возникновении нового события.
-   **Сигнализация события:** фильтр Graph Manager передает Windows событие, если в очереди есть события DirectShow, и сбрасывает событие, если очередь пуста.

Приложение может использовать любой из этих методов. Уведомление окна обычно проще.

**Уведомление окна**

Чтобы настроить уведомление окна, вызовите метод [**имедиаевентекс:: сетнотифивиндов**](/windows/desktop/api/Control/nf-control-imediaeventex-setnotifywindow) и укажите частное сообщение. Приложения могут использовать номера сообщений в диапазоне от приложения WM \_ через 0xBFFF как частные сообщения. каждый раз, когда фильтр Graph Manager помещает новое уведомление о событии в очередь, оно отправляет это сообщение в указанное окно. Приложение реагирует на сообщение в цикле обработки сообщений окна.

В следующем примере кода показано, как задать окно уведомления.


```C++
#define WM_GRAPHNOTIFY WM_APP + 1   // Private message.
pEvent->SetNotifyWindow((OAHWND)g_hwnd, WM_GRAPHNOTIFY, 0);
```



сообщение является обычным Windows сообщением и публикуется отдельно от DirectShow очереди уведомлений о событиях. Преимуществом этого подхода является то, что большинство приложений уже реализуют цикл обработки сообщений. таким образом, можно реализовать DirectShow обработку событий без значительной дополнительной работы.

В следующем примере кода показано, как реагировать на сообщение уведомления. Полный пример см. в разделе [реагирование на события](responding-to-events.md).


```C++
LRESULT CALLBACK WindowProc( HWND hwnd, UINT msg, UINT wParam, LONG lParam)
{
    switch (msg)
    {
        case WM_GRAPHNOTIFY:
            HandleEvent();  // Application-defined function.
            break;
        // Handle other Windows messages here too.
    }
    return (DefWindowProc(hwnd, msg, wParam, lParam));
}
```



Так как уведомления о событиях и цикл сообщений являются асинхронными, очередь может содержать более одного события на время ответа приложения на сообщение. Кроме того, события иногда могут быть удалены из очереди, если они становятся недействительными. Поэтому в коде обработки событий вызовите [**иаммедиаевент::-четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) , пока не вернется код сбоя, указывающий, что очередь пуста.

Перед освобождением указателя [**имедиаевентекс**](/windows/desktop/api/Control/nn-control-imediaeventex) отмените уведомление о событии, вызвав [**сетнотифивиндов**](/windows/desktop/api/Control/nf-control-imediaeventex-setnotifywindow) с **пустым** указателем. В коде обработки событий проверьте, является ли указатель **имедиаевентекс** допустимым, прежде чем [**вызывать метод**](/windows/desktop/api/Control/nf-control-imediaevent-getevent). Эти действия препятствуют возможной ошибке, при которой приложение получает уведомление о событии после того, как оно выпустило указатель **имедиаевентекс** .

**Сигнализация о событиях**

фильтр Graph Manager сохраняет событие ручного сброса, которое отражает состояние очереди событий. если очередь содержит уведомления о событиях, ожидающих выполнения, диспетчер Graph Manager сигнализирует о событии ручного сброса. Если очередь пуста, вызов метода [**имедиаевент::-четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) сбрасывает событие. Приложение может использовать это событие для определения состояния очереди.

> [!Note]  
> Эта терминология может быть запутанной. событие ручного сброса — это тип события, созданного функцией Windows [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa) ; Он не имеет никаких действий с событиями, определенными DirectShow.

 

Вызовите метод [**имедиаевент:: жетевенсандле**](/windows/desktop/api/Control/nf-control-imediaevent-geteventhandle) , чтобы получить маркер события ручного сброса. Дождитесь получения сигнала о событии, вызвав функцию, например [**WaitForMultipleObjects**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects). после получения сигнала для события вызовите [**имедиаевент::-четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) , чтобы получить событие DirectShow.

Этот подход показан в следующем примере кода. Он получает дескриптор события, а затем ожидает в 100-миллисекундах интервала для события. Если событие является сигнальным, оно вызывает метод in и выводит код **события и параметры** события в окно консоли. Цикл завершается, когда происходит событие [**EC \_ Complete**](ec-complete.md) , что означает, что воспроизведение завершено.


```C++
HANDLE  hEvent; 
long    evCode, param1, param2;
BOOLEAN bDone = FALSE;
HRESULT hr = S_OK;
hr = pEvent->GetEventHandle((OAEVENT*)&hEvent);
if (FAILED(hr))
{
    /* Insert failure-handling code here. */
}

while(!bDone) 
{
    if (WAIT_OBJECT_0 == WaitForSingleObject(hEvent, 100))
    { 
        while (S_OK == pEvent->GetEvent(&evCode, &param1, &param2, 0)) 
        {
            printf("Event code: %#04x\n Params: %d, %d\n", evCode, param1, param2);
            pEvent->FreeEventParams(evCode, param1, param2);
            bDone = (EC_COMPLETE == evCode);
        }
    }
} 
```



Так как граф фильтра автоматически задает или сбрасывает событие, если это уместно, приложение не должно этого делать. Кроме того, при освобождении графа фильтра граф фильтра закрывает обработчик события, поэтому не следует использовать этот обработчик после этой точки.

 

 
