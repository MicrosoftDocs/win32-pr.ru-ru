---
description: Общие сведения о потоке данных в DirectShow
ms.assetid: a1b30592-5106-44f5-8ee0-577573670167
title: Общие сведения о потоке данных в DirectShow
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5b5a34444991d6cba62026935f5ec2d7aa4eba77
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104495447"
---
# <a name="overview-of-data-flow-in-directshow"></a><span data-ttu-id="a6b93-103">Общие сведения о потоке данных в DirectShow</span><span class="sxs-lookup"><span data-stu-id="a6b93-103">Overview of Data Flow in DirectShow</span></span>

<span data-ttu-id="a6b93-104">В этом разделе содержится общий обзор работы потока данных в DirectShow.</span><span class="sxs-lookup"><span data-stu-id="a6b93-104">This section gives a broad overview of how data flow works in DirectShow.</span></span> <span data-ttu-id="a6b93-105">Подробные сведения можно найти в других разделах документации.</span><span class="sxs-lookup"><span data-stu-id="a6b93-105">Details can be found in other sections of the documentation.</span></span>

<span data-ttu-id="a6b93-106">Данные хранятся в буферах, которые представляют собой просто массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="a6b93-106">Data is held in buffers, which are simply arrays of bytes.</span></span> <span data-ttu-id="a6b93-107">Каждый буфер упаковывается COM-объектом, называемым *примером мультимедиа*, который реализует интерфейс [**имедиасампле**](/windows/desktop/api/Strmif/nn-strmif-imediasample) .</span><span class="sxs-lookup"><span data-stu-id="a6b93-107">Each buffer is wrapped by a COM object called a *media sample*, which implements the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="a6b93-108">Образцы создаются другим типом объекта, который называется распределителем, реализующим интерфейс [**имемаллокатор**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) .</span><span class="sxs-lookup"><span data-stu-id="a6b93-108">Samples are created by another type of object, called an allocator, which implements the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="a6b93-109">Распределитель назначается для каждого подключения к ПИН-коду, хотя два или более подключения ПИН-кода могут использовать один и тот же распределитель.</span><span class="sxs-lookup"><span data-stu-id="a6b93-109">An allocator is assigned for every pin connection, although two or more pin connections might share the same allocator.</span></span> <span data-ttu-id="a6b93-110">Этот процесс показан на следующем рисунке.</span><span class="sxs-lookup"><span data-stu-id="a6b93-110">The following image illustrates this process.</span></span>

![буферы, примеры и распределительы](images/dataflow.png)

<span data-ttu-id="a6b93-112">Каждый распределитель создает пул образцов носителей и выделяет буферы для каждого образца.</span><span class="sxs-lookup"><span data-stu-id="a6b93-112">Each allocator creates a pool of media samples and allocates the buffers for each sample.</span></span> <span data-ttu-id="a6b93-113">Каждый раз, когда фильтр должен заполнить буфер данными, он запрашивает выборку из распределителя путем вызова [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="a6b93-113">Whenever a filter needs to fill a buffer with data, it requests a sample from the allocator by calling [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="a6b93-114">Если распределитель содержит какие-либо выборки, которые в настоящее время не используются другим фильтром **, метод метода** WebMethod возвращает значение сразу с указателем на образец.</span><span class="sxs-lookup"><span data-stu-id="a6b93-114">If the allocator has any samples that are not currently in use by another filter, the **GetBuffer** method returns immediately with a pointer to the sample.</span></span> <span data-ttu-id="a6b93-115">Если все примеры распределителя используются, метод блокируется до тех пор, пока образец не станет доступным.</span><span class="sxs-lookup"><span data-stu-id="a6b93-115">If all of the allocator's samples are in use, the method blocks until a sample becomes available.</span></span> <span data-ttu-id="a6b93-116">Когда метод возвращает образец, фильтр помещает данные в буфер, устанавливает соответствующие флаги для образца (обычно включая метку времени) и доставляет пример в нисходящей.</span><span class="sxs-lookup"><span data-stu-id="a6b93-116">When the method does return a sample, the filter puts data into the buffer, sets the appropriate flags on the sample (typically including a time stamp), and delivers the sample downstream.</span></span>

<span data-ttu-id="a6b93-117">Когда фильтр модуля подготовки отчетов получает образец, он проверяет метку времени и удерживает ее в образце до тех пор, пока не будет указано, что данные должны быть визуализированы.</span><span class="sxs-lookup"><span data-stu-id="a6b93-117">When a renderer filter receives a sample, it checks the time stamp and holds onto the sample until the filter graph's reference clock indicates that the data should be rendered.</span></span> <span data-ttu-id="a6b93-118">После того как фильтр отрисовывает данные, он освобождает пример.</span><span class="sxs-lookup"><span data-stu-id="a6b93-118">After the filter renders the data, it releases the sample.</span></span> <span data-ttu-id="a6b93-119">Этот пример не возвращается в пул образцов распределителя, пока значение счетчика ссылок в образце не равно нулю, то есть каждый фильтр освободил пример.</span><span class="sxs-lookup"><span data-stu-id="a6b93-119">The sample does not go back into the allocator's pool of samples until the sample's reference count is zero, meaning that every filter has released the sample.</span></span> <span data-ttu-id="a6b93-120">Этот процесс показан на следующем рисунке.</span><span class="sxs-lookup"><span data-stu-id="a6b93-120">The following image illustrates this process.</span></span>

![декодер, ожидающий пример свободного носителя](images/dataflow2.png)

<span data-ttu-id="a6b93-122">Вышестоящий фильтр может работать впереди модуля подготовки отчетов, т. е. он может заполнять буферы быстрее, чем при использовании модуля подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="a6b93-122">The upstream filter might run ahead of the renderer — that is, it might fill buffers faster than the renderer consumes them.</span></span> <span data-ttu-id="a6b93-123">Несмотря на это, образцы не отображаются на раннем этапе, так как модуль подготовки отчетов хранит их до времени презентации.</span><span class="sxs-lookup"><span data-stu-id="a6b93-123">Even so, samples do not get rendered early, because the renderer holds each until its presentation time.</span></span> <span data-ttu-id="a6b93-124">Более того, вышестоящий фильтр случайно не перезаписывает буферы, так как метод- **Sample** возвращает только образцы, которые не используются в других случаях.</span><span class="sxs-lookup"><span data-stu-id="a6b93-124">Moreover, the upstream filter will not overwrite buffers accidentally, because **GetSample** only returns samples that are not otherwise in use.</span></span> <span data-ttu-id="a6b93-125">Величина, на которую воспроизводится вышестоящий фильтр, определяется количеством выборок в пуле распределителя.</span><span class="sxs-lookup"><span data-stu-id="a6b93-125">The amount by which the upstream filter can run ahead is determined by the number of samples in the allocator's pool.</span></span>

<span data-ttu-id="a6b93-126">На предыдущей схеме показан только один распределитель, но обычно существует несколько распределительов на поток.</span><span class="sxs-lookup"><span data-stu-id="a6b93-126">The previous diagram only shows one allocator, but typically there are several allocators per stream.</span></span> <span data-ttu-id="a6b93-127">Таким же, когда модуль подготовки отчетов освобождает пример, он может иметь каскадный результат.</span><span class="sxs-lookup"><span data-stu-id="a6b93-127">Thus, when the renderer releases a sample, it can have a cascading effect.</span></span> <span data-ttu-id="a6b93-128">На следующей диаграмме показана ситуация, когда декодер содержит сжатый кадр видео, в то время как он ожидает освобождения примера в модуле подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="a6b93-128">The following diagram shows a situation where a decoder holds a compressed video frame while it waits for the renderer to release a sample.</span></span> <span data-ttu-id="a6b93-129">Фильтр анализатора также ожидает, пока декодер выдаст пример.</span><span class="sxs-lookup"><span data-stu-id="a6b93-129">A parser filter is also waiting for the decoder to release a sample.</span></span>

![два фильтра ожидают выборки](images/dataflow3.png)

<span data-ttu-id="a6b93-131">Когда модуль подготовки к выпуску выдает свой пример, в нем возвращаются вызовы метода **buffer** .</span><span class="sxs-lookup"><span data-stu-id="a6b93-131">When the renderer releases its sample, the decoder's pending call to **GetBuffer** returns.</span></span> <span data-ttu-id="a6b93-132">Затем декодер может декодировать сжатый видеокадр и выпустить пример, который он удерживает, тем самым разблокируя отложенный вызов **метода** noframes средства синтаксического анализа.</span><span class="sxs-lookup"><span data-stu-id="a6b93-132">The decoder can then decode the compressed video frame and release the sample it was holding, thereby unblocking the parser's pending **GetBuffer** call.</span></span>

## <a name="related-topics"></a><span data-ttu-id="a6b93-133">См. также</span><span class="sxs-lookup"><span data-stu-id="a6b93-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="a6b93-134">Поток данных в графе фильтра</span><span class="sxs-lookup"><span data-stu-id="a6b93-134">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



