---
description: В этом разделе описывается написание пользовательского модуля подготовки видео для DirectShow.
ms.assetid: abba5113-125f-4dac-b566-99c0d9b5978c
title: Альтернативные модули подготовки видео
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 070e55375d9d1d5a32c306853aafcb431a76c368
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "103806610"
---
# <a name="alternative-video-renderers"></a><span data-ttu-id="7f421-103">Альтернативные модули подготовки видео</span><span class="sxs-lookup"><span data-stu-id="7f421-103">Alternative Video Renderers</span></span>

<span data-ttu-id="7f421-104">В этом разделе описывается написание пользовательского модуля подготовки видео для DirectShow.</span><span class="sxs-lookup"><span data-stu-id="7f421-104">This topic describes how to write a custom video renderer for DirectShow.</span></span>

> [!Note]  
> <span data-ttu-id="7f421-105">Вместо написания пользовательского модуля подготовки отчетов к просмотру рекомендуется написать подключаемый модуль распределительного устройства для микширования видео (VMR) или [**расширенного обработчика видео**](enhanced-video-renderer-filter.md) (Евр).</span><span class="sxs-lookup"><span data-stu-id="7f421-105">Instead of writing a custom video renderer, it is recommended that you write a plug-in allocator-presenter for the Video Mixing Renderer (VMR) or [**Enhanced Video Renderer**](enhanced-video-renderer-filter.md) (EVR).</span></span> <span data-ttu-id="7f421-106">Этот подход дает вам все преимущества VMR/евр, в том числе поддержку ускорения видео DirectX (ДКСВА), аппаратное чередование и пошаговое выполнение кадров, и, скорее всего, будет более устойчивым, чем пользовательский модуль визуализации видео.</span><span class="sxs-lookup"><span data-stu-id="7f421-106">This approach will give you all of the benefits of the VMR/EVR, including support for DirectX Video Acceleration (DXVA), hardware deinterlacing, and frame stepping, and is likely to be more robust than a custom video renderer.</span></span> <span data-ttu-id="7f421-107">Дополнительные сведения см. в следующих разделах:</span><span class="sxs-lookup"><span data-stu-id="7f421-107">For more information, see the following topics:</span></span>
>
> -   [<span data-ttu-id="7f421-108">Режим воспроизведения VMR (пользовательский распределитель — выступающие)</span><span class="sxs-lookup"><span data-stu-id="7f421-108">VMR Renderless Playback Mode (Custom Allocator-Presenters)</span></span>](vmr-renderless-playback-mode--custom-allocator-presenters.md)
> -   [<span data-ttu-id="7f421-109">Написание выступающего Евр</span><span class="sxs-lookup"><span data-stu-id="7f421-109">How to Write an EVR Presenter</span></span>](/windows/desktop/medfound/how-to-write-an-evr-presenter)

 

## <a name="writing-an-alternative-renderer"></a><span data-ttu-id="7f421-110">Создание альтернативного модуля подготовки отчетов</span><span class="sxs-lookup"><span data-stu-id="7f421-110">Writing an Alternative Renderer</span></span>

<span data-ttu-id="7f421-111">Microsoft DirectShow предоставляет модуль подготовки видео на основе окон; Он также предоставляет полноэкранный рендеринг во время выполнения установки.</span><span class="sxs-lookup"><span data-stu-id="7f421-111">Microsoft DirectShow provides a window-based video renderer; it also provides a full-screen renderer in the run-time installation.</span></span> <span data-ttu-id="7f421-112">Базовые классы DirectShow можно использовать для записи альтернативных модулей подготовки видео.</span><span class="sxs-lookup"><span data-stu-id="7f421-112">You can use the DirectShow base classes to write alternative video renderers.</span></span> <span data-ttu-id="7f421-113">Чтобы альтернативные модули подготовки отчетов правильно взаимодействовали с приложениями на основе DirectShow, модули подготовки отчетов должны соблюдать рекомендации, описанные в этой статье.</span><span class="sxs-lookup"><span data-stu-id="7f421-113">For alternative renderers to interact correctly with DirectShow-based applications, the renderers must adhere to the guidelines outlined in this article.</span></span> <span data-ttu-id="7f421-114">Вы можете использовать классы [**кбасерендерер**](cbaserenderer.md) и [**кбасевидеорендерер**](cbasevideorenderer.md) , чтобы следовать этим рекомендациям при реализации альтернативной прорисовки видео.</span><span class="sxs-lookup"><span data-stu-id="7f421-114">You can use the [**CBaseRenderer**](cbaserenderer.md) and [**CBaseVideoRenderer**](cbasevideorenderer.md) classes to help follow these guidelines when implementing an alternative video render.</span></span> <span data-ttu-id="7f421-115">Из-за текущей разработки DirectShow регулярно просматривайте свою реализацию, чтобы убедиться, что модули подготовки отчетов совместимы с самой последней версией DirectShow.</span><span class="sxs-lookup"><span data-stu-id="7f421-115">Because of the ongoing development of DirectShow, review your implementation periodically to ensure that the renderers are compatible with the most recent version of DirectShow.</span></span>

<span data-ttu-id="7f421-116">В этом разделе обсуждаются многие уведомления о том, что модуль подготовки отчетов отвечает за обработку.</span><span class="sxs-lookup"><span data-stu-id="7f421-116">This topic discusses many notifications that a renderer is responsible for handling.</span></span> <span data-ttu-id="7f421-117">Краткий обзор уведомлений DirectShow может помочь задать этап.</span><span class="sxs-lookup"><span data-stu-id="7f421-117">A brief review of DirectShow notifications might help to set the stage.</span></span> <span data-ttu-id="7f421-118">В DirectShow есть три вида уведомлений:</span><span class="sxs-lookup"><span data-stu-id="7f421-118">There are essentially three kinds of notifications that occur in DirectShow:</span></span>

-   <span data-ttu-id="7f421-119">*Потоковые уведомления*— это события, происходящие в потоке мультимедиа и передаваемые из одного фильтра в следующий.</span><span class="sxs-lookup"><span data-stu-id="7f421-119">*Stream notifications*, which are events that occur in the media stream and are passed from one filter to the next.</span></span> <span data-ttu-id="7f421-120">Это могут быть уведомления о начале, сбросе или окончании потока, а также отправляются путем вызова соответствующего метода для входного ПИН-кода подчиненного фильтра (например, [**Ипин:: бегинфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span><span class="sxs-lookup"><span data-stu-id="7f421-120">These can be begin-flushing, end-flushing or end-of-stream notifications and are sent by calling the appropriate method on the downstream filter's input pin (for example [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span></span>
-   <span data-ttu-id="7f421-121">*Отфильтруйте уведомления графа*, которые являются событиями, отправленными из фильтра в Диспетчер графа фильтров, например [**EC \_ Complete**](ec-complete.md).</span><span class="sxs-lookup"><span data-stu-id="7f421-121">*Filter graph notifications*, which are events sent from a filter to the Filter Graph Manager such as [**EC\_COMPLETE**](ec-complete.md).</span></span> <span data-ttu-id="7f421-122">Это достигается путем вызова метода [**имедиаевентсинк:: notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) в диспетчере графа фильтров.</span><span class="sxs-lookup"><span data-stu-id="7f421-122">This is accomplished by calling the [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) method on the Filter Graph Manager.</span></span>
-   <span data-ttu-id="7f421-123">*Уведомления приложения*, которые извлекаются из диспетчера графа фильтра управляющим приложением.</span><span class="sxs-lookup"><span data-stu-id="7f421-123">*Application notifications*, which are retrieved from the Filter Graph Manager by the controlling application.</span></span> <span data-ttu-id="7f421-124">Приложение вызывает метод [**имедиаевент:: четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) в диспетчере графа фильтров для получения этих событий.</span><span class="sxs-lookup"><span data-stu-id="7f421-124">An application calls the [**IMediaEvent::GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) method on the Filter Graph Manager to retrieve these events.</span></span> <span data-ttu-id="7f421-125">Часто диспетчер графа фильтров проходит через события, которые он получает в приложение.</span><span class="sxs-lookup"><span data-stu-id="7f421-125">Often, the Filter Graph Manager passes through the events it receives to the application.</span></span>

<span data-ttu-id="7f421-126">В этом разделе обсуждается ответственность фильтра модуля подготовки отчетов об обработке получаемых им уведомлений о потоках и отправке соответствующих уведомлений графа фильтра.</span><span class="sxs-lookup"><span data-stu-id="7f421-126">This topic discusses the responsibility of the renderer filter in handling stream notifications it receives and in sending appropriate filter graph notifications.</span></span>

## <a name="handling-end-of-stream-and-flushing-notifications"></a><span data-ttu-id="7f421-127">Обработка уведомлений о завершении потока и записи на диск</span><span class="sxs-lookup"><span data-stu-id="7f421-127">Handling End-of-stream and Flushing Notifications</span></span>

<span data-ttu-id="7f421-128">Уведомление о завершении потока начинается с вышестоящего фильтра (такого как фильтр источника), когда этот фильтр обнаруживает, что он может отсылать больше данных.</span><span class="sxs-lookup"><span data-stu-id="7f421-128">An end-of-stream notification begins at an upstream filter (such as the source filter) when that filter detects that it can send no more data.</span></span> <span data-ttu-id="7f421-129">Он передается через каждый фильтр в графе и в конечном итоге завершается модулем подготовки отчетов, который отвечает за последующее отправление уведомления о [**\_ завершении EC**](ec-complete.md) в Диспетчер графа фильтров.</span><span class="sxs-lookup"><span data-stu-id="7f421-129">It is passed through every filter in the graph and eventually ends at the renderer, which is responsible for subsequently sending an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="7f421-130">Модули подготовки отчетов имеют специальные обязанности, когда речь идет об обработке этих уведомлений.</span><span class="sxs-lookup"><span data-stu-id="7f421-130">Renderers have special responsibilities when it comes to handling these notifications.</span></span>

<span data-ttu-id="7f421-131">Модуль подготовки отчетов получает уведомление о завершении потока, когда метод [**Ипин:: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) из входного контакта вызывается вышестоящим фильтром.</span><span class="sxs-lookup"><span data-stu-id="7f421-131">A renderer receives an end-of-stream notification when its input pin's [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) method is called by the upstream filter.</span></span> <span data-ttu-id="7f421-132">Модуль подготовки отчетов должен отметить это уведомление и продолжить подготовку к просмотру уже полученных данных.</span><span class="sxs-lookup"><span data-stu-id="7f421-132">A renderer should note this notification and continue to render any data it has already received.</span></span> <span data-ttu-id="7f421-133">После получения всех оставшихся данных модуль подготовки отчетов должен отправить уведомление о [**\_ завершении EC**](ec-complete.md) в Диспетчер графа фильтров.</span><span class="sxs-lookup"><span data-stu-id="7f421-133">Once all remaining data has been received, the renderer should send an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="7f421-134">Уведомление **о \_ завершении EC** должно отправляться модулем подготовки отчетов только один раз при достижении конца потока.</span><span class="sxs-lookup"><span data-stu-id="7f421-134">The **EC\_COMPLETE** notification should be sent only once by a renderer each time it reaches the end of a stream.</span></span> <span data-ttu-id="7f421-135">Кроме того, уведомления о **\_ завершении EC** не должны отправляться, за исключением случаев, когда выполняется граф фильтра.</span><span class="sxs-lookup"><span data-stu-id="7f421-135">Furthermore, **EC\_COMPLETE** notifications must never be sent except when the filter graph is running.</span></span> <span data-ttu-id="7f421-136">Таким образом, если граф фильтра приостанавливается, когда фильтр источника отправляет уведомление об окончании потока, то не следует отправлять данные **EC \_ Complete** , пока граф фильтра не запустится.</span><span class="sxs-lookup"><span data-stu-id="7f421-136">Therefore, if the filter graph is paused when a source filter sends an end-of-stream notification, then **EC\_COMPLETE** should not be sent until the filter graph is finally run.</span></span>

<span data-ttu-id="7f421-137">Любые вызовы методов [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) или [**Имеминпутпин:: рецеивемултипле**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) после уведомления о завершении потока должны быть отклонены.</span><span class="sxs-lookup"><span data-stu-id="7f421-137">Any calls to the [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) methods after an end-of-stream notification is signaled should be rejected.</span></span> <span data-ttu-id="7f421-138">**Д \_ НЕПРЕДВИДЕНное** сообщение об ошибке, которое необходимо вернуть в этом случае.</span><span class="sxs-lookup"><span data-stu-id="7f421-138">**E\_UNEXPECTED** is the most appropriate error message to return in this case.</span></span>

<span data-ttu-id="7f421-139">При остановке графа фильтра любое кэшированное уведомление конца потока должно быть сброшено и не передаваться при следующем запуске.</span><span class="sxs-lookup"><span data-stu-id="7f421-139">When a filter graph is stopped, any cached end-of-stream notification should be cleared and not resent when next started.</span></span> <span data-ttu-id="7f421-140">Это связано с тем, что диспетчер графов фильтров всегда приостанавливает все фильтры непосредственно перед их запуском, чтобы обеспечить правильное выполнение очистки.</span><span class="sxs-lookup"><span data-stu-id="7f421-140">This is because the Filter Graph Manager always pauses all filters just before running them so that proper flushing occurs.</span></span> <span data-ttu-id="7f421-141">Например, если граф фильтра приостановлен и получено уведомление о завершении потока, а затем граф фильтра остановлен, модуль подготовки отчетов не должен отправить уведомление о [**\_ завершении EC**](ec-complete.md) при последующем запуске.</span><span class="sxs-lookup"><span data-stu-id="7f421-141">So, for example, if the filter graph is paused and an end-of-stream notification is received, and then the filter graph is stopped, the renderer should not send an [**EC\_COMPLETE**](ec-complete.md) notification when it is subsequently run.</span></span> <span data-ttu-id="7f421-142">Если поиск не выполнялся, фильтр источника будет автоматически отправит еще одно уведомление о прекращении потока во время паузы, предшествующее состоянию выполнения.</span><span class="sxs-lookup"><span data-stu-id="7f421-142">If no seeks have occurred, the source filter will automatically send another end-of-stream notification during the pause state that precedes a run state.</span></span> <span data-ttu-id="7f421-143">Если, с другой стороны, при остановке графа фильтра возникла операция поиска, то фильтр источника может содержать данные для отправки, поэтому он не отправляет уведомление об окончании потока.</span><span class="sxs-lookup"><span data-stu-id="7f421-143">If, on the other hand, a seek has occurred while the filter graph is stopped, then the source filter might have data to send, so it won't send an end-of-stream notification.</span></span>

<span data-ttu-id="7f421-144">Модули подготовки видео часто зависят от уведомлений на конец потока, что превышает отправку уведомлений [**о \_ завершении EC**](ec-complete.md) .</span><span class="sxs-lookup"><span data-stu-id="7f421-144">Video renderers often depend on end-of-stream notifications for more than the sending of [**EC\_COMPLETE**](ec-complete.md) notifications.</span></span> <span data-ttu-id="7f421-145">Например, если поток завершил воспроизведение (то есть отправляется уведомление об окончании потока), а другое окно перемещается через окно средства просмотра видео, будет создано несколько сообщений окна программы [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="7f421-145">For example, if a stream has finished playing (that is, an end-of-stream notification is sent) and another window is dragged over a video renderer window, a number of [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) window messages will be generated.</span></span> <span data-ttu-id="7f421-146">Типичная практика запуска модуля подготовки видео — не перерисовывать текущий кадр при получении сообщений **WM \_ Paint** (в зависимости от предположения, что будет получен другой кадр).</span><span class="sxs-lookup"><span data-stu-id="7f421-146">The typical practice for running video renderers is to refrain from repainting the current frame upon receipt of **WM\_PAINT** messages (based on the assumption that another frame to be drawn will be received).</span></span> <span data-ttu-id="7f421-147">Однако при отправке уведомления конца потока модуль подготовки отчетов находится в состоянии ожидания; Он по-прежнему работает, но имеет в виду, что он не будет получать дополнительные данные.</span><span class="sxs-lookup"><span data-stu-id="7f421-147">However, when the end-of-stream notification has been sent, the renderer is in a waiting state; it is still running but is aware that it will not receive any additional data.</span></span> <span data-ttu-id="7f421-148">В этих случаях модуль подготовки отчетов создает черный область воспроизведения.</span><span class="sxs-lookup"><span data-stu-id="7f421-148">Under these circumstances, the renderer customarily draws the playback area black.</span></span>

<span data-ttu-id="7f421-149">Обработка очистки — это дополнительная сложность для модулей подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="7f421-149">Handling flushing is an additional complication for renderers.</span></span> <span data-ttu-id="7f421-150">Очистка выполняется с помощью пары методов [**Ипин**](/windows/desktop/api/Strmif/nn-strmif-ipin) , именуемых [**бегинфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) и [**ендфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span><span class="sxs-lookup"><span data-stu-id="7f421-150">Flushing is carried out through a pair of [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) methods called [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) and [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span> <span data-ttu-id="7f421-151">Очистка по сути является дополнительным состоянием, которое должен обрабатываться модулем подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="7f421-151">Flushing is essentially an additional state that the renderer must handle.</span></span> <span data-ttu-id="7f421-152">Недопустимый фильтр источника для вызова **бегинфлуш** без вызова **ендфлуш**, поэтому мы будем надеяться, что штат является коротким и дискретным. Однако модуль подготовки отчетов должен правильно обрабатывать данные или уведомления, получаемые при переходе на диск.</span><span class="sxs-lookup"><span data-stu-id="7f421-152">It is illegal for a source filter to call **BeginFlush** without calling **EndFlush**, so hopefully the state is short and discrete; however, the renderer must correctly handle data or notifications it receives during the flush transition.</span></span>

<span data-ttu-id="7f421-153">Все данные, полученные после вызова [**бегинфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) , следует отклонять немедленно, возвращая **\_ значение S false**.</span><span class="sxs-lookup"><span data-stu-id="7f421-153">Any data received after calling [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) should be rejected immediately by returning **S\_FALSE**.</span></span> <span data-ttu-id="7f421-154">Кроме того, любое кэшированное уведомление конца потока также должно быть очищено при сбросе модуля подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="7f421-154">Furthermore, any cached end-of-stream notification should also be cleared when a renderer is flushed.</span></span> <span data-ttu-id="7f421-155">Модуль подготовки отчетов, как правило, очищается в ответ на поиск.</span><span class="sxs-lookup"><span data-stu-id="7f421-155">A renderer will typically be flushed in response to a seek.</span></span> <span data-ttu-id="7f421-156">Очистка гарантирует, что старые данные будут удалены из графа фильтра перед отправкой новых образцов.</span><span class="sxs-lookup"><span data-stu-id="7f421-156">The flush ensures that old data is cleared from the filter graph before fresh samples are sent.</span></span> <span data-ttu-id="7f421-157">(Как правило, воспроизведение двух разделов потока, один за другим, лучше всего обрабатывается через отложенные команды вместо того, чтобы ждать завершения одного раздела и затем выполнить команду Seek.)</span><span class="sxs-lookup"><span data-stu-id="7f421-157">(Typically, the playing of two sections of a stream, one after another, is best handled through deferred commands rather than waiting for one section to finish and then issuing a seek command.)</span></span>

## <a name="handling-state-changes-and-pause-completion"></a><span data-ttu-id="7f421-158">Обработка изменений состояния и Приостановка выполнения</span><span class="sxs-lookup"><span data-stu-id="7f421-158">Handling State Changes and Pause Completion</span></span>

<span data-ttu-id="7f421-159">Фильтр модуля подготовки отчетов работает так же, как и любой другой фильтр в графе фильтра при изменении его состояния, за исключением следующего.</span><span class="sxs-lookup"><span data-stu-id="7f421-159">A renderer filter behaves the same as any other filter in the filter graph when its state is changed, with the following exception.</span></span> <span data-ttu-id="7f421-160">После приостановки модуль подготовки отчетов будет содержать некоторые данные, готовые к просмотру при последующем запуске.</span><span class="sxs-lookup"><span data-stu-id="7f421-160">After being paused, the renderer will have some data queued, ready to be rendered when subsequently run.</span></span> <span data-ttu-id="7f421-161">Когда модуль подготовки видео остановлен, он удерживает данные в очереди.</span><span class="sxs-lookup"><span data-stu-id="7f421-161">When the video renderer is stopped, it holds on to this queued data.</span></span> <span data-ttu-id="7f421-162">Это исключение в правиле DirectShow, которое не должно храниться в фильтрах во время остановки графа фильтра.</span><span class="sxs-lookup"><span data-stu-id="7f421-162">This is an exception to the DirectShow rule that no resources should be held by filters while the filter graph is stopped.</span></span>

<span data-ttu-id="7f421-163">Причина этого исключения заключается в том, что при удержании ресурсов модуль подготовки отчетов всегда будет иметь изображение, с помощью которого можно перерисовать окно, если оно получит сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="7f421-163">The reason for this exception is that by holding resources, the renderer will always have an image with which to repaint the window if it receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message.</span></span> <span data-ttu-id="7f421-164">Он также имеет изображение для удовлетворения методов, таких как [**кбасеконтролвидео:: жетстатиЦимаже**](cbasecontrolvideo-getstaticimage.md), которые запрашивают копию текущего изображения.</span><span class="sxs-lookup"><span data-stu-id="7f421-164">It also has an image to satisfy methods, such as [**CBaseControlVideo::GetStaticImage**](cbasecontrolvideo-getstaticimage.md), that request a copy of the current image.</span></span> <span data-ttu-id="7f421-165">Еще одним следствием удержания ресурсов является то, что при переходе на изображение распределитель останавливается, что, в свою очередь, делает следующее изменение состояния гораздо быстрее, так как буферы изображений уже выделены.</span><span class="sxs-lookup"><span data-stu-id="7f421-165">Another effect of holding resources is that holding on to the image stops the allocator from being decommitted, which in turn makes the next state change occur much faster because the image buffers are already allocated.</span></span>

<span data-ttu-id="7f421-166">Модуль подготовки отчетов должен визуализировать и выпустить образцы только во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7f421-166">A video renderer should render and release samples only while running.</span></span> <span data-ttu-id="7f421-167">При приостановке фильтр может визуализировать их (например, при рисовании статического изображения афиши в окне), но не должен освобождать их.</span><span class="sxs-lookup"><span data-stu-id="7f421-167">While paused, the filter might render them (for example, when drawing a static poster image in a window), but should not release them.</span></span> <span data-ttu-id="7f421-168">Модули подготовки звука не будут выполнять отрисовку при приостановке (хотя они могут выполнять другие действия, например, подготавливать звуковое устройство).</span><span class="sxs-lookup"><span data-stu-id="7f421-168">Audio renderers will do no rendering while paused (although they can perform other activities, such as preparing the wave device, for example).</span></span> <span data-ttu-id="7f421-169">Время, когда следует подготавливать выборки, получается путем объединения времени потока в примере со временем ссылки, переданным в качестве параметра в метод [**имедиаконтрол:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) .</span><span class="sxs-lookup"><span data-stu-id="7f421-169">The time at which the samples should be rendered is obtained by combining the stream time in the sample with the reference time passed as a parameter to the [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) method.</span></span> <span data-ttu-id="7f421-170">Модули подготовки отчетов должны отклонять выборки с временем начала меньше или равным времени окончания.</span><span class="sxs-lookup"><span data-stu-id="7f421-170">Renderers should reject samples with start times less than or equal to end times.</span></span>

<span data-ttu-id="7f421-171">Когда приложение приостанавливает граф фильтра, граф фильтра не возвращает метод [**имедиаконтрол::P Аусе**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) , пока данные не помещаются в очередь модулей подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="7f421-171">When an application pauses a filter graph, the filter graph does not return from its [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) method until there is data queued at the renderers.</span></span> <span data-ttu-id="7f421-172">Чтобы обеспечить это, когда модуль подготовки отчетов приостанавливается, он должен вернуть \_ значение false, если данные, ожидающие подготовки к просмотру, отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="7f421-172">In order to ensure this, when a renderer is paused, it should return S\_FALSE if there is no data waiting to be rendered.</span></span> <span data-ttu-id="7f421-173">Если в очереди есть данные, они могут вернуть **S \_ ОК**.</span><span class="sxs-lookup"><span data-stu-id="7f421-173">If it has data queued, then it can return **S\_OK**.</span></span>

<span data-ttu-id="7f421-174">Диспетчер графов фильтров проверяет все возвращаемые значения при приостановке графа фильтра, чтобы убедиться, что модули подготовки отчетов имеют данные в очереди.</span><span class="sxs-lookup"><span data-stu-id="7f421-174">The Filter Graph Manager checks all return values when pausing a filter graph, to ensure that the renderers have data queued.</span></span> <span data-ttu-id="7f421-175">Если один или несколько фильтров не готовы, диспетчер графа фильтров опрашивает фильтры в графе, вызывая [**имедиафилтер:: State**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span><span class="sxs-lookup"><span data-stu-id="7f421-175">If one or more filters are not ready, then the Filter Graph Manager polls the filters in the graph by calling [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span></span> <span data-ttu-id="7f421-176">Метод **WebMethod** принимает параметр времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="7f421-176">The **GetState** method takes a time-out parameter.</span></span> <span data-ttu-id="7f421-177">Фильтр (обычно модуль подготовки отчетов), который по-прежнему ожидает поступления данных перед завершением изменения состояния, возвращает **VFW \_ S \_ State \_** , если метод **метода WebMethod** истекает.</span><span class="sxs-lookup"><span data-stu-id="7f421-177">A filter (typically a renderer) that is still waiting for data to arrive before completing the state change returns **VFW\_S\_STATE\_INTERMEDIATE** if the **GetState** method expires.</span></span> <span data-ttu-id="7f421-178">Когда данные поступают в модуль подготовки отчетов, параметру " **State** " следует немедленно возвращаться с помощью **S \_ ОК**.</span><span class="sxs-lookup"><span data-stu-id="7f421-178">Once data arrives at the renderer, **GetState** should be returned immediately with **S\_OK**.</span></span>

<span data-ttu-id="7f421-179">В состоянии "промежуточное" и "завершено" состояние отфильтрованного фильтра будет \_ приостановлено.</span><span class="sxs-lookup"><span data-stu-id="7f421-179">In both the intermediate and completed state, the reported filter state will be State\_Paused.</span></span> <span data-ttu-id="7f421-180">Только возвращаемое значение указывает, действительно ли фильтр готов.</span><span class="sxs-lookup"><span data-stu-id="7f421-180">Only the return value indicates whether the filter is really ready or not.</span></span> <span data-ttu-id="7f421-181">Если, в то время как модуль подготовки отчетов ожидает поступления данных, его фильтр источника отправляет уведомление о завершении потока, а затем также завершает изменение состояния.</span><span class="sxs-lookup"><span data-stu-id="7f421-181">If, while a renderer is waiting for data to arrive, its source filter sends an end-of-stream notification, then that should also complete the state change.</span></span>

<span data-ttu-id="7f421-182">После того как все фильтры на самом деле имеют данные, ожидающие подготовки к просмотру, граф фильтра завершит изменение состояния приостановки.</span><span class="sxs-lookup"><span data-stu-id="7f421-182">Once all filters actually have data waiting to be rendered, the filter graph will complete its pause state change.</span></span>

## <a name="handling-termination"></a><span data-ttu-id="7f421-183">Завершение обработки</span><span class="sxs-lookup"><span data-stu-id="7f421-183">Handling Termination</span></span>

<span data-ttu-id="7f421-184">Модули подготовки видео должны правильно обрабатывать события завершения от пользователя.</span><span class="sxs-lookup"><span data-stu-id="7f421-184">Video renderers must correctly handle termination events from the user.</span></span> <span data-ttu-id="7f421-185">Это означает правильное скрытие окна и знание того, что нужно делать, если окно впоследствии будет отображено.</span><span class="sxs-lookup"><span data-stu-id="7f421-185">This implies correctly hiding the window and knowing what to do if a window is subsequently forced to be displayed.</span></span> <span data-ttu-id="7f421-186">Кроме того, модули подготовки видео должны уведомлять диспетчер графов фильтров, когда его окно уничтожается (или точнее, когда модуль подготовки отчетов удаляется из графа фильтра) для освобождения ресурсов.</span><span class="sxs-lookup"><span data-stu-id="7f421-186">Also, video renderers must notify the Filter Graph Manager when its window is destroyed (or more accurately, when the renderer is removed from the filter graph) to free resources.</span></span>

<span data-ttu-id="7f421-187">Если пользователь закрывает окно видео (например, нажав клавиши ALT + F4), то в соответствии с соглашением вы немедленно скрываете окно и отправляете уведомление [**EC \_ Усераборт**](ec-userabort.md) в Диспетчер графа фильтров.</span><span class="sxs-lookup"><span data-stu-id="7f421-187">If the user closes the video window (for instance by pressing ALT+F4), the convention is to hide the window immediately and send an [**EC\_USERABORT**](ec-userabort.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="7f421-188">Это уведомление передается в приложение, что приведет к прерыванию воспроизведения графа.</span><span class="sxs-lookup"><span data-stu-id="7f421-188">This notification is passed through to the application, which will stop the graph playing.</span></span> <span data-ttu-id="7f421-189">После отправки **EC \_ усераборт** модуль подготовки отчетов должен отклонять любые дополнительные образцы, доставляемые на него.</span><span class="sxs-lookup"><span data-stu-id="7f421-189">After sending **EC\_USERABORT**, a video renderer should reject any additional samples delivered to it.</span></span>

<span data-ttu-id="7f421-190">Отметка "граф остановлена" должна быть оставлена модулем подготовки отчетов до тех пор, пока он не будет остановлен, после чего он должен быть сброшен, чтобы приложение может переопределить действие пользователя и продолжить воспроизведение графа по своему последствии.</span><span class="sxs-lookup"><span data-stu-id="7f421-190">The graph-stopped flag should be left on by the renderer until it is subsequently stopped, at which point it should be reset so that an application can override the user action and continue playing the graph if it desires.</span></span> <span data-ttu-id="7f421-191">Если во время работы видео нажата клавиша ALT + F4, окно будет скрыто, и все последующие выборки будут отклонены.</span><span class="sxs-lookup"><span data-stu-id="7f421-191">If ALT+F4 is pressed while the video is running, the window will be hidden and all further samples delivered will be rejected.</span></span> <span data-ttu-id="7f421-192">Если окно отображается последующим образом (например, через [**ивидеовиндов::p UT \_ Visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), то уведомления о [**\_ перерисовке EC**](ec-repaint.md) создаваться не должны.</span><span class="sxs-lookup"><span data-stu-id="7f421-192">If the window is subsequently shown (perhaps through [**IVideoWindow::put\_Visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), then no [**EC\_REPAINT**](ec-repaint.md) notifications should be generated.</span></span>

<span data-ttu-id="7f421-193">Модуль подготовки отчетов также должен отправить на граф фильтра уведомление о [**\_ \_ поврежденном окне EC**](ec-window-destroyed.md) при завершении работы модуля обработки видео.</span><span class="sxs-lookup"><span data-stu-id="7f421-193">The video renderer should also send the [**EC\_WINDOW\_DESTROYED**](ec-window-destroyed.md) notification to the filter graph when the video renderer is terminating.</span></span> <span data-ttu-id="7f421-194">На самом деле лучше обрабатывать это, когда метод [**ибасефилтер:: жоинфилтерграф**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) визуализатора вызывается с параметром null (что означает, что модуль подготовки отчетов будет удален из графа фильтра), а не ждать, пока не будет уничтожено реальное окно видео.</span><span class="sxs-lookup"><span data-stu-id="7f421-194">In fact, it is best to handle this when the renderer's [**IBaseFilter::JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) method is called with a null parameter (indicating that the renderer is about to be removed from the filter graph), rather than waiting until the actual video window is destroyed.</span></span> <span data-ttu-id="7f421-195">Отправка этого уведомления позволяет подключаемому модулю распространителя в диспетчере графов фильтров передавать ресурсы, зависящие от фокуса, на другие фильтры, такие как звуковые устройства.</span><span class="sxs-lookup"><span data-stu-id="7f421-195">Sending this notification enables the plug-in distributor in the Filter Graph Manager to pass on resources that depend on window focus to other filters, such as audio devices.</span></span>

## <a name="handling-dynamic-format-changes"></a><span data-ttu-id="7f421-196">Обработка изменений динамического формата</span><span class="sxs-lookup"><span data-stu-id="7f421-196">Handling Dynamic Format Changes</span></span>

<span data-ttu-id="7f421-197">В некоторых случаях вышестоящий фильтр модуля подготовки отчетов может попытаться изменить формат видео во время воспроизведения видео.</span><span class="sxs-lookup"><span data-stu-id="7f421-197">In some cases, the renderer's upstream filter might try to change the video format while the video is playing.</span></span> <span data-ttu-id="7f421-198">Чаще всего это декомпрессор видео, запускающее динамическое изменение формата.</span><span class="sxs-lookup"><span data-stu-id="7f421-198">It is most often the video decompressor that initiates a dynamic format change.</span></span>

<span data-ttu-id="7f421-199">Вышестоящий фильтр, который пытается динамически изменить форматы, всегда должен вызывать метод [**Ипин:: куерякцепт**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) для входного ПИН-кода модуля подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="7f421-199">An upstream filter attempting to change formats dynamically should always call the [**IPin::QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) method on the renderer input pin.</span></span> <span data-ttu-id="7f421-200">Модуль подготовки видео имеет некоторые отклонения, как и какие виды изменений динамического формата он должен поддерживать.</span><span class="sxs-lookup"><span data-stu-id="7f421-200">A video renderer has some leeway as to what kinds of dynamic format changes it should support.</span></span> <span data-ttu-id="7f421-201">Как минимум, он должен позволить вышестоящему фильтру изменить палитры.</span><span class="sxs-lookup"><span data-stu-id="7f421-201">At a minimum, it should allow the upstream filter to change palettes.</span></span> <span data-ttu-id="7f421-202">Когда вышестоящий фильтр изменяет типы носителей, он прикрепляет тип носителя к первому образцу, доставке в новом формате.</span><span class="sxs-lookup"><span data-stu-id="7f421-202">When an upstream filter changes media types, it attaches the media type to the first sample delivered in the new format.</span></span> <span data-ttu-id="7f421-203">Если модуль подготовки отчетов хранит образцы в очереди для подготовки к просмотру, он не должен изменять формат до тех пор, пока не будет отображен образец с изменением типа.</span><span class="sxs-lookup"><span data-stu-id="7f421-203">If the renderer holds samples in a queue for rendering, it should not change the format until it renders the sample with the type change.</span></span>

<span data-ttu-id="7f421-204">Модуль обработки видео также может запрашивать изменение формата от декодера.</span><span class="sxs-lookup"><span data-stu-id="7f421-204">A video renderer can also request a format change from the decoder.</span></span> <span data-ttu-id="7f421-205">Например, он может попросить декодера предоставить совместимый с DirectDraw формат с отрицательным **бихеигхт**.</span><span class="sxs-lookup"><span data-stu-id="7f421-205">For example, it might ask the decoder to provide a DirectDraw-compatible format with a negative **biHeight**.</span></span> <span data-ttu-id="7f421-206">Когда модуль подготовки отчетов приостанавливается, он должен вызвать [**куерякцепт**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) для вышестоящего ПИН-кода, чтобы узнать, какие форматы может предоставить декодер.</span><span class="sxs-lookup"><span data-stu-id="7f421-206">When the renderer is paused, it should call [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) on the upstream pin to see which formats the decoder can provide.</span></span> <span data-ttu-id="7f421-207">Однако декодер может не перечислять все типы, которые он может принять, поэтому модуль подготовки отчетов должен предлагать некоторые типы, даже если декодер не объявляет их.</span><span class="sxs-lookup"><span data-stu-id="7f421-207">The decoder might not enumerate all of the types that it can accept, however, so the renderer should offer some types even if the decoder does not advertise them.</span></span>

<span data-ttu-id="7f421-208">Если декодер может переключиться в запрошенный формат, он возвращает значение **S \_ ОК** из [**куерякцепт**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span><span class="sxs-lookup"><span data-stu-id="7f421-208">If the decoder can switch to the requested format, it returns **S\_OK** from [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span></span> <span data-ttu-id="7f421-209">Затем модуль подготовки отчетов присоединяет новый тип мультимедиа к следующему примеру носителя в вышестоящем распределителе.</span><span class="sxs-lookup"><span data-stu-id="7f421-209">The renderer then attaches the new media type to the next media sample on the upstream allocator.</span></span> <span data-ttu-id="7f421-210">Чтобы это работало, модуль подготовки отчетов должен предоставить пользовательский распределитель, реализующий частный метод для присоединения типа мультимедиа к следующему примеру.</span><span class="sxs-lookup"><span data-stu-id="7f421-210">For this to work, the renderer must provide a custom allocator that implements a private method for attaching the media type to the next sample.</span></span> <span data-ttu-id="7f421-211">(В этом частном методе вызовите [**имедиасампле:: сетмедиатипе**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) , чтобы задать тип.)</span><span class="sxs-lookup"><span data-stu-id="7f421-211">(Within this private method, call [**IMediaSample::SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) to set the type.)</span></span>

<span data-ttu-id="7f421-212">Входной ПИН-код модуля подготовки отчетов должен возвращать пользовательский распределитель модуля подготовки отчетов в методе [**имеминпутпин::-распределителя**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) .</span><span class="sxs-lookup"><span data-stu-id="7f421-212">The renderer's input pin should return the renderer's custom allocator in the [**IMemInputPin::GetAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) method.</span></span> <span data-ttu-id="7f421-213">Переопределите [**имеминпутпин:: нотифяллокатор**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) , чтобы он завершился ошибкой, если вышестоящий фильтр не использует распределитель модуля подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="7f421-213">Override [**IMemInputPin::NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) so that it fails if the upstream filter does not use the renderer's allocator.</span></span>

<span data-ttu-id="7f421-214">При использовании некоторых декодеров установка **бихеигхт** в положительное число в типах YUV приводит к тому, что декодер выводит изображение на 180 градусов.</span><span class="sxs-lookup"><span data-stu-id="7f421-214">With some decoders, setting **biHeight** to a positive number on YUV types causes the decoder to draw the image upside down.</span></span> <span data-ttu-id="7f421-215">(Это неверно, и его следует рассматривать как ошибку в декодере.)</span><span class="sxs-lookup"><span data-stu-id="7f421-215">(This is incorrect, and should be considered a bug in the decoder.)</span></span>

<span data-ttu-id="7f421-216">При обнаружении изменения формата модулем подготовки видео он должен отправить уведомление об [**\_ \_ изменении дисплея EC**](ec-display-changed.md) .</span><span class="sxs-lookup"><span data-stu-id="7f421-216">Whenever a format change is detected by the video renderer, it should send an [**EC\_DISPLAY\_CHANGED**](ec-display-changed.md) notification.</span></span> <span data-ttu-id="7f421-217">Большинство модулей обработки видео выбирают формат во время подключения, чтобы его можно было эффективно прорисовывать через GDI.</span><span class="sxs-lookup"><span data-stu-id="7f421-217">Most video renderers pick a format during connection so that the format can be drawn efficiently through GDI.</span></span> <span data-ttu-id="7f421-218">Если пользователь изменяет текущий режим отображения без перезагрузки компьютера, модуль подготовки отчетов может обнаружить неверное соединение с форматом изображения и отправить это уведомление.</span><span class="sxs-lookup"><span data-stu-id="7f421-218">If the user changes the current display mode without restarting the computer, a renderer might find itself with a bad image format connection and should send this notification.</span></span> <span data-ttu-id="7f421-219">Первым параметром должен быть ПИН-код, требующий повторного подключения.</span><span class="sxs-lookup"><span data-stu-id="7f421-219">The first parameter should be the pin that needs reconnecting.</span></span> <span data-ttu-id="7f421-220">Диспетчер графов фильтров будет упорядочивать график для остановки и повторного подключения ПИН-кода.</span><span class="sxs-lookup"><span data-stu-id="7f421-220">The Filter Graph Manager will arrange for the filter graph to be stopped and the pin reconnected.</span></span> <span data-ttu-id="7f421-221">Во время последующего повторного подключения модуль подготовки отчетов может принять более подходящий формат.</span><span class="sxs-lookup"><span data-stu-id="7f421-221">During the subsequent reconnection, the renderer can accept a more appropriate format.</span></span>

<span data-ttu-id="7f421-222">Всякий раз, когда модуль обработки видео обнаруживает изменение палитры в потоке, он должен отправить уведомление об [**\_ \_ изменении палитры EC**](ec-palette-changed.md) в Диспетчер графа фильтров.</span><span class="sxs-lookup"><span data-stu-id="7f421-222">Whenever a video renderer detects a palette change in the stream it should send the [**EC\_PALETTE\_CHANGED**](ec-palette-changed.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="7f421-223">Модули подготовки видео DirectShow обнаруживают, что палитра действительно изменилась в динамическом формате.</span><span class="sxs-lookup"><span data-stu-id="7f421-223">The DirectShow video renderers detect whether a palette has really changed in dynamic format or not.</span></span> <span data-ttu-id="7f421-224">Модули подготовки видео делают это не только для фильтрации количества **\_ \_ измененных уведомлений в палитре EC** , но и для уменьшения объема, необходимого для создания, установки и удаления палитры.</span><span class="sxs-lookup"><span data-stu-id="7f421-224">The video renderers do this not only to filter out the number of **EC\_PALETTE\_CHANGED** notifications sent but also to reduce the amount of palette creation, installation, and deletion required.</span></span>

<span data-ttu-id="7f421-225">Наконец, модуль подготовки отчетов может также обнаружить, что размер видео изменился. в этом случае он должен отправить уведомление об [**\_ \_ \_ изменении размера видео EC**](ec-video-size-changed.md) .</span><span class="sxs-lookup"><span data-stu-id="7f421-225">Finally, the video renderer might also detect that the size of the video has changed, in which case, it should send the [**EC\_VIDEO\_SIZE\_CHANGED**](ec-video-size-changed.md) notification.</span></span> <span data-ttu-id="7f421-226">Приложение может использовать это уведомление для согласования пространства в составном документе.</span><span class="sxs-lookup"><span data-stu-id="7f421-226">An application might use this notification to negotiate space in a compound document.</span></span> <span data-ttu-id="7f421-227">Фактические измерения видео доступны через интерфейс элемента управления [**ибасиквидео**](/windows/desktop/api/Control/nn-control-ibasicvideo) .</span><span class="sxs-lookup"><span data-stu-id="7f421-227">The actual video dimensions are available through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) control interface.</span></span> <span data-ttu-id="7f421-228">Модули подготовки DirectShow определяют, изменился ли размер видео на самом деле, или не перед отправкой этих событий.</span><span class="sxs-lookup"><span data-stu-id="7f421-228">The DirectShow renderers detect whether the video has actually changed size or not prior to sending these events.</span></span>

## <a name="handling-persistent-properties"></a><span data-ttu-id="7f421-229">Обработка постоянных свойств</span><span class="sxs-lookup"><span data-stu-id="7f421-229">Handling Persistent Properties</span></span>

<span data-ttu-id="7f421-230">Все свойства, заданные через интерфейсы [**ибасиквидео**](/windows/desktop/api/Control/nn-control-ibasicvideo) и [**ивидеовиндов**](/windows/desktop/api/Control/nn-control-ivideowindow) , должны быть постоянными в соединениях.</span><span class="sxs-lookup"><span data-stu-id="7f421-230">All properties set through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) interfaces are meant to be persistent across connections.</span></span> <span data-ttu-id="7f421-231">Таким образом, отсоединение и повторное подключение модуля подготовки отчетов к просмотру не должно полагаться на размер окна, его расположение или стили.</span><span class="sxs-lookup"><span data-stu-id="7f421-231">Therefore, disconnecting and reconnecting a renderer should show no effects on the window size, position, or styles.</span></span> <span data-ttu-id="7f421-232">Однако при изменении размеров видео между соединениями модуль подготовки отчетов должен сбрасывать исходные и конечные прямоугольники в значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="7f421-232">However, if the video dimensions change between connections, the renderer should reset the source and destination rectangles to their defaults.</span></span> <span data-ttu-id="7f421-233">Исходное и конечное положения задаются через интерфейс **ибасиквидео** .</span><span class="sxs-lookup"><span data-stu-id="7f421-233">The source and destination positions are set through the **IBasicVideo** interface.</span></span>

<span data-ttu-id="7f421-234">Как [**ибасиквидео**](/windows/desktop/api/Control/nn-control-ibasicvideo) , так и [**ивидеовиндов**](/windows/desktop/api/Control/nn-control-ivideowindow) предоставляют достаточный доступ к свойствам, позволяя приложению сохранять и восстанавливать все данные в интерфейсе в постоянном формате.</span><span class="sxs-lookup"><span data-stu-id="7f421-234">Both [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) provide enough access to properties to allow an application to save and restore all the data in the interface in a persistent format.</span></span> <span data-ttu-id="7f421-235">Это будет полезно для приложений, которые должны сохранять точную конфигурацию и свойства графов фильтра во время сеанса редактирования и восстанавливать их позже.</span><span class="sxs-lookup"><span data-stu-id="7f421-235">This will be useful to applications that must save the exact configuration and properties of filter graphs during an editing session and restore them later.</span></span>

## <a name="handling-ec_repaint-notifications"></a><span data-ttu-id="7f421-236">Обработка \_ уведомлений о ПЕРЕрисовке EC</span><span class="sxs-lookup"><span data-stu-id="7f421-236">Handling EC\_REPAINT Notifications</span></span>

<span data-ttu-id="7f421-237">Уведомление [**о \_ перерисовке EC**](ec-repaint.md) отправляется, только если модуль подготовки отчетов приостановлен или остановлен.</span><span class="sxs-lookup"><span data-stu-id="7f421-237">The [**EC\_REPAINT**](ec-repaint.md) notification is sent only when the renderer is either paused or stopped.</span></span> <span data-ttu-id="7f421-238">Это уведомление сигнализирует диспетчеру графа фильтра о том, что модуль подготовки отчетов нуждается в данных.</span><span class="sxs-lookup"><span data-stu-id="7f421-238">This notification signals to the Filter Graph Manager that the renderer needs data.</span></span> <span data-ttu-id="7f421-239">Если граф фильтра был остановлен при получении одного из этих уведомлений, это приведет к приостановке графа фильтра, дожидаться получения данных всеми фильтрами (путем вызова метода " [**State**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)") и последующей остановки.</span><span class="sxs-lookup"><span data-stu-id="7f421-239">If the filter graph is stopped when it receives one of these notifications, it will pause the filter graph, wait for all filters to receive data (by calling [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)), and then stop it again.</span></span> <span data-ttu-id="7f421-240">При остановке обработчик видео должен удерживаться на изображении, чтобы можно было обрабатывать последующие сообщения [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="7f421-240">When stopped, a video renderer should hold on to the image so that subsequent [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages can be handled.</span></span>

<span data-ttu-id="7f421-241">Таким образом, если модуль подготовки видео получает сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) при остановке или приостановке и не содержит ничего, с которым будет закрашиваться окно, оно должно ОТсылать [**\_ перерисовки EC**](ec-repaint.md) в Диспетчер графа фильтров.</span><span class="sxs-lookup"><span data-stu-id="7f421-241">Therefore, if a video renderer receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message when stopped or paused, and it has nothing with which to paint its window, then it should send [**EC\_REPAINT**](ec-repaint.md) to the Filter Graph Manager.</span></span> <span data-ttu-id="7f421-242">Если при приостановке получается уведомление о **\_ перерисовке EC** , диспетчер графа фильтров вызывает [**имедиапоситион::p UT \_ CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) с текущей позицией (т. е. выполняет поиск в текущей положении).</span><span class="sxs-lookup"><span data-stu-id="7f421-242">If an **EC\_REPAINT** notification is received while paused, then the Filter Graph Manager calls [**IMediaPosition::put\_CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) with the current position (that is, seeks to the current position).</span></span> <span data-ttu-id="7f421-243">Это приводит к тому, что фильтры источника сбрасывают граф фильтра и вызывают отправку новых данных через граф фильтра.</span><span class="sxs-lookup"><span data-stu-id="7f421-243">This causes the source filters to flush the filter graph and causes new data to be sent through the filter graph.</span></span>

<span data-ttu-id="7f421-244">Модуль подготовки отчетов должен отправлять только одно из этих уведомлений за раз.</span><span class="sxs-lookup"><span data-stu-id="7f421-244">A renderer must send only one of these notifications at a time.</span></span> <span data-ttu-id="7f421-245">Таким образом, когда модуль подготовки отчетов отправляет уведомление, он должен гарантировать, что все больше не будут отправляться, пока не будут доставлены некоторые образцы.</span><span class="sxs-lookup"><span data-stu-id="7f421-245">Therefore, once the renderer sends a notification, it should ensure no more are sent until some samples are delivered.</span></span> <span data-ttu-id="7f421-246">Обычный способ сделать это — установить флаг, означающий, что перерисовку можно отправить, что будет отключено после отправки уведомления о [**\_ перерисовке EC**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="7f421-246">The conventional way to do this is to have a flag to signify that a repaint can be sent, which is turned off after an [**EC\_REPAINT**](ec-repaint.md) notification is sent.</span></span> <span data-ttu-id="7f421-247">Этот флаг должен быть сброшен после доставки данных или ввода ПИН-кода для записи на диск, но не в случае, если на входном заметке сообщается конец потока.</span><span class="sxs-lookup"><span data-stu-id="7f421-247">This flag should be reset once data is delivered or when the input pin is flushed, but not if end-of-stream is signaled on the input pin.</span></span>

<span data-ttu-id="7f421-248">Если модуль подготовки отчетов не отслеживает уведомления о [**\_ перерисовке EC**](ec-repaint.md) , он переводит диспетчер графов фильтров в запросы **\_ перерисовки EC** (которые относительно ресурсоемких процессов).</span><span class="sxs-lookup"><span data-stu-id="7f421-248">If the renderer does not monitor its [**EC\_REPAINT**](ec-repaint.md) notifications, it will flood the Filter Graph Manager with **EC\_REPAINT** requests (which are relatively expensive to process).</span></span> <span data-ttu-id="7f421-249">Например, если у модуля подготовки отчетов нет изображения для рисования, а другое окно перемещается по окну модуля отрисовки в операции полного перетаскивания, модуль подготовки отчетов получает несколько сообщений [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="7f421-249">For example, if a renderer has no image to draw, and another window is dragged across the window of the renderer in a full-drag operation, the renderer receives multiple [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages.</span></span> <span data-ttu-id="7f421-250">Только первый из них должен создавать уведомление о событии **EC \_ перерисовки** из модуля подготовки к просмотру диспетчера графа фильтров.</span><span class="sxs-lookup"><span data-stu-id="7f421-250">Only the first of these should generate an **EC\_REPAINT** event notification from the renderer to the Filter Graph Manager.</span></span>

<span data-ttu-id="7f421-251">Модуль подготовки отчетов должен отправить свой входной ПИН-код в качестве первого параметра в уведомление о [**\_ перерисовке EC**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="7f421-251">A renderer should send its input pin as the first parameter to the [**EC\_REPAINT**](ec-repaint.md) notification.</span></span> <span data-ttu-id="7f421-252">При этом будет выполнен запрос к присоединенному закреплениям выходных данных для [**имедиаевентсинк**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink), и если оно поддерживается, уведомление о **\_ перерисовке EC** будет отправлено в первую очередь.</span><span class="sxs-lookup"><span data-stu-id="7f421-252">By doing this, the attached output pin will be queried for [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink), and if supported, the **EC\_REPAINT** notification will be sent there first.</span></span> <span data-ttu-id="7f421-253">Это позволяет выходным закреплениям обрабатывать перерисовки до того, как необходимо затронуть граф фильтра.</span><span class="sxs-lookup"><span data-stu-id="7f421-253">This enables output pins to handle repaints before the filter graph must be touched.</span></span> <span data-ttu-id="7f421-254">Это не будет выполнено, если граф фильтра остановлен, поскольку буферы не будут доступны из распределителя незафиксированного модуля подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="7f421-254">This will not be done if the filter graph is stopped, because no buffers would be available from the decommitted renderer allocator.</span></span>

<span data-ttu-id="7f421-255">Если выходной ПИН-код не может обрабатывать запрос и граф фильтра работает, уведомление о [**\_ перерисовке EC**](ec-repaint.md) игнорируется.</span><span class="sxs-lookup"><span data-stu-id="7f421-255">If the output pin cannot handle the request and the filter graph is running, then the [**EC\_REPAINT**](ec-repaint.md) notification is ignored.</span></span> <span data-ttu-id="7f421-256">Закрепление вывода должно возвращать значение **S \_ ОК** от [**имедиаевентсинк:: notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) , чтобы сообщить о том, что запрос на перерисовку успешно обработан.</span><span class="sxs-lookup"><span data-stu-id="7f421-256">An output pin must return **S\_OK** from [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) to signal that it processed the repaint request successfully.</span></span> <span data-ttu-id="7f421-257">Закрепление вывода будет вызываться в рабочем потоке диспетчера графа фильтра, что позволяет избежать непосредственного вызова выходного ПИН-кода и сидестепс всех проблем взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="7f421-257">The output pin will be called on the Filter Graph Manager worker thread, which avoids having the renderer call the output pin directly, and so sidesteps any deadlock issues.</span></span> <span data-ttu-id="7f421-258">Если граф фильтра остановлен или приостановлен, а выходные данные не обрабатывают запрос, обработка по умолчанию выполняется.</span><span class="sxs-lookup"><span data-stu-id="7f421-258">If the filter graph is stopped or paused and the output doesn't handle the request, then the default processing is done.</span></span>

## <a name="handling-notifications-in-full-screen-mode"></a><span data-ttu-id="7f421-259">Обработка уведомлений в режиме Full-Screen</span><span class="sxs-lookup"><span data-stu-id="7f421-259">Handling Notifications in Full-Screen Mode</span></span>

<span data-ttu-id="7f421-260">Подключаемый модуль [**ивидеовиндов**](/windows/desktop/api/Control/nn-control-ivideowindow) (PID) в графе фильтра управляет воспроизведением на полноэкранном режиме.</span><span class="sxs-lookup"><span data-stu-id="7f421-260">The [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) plug-in distributor (PID) in the filter graph manages full-screen playback.</span></span> <span data-ttu-id="7f421-261">Он будет переключать модуль визуализации видео на средство подготовки полноэкранного режима для специалистов, растянуть окно модуля подготовки отчетов в полноэкранный режим или подготовить его к полноэкранному воспроизведению напрямую.</span><span class="sxs-lookup"><span data-stu-id="7f421-261">It will swap a video renderer out for a specialist full-screen renderer, stretch a window of a renderer to full screen, or have the renderer implement full-screen playback directly.</span></span> <span data-ttu-id="7f421-262">Для взаимодействия с полноэкранными протоколами модуль подготовки отчетов должен отправить уведомление об [**\_ активации EC**](ec-activate.md) всякий раз, когда его окно активируется или деактивируется.</span><span class="sxs-lookup"><span data-stu-id="7f421-262">To interact in full-screen protocols, a video renderer should send an [**EC\_ACTIVATE**](ec-activate.md) notification whenever its window is either activated or deactivated.</span></span> <span data-ttu-id="7f421-263">Иными словами, для каждого сообщения WM активатеапп, полученного модулем подготовки, должно быть отправлено уведомление об **\_ активации EC** \_ .</span><span class="sxs-lookup"><span data-stu-id="7f421-263">In other words, an **EC\_ACTIVATE** notification should be sent for each WM\_ACTIVATEAPP message a renderer receives.</span></span>

<span data-ttu-id="7f421-264">При использовании модуля подготовки отчетов в полноэкранном режиме эти уведомления управляют переключением в полноэкранный режим и из него.</span><span class="sxs-lookup"><span data-stu-id="7f421-264">When a renderer is being used in full-screen mode, these notifications manage the switching into and out of that full-screen mode.</span></span> <span data-ttu-id="7f421-265">Деактивация окна обычно происходит, когда пользователь нажимает ALT + TAB для переключения на другое окно, которое модуль подготовки отчетов DirectShow использует в качестве подсказки для возврата в обычный режим рендеринга.</span><span class="sxs-lookup"><span data-stu-id="7f421-265">Window deactivation typically occurs when a user presses ALT+TAB to switch to another window, which the DirectShow full-screen renderer uses as a cue to return to typical rendering mode.</span></span>

<span data-ttu-id="7f421-266">Когда уведомление [**о \_ активации EC**](ec-activate.md) отправляется в Диспетчер графов фильтров при выходе из полноэкранного режима, диспетчер графа фильтров отправляет в управляющее приложение уведомление о [**\_ неполноэкранном \_ режиме EC**](ec-fullscreen-lost.md) .</span><span class="sxs-lookup"><span data-stu-id="7f421-266">When the [**EC\_ACTIVATE**](ec-activate.md) notification is sent to the Filter Graph Manager upon switching out of full-screen mode, the Filter Graph Manager sends an [**EC\_FULLSCREEN\_LOST**](ec-fullscreen-lost.md) notification to the controlling application.</span></span> <span data-ttu-id="7f421-267">Приложение может использовать это уведомление для восстановления состояния полноэкранной кнопки, например.</span><span class="sxs-lookup"><span data-stu-id="7f421-267">The application might use this notification to restore the state of a full-screen button, for example.</span></span> <span data-ttu-id="7f421-268">Уведомления **об \_ активации EC** используются внутри DirectShow для управления полноэкранным переключением в подсказках из модулей подготовки видео.</span><span class="sxs-lookup"><span data-stu-id="7f421-268">The **EC\_ACTIVATE** notifications are used internally by DirectShow to manage full-screen switching on cues from the video renderers.</span></span>

## <a name="summary-of-notifications"></a><span data-ttu-id="7f421-269">Сводка уведомлений</span><span class="sxs-lookup"><span data-stu-id="7f421-269">Summary of Notifications</span></span>

<span data-ttu-id="7f421-270">В этом разделе перечислены уведомления графа фильтра, которые могут отправляться модулем подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="7f421-270">This section lists the filter graph notifications that a renderer can send.</span></span>



| <span data-ttu-id="7f421-271">Уведомление о событии</span><span class="sxs-lookup"><span data-stu-id="7f421-271">Event notification</span></span>                                        | <span data-ttu-id="7f421-272">Описание</span><span class="sxs-lookup"><span data-stu-id="7f421-272">Description</span></span>                                                                                                                                                                                       |
|-----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="7f421-273">**\_Активация EC**</span><span class="sxs-lookup"><span data-stu-id="7f421-273">**EC\_ACTIVATE**</span></span>](ec-activate.md)                       | <span data-ttu-id="7f421-274">Отправляется модулями подготовки видео в полноэкранном режиме для каждого \_ полученного сообщения WM активатеапп.</span><span class="sxs-lookup"><span data-stu-id="7f421-274">Sent by video renderers in full-screen rendering mode for each WM\_ACTIVATEAPP message received.</span></span>                                                                                                  |
| [<span data-ttu-id="7f421-275">**EC \_ завершено**</span><span class="sxs-lookup"><span data-stu-id="7f421-275">**EC\_COMPLETE**</span></span>](ec-complete.md)                       | <span data-ttu-id="7f421-276">Посылается модулями подготовки отчетов после подготовки к просмотру всех данных.</span><span class="sxs-lookup"><span data-stu-id="7f421-276">Sent by renderers after all data has been rendered.</span></span>                                                                                                                                               |
| [<span data-ttu-id="7f421-277">**\_изменение дисплея \_ EC**</span><span class="sxs-lookup"><span data-stu-id="7f421-277">**EC\_DISPLAY\_CHANGED**</span></span>](ec-display-changed.md)        | <span data-ttu-id="7f421-278">Отправляется модулями подготовки видео при изменении формата отображения.</span><span class="sxs-lookup"><span data-stu-id="7f421-278">Sent by video renderers when a display format changes.</span></span>                                                                                                                                            |
| [<span data-ttu-id="7f421-279">**\_Изменение палитры EC \_**</span><span class="sxs-lookup"><span data-stu-id="7f421-279">**EC\_PALETTE\_CHANGED**</span></span>](ec-palette-changed.md)        | <span data-ttu-id="7f421-280">Отправляется каждый раз, когда модуль подготовки видео обнаруживает изменение палитры в потоке.</span><span class="sxs-lookup"><span data-stu-id="7f421-280">Sent whenever a video renderer detects a palette change in the stream.</span></span>                                                                                                                            |
| [<span data-ttu-id="7f421-281">**\_ПЕРЕрисовка EC**</span><span class="sxs-lookup"><span data-stu-id="7f421-281">**EC\_REPAINT**</span></span>](ec-repaint.md)                         | <span data-ttu-id="7f421-282">Отправляется остановленными или приостановленными модулями подготовки видео, когда \_ получено сообщение WM Paint и отсутствуют данные для отображения.</span><span class="sxs-lookup"><span data-stu-id="7f421-282">Sent by stopped or paused video renderers when a WM\_PAINT message is received and there is no data to display.</span></span> <span data-ttu-id="7f421-283">Это приводит к тому, что диспетчер графов фильтров создает рамку для рисования на экране.</span><span class="sxs-lookup"><span data-stu-id="7f421-283">This causes the Filter Graph Manager to generate a frame to paint to the display.</span></span> |
| [<span data-ttu-id="7f421-284">**EC \_ усераборт**</span><span class="sxs-lookup"><span data-stu-id="7f421-284">**EC\_USERABORT**</span></span>](ec-userabort.md)                     | <span data-ttu-id="7f421-285">Отправляется модулями подготовки видео для сигнализации о закрытии, запрошенном пользователем (например, при закрытии видео окна).</span><span class="sxs-lookup"><span data-stu-id="7f421-285">Sent by video renderers to signal a closure that the user requested (for example, a user closing the video window).</span></span>                                                                               |
| [<span data-ttu-id="7f421-286">**\_Размер видео \_ EC \_ изменен**</span><span class="sxs-lookup"><span data-stu-id="7f421-286">**EC\_VIDEO\_SIZE\_CHANGED**</span></span>](ec-video-size-changed.md) | <span data-ttu-id="7f421-287">Отправляется модулями подготовки видео при обнаружении изменений в собственном размере видео.</span><span class="sxs-lookup"><span data-stu-id="7f421-287">Sent by video renderers whenever a change in native video size is detected.</span></span>                                                                                                                       |
| [<span data-ttu-id="7f421-288">**\_окно EC \_ уничтожено**</span><span class="sxs-lookup"><span data-stu-id="7f421-288">**EC\_WINDOW\_DESTROYED**</span></span>](ec-window-destroyed.md)      | <span data-ttu-id="7f421-289">Посылается модулями подготовки видео, когда фильтр удаляется или уничтожается, чтобы ресурсы, зависящие от фокуса окна, можно было передавать другим фильтрам.</span><span class="sxs-lookup"><span data-stu-id="7f421-289">Sent by video renderers when the filter is removed or destroyed so that resources that depend on window focus can be passed to other filters.</span></span>                                                     |



 

## <a name="related-topics"></a><span data-ttu-id="7f421-290">См. также</span><span class="sxs-lookup"><span data-stu-id="7f421-290">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="7f421-291">Написание модулей подготовки видео</span><span class="sxs-lookup"><span data-stu-id="7f421-291">Writing Video Renderers</span></span>](writing-video-renderers.md)
</dt> </dl>

 

 
