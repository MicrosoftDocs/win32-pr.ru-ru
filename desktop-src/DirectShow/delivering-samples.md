---
description: Доставка образцов
ms.assetid: 31aabb6d-dec6-41fa-b24d-35a77b67bc4a
title: Доставка образцов
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 083bc8c88649c04bdf9f93f86ebcc277ee48e75e
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104423165"
---
# <a name="delivering-samples"></a><span data-ttu-id="06f8b-103">Доставка образцов</span><span class="sxs-lookup"><span data-stu-id="06f8b-103">Delivering Samples</span></span>

<span data-ttu-id="06f8b-104">В этой статье описывается, как фильтр доставляет пример.</span><span class="sxs-lookup"><span data-stu-id="06f8b-104">This article describes how a filter delivers a sample.</span></span> <span data-ttu-id="06f8b-105">В нем описывается как модель push-уведомлений с помощью методов [**имеминпутпин**](/windows/desktop/api/Strmif/nn-strmif-imeminputpin) , так и модель извлечения с помощью [**иасинкреадер**](/windows/desktop/api/Strmif/nn-strmif-iasyncreader).</span><span class="sxs-lookup"><span data-stu-id="06f8b-105">It describes both the push model, using [**IMemInputPin**](/windows/desktop/api/Strmif/nn-strmif-imeminputpin) methods, and the pull model, using [**IAsyncReader**](/windows/desktop/api/Strmif/nn-strmif-iasyncreader).</span></span>

<span data-ttu-id="06f8b-106">**Модель push-уведомлений: Доставка образца**</span><span class="sxs-lookup"><span data-stu-id="06f8b-106">**Push Model: Delivering a Sample**</span></span>

<span data-ttu-id="06f8b-107">Закрепление вывода предоставляет пример вызова метода [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) или метода [**Имеминпутпин:: рецеивемултипле**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) , который эквивалентен, но доставляет массив примеров.</span><span class="sxs-lookup"><span data-stu-id="06f8b-107">The output pin delivers a sample by calling the [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method or the [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) method, which is equivalent but delivers an array of samples.</span></span> <span data-ttu-id="06f8b-108">Входной ПИН-код может блокироваться внутри **Receive** (или **рецеивемултипле**).</span><span class="sxs-lookup"><span data-stu-id="06f8b-108">The input pin can block inside **Receive** (or **ReceiveMultiple**).</span></span> <span data-ttu-id="06f8b-109">Если ПИН-код может быть заблокирован, его метод [**имеминпутпин:: рецеивеканблокк**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivecanblock) должен вернуть значение S \_ ОК.</span><span class="sxs-lookup"><span data-stu-id="06f8b-109">If the pin might block, its [**IMemInputPin::ReceiveCanBlock**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivecanblock) method should return S\_OK.</span></span> <span data-ttu-id="06f8b-110">Если ПИН-код никогда не блокируется, **рецеивеканблокк** должен возвращать \_ значение S false.</span><span class="sxs-lookup"><span data-stu-id="06f8b-110">If the pin guarantees never to block, **ReceiveCanBlock** should return S\_FALSE.</span></span> <span data-ttu-id="06f8b-111">\_Возвращаемое значение S ОК не означает, что **Receive** всегда блокируется, просто это может быть.</span><span class="sxs-lookup"><span data-stu-id="06f8b-111">The S\_OK return value does not mean that **Receive** always blocks, just that it might.</span></span>

<span data-ttu-id="06f8b-112">Несмотря на то, что **Receive** может блокировать доступность ресурса, он не должен блокировать ожидание дополнительных данных из вышестоящего фильтра.</span><span class="sxs-lookup"><span data-stu-id="06f8b-112">Although **Receive** can block to wait for a resource to become available, it should not block to wait for more data from the upstream filter.</span></span> <span data-ttu-id="06f8b-113">Это может привести к взаимоблокировке, когда вышестоящий фильтр ожидает, пока нисходящий фильтр выдаст пример, который не происходит, так как подчиненный фильтр ожидает вышестоящего фильтра.</span><span class="sxs-lookup"><span data-stu-id="06f8b-113">Doing so can cause a deadlock where the upstream filter waits for the downstream filter to release the sample, which never happens because the downstream filter is waiting on the upstream filter.</span></span> <span data-ttu-id="06f8b-114">Однако если у фильтра есть несколько входных ПИН-кодов, один из них может ожидать получения данных другим ПИН-кодом.</span><span class="sxs-lookup"><span data-stu-id="06f8b-114">If a filter has multiple input pins, however, one pin can wait for another pin to receive data.</span></span> <span data-ttu-id="06f8b-115">Например, фильтр [мультиплексора](avi-mux-filter.md) в формате AVI делает это для чередования аудио и видео данных.</span><span class="sxs-lookup"><span data-stu-id="06f8b-115">For example, the [AVI Mux](avi-mux-filter.md) filter does this so that it can interleave audio and video data.</span></span>

<span data-ttu-id="06f8b-116">ПИН-код может отклонить выбор по ряду причин:</span><span class="sxs-lookup"><span data-stu-id="06f8b-116">A pin might reject a sample for a number of reasons:</span></span>

-   <span data-ttu-id="06f8b-117">ПИН-код очищается (см. раздел [Очистка](flushing.md)).</span><span class="sxs-lookup"><span data-stu-id="06f8b-117">The pin is flushing (see [Flushing](flushing.md)).</span></span>
-   <span data-ttu-id="06f8b-118">ПИН-код не подключен.</span><span class="sxs-lookup"><span data-stu-id="06f8b-118">The pin is not connected.</span></span>
-   <span data-ttu-id="06f8b-119">Фильтр остановлен.</span><span class="sxs-lookup"><span data-stu-id="06f8b-119">The filter is stopped.</span></span>
-   <span data-ttu-id="06f8b-120">Произошла другая ошибка.</span><span class="sxs-lookup"><span data-stu-id="06f8b-120">Some other error occurred.</span></span>

<span data-ttu-id="06f8b-121">В первом случае метод **Receive** должен возвращать \_ значение false, а в других случаях — код сбоя.</span><span class="sxs-lookup"><span data-stu-id="06f8b-121">The **Receive** method should return S\_FALSE in the first case, and a failure code in the other cases.</span></span> <span data-ttu-id="06f8b-122">Вышестоящий фильтр должен закончить отправку образцов, если код возврата имеет значение, отличное от S \_ ОК.</span><span class="sxs-lookup"><span data-stu-id="06f8b-122">The upstream filter should stop sending samples when the return code is anything other than S\_OK.</span></span>

<span data-ttu-id="06f8b-123">Первые три варианта можно рассматривать как «ожидаемые» сбои, в том смысле, что фильтр находился в неправильном состоянии для получения образцов.</span><span class="sxs-lookup"><span data-stu-id="06f8b-123">You can consider the first three cases to be "expected" failures, in the sense that the filter was in the wrong state to receive samples.</span></span> <span data-ttu-id="06f8b-124">Непредвиденный сбой может привести к тому, что ПИН-код отклонит выборку, даже если ПИН-код находится в состоянии получения.</span><span class="sxs-lookup"><span data-stu-id="06f8b-124">An unexpected failure would be one that causes the pin to reject a sample even though the pin is in a receiving state.</span></span> <span data-ttu-id="06f8b-125">При возникновении ошибки такого типа ПИН-код должен отсылать уведомление о завершении потока и отправить событие [**EC \_ Еррораборт**](ec-errorabort.md) в Диспетчер графа фильтров.</span><span class="sxs-lookup"><span data-stu-id="06f8b-125">If an error of this type occurs, the pin should send an end-of-stream notification downstream, and send an [**EC\_ERRORABORT**](ec-errorabort.md) event to the Filter Graph Manager.</span></span>

<span data-ttu-id="06f8b-126">В базовых классах DirectShow метод [**кбасеинпутпин:: чеккстреаминг**](cbaseinputpin-checkstreaming.md) проверяет общие случаи сбоев — запись на диск, остановка и т. д.</span><span class="sxs-lookup"><span data-stu-id="06f8b-126">In the DirectShow base classes, the [**CBaseInputPin::CheckStreaming**](cbaseinputpin-checkstreaming.md) method checks for the general failure cases—flushing, stopped, and so forth.</span></span> <span data-ttu-id="06f8b-127">Производный класс должен проверять наличие сбоев, характерных для фильтра.</span><span class="sxs-lookup"><span data-stu-id="06f8b-127">The derived class will need to check for failures that are specific to the filter.</span></span> <span data-ttu-id="06f8b-128">В случае ошибки метод [**кбасеинпутпин:: Receive**](cbaseinputpin-receive.md) отправляет уведомление об окончании потока и \_ событие EC еррораборт.</span><span class="sxs-lookup"><span data-stu-id="06f8b-128">In case of an error, the [**CBaseInputPin::Receive**](cbaseinputpin-receive.md) method sends the end-of-stream notification and the EC\_ERRORABORT event.</span></span>

<span data-ttu-id="06f8b-129">**Модель извлечения: запрос примера**</span><span class="sxs-lookup"><span data-stu-id="06f8b-129">**Pull Model: Requesting a Sample**</span></span>

<span data-ttu-id="06f8b-130">В интерфейсе **иасинкреадер** входной ПИН-код запрашивает примеры из выходного ПИН-кода, вызывая один из следующих методов:</span><span class="sxs-lookup"><span data-stu-id="06f8b-130">In the **IAsyncReader** interface, the input pin requests samples from the output pin by calling one of the following methods:</span></span>

-   [<span data-ttu-id="06f8b-131">**Иасинкреадер:: Request**</span><span class="sxs-lookup"><span data-stu-id="06f8b-131">**IAsyncReader::Request**</span></span>](/windows/desktop/api/Strmif/nf-strmif-iasyncreader-request)
-   [<span data-ttu-id="06f8b-132">**Иасинкреадер:: Синкреад**</span><span class="sxs-lookup"><span data-stu-id="06f8b-132">**IAsyncReader::SyncRead**</span></span>](/windows/desktop/api/Strmif/nf-strmif-iasyncreader-syncread)
-   [<span data-ttu-id="06f8b-133">**Иасинкреадер:: Синкреадалигнед**</span><span class="sxs-lookup"><span data-stu-id="06f8b-133">**IAsyncReader::SyncReadAligned**</span></span>](/windows/desktop/api/Strmif/nf-strmif-iasyncreader-syncreadaligned)

<span data-ttu-id="06f8b-134">Метод **запроса** является асинхронным; входной ПИН-код вызывает [**иасинкреадер:: ваитфорнекст**](/windows/desktop/api/Strmif/nf-strmif-iasyncreader-waitfornext) , чтобы дождаться завершения запроса.</span><span class="sxs-lookup"><span data-stu-id="06f8b-134">The **Request** method is asynchronous; the input pin calls [**IAsyncReader::WaitForNext**](/windows/desktop/api/Strmif/nf-strmif-iasyncreader-waitfornext) to wait for the request to complete.</span></span> <span data-ttu-id="06f8b-135">Два других метода являются синхронными.</span><span class="sxs-lookup"><span data-stu-id="06f8b-135">The other two methods are synchronous.</span></span>

<span data-ttu-id="06f8b-136">**Время доставки данных**</span><span class="sxs-lookup"><span data-stu-id="06f8b-136">**When to Deliver Data**</span></span>

<span data-ttu-id="06f8b-137">Фильтр всегда доставляет образцы, пока находится в состоянии выполняется.</span><span class="sxs-lookup"><span data-stu-id="06f8b-137">A filter always delivers samples while it is in the running state.</span></span> <span data-ttu-id="06f8b-138">В большинстве случаев фильтр также доставляет образцы при приостановке.</span><span class="sxs-lookup"><span data-stu-id="06f8b-138">In most cases, a filter also delivers samples while paused.</span></span> <span data-ttu-id="06f8b-139">Это позволяет диаграмме занимать данные, чтобы воспроизведение начиналось сразу же после вызова метода **Run** (см. сведения о [состояниях фильтра](filter-states.md)).</span><span class="sxs-lookup"><span data-stu-id="06f8b-139">This enables the graph to cue up the data so that playback starts immediately when **Run** is called (see [Filter States](filter-states.md)).</span></span> <span data-ttu-id="06f8b-140">Если фильтр не доставляет данные при приостановке, метод **имедиафилтер::** noreturn фильтра должен возвращать VFW s не \_ \_ удается \_ подсказку в приостановленном состоянии.</span><span class="sxs-lookup"><span data-stu-id="06f8b-140">If your filter does not deliver data while paused, the filter's **IMediaFilter::GetState** method should return VFW\_S\_CANT\_CUE in the paused state.</span></span> <span data-ttu-id="06f8b-141">Этот код возврата сигнализирует графу фильтра не ждать данных из фильтра до завершения перехода на паузу.</span><span class="sxs-lookup"><span data-stu-id="06f8b-141">This return code signals the filter graph not to wait for data from your filter before it completes the pause transition.</span></span> <span data-ttu-id="06f8b-142">В противном случае метод **Pause** будет заблокирован бесконечно.</span><span class="sxs-lookup"><span data-stu-id="06f8b-142">Otherwise, the **Pause** method will block indefinitely.</span></span> <span data-ttu-id="06f8b-143">Пример кода см. в разделе [**кбасефилтер:: «State**](cbasefilter-getstate.md)».</span><span class="sxs-lookup"><span data-stu-id="06f8b-143">For example code, see [**CBaseFilter::GetState**](cbasefilter-getstate.md).</span></span>

<span data-ttu-id="06f8b-144">Ниже приведены некоторые примеры того, когда фильтру может потребоваться вернуть в \_ очередь VFW S, не \_ могу \_ подсказку:</span><span class="sxs-lookup"><span data-stu-id="06f8b-144">Here are some examples of when a filter might need to return VFW\_S\_CANT\_CUE:</span></span>

-   <span data-ttu-id="06f8b-145">Динамические источники, такие как фильтры записи, не должны отсылать данные при приостановке.</span><span class="sxs-lookup"><span data-stu-id="06f8b-145">Live sources, such as capture filters, should not send data while paused.</span></span> <span data-ttu-id="06f8b-146">См. раздел [Создание данных в фильтре записи](producing-data-in-a-capture-filter.md).</span><span class="sxs-lookup"><span data-stu-id="06f8b-146">See [Producing Data in a Capture Filter](producing-data-in-a-capture-filter.md).</span></span>
-   <span data-ttu-id="06f8b-147">Фильтр разделителя может отсылать или не передавать данные во время приостановки, в зависимости от реализации.</span><span class="sxs-lookup"><span data-stu-id="06f8b-147">A splitter filter might or might not send data while paused, depending on the implementation.</span></span> <span data-ttu-id="06f8b-148">Если фильтр использует отдельные потоки для ввода данных в очередь каждого выходного контакта, он может отправить данные при приостановке.</span><span class="sxs-lookup"><span data-stu-id="06f8b-148">If the filter uses separate threads to queue data on each output pin, then it can send data while paused.</span></span> <span data-ttu-id="06f8b-149">Но если фильтр использует один поток для каждого выходного контакта, первый ПИН-код может блокировать поток при вызове **Receive**, что предотвратит передачу данных другими контактами.</span><span class="sxs-lookup"><span data-stu-id="06f8b-149">But if the filter uses a single thread for every output pin, the first pin might block the thread when it calls **Receive**, which will prevent the other pins from sending data.</span></span> <span data-ttu-id="06f8b-150">В этом случае следует возвращать VFW \_ S не \_ удается \_ подсказку.</span><span class="sxs-lookup"><span data-stu-id="06f8b-150">In that case, you should return VFW\_S\_CANT\_CUE.</span></span>
-   <span data-ttu-id="06f8b-151">Фильтр может доставлять данные нерегулярно.</span><span class="sxs-lookup"><span data-stu-id="06f8b-151">A filter might deliver data sporadically.</span></span> <span data-ttu-id="06f8b-152">Например, он может анализировать пользовательский поток данных и отфильтровывать некоторые пакеты при доставке других.</span><span class="sxs-lookup"><span data-stu-id="06f8b-152">For example, it might parse a custom data stream and filter out some packets while delivering others.</span></span> <span data-ttu-id="06f8b-153">В этом случае фильтр может не гарантировать доставку данных при приостановке.</span><span class="sxs-lookup"><span data-stu-id="06f8b-153">In that case, the filter may not be guaranteed to deliver data while paused.</span></span>

<span data-ttu-id="06f8b-154">Фильтр источника (с использованием модели push-уведомлений) или фильтр средства синтаксического анализа (с использованием модели принудительной отправки и извлечения) создает один или несколько потоков потоковой передачи, которые предоставляют образцы как можно быстрее.</span><span class="sxs-lookup"><span data-stu-id="06f8b-154">A source filter (using the push model) or a parser filter (using the push/pull model) creates one or more streaming threads, which deliver samples as quickly as possible.</span></span> <span data-ttu-id="06f8b-155">Нисходящие фильтры, такие как декодеры и преобразования, обычно отправляют данные только при вызове метода **Receive** на входных ПИН-кодах.</span><span class="sxs-lookup"><span data-stu-id="06f8b-155">Downstream filters, such as decoders and transforms, typically send data only when **Receive** is called on their input pins.</span></span>

## <a name="related-topics"></a><span data-ttu-id="06f8b-156">См. также</span><span class="sxs-lookup"><span data-stu-id="06f8b-156">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="06f8b-157">Получение и доставка примеров</span><span class="sxs-lookup"><span data-stu-id="06f8b-157">Receiving and Delivering Samples</span></span>](receiving-and-delivering-samples.md)
</dt> </dl>

 

 



