---
description: Потоковая передача и потоки приложений
ms.assetid: 954f7abd-fe06-430a-b6f7-d60852826bc9
title: Потоковая передача и потоки приложений
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 432e613ff0322377c042e796d84ef7affdda99c2
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104547018"
---
# <a name="the-streaming-and-application-threads"></a><span data-ttu-id="9584b-103">Потоковая передача и потоки приложений</span><span class="sxs-lookup"><span data-stu-id="9584b-103">The Streaming and Application Threads</span></span>

<span data-ttu-id="9584b-104">Любое приложение DirectShow содержит по крайней мере два важных потока: поток приложения и один или несколько потоков потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="9584b-104">Any DirectShow application contains at least two important threads: the application thread, and one or more streaming threads.</span></span> <span data-ttu-id="9584b-105">Образцы доставляются в потоках потоковой передачи, а изменения состояния происходят в потоке приложения.</span><span class="sxs-lookup"><span data-stu-id="9584b-105">Samples are delivered on the streaming threads, and state changes happen on the application thread.</span></span> <span data-ttu-id="9584b-106">Основной поток потоковой передачи создается с помощью фильтра источника или средства синтаксического анализа.</span><span class="sxs-lookup"><span data-stu-id="9584b-106">The main streaming thread is created by a source or parser filter.</span></span> <span data-ttu-id="9584b-107">Другие фильтры могут создавать рабочие потоки, которые доставляют образцы, и они также считаются потоками потоков.</span><span class="sxs-lookup"><span data-stu-id="9584b-107">Other filters might create worker threads that deliver samples, and these are considered streaming threads as well.</span></span>

<span data-ttu-id="9584b-108">Некоторые методы вызываются в потоке приложения, а другие вызываются в потоке потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="9584b-108">Some methods are called on the application thread, while others are called on a streaming thread.</span></span> <span data-ttu-id="9584b-109">Пример:</span><span class="sxs-lookup"><span data-stu-id="9584b-109">For example:</span></span>

-   <span data-ttu-id="9584b-110">Потоки потоковой передачи: [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive), [**Имеминпутпин:: рецеивемултипле**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple), [**Ипин:: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream), [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="9584b-110">Streaming thread(s): [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive), [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple), [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream), [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span>
-   <span data-ttu-id="9584b-111">Поток приложения: [**имедиафилтер::P Аусе**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause), [**Имедиафилтер:: Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run), [**имедиафилтер:: останавливаться**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop), [**имедиасикинг:: сетпоситионс**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions), [**Ипин:: бегинфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush), [**IPIN:: EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span><span class="sxs-lookup"><span data-stu-id="9584b-111">Application thread: [**IMediaFilter::Pause**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause), [**IMediaFilter::Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run), [**IMediaFilter::Stop**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop), [**IMediaSeeking::SetPositions**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions), [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush), [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span>
-   <span data-ttu-id="9584b-112">Либо: [**Ипин:: невсегмент**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).</span><span class="sxs-lookup"><span data-stu-id="9584b-112">Either: [**IPin::NewSegment**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).</span></span>

<span data-ttu-id="9584b-113">Наличие отдельного потока потоковой передачи позволяет передавать данные через граф, пока поток приложения ожидает ввода данных пользователем.</span><span class="sxs-lookup"><span data-stu-id="9584b-113">Having a separate streaming thread allows data to flow through the graph while the application thread waits for user input.</span></span> <span data-ttu-id="9584b-114">Опасность нескольких потоков, однако, заключается в том, что фильтр может создавать ресурсы при приостановке (в потоке приложения), использовать их внутри метода потоковой передачи и уничтожать их при остановке (также в потоке приложения).</span><span class="sxs-lookup"><span data-stu-id="9584b-114">The danger of multiple threads, however, is that a filter may create resources when it pauses (on the application thread), use them inside a streaming method, and destroy them when it stops (also on the application thread).</span></span> <span data-ttu-id="9584b-115">Если вы не проследите, поток потоковой передачи может попытаться использовать ресурсы после их уничтожения.</span><span class="sxs-lookup"><span data-stu-id="9584b-115">If you are not careful, the streaming thread might try to use the resources after they are destroyed.</span></span> <span data-ttu-id="9584b-116">Решение заключается в защите ресурсов с помощью критических разделов и синхронизации методов потоковой передачи с изменениями состояния.</span><span class="sxs-lookup"><span data-stu-id="9584b-116">The solution is to protect resources using critical sections, and synchronize streaming methods with state changes.</span></span>

<span data-ttu-id="9584b-117">Для защиты состояния фильтра фильтру требуется одна критическая секция.</span><span class="sxs-lookup"><span data-stu-id="9584b-117">A filter needs one critical section to protect the filter state.</span></span> <span data-ttu-id="9584b-118">Класс [**кбасефилтер**](cbasefilter.md) имеет переменную-член для этого критического раздела, [**кбасефилтер:: m \_ плокк**](cbasefilter-m-plock.md).</span><span class="sxs-lookup"><span data-stu-id="9584b-118">The [**CBaseFilter**](cbasefilter.md) class has a member variable for this critical section, [**CBaseFilter::m\_pLock**](cbasefilter-m-plock.md).</span></span> <span data-ttu-id="9584b-119">Этот критический раздел называется блокировкой фильтра.</span><span class="sxs-lookup"><span data-stu-id="9584b-119">This critical section is called the filter lock.</span></span> <span data-ttu-id="9584b-120">Кроме того, каждому входному ПИН-коду требуется критическая секция для защиты ресурсов, используемых потоком потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="9584b-120">Also, each input pin needs a critical section to protect resources used by the streaming thread.</span></span> <span data-ttu-id="9584b-121">Эти критические разделы называются потоковой блокировкой. их необходимо объявить в производном классе закрепления.</span><span class="sxs-lookup"><span data-stu-id="9584b-121">These critical sections are called streaming locks; you must declare them in your derived pin class.</span></span> <span data-ttu-id="9584b-122">Проще всего использовать класс [**ккритсек**](ccritsec.md) , который создает оболочку для объекта **критического \_ раздела** Windows и может быть заблокирован с помощью класса [**каутолокк**](cautolock.md) .</span><span class="sxs-lookup"><span data-stu-id="9584b-122">It is easiest to use the [**CCritSec**](ccritsec.md) class, which wraps a Windows **CRITICAL\_SECTION** object and can be locked using the [**CAutoLock**](cautolock.md) class.</span></span> <span data-ttu-id="9584b-123">Класс **ккритсек** также предоставляет некоторые полезные функции отладки.</span><span class="sxs-lookup"><span data-stu-id="9584b-123">The **CCritSec** class also provides some useful debugging functions.</span></span> <span data-ttu-id="9584b-124">Дополнительные сведения см. в разделе [функции отладки критических секций](critical-section-debugging-functions.md).</span><span class="sxs-lookup"><span data-stu-id="9584b-124">For more information, see [Critical Section Debugging Functions](critical-section-debugging-functions.md).</span></span>

<span data-ttu-id="9584b-125">При остановке или сбросе фильтра он должен синхронизировать поток приложения с потоком потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="9584b-125">When a filter stops or flushes, it must synchronize the application thread with the streaming thread.</span></span> <span data-ttu-id="9584b-126">Чтобы избежать взаимоблокировки, необходимо сначала разблокировать поток потоковой передачи, который может быть заблокирован по нескольким причинам:</span><span class="sxs-lookup"><span data-stu-id="9584b-126">To avoid deadlocking, it must first unblock the streaming thread, which might be blocked for several reasons:</span></span>

-   <span data-ttu-id="9584b-127">Он ожидает получения образца в методе [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , так как все примеры распределителя используются.</span><span class="sxs-lookup"><span data-stu-id="9584b-127">It is waiting to get a sample inside the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, because all of the allocator's samples are in use.</span></span>
-   <span data-ttu-id="9584b-128">Он ожидает возврата другим фильтром из потокового метода, например **Receive**.</span><span class="sxs-lookup"><span data-stu-id="9584b-128">It is waiting for another filter to return from a streaming method, such as **Receive**.</span></span>
-   <span data-ttu-id="9584b-129">Он ожидает внутри одного из своих методов потоковой передачи, чтобы некоторый ресурс стал доступным.</span><span class="sxs-lookup"><span data-stu-id="9584b-129">It is waiting inside one of its own streaming methods, for some resource to become available.</span></span>
-   <span data-ttu-id="9584b-130">Это фильтр модуля подготовки отчетов, ожидающий время презентации для следующего примера</span><span class="sxs-lookup"><span data-stu-id="9584b-130">It is a renderer filter waiting for the presentation time of the next sample</span></span>
-   <span data-ttu-id="9584b-131">Это фильтр модуля подготовки отчетов, ожидающий в методе **Receive** во время приостановки.</span><span class="sxs-lookup"><span data-stu-id="9584b-131">It is a renderer filter waiting inside the **Receive** method while paused.</span></span>

<span data-ttu-id="9584b-132">Поэтому при остановке или сбросе фильтра необходимо выполнить следующие действия.</span><span class="sxs-lookup"><span data-stu-id="9584b-132">Therefore, when the filter stops or flushes, it must do the following:</span></span>

-   <span data-ttu-id="9584b-133">Выпустите любой из примеров, который он удерживает по какой-либо причине.</span><span class="sxs-lookup"><span data-stu-id="9584b-133">Release any sample it is holding for any reason.</span></span> <span data-ttu-id="9584b-134">Это разблокирует **метод метода** WebMethod.</span><span class="sxs-lookup"><span data-stu-id="9584b-134">Doing so unblocks the **GetBuffer** method.</span></span>
-   <span data-ttu-id="9584b-135">Вернитесь из любого метода потоковой передачи как можно быстрее.</span><span class="sxs-lookup"><span data-stu-id="9584b-135">Return from any streaming method as quickly as possible.</span></span> <span data-ttu-id="9584b-136">Если потоковый метод ожидает ресурс, он должен немедленно закончить ожидание.</span><span class="sxs-lookup"><span data-stu-id="9584b-136">If a streaming method is waiting for a resource, it must stop waiting immediately.</span></span>
-   <span data-ttu-id="9584b-137">Начните отклонять примеры в **Receive**, чтобы поток потоковой передачи не получал доступ к большему ресурсу.</span><span class="sxs-lookup"><span data-stu-id="9584b-137">Start rejecting samples in **Receive**, so that the streaming thread does not access any more resources.</span></span> <span data-ttu-id="9584b-138">(Класс [**кбасеинпутпин**](cbaseinputpin.md) обрабатывает это автоматически.)</span><span class="sxs-lookup"><span data-stu-id="9584b-138">(The [**CBaseInputPin**](cbaseinputpin.md) class handles this automatically.)</span></span>
-   <span data-ttu-id="9584b-139">Метод **останавливаться** должен отменять фиксацию всех распределителя фильтра.</span><span class="sxs-lookup"><span data-stu-id="9584b-139">The **Stop** method must decommit all of the filter's allocators.</span></span> <span data-ttu-id="9584b-140">(Класс **кбасеинпутпин** обрабатывает это автоматически.)</span><span class="sxs-lookup"><span data-stu-id="9584b-140">(The **CBaseInputPin** class handles this automatically.)</span></span>

<span data-ttu-id="9584b-141">В потоке приложения происходит очистка и остановка.</span><span class="sxs-lookup"><span data-stu-id="9584b-141">Flushing and stopping both happen on the application thread.</span></span> <span data-ttu-id="9584b-142">Фильтр останавливается в ответ на метод [**имедиаконтрол:: Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) .</span><span class="sxs-lookup"><span data-stu-id="9584b-142">A filter stops in response to the [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) method.</span></span> <span data-ttu-id="9584b-143">Диспетчер графов фильтров выдает команду "выполнить" в восходящий порядок, начиная с модулей подготовки отчетов и перезапускаясь на исходные фильтры.</span><span class="sxs-lookup"><span data-stu-id="9584b-143">The Filter Graph Manager issues the stop command in upstream order, starting from the renderers and working backward to the source filters.</span></span> <span data-ttu-id="9584b-144">Команда "завершить" полностью выполняется внутри метода **кбасефилтер:: останавливаться** фильтра.</span><span class="sxs-lookup"><span data-stu-id="9584b-144">The stop command happens completely inside the filter's **CBaseFilter::Stop** method.</span></span> <span data-ttu-id="9584b-145">Когда метод возвращает значение, фильтр должен находиться в остановленном состоянии.</span><span class="sxs-lookup"><span data-stu-id="9584b-145">When the method returns, the filter should be in a stopped state.</span></span>

<span data-ttu-id="9584b-146">Очистка обычно происходит из-за команды Seek.</span><span class="sxs-lookup"><span data-stu-id="9584b-146">Flushing typically occurs because of a seek command.</span></span> <span data-ttu-id="9584b-147">Команда Flush начинается с исходного или из фильтра синтаксического анализатора и перемещается в нисходящий.</span><span class="sxs-lookup"><span data-stu-id="9584b-147">A flush command starts from the source or parser filter, and travels downstream.</span></span> <span data-ttu-id="9584b-148">Запись на диск происходит в два этапа: метод [**Ипин:: бегинфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) информирует фильтр о том, что все ожидающие и входящие данные отменяются; метод [**Ипин:: ендфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) сигнализирует фильтру о необходимости повторного приема данных.</span><span class="sxs-lookup"><span data-stu-id="9584b-148">Flushing happens in two stages: The [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) method informs a filter to discard all pending and incoming data; the [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) method signals the filter to accept data again.</span></span> <span data-ttu-id="9584b-149">Для очистки требуется два этапа, так как вызов **бегинфлуш** выполняется в потоке приложения, в течение которого потоковая передача продолжит доставлять данные.</span><span class="sxs-lookup"><span data-stu-id="9584b-149">Flushing requires two stages because the **BeginFlush** call is on the application thread, during which the streaming thread continues to deliver data.</span></span> <span data-ttu-id="9584b-150">Поэтому некоторые примеры могут поступать после вызова **бегинфлуш** .</span><span class="sxs-lookup"><span data-stu-id="9584b-150">Therefore, some samples may arrive after the **BeginFlush** call.</span></span> <span data-ttu-id="9584b-151">Фильтр должен отбросить их.</span><span class="sxs-lookup"><span data-stu-id="9584b-151">The filter should discard these.</span></span> <span data-ttu-id="9584b-152">Все примеры, поступающие после вызова **ендфлуш** , будут гарантированно новыми и должны быть доставлены.</span><span class="sxs-lookup"><span data-stu-id="9584b-152">Any samples that arrive after the **EndFlush** call are guaranteed to be new, and should be delivered.</span></span>

<span data-ttu-id="9584b-153">В следующих разделах содержатся примеры кода, демонстрирующие способы реализации наиболее важных методов фильтрации, таких как **Пауза**, **Получение** и т. д., чтобы избежать взаимоблокировок и конкуренции.</span><span class="sxs-lookup"><span data-stu-id="9584b-153">The sections that follow contain code samples showing how to implement the most important filter methods, such as **Pause**, **Receive**, and so forth, in ways that avoid deadlocks and race conditions.</span></span> <span data-ttu-id="9584b-154">Однако у каждого фильтра есть свои требования, поэтому вам потребуется адаптировать эти примеры к конкретному фильтру.</span><span class="sxs-lookup"><span data-stu-id="9584b-154">Every filter has different requirements, however, so you will need to adapt these examples to your particular filter.</span></span>

> [!Note]  
> <span data-ttu-id="9584b-155">Базовые классы [**ктрансформфилтер**](ctransformfilter.md) и [**ктрансинплацефилтер**](ctransinplacefilter.md) обработают многие проблемы, описанные в этой статье.</span><span class="sxs-lookup"><span data-stu-id="9584b-155">The [**CTransformFilter**](ctransformfilter.md) and [**CTransInPlaceFilter**](ctransinplacefilter.md) base classes handle many of the issues described in this article.</span></span> <span data-ttu-id="9584b-156">Если вы создаете фильтр преобразования, и фильтр не ожидает события внутри потокового метода или удерживает выборку за пределами **Receive**, то эти базовые классы должны быть достаточными.</span><span class="sxs-lookup"><span data-stu-id="9584b-156">If you are writing a transform filter, and your filter does not wait on events inside a streaming method, or hold onto samples outside of **Receive**, then these base classes should be sufficient.</span></span>

 

 

 



