---
description: Фильтрация состояний
ms.assetid: 97418307-eb50-4c8e-b03b-a2cd08139bdc
title: Фильтрация состояний
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d61f66e1446d97d289f7e489f116f747f339d9a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "105650436"
---
# <a name="filter-states"></a><span data-ttu-id="b29cc-103">Фильтрация состояний</span><span class="sxs-lookup"><span data-stu-id="b29cc-103">Filter States</span></span>

<span data-ttu-id="b29cc-104">Фильтры имеют три возможных состояния: остановлено, приостановлено и запущено.</span><span class="sxs-lookup"><span data-stu-id="b29cc-104">Filters have three possible states: stopped, paused, and running.</span></span> <span data-ttu-id="b29cc-105">Назначением приостановленного состояния является подсказка в графе, чтобы команда запуска немедленно отвечала на запросы.</span><span class="sxs-lookup"><span data-stu-id="b29cc-105">The purpose of the paused state is to cue data in the graph, so that a run command responds immediately.</span></span> <span data-ttu-id="b29cc-106">Диспетчер графов фильтров управляет всеми переходами состояний.</span><span class="sxs-lookup"><span data-stu-id="b29cc-106">The Filter Graph Manager controls all state transitions.</span></span> <span data-ttu-id="b29cc-107">Когда приложение вызывает [**имедиаконтрол:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**имедиаконтрол::P Аусе**](/windows/desktop/api/Control/nf-control-imediacontrol-pause)или [**Имедиаконтрол:: останавливаться**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), диспетчер графа фильтров вызывает соответствующий метод [**имедиафилтер**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) для всех фильтров.</span><span class="sxs-lookup"><span data-stu-id="b29cc-107">When an application calls [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause), or [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), the Filter Graph Manager calls the corresponding [**IMediaFilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) method on all of the filters.</span></span> <span data-ttu-id="b29cc-108">Переходы между остановленными и запущенными всегда проходят через приостановленное состояние, поэтому если приложение вызывает **Запуск** на остановленном графе, диспетчер графа фильтров приостанавливает граф перед его запуском.</span><span class="sxs-lookup"><span data-stu-id="b29cc-108">Transitions between stopped and running always go through the paused state, so if the application calls **Run** on a stopped graph, the Filter Graph Manager pauses the graph before running it.</span></span>

<span data-ttu-id="b29cc-109">Для большинства фильтров запущенные и приостановленные состояния идентичны.</span><span class="sxs-lookup"><span data-stu-id="b29cc-109">For most filters, the running and paused states are identical.</span></span> <span data-ttu-id="b29cc-110">Рассмотрим следующий граф фильтра:</span><span class="sxs-lookup"><span data-stu-id="b29cc-110">Consider the following filter graph:</span></span>

<span data-ttu-id="b29cc-111">Модуль подготовки > преобразования источника ></span><span class="sxs-lookup"><span data-stu-id="b29cc-111">Source > Transform > Renderer</span></span>

<span data-ttu-id="b29cc-112">Предположим, что фильтр источника не является источником динамической записи.</span><span class="sxs-lookup"><span data-stu-id="b29cc-112">Assume for now that the source filter is not a live capture source.</span></span> <span data-ttu-id="b29cc-113">Когда фильтр источника приостанавливается, он создает поток, который создает новые данные и записывает их в примеры носителей как можно быстрее.</span><span class="sxs-lookup"><span data-stu-id="b29cc-113">When the source filter pauses, it creates a thread that generates new data and writes it into media samples as quickly as possible.</span></span> <span data-ttu-id="b29cc-114">Поток "отправляет" образцы, вызывая [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) на входном закрепление фильтра преобразования.</span><span class="sxs-lookup"><span data-stu-id="b29cc-114">The thread "pushes" the samples downstream by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the transform filter's input pin.</span></span> <span data-ttu-id="b29cc-115">Фильтр преобразования получает образцы в потоке исходного фильтра.</span><span class="sxs-lookup"><span data-stu-id="b29cc-115">The transform filter receives the samples on the source filter's thread.</span></span> <span data-ttu-id="b29cc-116">Он может использовать рабочий поток для доставки образцов в модуль подготовки отчетов, но обычно он доставляет их в один и тот же поток.</span><span class="sxs-lookup"><span data-stu-id="b29cc-116">It may use a worker thread to deliver the samples to the renderer, but typically it delivers them on the same thread.</span></span> <span data-ttu-id="b29cc-117">Пока модуль подготовки отчетов приостановлен, он ждет получения примера.</span><span class="sxs-lookup"><span data-stu-id="b29cc-117">While the renderer is paused, it waits to receive a sample.</span></span> <span data-ttu-id="b29cc-118">После получения он блокирует и удерживает этот пример неограниченным образом.</span><span class="sxs-lookup"><span data-stu-id="b29cc-118">After it receives one, it blocks and holds that sample indefinitely.</span></span> <span data-ttu-id="b29cc-119">Если это модуль подготовки видео, он отображает пример в виде изображения афиши, при необходимости Перерисовывает изображение.</span><span class="sxs-lookup"><span data-stu-id="b29cc-119">If it is a video renderer, it displays the sample as a poster image, repainting the image as necessary.</span></span>

<span data-ttu-id="b29cc-120">На этом этапе поток полностью куед и готов к отрисовке.</span><span class="sxs-lookup"><span data-stu-id="b29cc-120">At this point, the stream is fully cued and ready for rendering.</span></span> <span data-ttu-id="b29cc-121">Если граф остается приостановленным, выборка будет [**выводиться**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) на диаграмме за первый пример, пока все фильтры не будут заблокированы в Receive или [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="b29cc-121">If the graph remains paused, samples will "pile up" in the graph behind the first sample, until every filter is blocked in [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="b29cc-122">Однако данные не теряются.</span><span class="sxs-lookup"><span data-stu-id="b29cc-122">No data is lost, though.</span></span> <span data-ttu-id="b29cc-123">После того как исходный поток разблокируется, он просто возобновляется с того места, где он был заблокирован.</span><span class="sxs-lookup"><span data-stu-id="b29cc-123">Once the source thread is unblocked, it simply resumes from the point where it blocked.</span></span>

<span data-ttu-id="b29cc-124">Фильтр источника и фильтр преобразования игнорируют переход от приостановленного к работающему — они просто продолжают обрабатывать данные как можно быстрее.</span><span class="sxs-lookup"><span data-stu-id="b29cc-124">The source filter and the transform filter ignore the transition from paused to running—they simply continue to process data as fast as possible.</span></span> <span data-ttu-id="b29cc-125">Но когда модуль подготовки отчетов запускается, он начинает отрисовку образцов.</span><span class="sxs-lookup"><span data-stu-id="b29cc-125">But when the renderer runs, it starts rendering samples.</span></span> <span data-ttu-id="b29cc-126">Сначала он выводит пример, удерживаемый в момент приостановки.</span><span class="sxs-lookup"><span data-stu-id="b29cc-126">First it renders the sample it held while it was paused.</span></span> <span data-ttu-id="b29cc-127">Затем каждый раз, когда он получает новый пример, он вычисляет время презентации в примере.</span><span class="sxs-lookup"><span data-stu-id="b29cc-127">Then, each time it receives a new sample, it calculates the sample's presentation time.</span></span> <span data-ttu-id="b29cc-128">(Дополнительные сведения см. [в разделе время и часы в DirectShow](time-and-clocks-in-directshow.md).) Модуль подготовки отчетов хранит каждый выбор до времени презентации, после чего он отображает пример.</span><span class="sxs-lookup"><span data-stu-id="b29cc-128">(For details, see [Time and Clocks in DirectShow](time-and-clocks-in-directshow.md).) The renderer holds each sample until the presentation time, at which point it renders the sample.</span></span> <span data-ttu-id="b29cc-129">Хотя он ждет времени презентации, он либо блокируется в методе [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) , либо получает новые примеры в рабочем потоке с очередью.</span><span class="sxs-lookup"><span data-stu-id="b29cc-129">While it waits for the presentation time, it either blocks in the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, or receives new samples on a worker thread with a queue.</span></span> <span data-ttu-id="b29cc-130">Фильтрация вышестоящего модуля модуля подготовки отчетов не участвует в планировании.</span><span class="sxs-lookup"><span data-stu-id="b29cc-130">Filters upstream from the renderer are not involved in scheduling.</span></span>

<span data-ttu-id="b29cc-131">Динамические источники, такие как устройства записи, являются исключением из этой общей архитектуры.</span><span class="sxs-lookup"><span data-stu-id="b29cc-131">Live sources, such as capture devices, are an exception to this general architecture.</span></span> <span data-ttu-id="b29cc-132">В реальном источнике нет необходимости заранее полагаться на какие-либо данные.</span><span class="sxs-lookup"><span data-stu-id="b29cc-132">With a live source, it is not appropriate to cue any data in advance.</span></span> <span data-ttu-id="b29cc-133">Приложение может приостановить граф, а затем подождать длительное время, прежде чем запускать его.</span><span class="sxs-lookup"><span data-stu-id="b29cc-133">The application might pause the graph and then wait for a long time before running it.</span></span> <span data-ttu-id="b29cc-134">Граф не должен визуализировать "устаревшие" образцы.</span><span class="sxs-lookup"><span data-stu-id="b29cc-134">The graph should not render "stale" samples.</span></span> <span data-ttu-id="b29cc-135">Таким образом, в реальном источнике нет выборок при приостановке, только во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="b29cc-135">Therefore, a live source produces no samples while paused, only while running.</span></span> <span data-ttu-id="b29cc-136">Чтобы сообщить об этом факте диспетчеру графа фильтров, метод [**имедиафилтер::**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) WebMethod исходного фильтра возвращает VFW \_ s не \_ удается \_ подсказку.</span><span class="sxs-lookup"><span data-stu-id="b29cc-136">To signal this fact to the Filter Graph Manager, the source filter's [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) method returns VFW\_S\_CANT\_CUE.</span></span> <span data-ttu-id="b29cc-137">Этот код возврата означает, что фильтр переключен на приостановленное состояние, даже если модуль подготовки отчетов не получал никаких данных.</span><span class="sxs-lookup"><span data-stu-id="b29cc-137">This return code indicates that the filter has switched to the paused state, even though the renderer did not receive any data.</span></span>

<span data-ttu-id="b29cc-138">Когда фильтр останавливается, он отклоняет любые другие выдаваемые ему образцы.</span><span class="sxs-lookup"><span data-stu-id="b29cc-138">When a filter stops, it rejects any more samples delivered to it.</span></span> <span data-ttu-id="b29cc-139">Фильтры источников завершают потоки потоковой передачи, а другие фильтры завершают работу рабочих потоков, которые они могли создать.</span><span class="sxs-lookup"><span data-stu-id="b29cc-139">Source filters shut down their streaming threads, and other filters shut down any worker threads they may have created.</span></span> <span data-ttu-id="b29cc-140">Фиксирует фиксации распределителя.</span><span class="sxs-lookup"><span data-stu-id="b29cc-140">Pins decommit their allocators.</span></span>

### <a name="state-transitions"></a><span data-ttu-id="b29cc-141">Переходы состояния</span><span class="sxs-lookup"><span data-stu-id="b29cc-141">State Transitions</span></span>

<span data-ttu-id="b29cc-142">Диспетчер графов фильтров выполняет все переходы состояний в восходящий порядок, начиная с модуля подготовки отчетов и перезапуская исходный фильтр.</span><span class="sxs-lookup"><span data-stu-id="b29cc-142">The Filter Graph Manager carries out all state transitions in upstream order, starting from the renderer and working backward to the source filter.</span></span> <span data-ttu-id="b29cc-143">Этот порядок необходимо для предотвращения удаления образцов и предотвращения взаимоблокировки графа.</span><span class="sxs-lookup"><span data-stu-id="b29cc-143">This ordering is necessary to prevent samples from being dropped and to prevent the graph from deadlocking.</span></span> <span data-ttu-id="b29cc-144">Самые критические переходы состояний находятся между приостановленными и остановленными.</span><span class="sxs-lookup"><span data-stu-id="b29cc-144">The most crucial state transitions are between paused and stopped:</span></span>

-   <span data-ttu-id="b29cc-145">Приостановлено для приостановки: по мере приостановки каждого фильтра он готов к получению примеров со следующего фильтра.</span><span class="sxs-lookup"><span data-stu-id="b29cc-145">Stopped to paused: As each filter pauses, it becomes ready to receive samples from the next filter.</span></span> <span data-ttu-id="b29cc-146">Фильтр источника является последним для приостановки.</span><span class="sxs-lookup"><span data-stu-id="b29cc-146">The source filter is the last to pause.</span></span> <span data-ttu-id="b29cc-147">Он создает поток потоковой передачи и начинает доставку образцов.</span><span class="sxs-lookup"><span data-stu-id="b29cc-147">It creates the streaming thread and begins delivering samples.</span></span> <span data-ttu-id="b29cc-148">Так как все нисходящие фильтры приостановлены, ни один из фильтров не отклоняет выборки.</span><span class="sxs-lookup"><span data-stu-id="b29cc-148">Because all of the downstream filters are paused, no filter rejects any samples.</span></span> <span data-ttu-id="b29cc-149">Диспетчер графов фильтров не завершает переход, пока каждый визуализатор в графе не получил выборку (за исключением динамических источников, как описано выше).</span><span class="sxs-lookup"><span data-stu-id="b29cc-149">The Filter Graph Manager does not complete the transition until every renderer in the graph has received a sample (with the exception of live sources, as described earlier).</span></span>
-   <span data-ttu-id="b29cc-150">Приостановлено на остановлено: при остановке фильтра он освобождает все содержащиеся в нем образцы, которые разблокируют все исходящие фильтры, [**ожидающие в процессе работы с потоком.**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer)</span><span class="sxs-lookup"><span data-stu-id="b29cc-150">Paused to stopped: When a filter stops, it releases any samples that it holds, which unblocks any upstream filters waiting in [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="b29cc-151">Если фильтр ожидает ресурс внутри метода [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) , он останавливает ожидание и возвращает результат **Receive**, который разблокирует вызывающий фильтр.</span><span class="sxs-lookup"><span data-stu-id="b29cc-151">If the filter is waiting for a resource inside the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, it stops waiting and returns from **Receive**, which unblocks the calling filter.</span></span> <span data-ttu-id="b29cc-152">Таким образом, когда диспетчер графа фильтров останавливает следующий вышестоящий фильтр, этот фильтр не блокируется в команде «GetNext **» или «** **получить**» и может реагировать на команду Stop.</span><span class="sxs-lookup"><span data-stu-id="b29cc-152">Therefore, when the Filter Graph Manager stops the next upstream filter, that filter is not blocked in either **GetBuffer** or **Receive**, and can respond to the stop command.</span></span> <span data-ttu-id="b29cc-153">Вышестоящий фильтр может доставлять несколько дополнительных выборок перед получением команды остановки, но подчиненный фильтр просто отклоняет их, так как он уже остановлен.</span><span class="sxs-lookup"><span data-stu-id="b29cc-153">The upstream filter might deliver a few extra samples before it gets the stop command, but the downstream filter simply rejects them, because it already stopped.</span></span>

## <a name="related-topics"></a><span data-ttu-id="b29cc-154">См. также</span><span class="sxs-lookup"><span data-stu-id="b29cc-154">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="b29cc-155">Поток данных в графе фильтра</span><span class="sxs-lookup"><span data-stu-id="b29cc-155">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



