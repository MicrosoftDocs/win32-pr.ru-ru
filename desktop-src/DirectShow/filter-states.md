---
description: Фильтрация состояний
ms.assetid: 97418307-eb50-4c8e-b03b-a2cd08139bdc
title: Фильтрация состояний
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 487b2f5e71cfebd8a9c7282679aa39b2264f0460dd72ad23e1b2b26926e0c979
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119015742"
---
# <a name="filter-states"></a>Фильтрация состояний

Фильтры имеют три возможных состояния: остановлено, приостановлено и запущено. Назначением приостановленного состояния является подсказка в графе, чтобы команда запуска немедленно отвечала на запросы. фильтр Graph Manager управляет всеми переходами состояния. когда приложение вызывает [**имедиаконтрол:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**имедиаконтрол::P аусе**](/windows/desktop/api/Control/nf-control-imediacontrol-pause)или [**имедиаконтрол:: останавливаться**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), фильтр Graph Manager вызывает соответствующий метод [**имедиафилтер**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) для всех фильтров. переходы между остановленными и запущенными всегда проходят через приостановленное состояние, поэтому если приложение вызывает **выполнение** на остановленном графе, фильтр Graph Manager приостанавливает граф перед его запуском.

Для большинства фильтров запущенные и приостановленные состояния идентичны. Рассмотрим следующий граф фильтра:

Модуль подготовки > преобразования источника >

Предположим, что фильтр источника не является источником динамической записи. Когда фильтр источника приостанавливается, он создает поток, который создает новые данные и записывает их в примеры носителей как можно быстрее. Поток "отправляет" образцы, вызывая [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) на входном закрепление фильтра преобразования. Фильтр преобразования получает образцы в потоке исходного фильтра. Он может использовать рабочий поток для доставки образцов в модуль подготовки отчетов, но обычно он доставляет их в один и тот же поток. Пока модуль подготовки отчетов приостановлен, он ждет получения примера. После получения он блокирует и удерживает этот пример неограниченным образом. Если это модуль подготовки видео, он отображает пример в виде изображения афиши, при необходимости Перерисовывает изображение.

На этом этапе поток полностью куед и готов к отрисовке. Если граф остается приостановленным, выборка будет [**выводиться**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) на диаграмме за первый пример, пока все фильтры не будут заблокированы в Receive или [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer). Однако данные не теряются. После того как исходный поток разблокируется, он просто возобновляется с того места, где он был заблокирован.

Фильтр источника и фильтр преобразования игнорируют переход от приостановленного к работающему — они просто продолжают обрабатывать данные как можно быстрее. Но когда модуль подготовки отчетов запускается, он начинает отрисовку образцов. Сначала он выводит пример, удерживаемый в момент приостановки. Затем каждый раз, когда он получает новый пример, он вычисляет время презентации в примере. (Дополнительные сведения см. [в разделе время и часы в DirectShow](time-and-clocks-in-directshow.md).) Модуль подготовки отчетов хранит каждый выбор до времени презентации, после чего он отображает пример. Хотя он ждет времени презентации, он либо блокируется в методе [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) , либо получает новые примеры в рабочем потоке с очередью. Фильтрация вышестоящего модуля модуля подготовки отчетов не участвует в планировании.

Динамические источники, такие как устройства записи, являются исключением из этой общей архитектуры. В реальном источнике нет необходимости заранее полагаться на какие-либо данные. Приложение может приостановить граф, а затем подождать длительное время, прежде чем запускать его. Граф не должен визуализировать "устаревшие" образцы. Таким образом, в реальном источнике нет выборок при приостановке, только во время выполнения. чтобы сообщить об этом факте в фильтр Graph Manager, метод [**имедиафилтер::**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) webmethod исходного фильтра возвращает команду VFW \_ s не \_ удается \_ подсказку. Этот код возврата означает, что фильтр переключен на приостановленное состояние, даже если модуль подготовки отчетов не получал никаких данных.

Когда фильтр останавливается, он отклоняет любые другие выдаваемые ему образцы. Фильтры источников завершают потоки потоковой передачи, а другие фильтры завершают работу рабочих потоков, которые они могли создать. Фиксирует фиксации распределителя.

### <a name="state-transitions"></a>Переходы состояния

фильтр Graph Manager выполняет все переходы состояний в вышестоящем порядке, начиная от модуля подготовки отчетов и перезапуская исходный фильтр. Этот порядок необходимо для предотвращения удаления образцов и предотвращения взаимоблокировки графа. Самые критические переходы состояний находятся между приостановленными и остановленными.

-   Приостановлено для приостановки: по мере приостановки каждого фильтра он готов к получению примеров со следующего фильтра. Фильтр источника является последним для приостановки. Он создает поток потоковой передачи и начинает доставку образцов. Так как все нисходящие фильтры приостановлены, ни один из фильтров не отклоняет выборки. фильтр Graph Manager не завершает переход, пока каждый визуализатор в графе не получит пример (за исключением динамических источников, как описано выше).
-   Приостановлено на остановлено: при остановке фильтра он освобождает все содержащиеся в нем образцы, которые разблокируют все исходящие фильтры, [**ожидающие в процессе работы с потоком.**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) Если фильтр ожидает ресурс внутри метода [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) , он останавливает ожидание и возвращает результат **Receive**, который разблокирует вызывающий фильтр. таким образом, когда диспетчер Graph Manager останавливает следующий вышестоящий фильтр, этот фильтр не блокируется в @ **buffer** или **Receive** и может реагировать на команду stop. Вышестоящий фильтр может доставлять несколько дополнительных выборок перед получением команды остановки, но подчиненный фильтр просто отклоняет их, так как он уже остановлен.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Flow данных в фильтре Graph](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



