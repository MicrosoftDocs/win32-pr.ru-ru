---
description: Куерякцепт (нисходящий)
ms.assetid: 3ca30f62-c320-40ea-9bf5-022abad912c4
title: Куерякцепт (нисходящий)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9015e0a246abb9fb996c0771e4bc935cccda054d
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104553205"
---
# <a name="queryaccept-downstream"></a><span data-ttu-id="73eac-103">Куерякцепт (нисходящий)</span><span class="sxs-lookup"><span data-stu-id="73eac-103">QueryAccept (Downstream)</span></span>

<span data-ttu-id="73eac-104">Этот механизм позволяет выходному закреплениям предлагать новый формат его нижестоящим одноранговым узлам.</span><span class="sxs-lookup"><span data-stu-id="73eac-104">This mechanism enables an output pin to propose a new format to its downstream peer.</span></span> <span data-ttu-id="73eac-105">Новый формат не должен требовать большего размера буфера.</span><span class="sxs-lookup"><span data-stu-id="73eac-105">The new format must not require a larger buffer size.</span></span> <span data-ttu-id="73eac-106">Закрепление вывода выполняет следующие действия:</span><span class="sxs-lookup"><span data-stu-id="73eac-106">The output pin does the following:</span></span>

1.  <span data-ttu-id="73eac-107">Вызывает [**Ипин:: куерякцепт**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) или [**Ипинконнектион::D инамиккуерякцепт**](/windows/desktop/api/Strmif/nf-strmif-ipinconnection-dynamicqueryaccept) на нижестоящий ПИН-коде, чтобы проверить, может ли другой ПИН-код принимать новый тип носителя (см. иллюстрацию, шаг а).</span><span class="sxs-lookup"><span data-stu-id="73eac-107">Calls [**IPin::QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) or [**IPinConnection::DynamicQueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipinconnection-dynamicqueryaccept) on the downstream pin, to verify whether the other pin can accept the new media type (see illustration, step A).</span></span>
2.  <span data-ttu-id="73eac-108">Если возвращенное значение из шага 1 равно S \_ , ПИН-код прикрепляет тип мультимедиа к следующему примеру.</span><span class="sxs-lookup"><span data-stu-id="73eac-108">If the return value from step 1 is S\_OK, the pin attaches the media type to the next sample.</span></span> <span data-ttu-id="73eac-109">Для этого сначала вызывается [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) для получения образца (B).</span><span class="sxs-lookup"><span data-stu-id="73eac-109">To do this, first it calls [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) to obtain the sample (B).</span></span> <span data-ttu-id="73eac-110">Затем вызывается [**имедиасампле:: сетмедиатипе**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) , чтобы присоединить тип мультимедиа к этому примеру (C).</span><span class="sxs-lookup"><span data-stu-id="73eac-110">Then it calls [**IMediaSample::SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) to attach the media type to that sample (C).</span></span> <span data-ttu-id="73eac-111">Присоединив к образцу тип мультимедиа, фильтр указывает, что формат изменился, начиная с этого примера.</span><span class="sxs-lookup"><span data-stu-id="73eac-111">By attaching the media type to the sample, the filter indicates that the format has changed, starting with that sample.</span></span>
3.  <span data-ttu-id="73eac-112">ПИН-код доставляет пример (D).</span><span class="sxs-lookup"><span data-stu-id="73eac-112">The pin delivers the sample (D).</span></span>
4.  <span data-ttu-id="73eac-113">Когда нисходящий фильтр получает образец, он вызывает [**имедиасампле:: жетмедиатипе**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getmediatype) для получения нового типа мультимедиа.</span><span class="sxs-lookup"><span data-stu-id="73eac-113">When the downstream filter receives the sample, it calls [**IMediaSample::GetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getmediatype) to retrieve the new media type.</span></span>

    ![куерякцепт (нисходящий)](images/dynformat3.png)

<span data-ttu-id="73eac-115">Все ПИН-коды поддерживают `QueryAccept` метод.</span><span class="sxs-lookup"><span data-stu-id="73eac-115">All pins support the `QueryAccept` method.</span></span> <span data-ttu-id="73eac-116">Однако этот метод немного неоднозначен, поскольку возвращаемое значение S \_ ОК не всегда гарантирует, что вы можете изменить формат, пока граф активен.</span><span class="sxs-lookup"><span data-stu-id="73eac-116">However, this method is slightly ambiguous, because a return value of S\_OK does not always guarantee that you can change the format while the graph is active.</span></span> <span data-ttu-id="73eac-117">Некоторые фильтры могут вернуть \_ значение S ОК, но отклонить изменение, если граф активен.</span><span class="sxs-lookup"><span data-stu-id="73eac-117">Some filters might return S\_OK but reject the change if the graph is active.</span></span> <span data-ttu-id="73eac-118">Метод **динамиккуерякцепт** , поддерживаемый некоторыми входными ПИН-кодом, явно определяет S \_ как, что означает, что ПИН может изменять форматы в активном состоянии.</span><span class="sxs-lookup"><span data-stu-id="73eac-118">The **DynamicQueryAccept** method, which is supported by some input pins, explicitly defines S\_OK to mean the pin can change formats while active.</span></span> <span data-ttu-id="73eac-119">Если входной ПИН-код поддерживает интерфейс **ипинконнектион** , следует вызвать **динамиккуерякцепт** , а не `QueryAccept` .</span><span class="sxs-lookup"><span data-stu-id="73eac-119">If an input pin supports the **IPinConnection** interface, you should call **DynamicQueryAccept** rather than `QueryAccept`.</span></span>

<span data-ttu-id="73eac-120">В большинстве случаев этот механизм не допускает радикальных изменений в формате, например при изменении глубины битов.</span><span class="sxs-lookup"><span data-stu-id="73eac-120">In most cases, this mechanism does not allow for drastic changes to the format, such as changing the bit depth.</span></span> <span data-ttu-id="73eac-121">Ситуация, когда ее можно использовать, заключается в том, что видеодекодер переключает палитры.</span><span class="sxs-lookup"><span data-stu-id="73eac-121">One situation in which it can be used is when a video decoder switches palettes.</span></span> <span data-ttu-id="73eac-122">Основные сведения о формате остаются неизменными, такие как размеры изображения и битовая глубина, но новый тип мультимедиа имеет другой набор записей палитры.</span><span class="sxs-lookup"><span data-stu-id="73eac-122">The basic details of the format stay the same, such as the image dimensions and the bit depth, but the new media type has a different set of palette entries.</span></span>

<span data-ttu-id="73eac-123">**Примечание о реализации**</span><span class="sxs-lookup"><span data-stu-id="73eac-123">**Implementation Note**</span></span>

<span data-ttu-id="73eac-124">В базовых классах DirectShow [**кбасепин:: куерякцепт**](cbasepin-queryaccept.md) вызывает метод **чеккмедиатипе** , который также вызывается во время первоначального подключения ПИН-кода.</span><span class="sxs-lookup"><span data-stu-id="73eac-124">In the DirectShow base classes, [**CBasePin::QueryAccept**](cbasepin-queryaccept.md) calls the **CheckMediaType** method, which is also called during the initial pin connection.</span></span> <span data-ttu-id="73eac-125">В случае фильтра преобразования метод **чеккмедиатипе** входного контакта всегда должен проверять, подключен ли выходной ПИН-код, и если да, то является ли тип входного носителя совместимым с выходным типом носителя.</span><span class="sxs-lookup"><span data-stu-id="73eac-125">In the case of a transform filter, the input pin's **CheckMediaType** method should always check whether the output pin is connected, and if so, whether the input media type is compatible with the output media type.</span></span> <span data-ttu-id="73eac-126">Поэтому эта реализация, скорее всего, будет действительна для `QueryAccept` .</span><span class="sxs-lookup"><span data-stu-id="73eac-126">Therefore, this implementation will likely be valid for `QueryAccept`.</span></span> <span data-ttu-id="73eac-127">В противном случае необходимо переопределить, `QueryAccept` чтобы выполнить дополнительные проверки, которые необходимы.</span><span class="sxs-lookup"><span data-stu-id="73eac-127">If not, you should override `QueryAccept` in order to perform any additional checks that are needed.</span></span> <span data-ttu-id="73eac-128">Кроме того, обратите внимание, что класс [**ктрансформфилтер**](ctransformfilter.md) инкапсулирует эту логику в методы **чеккинпуттипе** и **чекктрансформ** .</span><span class="sxs-lookup"><span data-stu-id="73eac-128">Also, note that the [**CTransformFilter**](ctransformfilter.md) class encapsulates this logic within the **CheckInputType** and **CheckTransform** methods.</span></span> <span data-ttu-id="73eac-129">Класс [**ктрансинплацефилтер**](ctransinplacefilter.md) , с другой стороны, всегда вызывает `QueryAccept` следующий вышестоящий или нисходящий фильтр.</span><span class="sxs-lookup"><span data-stu-id="73eac-129">The [**CTransInPlaceFilter**](ctransinplacefilter.md) class, on the other hand, always calls `QueryAccept` on the next upstream or downstream filter.</span></span>

<span data-ttu-id="73eac-130">Метод [**кбасеинпутпин:: Receive**](cbaseinputpin-receive.md) проверяет тип носителя во входящем примере, и, если таковой имеется, вызывает **чеккмедиатипе**.</span><span class="sxs-lookup"><span data-stu-id="73eac-130">The [**CBaseInputPin::Receive**](cbaseinputpin-receive.md) method checks for a media type on the incoming sample, and if there is one, calls **CheckMediaType**.</span></span> <span data-ttu-id="73eac-131">Однако он не обновляет элемент **m \_** , закрепление которого содержит текущий тип носителя.</span><span class="sxs-lookup"><span data-stu-id="73eac-131">However, it does not update the pin's **m\_mt** member, which holds the current media type.</span></span> <span data-ttu-id="73eac-132">Когда фильтр обрабатывает пример, следует проверить пример для типа мультимедиа.</span><span class="sxs-lookup"><span data-stu-id="73eac-132">When your filter processes the sample, you should check the sample for a media type.</span></span> <span data-ttu-id="73eac-133">Если имеется новый тип, возможно, потребуется сохранить его, вызвав **сетмедиатипе** на вашем ПИН-коде или задав значение **m \_ MT** напрямую.</span><span class="sxs-lookup"><span data-stu-id="73eac-133">If there is a new type, you will probably need to store it, either by calling **SetMediaType** on your pin or by setting the value of **m\_mt** directly.</span></span> <span data-ttu-id="73eac-134">С другой стороны, класс [**квидеотрансформфилтер**](cvideotransformfilter.md) , предназначенный для фильтров преобразования видео, сохраняет тип мультимедиа при его изменении.</span><span class="sxs-lookup"><span data-stu-id="73eac-134">On the other hand, the [**CVideoTransformFilter**](cvideotransformfilter.md) class, which is designed for video transform filters, stores the media type when it changes.</span></span> <span data-ttu-id="73eac-135">Дополнительные сведения см. в исходном коде для [**квидеотрансформфилтер:: Receive**](cvideotransformfilter-receive.md) в библиотеке базовых классов DirectShow.</span><span class="sxs-lookup"><span data-stu-id="73eac-135">For details, see the source code for [**CVideoTransformFilter::Receive**](cvideotransformfilter-receive.md) in the DirectShow base class library.</span></span>

<span data-ttu-id="73eac-136">В некоторых случаях можно просто передать `QueryAccept` вызов, а затем присоединить тип мультимедиа к образцу вывода и позволить нисходящим фильтрам изменять формат.</span><span class="sxs-lookup"><span data-stu-id="73eac-136">In some cases, you might simply pass the `QueryAccept` call downstream, then attach the media type to the output sample and let the downstream filter handle the format change.</span></span>

 

 



