---
description: Примеры и Распределительы
ms.assetid: 1fbea741-f29a-4815-9885-94ca9cf4bb95
title: Примеры и Распределительы
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6f9132ff2c70b5ade63f8853b5c03bacb7a25371
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104562939"
---
# <a name="samples-and-allocators"></a><span data-ttu-id="88b18-103">Примеры и Распределительы</span><span class="sxs-lookup"><span data-stu-id="88b18-103">Samples and Allocators</span></span>

<span data-ttu-id="88b18-104">Когда ПИН-код предоставляет данные мультимедиа другому ПИН-коду, он не передает прямой указатель на буфер памяти.</span><span class="sxs-lookup"><span data-stu-id="88b18-104">When a pin delivers media data to another pin, it does not pass a direct pointer to the memory buffer.</span></span> <span data-ttu-id="88b18-105">Вместо этого он доставляет указатель на COM-объект, управляющий памятью.</span><span class="sxs-lookup"><span data-stu-id="88b18-105">Instead, it delivers a pointer to a COM object that manages the memory.</span></span> <span data-ttu-id="88b18-106">Этот объект, называемый *примером носителя*, предоставляет интерфейс [**имедиасампле**](/windows/desktop/api/Strmif/nn-strmif-imediasample) .</span><span class="sxs-lookup"><span data-stu-id="88b18-106">This object, called a *media sample*, exposes the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="88b18-107">Полученный ПИН-код обращается к буферу памяти путем вызова методов **имедиасампле** , таких как [**имедиасампле::**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**Имедиасампле:: resize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize)и [**имедиасампле:: жетактуалдаталенгс**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span><span class="sxs-lookup"><span data-stu-id="88b18-107">The receiving pin accesses the memory buffer by calling **IMediaSample** methods, such as [**IMediaSample::GetPointer**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**IMediaSample::GetSize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize), and [**IMediaSample::GetActualDataLength**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span></span>

<span data-ttu-id="88b18-108">Примеры всегда перемещаются вверх, от выходного контакта до входного ПИН-кода.</span><span class="sxs-lookup"><span data-stu-id="88b18-108">Samples always travel downstream, from output pin to input pin.</span></span> <span data-ttu-id="88b18-109">В модели push-уведомлений выходным закреплением доставляется образец путем вызова [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) во входной ПИН-коде.</span><span class="sxs-lookup"><span data-stu-id="88b18-109">In the push model, the output pin delivers a sample by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the input pin.</span></span> <span data-ttu-id="88b18-110">Входной ПИН-код будет либо обрабатывать данные синхронно (то есть полностью внутри метода **Receive** ), либо асинхронно обрабатываться в рабочем потоке.</span><span class="sxs-lookup"><span data-stu-id="88b18-110">The input pin will either process the data synchronously (that is, completely inside the **Receive** method), or process it asynchronously on a worker thread.</span></span> <span data-ttu-id="88b18-111">Входной ПИН-код может блокироваться в методе **Receive** , если он должен ждать ресурсов.</span><span class="sxs-lookup"><span data-stu-id="88b18-111">The input pin is allowed to block within the **Receive** method, if it needs to wait for resources.</span></span>

<span data-ttu-id="88b18-112">Другой COM-объект, называемый *распределителем*, отвечает за создание образцов носителей и управление ими.</span><span class="sxs-lookup"><span data-stu-id="88b18-112">Another COM object, called an *allocator*, is responsible for creating and managing media samples.</span></span> <span data-ttu-id="88b18-113">Распределительы предоставляют интерфейс [**имемаллокатор**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) .</span><span class="sxs-lookup"><span data-stu-id="88b18-113">Allocators expose the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="88b18-114">Каждый раз, когда для фильтра требуется пример носителя с пустым буфером, он вызывает метод [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , который возвращает указатель на образец.</span><span class="sxs-lookup"><span data-stu-id="88b18-114">Whenever a filter needs a media sample with an empty buffer, it calls the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, which returns a pointer to the sample.</span></span> <span data-ttu-id="88b18-115">Каждое подключение к закреплениям использует один распределитель.</span><span class="sxs-lookup"><span data-stu-id="88b18-115">Every pin connection shares one allocator.</span></span> <span data-ttu-id="88b18-116">Когда два контакта соединяются, они решают, какой фильтр будет предоставлять распределитель.</span><span class="sxs-lookup"><span data-stu-id="88b18-116">When two pins connect, they decide which filter will provide the allocator.</span></span> <span data-ttu-id="88b18-117">ПИН-коды также задают свойства распределителя, например количество буферов и размер каждого буфера.</span><span class="sxs-lookup"><span data-stu-id="88b18-117">The pins also set properties on the allocator, such as the number of buffers and the size of each buffer.</span></span> <span data-ttu-id="88b18-118">(Дополнительные сведения см. в разделе [Фильтрация подключения](how-filters-connect.md) и [согласования распределителя](negotiating-allocators.md).)</span><span class="sxs-lookup"><span data-stu-id="88b18-118">(For details, see [How Filters Connect](how-filters-connect.md) and [Negotiating Allocators](negotiating-allocators.md).)</span></span>

<span data-ttu-id="88b18-119">На следующем рисунке показаны связи между распределителем, примерами мультимедиа и фильтром.</span><span class="sxs-lookup"><span data-stu-id="88b18-119">The following illustration shows the relationships among the allocator, the media samples, and the filter.</span></span>

![примеры и распределительы носителей](images/mediasamples.png)

<span data-ttu-id="88b18-121">**Счетчик ссылок образца носителя**</span><span class="sxs-lookup"><span data-stu-id="88b18-121">**Media Sample Reference Counts**</span></span>

<span data-ttu-id="88b18-122">Распределитель создает конечный пул образцов.</span><span class="sxs-lookup"><span data-stu-id="88b18-122">An allocator creates a finite pool of samples.</span></span> <span data-ttu-id="88b18-123">Некоторые примеры могут быть использованы в любой момент, а другие — **с вызовами** at.</span><span class="sxs-lookup"><span data-stu-id="88b18-123">At any time, some samples may be in use, while others are available for **GetBuffer** calls.</span></span> <span data-ttu-id="88b18-124">Распределитель использует подсчет ссылок для наблюдения за примерами.</span><span class="sxs-lookup"><span data-stu-id="88b18-124">The allocator uses reference counting to keep track of the samples.</span></span> <span data-ttu-id="88b18-125">Метод **метода** IsReference возвращает образец со значением счетчика ссылок, равным 1.</span><span class="sxs-lookup"><span data-stu-id="88b18-125">The **GetBuffer** method returns a sample with a reference count of 1.</span></span> <span data-ttu-id="88b18-126">Если число ссылок становится равным нулю, пример возвращается в пул распределителя, где его можно использовать **в следующем** вызове функции GetNext.</span><span class="sxs-lookup"><span data-stu-id="88b18-126">If the reference count goes to zero, the sample goes back into the allocator's pool, where it can be used in the next **GetBuffer** call.</span></span> <span data-ttu-id="88b18-127">Пока значение счетчика ссылок остается больше нуля, выборка недоступна для- **buffer**.</span><span class="sxs-lookup"><span data-stu-id="88b18-127">As long as the reference count remains above zero, the sample is not available to **GetBuffer**.</span></span> <span data-ttu-id="88b18-128">Если используется любой пример, принадлежащий распределительу, метод метода WebMethod блокируется до тех **пор, пока** образец не станет доступным.</span><span class="sxs-lookup"><span data-stu-id="88b18-128">If every sample belonging to the allocator is in use, the **GetBuffer** method blocks until a sample becomes available.</span></span>

<span data-ttu-id="88b18-129">Например, предположим, что входной ПИН-код получает пример.</span><span class="sxs-lookup"><span data-stu-id="88b18-129">For example, suppose that an input pin receives a sample.</span></span> <span data-ttu-id="88b18-130">Если он обрабатывает пример синхронно, внутри метода **Receive** он не увеличивает число ссылок.</span><span class="sxs-lookup"><span data-stu-id="88b18-130">If it processes the sample synchronously, inside the **Receive** method, it does not increment the reference count.</span></span> <span data-ttu-id="88b18-131">После **получения** возврата выходной ПИН-код освобождает пример, счетчик ссылок переходит к нулю, а пример возвращается в пул распределителя.</span><span class="sxs-lookup"><span data-stu-id="88b18-131">After **Receive** returns, the output pin releases the sample, the reference count goes to zero, and the sample returns to the allocator's pool.</span></span> <span data-ttu-id="88b18-132">С другой стороны, если входной ПИН-код обрабатывает пример в рабочем потоке, он увеличивает счетчик ссылок до выхода из метода **Receive** .</span><span class="sxs-lookup"><span data-stu-id="88b18-132">On the other hand, if the input pin processes the sample on a worker thread, it increments the reference count before leaving the **Receive** method.</span></span> <span data-ttu-id="88b18-133">Число ссылок теперь равно 2.</span><span class="sxs-lookup"><span data-stu-id="88b18-133">The reference count is now 2.</span></span> <span data-ttu-id="88b18-134">Когда закрепление выходных данных освобождает пример, счетчик переходит к 1; образец еще не возвращается в пул.</span><span class="sxs-lookup"><span data-stu-id="88b18-134">When the output pin releases the sample, the count goes to 1; the sample does not yet return to the pool.</span></span> <span data-ttu-id="88b18-135">После того как рабочий поток будет выполнен в примере, он вызывает **выпуск** , чтобы освободить пример.</span><span class="sxs-lookup"><span data-stu-id="88b18-135">After the worker thread is done with the sample, it calls **Release** to free the sample.</span></span> <span data-ttu-id="88b18-136">Теперь пример возвращает в пул.</span><span class="sxs-lookup"><span data-stu-id="88b18-136">Now the sample returns to the pool.</span></span>

<span data-ttu-id="88b18-137">Когда ПИН-код получает пример, он может скопировать данные в другой образец или изменить исходный образец и доставить его на следующий фильтр.</span><span class="sxs-lookup"><span data-stu-id="88b18-137">When a pin receives a sample, it can copy the data to another sample, or it can modify the original sample and deliver that one to the next filter.</span></span> <span data-ttu-id="88b18-138">Потенциально пример может передавать всю длину графа, каждый из которых вызывает **AddRef** и **Release** в свою очередь.</span><span class="sxs-lookup"><span data-stu-id="88b18-138">Potentially, a sample can travel the entire length of the graph, each filter calling **AddRef** and **Release** in turn.</span></span> <span data-ttu-id="88b18-139">Таким образом, ПИН-код не должен повторно использовать выборку после вызова метода **Receive**, так как этот пример может использовать нисходящий фильтр.</span><span class="sxs-lookup"><span data-stu-id="88b18-139">Therefore, the output pin must never re-use a sample after it calls **Receive**, because a downstream filter may be using the sample.</span></span> <span data-ttu-id="88b18-140">Для получения нового образца выходной ПИН-код должен всегда вызывать метод " **buffer** ".</span><span class="sxs-lookup"><span data-stu-id="88b18-140">The output pin must always call **GetBuffer** to get a new sample.</span></span>

<span data-ttu-id="88b18-141">Этот механизм уменьшает объем выделения памяти, поскольку фильтры повторно используют одни и те же буферы.</span><span class="sxs-lookup"><span data-stu-id="88b18-141">This mechanism reduces the amount of memory allocation, because filters re-use the same buffers.</span></span> <span data-ttu-id="88b18-142">Это также предотвращает случайную запись фильтров по данным, которые не были обработаны, так как распределитель поддерживает список доступных образцов.</span><span class="sxs-lookup"><span data-stu-id="88b18-142">It also prevents filters from accidentally writing over data that has not been processed, because the allocator maintains a list of available samples.</span></span>

<span data-ttu-id="88b18-143">Фильтр может использовать отдельные распределителя для ввода и вывода.</span><span class="sxs-lookup"><span data-stu-id="88b18-143">A filter can use separate allocators for input and output.</span></span> <span data-ttu-id="88b18-144">Это можно сделать, если распаковать входные данные (например, путем распаковки).</span><span class="sxs-lookup"><span data-stu-id="88b18-144">It might do this if it expands the input data (for example, by decompressing it).</span></span> <span data-ttu-id="88b18-145">Если выходные данные больше, чем входные данные, фильтр может обработать данные на месте, не копируя их в новый пример.</span><span class="sxs-lookup"><span data-stu-id="88b18-145">If the output is no larger than the input, a filter might process the data in place, without copying it to a new sample.</span></span> <span data-ttu-id="88b18-146">В этом случае два или более подключения ПИН-кода могут совместно использовать один распределитель.</span><span class="sxs-lookup"><span data-stu-id="88b18-146">In that case, two or more pin connections can share one allocator.</span></span>

<span data-ttu-id="88b18-147">**Фиксация и дефиксация распределителя**</span><span class="sxs-lookup"><span data-stu-id="88b18-147">**Committing and Decommitting Allocators**</span></span>

<span data-ttu-id="88b18-148">Когда фильтр сначала создает распределитель, распределитель не зарезервирует буферы памяти.</span><span class="sxs-lookup"><span data-stu-id="88b18-148">When a filter first creates an allocator, the allocator has not reserved any memory buffers.</span></span> <span data-ttu-id="88b18-149">На этом этапе все вызовы метода «методу **buffer** » завершатся ошибкой.</span><span class="sxs-lookup"><span data-stu-id="88b18-149">At this point, any calls to the **GetBuffer** method will fail.</span></span> <span data-ttu-id="88b18-150">При запуске потоковой передачи выходной ПИН-код вызывает [**имемаллокатор:: Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), который фиксирует распределитель, что приводит к выделению памяти.</span><span class="sxs-lookup"><span data-stu-id="88b18-150">When streaming starts, the output pin calls [**IMemAllocator::Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), which commits the allocator, causing it to allocate memory.</span></span> <span data-ttu-id="88b18-151">Теперь ПИН-коды могут вызывать метод " **buffer**".</span><span class="sxs-lookup"><span data-stu-id="88b18-151">Pins can now call **GetBuffer**.</span></span>

<span data-ttu-id="88b18-152">При остановке потоковой передачи ПИН-код вызывает [**имемаллокатор::D екоммит**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), который отменяет распределитель.</span><span class="sxs-lookup"><span data-stu-id="88b18-152">When streaming stops, the pin calls [**IMemAllocator::Decommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), which decommits the allocator.</span></span> <span data-ttu-id="88b18-153">Все последующие вызовы метода **buffer** завершаются сбоем до тех пор, пока распределитель не будет зафиксирован снова.</span><span class="sxs-lookup"><span data-stu-id="88b18-153">All subsequent calls to **GetBuffer** fail until the allocator is committed again.</span></span> <span data-ttu-id="88b18-154">Кроме того, если какие-либо вызовы метода **buffer** в данный момент заблокированы в ожидании образца, они немедленно возвращают код ошибки.</span><span class="sxs-lookup"><span data-stu-id="88b18-154">Also, if any calls to **GetBuffer** are currently blocked waiting for a sample, they immediately return a failure code.</span></span> <span data-ttu-id="88b18-155">Метод **uncommit** может освободить память в зависимости от реализации.</span><span class="sxs-lookup"><span data-stu-id="88b18-155">The **Decommit** method may or may not free the memory, depending on the implementation.</span></span> <span data-ttu-id="88b18-156">Например, класс [**кмемаллокатор**](cmemallocator.md) ожидает, пока метод деструктора не освободит память.</span><span class="sxs-lookup"><span data-stu-id="88b18-156">For example, the [**CMemAllocator**](cmemallocator.md) class waits until its destructor method to free memory.</span></span>

## <a name="related-topics"></a><span data-ttu-id="88b18-157">См. также</span><span class="sxs-lookup"><span data-stu-id="88b18-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="88b18-158">Поток данных в графе фильтра</span><span class="sxs-lookup"><span data-stu-id="88b18-158">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 
