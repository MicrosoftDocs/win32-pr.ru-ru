---
description: В этом разделе описывается написание пользовательского фильтра источника для DirectShow.
ms.assetid: 032f7624-2237-41cd-844a-18ed4a2e420d
title: Написание фильтра источника для DirectShow
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 87af99595a43c86be0e2f4ecaa51768a211e9674
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104538042"
---
# <a name="how-to-write-a-source-filter-for-directshow"></a><span data-ttu-id="cc482-103">Написание фильтра источника для DirectShow</span><span class="sxs-lookup"><span data-stu-id="cc482-103">How to Write a Source Filter for DirectShow</span></span>

<span data-ttu-id="cc482-104">В этом разделе описывается написание пользовательского фильтра источника для DirectShow.</span><span class="sxs-lookup"><span data-stu-id="cc482-104">This topic describes how to write a custom source filter for DirectShow.</span></span>

> [!Note]  
> <span data-ttu-id="cc482-105">В этом разделе описываются только источники push-уведомлений. Он не описывает источники извлечения, такие как фильтр асинхронного чтения, или фильтры разделителя, которые подключаются к источникам извлечения.</span><span class="sxs-lookup"><span data-stu-id="cc482-105">This topic describes push sources only; it does not describe pull sources, such as the Async Reader Filter, or splitter filters that connect to pull sources.</span></span> <span data-ttu-id="cc482-106">Различие между источником *push-уведомлений* и источниками *извлечения* см. в разделе [поток данных для разработчиков фильтров](data-flow-for-filter-developers.md).</span><span class="sxs-lookup"><span data-stu-id="cc482-106">For the distinction between *push* and *pull* sources, see [Data Flow for Filter Developers](data-flow-for-filter-developers.md).</span></span>

 

## <a name="the-directshow-streaming-model"></a><span data-ttu-id="cc482-107">Модель потоковой передачи DirectShow</span><span class="sxs-lookup"><span data-stu-id="cc482-107">The DirectShow Streaming Model</span></span>

<span data-ttu-id="cc482-108">При написании исходного фильтра важно понимать, что источник push-уведомлений отличается от источника в реальном времени.</span><span class="sxs-lookup"><span data-stu-id="cc482-108">When you write a source filter, it is important to understand that a push source is not the same thing as a live source.</span></span> <span data-ttu-id="cc482-109">Активный источник получает данные из какого-либо внешнего источника, например камеры или сетевого потока.</span><span class="sxs-lookup"><span data-stu-id="cc482-109">A live source gets data from some external source, such as a camera or a network stream.</span></span> <span data-ttu-id="cc482-110">Как правило, активный источник не может управлять входящей скоростью данных.</span><span class="sxs-lookup"><span data-stu-id="cc482-110">Generally, a live source cannot control the incoming rate of data.</span></span> <span data-ttu-id="cc482-111">Если нисходящие фильтры не потребляют данные достаточно быстро, источнику потребуется удалить образцы.</span><span class="sxs-lookup"><span data-stu-id="cc482-111">If the downstream filters do not consume the data fast enough, the source will need to drop samples.</span></span>

<span data-ttu-id="cc482-112">Но источник push-уведомлений не обязательно должен быть активным источником.</span><span class="sxs-lookup"><span data-stu-id="cc482-112">But a push source does not have to be a live source.</span></span> <span data-ttu-id="cc482-113">Например, источник отправки может считывать данные из локального файла.</span><span class="sxs-lookup"><span data-stu-id="cc482-113">For example, a push source can read data from a local file.</span></span> <span data-ttu-id="cc482-114">В этом случае подчиненные фильтры визуализации определяют, насколько быстро они потребляют данные из источника, основываясь на эталонном времени и образцах меток времени.</span><span class="sxs-lookup"><span data-stu-id="cc482-114">In that case, the downstream renderer filters determine how fast they consume the data from the source, based on the reference clock and the sample time stamps.</span></span> <span data-ttu-id="cc482-115">Фильтр источника доставляет образцы как можно быстрее, но фактический поток данных ограничен модулями подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="cc482-115">The source filter delivers samples as quickly as possible, but the actual data flow is gated limited by the renderers.</span></span> <span data-ttu-id="cc482-116">Механизмы ограничения потока данных описаны в статье [поток данных для разработчиков фильтров](data-flow-for-filter-developers.md).</span><span class="sxs-lookup"><span data-stu-id="cc482-116">The mechanisms for gating the data flow are described in [Data Flow for Filter Developers](data-flow-for-filter-developers.md).</span></span>

<span data-ttu-id="cc482-117">Каждый выходной закрепление в фильтре источника создает поток, называемый *потоком потоковой передачи*.</span><span class="sxs-lookup"><span data-stu-id="cc482-117">Each output pin on the source filter creates a thread called a *streaming thread*.</span></span> <span data-ttu-id="cc482-118">ПИН-код предоставляет примеры в потоке потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="cc482-118">The pin delivers samples on the streaming thread.</span></span> <span data-ttu-id="cc482-119">Как правило, все декодирование, обработка и подготовка к просмотру выполняются в этом потоке, хотя некоторые нисходящие фильтры могут создавать дополнительные потоки для постановки их выходных образцов.</span><span class="sxs-lookup"><span data-stu-id="cc482-119">Typically, all of the decoding, processing, and rendering happens on this thread, although some downstream filters might create additional threads to queue their output samples.</span></span>

<span data-ttu-id="cc482-120">Поток потоковой передачи выполняет цикл со следующей структурой:</span><span class="sxs-lookup"><span data-stu-id="cc482-120">The streaming thread runs a loop with the following structure:</span></span>

``` syntax
until (stopped)
  1. Get a media sample from the allocator.
  2. Fill the sample with data.
  3. Time stamp the sample. 
  4. Deliver the sample downstream.
```

<span data-ttu-id="cc482-121">Если образцы недоступны, шаг 1 блокируется до тех пор, пока образец не станет доступным.</span><span class="sxs-lookup"><span data-stu-id="cc482-121">If no samples are available, step 1 blocks until a sample becomes available.</span></span> <span data-ttu-id="cc482-122">Шаг 4 также можно заблокировать; Например, он может блокироваться во время приостановки графа.</span><span class="sxs-lookup"><span data-stu-id="cc482-122">Step 4 can also block; for example, it can block while the graph is paused.</span></span>

<span data-ttu-id="cc482-123">Цикл выполняется как можно быстрее, но ограничивается тем, насколько быстро фильтр модуля подготовки отчетов визуализирует каждый пример.</span><span class="sxs-lookup"><span data-stu-id="cc482-123">The loop runs as quickly as possible, but is limited by how quickly the renderer filter renders each sample.</span></span> <span data-ttu-id="cc482-124">Если граф фильтра имеет ссылочный интервал времени, скорость определяется во время представления образцов.</span><span class="sxs-lookup"><span data-stu-id="cc482-124">Assuming the filter graph has a reference clock, the rate is determined by the presentation times on the samples.</span></span> <span data-ttu-id="cc482-125">Если эталонные часы отсутствуют, модуль подготовки отчетов использует примеры как можно быстрее.</span><span class="sxs-lookup"><span data-stu-id="cc482-125">If there is no reference clock, the renderer consumes samples as quickly as possible.</span></span>

## <a name="using-csource-and-csourcestream"></a><span data-ttu-id="cc482-126">Использование Ксаурце и Ксаурцестреам</span><span class="sxs-lookup"><span data-stu-id="cc482-126">Using CSource and CSourceStream</span></span>

<span data-ttu-id="cc482-127">Базовые классы DirectShow включают два класса, которые поддерживают источники push-уведомлений: [**ксаурце**](csource.md) и [**ксаурцестреам**](csourcestream.md).</span><span class="sxs-lookup"><span data-stu-id="cc482-127">The DirectShow base classes include two classes that support push sources: [**CSource**](csource.md) and [**CSourceStream**](csourcestream.md).</span></span>

-   <span data-ttu-id="cc482-128">[**Ксаурце**](csource.md) является базовым классом для фильтра и реализует интерфейс [**ибасефилтер**](/windows/desktop/api/Strmif/nn-strmif-ibasefilter) .</span><span class="sxs-lookup"><span data-stu-id="cc482-128">[**CSource**](csource.md) is the base class for the filter and implements the [**IBaseFilter**](/windows/desktop/api/Strmif/nn-strmif-ibasefilter) interface.</span></span>
-   <span data-ttu-id="cc482-129">[**Ксаурцестреам**](csourcestream.md) является базовым классом для закрепления вывода и реализует интерфейс [**Ипин**](/windows/desktop/api/Strmif/nn-strmif-ipin) .</span><span class="sxs-lookup"><span data-stu-id="cc482-129">[**CSourceStream**](csourcestream.md) is the base class for the output pins, and implements the [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) interface.</span></span>

### <a name="output-pins"></a><span data-ttu-id="cc482-130">Выходные контакты</span><span class="sxs-lookup"><span data-stu-id="cc482-130">Output Pins</span></span>

<span data-ttu-id="cc482-131">Фильтр источника может иметь более одного выходного ПИН-кода.</span><span class="sxs-lookup"><span data-stu-id="cc482-131">A source filter can have more than one output pin.</span></span> <span data-ttu-id="cc482-132">В методе конструктора фильтра создайте один или несколько ПИН-кодов, производных от [**ксаурцестреам**](csourcestream.md) (один ПИН-код на поток вывода).</span><span class="sxs-lookup"><span data-stu-id="cc482-132">In your filter's constructor method, create one or more pins derived from [**CSourceStream**](csourcestream.md) (one pin per output stream).</span></span> <span data-ttu-id="cc482-133">Не нужно хранить указатели на ПИН-коды; ПИН-коды автоматически добавляются в фильтр при их создании.</span><span class="sxs-lookup"><span data-stu-id="cc482-133">You don't need to store pointers to the pins; the pins automatically add themselves to the filter when they are created.</span></span>

### <a name="output-formats"></a><span data-ttu-id="cc482-134">Форматы выходных данных</span><span class="sxs-lookup"><span data-stu-id="cc482-134">Output Formats</span></span>

<span data-ttu-id="cc482-135">Выходной ПИН-код обрабатывает согласование формата со следующими методами [**ксаурцестреам**](csourcestream.md) :</span><span class="sxs-lookup"><span data-stu-id="cc482-135">The output pin handles format negotiation with the following [**CSourceStream**](csourcestream.md) methods:</span></span>



| <span data-ttu-id="cc482-136">Метод</span><span class="sxs-lookup"><span data-stu-id="cc482-136">Method</span></span>                                                 | <span data-ttu-id="cc482-137">Описание</span><span class="sxs-lookup"><span data-stu-id="cc482-137">Description</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|--------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="cc482-138">**жетмедиатипе**</span><span class="sxs-lookup"><span data-stu-id="cc482-138">**GetMediaType**</span></span>](csourcestream-getmediatype.md)     | <span data-ttu-id="cc482-139">Возвращает тип носителя из выходного контакта.</span><span class="sxs-lookup"><span data-stu-id="cc482-139">Gets a media type from the output pin.</span></span> <br/> <span data-ttu-id="cc482-140">ПИН-код должен предложить по крайней мере один тип носителя, так как нисходящий фильтр может не предлагать типы.</span><span class="sxs-lookup"><span data-stu-id="cc482-140">The pin must propose at least one media type, because the downstream filter might not propose any types.</span></span> <span data-ttu-id="cc482-141">В большинстве случаев нисходящий фильтр будет декодером или модулем подготовки отчетов в зависимости от того, доставляет ли фильтр источника сжатые или несжатые данные.</span><span class="sxs-lookup"><span data-stu-id="cc482-141">In most cases, the downstream filter will be a decoder or a renderer, depending on whether the source filter delivers compressed or uncompressed data.</span></span> <span data-ttu-id="cc482-142">Фильтру модуля подготовки отчетов обычно требуется полный тип мультимедиа, содержащий все сведения о формате, необходимые для отрисовки потока.</span><span class="sxs-lookup"><span data-stu-id="cc482-142">A renderer filter usually requires a complete media type, containing all of the format information needed to render the stream.</span></span> <span data-ttu-id="cc482-143">Для декодера объем информации, необходимый для типа носителя, зависит очень много от формата кодирования.</span><span class="sxs-lookup"><span data-stu-id="cc482-143">For a decoder, the amount of information that is required in the media type depends very much on the encoding format.</span></span><br/> |
| [<span data-ttu-id="cc482-144">**чеккмедиатипе**</span><span class="sxs-lookup"><span data-stu-id="cc482-144">**CheckMediaType**</span></span>](csourcestream-checkmediatype.md) | <span data-ttu-id="cc482-145">Проверяет, принимает ли выходной ПИН-код данный тип носителя.</span><span class="sxs-lookup"><span data-stu-id="cc482-145">Checks if the output pin accepts a given media type.</span></span> <span data-ttu-id="cc482-146">Переопределение этого метода является необязательным, в зависимости от того, как реализуется [**жетмедиатипе**](csourcestream-getmediatype.md).</span><span class="sxs-lookup"><span data-stu-id="cc482-146">Overriding this method is optional, depending on how you implement [**GetMediaType**](csourcestream-getmediatype.md).</span></span>                                                                                                                                                                                                                                                                                                                                                                                                         |



 

<span data-ttu-id="cc482-147">Метод [**жетмедиатипе**](csourcestream-getmediatype.md) перегружен:</span><span class="sxs-lookup"><span data-stu-id="cc482-147">The [**GetMediaType**](csourcestream-getmediatype.md) method is overloaded:</span></span>

-   <span data-ttu-id="cc482-148">[**Жетмедиатипе**](csourcestream-getmediatype.md) (1) принимает один параметр — указатель на объект [**кмедиатипе**](cmediatype.md) .</span><span class="sxs-lookup"><span data-stu-id="cc482-148">[**GetMediaType**](csourcestream-getmediatype.md) (1) takes a single parameter, a pointer to a [**CMediaType**](cmediatype.md) object.</span></span>
-   <span data-ttu-id="cc482-149">[**Жетмедиатипе**](csourcestream-getmediatype2.md) (2) принимает переменную индекса и указатель на объект [**кмедиатипе**](cmediatype.md) .</span><span class="sxs-lookup"><span data-stu-id="cc482-149">[**GetMediaType**](csourcestream-getmediatype2.md) (2) takes an index variable and a pointer to a [**CMediaType**](cmediatype.md) object.</span></span>

<span data-ttu-id="cc482-150">Если выходной ПИН-код фильтра источника поддерживает ровно один формат мультимедиа, следует переопределить (1), чтобы инициализировать объект [**кмедиатипе**](cmediatype.md) с этим форматом.</span><span class="sxs-lookup"><span data-stu-id="cc482-150">If the source filter's output pin supports exactly one media format, you should override (1) to initialize the [**CMediaType**](cmediatype.md) object with that format.</span></span> <span data-ttu-id="cc482-151">Оставьте реализацию по умолчанию (2), а также оставьте реализацию [**чеккмедиатипе**](csourcestream-checkmediatype.md)по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="cc482-151">Leave the default implementation of (2) and also leave the default implementation of [**CheckMediaType**](csourcestream-checkmediatype.md).</span></span>

<span data-ttu-id="cc482-152">Если ПИН-код поддерживает более одного формата, переопределите (2).</span><span class="sxs-lookup"><span data-stu-id="cc482-152">If the pin supports more than one format, override (2).</span></span> <span data-ttu-id="cc482-153">Инициализируйте объект [**кмедиатипе**](cmediatype.md) в соответствии со значением переменной индекса.</span><span class="sxs-lookup"><span data-stu-id="cc482-153">Initialize the [**CMediaType**](cmediatype.md) object according to the value of the index variable.</span></span> <span data-ttu-id="cc482-154">ПИН-код должен возвращать форматы в виде упорядоченного списка.</span><span class="sxs-lookup"><span data-stu-id="cc482-154">The pin should return the formats as an ordered list.</span></span> <span data-ttu-id="cc482-155">В этом случае необходимо также переопределить [**чеккмедиатипе**](csourcestream-checkmediatype.md) , чтобы проверить тип мультимедиа по списку форматов.</span><span class="sxs-lookup"><span data-stu-id="cc482-155">In this case, you must also override the [**CheckMediaType**](csourcestream-checkmediatype.md) to check the media type against your list of formats.</span></span>

<span data-ttu-id="cc482-156">Для несжатых видеоформатов Помните, что нисходящий фильтр может предлагать форматы с различными значениями STRIDE.</span><span class="sxs-lookup"><span data-stu-id="cc482-156">For uncompressed video formats, remember that the downstream filter can propose formats with various stride values.</span></span> <span data-ttu-id="cc482-157">Фильтр должен принимать любое допустимое значение шага.</span><span class="sxs-lookup"><span data-stu-id="cc482-157">Your filter should accept any valid stride value.</span></span> <span data-ttu-id="cc482-158">Дополнительные сведения см. в разделе [**битмапинфохеадер**](/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader).</span><span class="sxs-lookup"><span data-stu-id="cc482-158">For more information, see [**BITMAPINFOHEADER**](/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader).</span></span>

<span data-ttu-id="cc482-159">Необходимо также переопределить метод чистого виртуального [**кбасеаутпутпин::D еЦидебуфферсизе**](cbaseoutputpin-decidebuffersize.md) .</span><span class="sxs-lookup"><span data-stu-id="cc482-159">You must also override the pure-virtual [**CBaseOutputPin::DecideBufferSize**](cbaseoutputpin-decidebuffersize.md) method.</span></span> <span data-ttu-id="cc482-160">Используйте этот метод, чтобы задать размер буферов выборки.</span><span class="sxs-lookup"><span data-stu-id="cc482-160">Use this method to set the size of the sample buffers.</span></span>

### <a name="streaming"></a><span data-ttu-id="cc482-161">Потоковая передача</span><span class="sxs-lookup"><span data-stu-id="cc482-161">Streaming</span></span>

<span data-ttu-id="cc482-162">Класс [**ксаурцестреам**](csourcestream.md) создает поток потоковой передачи для ПИН-кода.</span><span class="sxs-lookup"><span data-stu-id="cc482-162">The [**CSourceStream**](csourcestream.md) class creates the streaming thread for the pin.</span></span> <span data-ttu-id="cc482-163">Процедура потока реализована в методе [**ксаурцестреам::D обуфферпроцессинглуп**](csourcestream-dobufferprocessingloop.md) .</span><span class="sxs-lookup"><span data-stu-id="cc482-163">The thread procedure is implemented in the [**CSourceStream::DoBufferProcessingLoop**](csourcestream-dobufferprocessingloop.md) method.</span></span> <span data-ttu-id="cc482-164">Этот метод вызывает метод чистого виртуального [**ксаурцестреам:: филлбуффер**](csourcestream-fillbuffer.md) , который должен переопределяться производным классом.</span><span class="sxs-lookup"><span data-stu-id="cc482-164">This method calls the pure-virtual [**CSourceStream::FillBuffer**](csourcestream-fillbuffer.md) method, which the derived class must override.</span></span> <span data-ttu-id="cc482-165">Этот метод заключается в том, что закрепление заполняет буфер данными.</span><span class="sxs-lookup"><span data-stu-id="cc482-165">This method is where the pin fills the buffer with data.</span></span> <span data-ttu-id="cc482-166">Например, если фильтр доставляет видео в несжатом виде, здесь вы Нарисуйте кадры видео.</span><span class="sxs-lookup"><span data-stu-id="cc482-166">For example, if your filter delivers uncompressed video, this is where you would draw the video frames.</span></span>

<span data-ttu-id="cc482-167">Базовый класс автоматически запускает и останавливает цикл потоков в нужное время, когда фильтр приостанавливается или останавливается.</span><span class="sxs-lookup"><span data-stu-id="cc482-167">The base class automatically starts and stops the thread loop at the right times, when the filter pauses or stops.</span></span> <span data-ttu-id="cc482-168">В этом случае класс [**ксаурцестреам**](csourcestream.md) вызывает некоторые методы для уведомления от производного класса:</span><span class="sxs-lookup"><span data-stu-id="cc482-168">When this happens, the [**CSourceStream**](csourcestream.md) class calls some methods to notify your derived class:</span></span>

-   [<span data-ttu-id="cc482-169">**Ксаурцестреам:: Онсреадкреате**</span><span class="sxs-lookup"><span data-stu-id="cc482-169">**CSourceStream::OnThreadCreate**</span></span>](csourcestream-onthreadcreate.md)
-   [<span data-ttu-id="cc482-170">**Ксаурцестреам:: Онсреаддестрой**</span><span class="sxs-lookup"><span data-stu-id="cc482-170">**CSourceStream::OnThreadDestroy**</span></span>](csourcestream-onthreaddestroy.md)
-   [<span data-ttu-id="cc482-171">**Ксаурцестреам:: Онсреадстартплай**</span><span class="sxs-lookup"><span data-stu-id="cc482-171">**CSourceStream::OnThreadStartPlay**</span></span>](csourcestream-onthreadstartplay.md)

<span data-ttu-id="cc482-172">Эти методы можно переопределить, если нужно добавить любую специальную обработку.</span><span class="sxs-lookup"><span data-stu-id="cc482-172">You can override these methods if you need to add any special handling.</span></span> <span data-ttu-id="cc482-173">В противном случае реализации по умолчанию просто возвращают значение **S \_ ОК**.</span><span class="sxs-lookup"><span data-stu-id="cc482-173">Otherwise, the default implementations simply return **S\_OK**.</span></span>

## <a name="seeking"></a><span data-ttu-id="cc482-174">Нужна</span><span class="sxs-lookup"><span data-stu-id="cc482-174">Seeking</span></span>

<span data-ttu-id="cc482-175">Если у вас есть фильтр источников с одним выходным закреплением, можно использовать класс [**ксаурцесикинг**](csourceseeking.md) в качестве отправной точки для реализации поиска.</span><span class="sxs-lookup"><span data-stu-id="cc482-175">If you have a source filter with one output pin, you can use the [**CSourceSeeking**](csourceseeking.md) class as a starting point for implementing seeking.</span></span> <span data-ttu-id="cc482-176">Наследуйте класс ПИН-кода как в [**ксаурцестреам**](csourcestream.md) , так и в **ксаурцесикинг**.</span><span class="sxs-lookup"><span data-stu-id="cc482-176">Inherit your pin class from both [**CSourceStream**](csourcestream.md) and **CSourceSeeking**.</span></span>

> [!Note]  
> <span data-ttu-id="cc482-177">[**Ксаурцесикинг**](csourceseeking.md) не рекомендуется использовать для фильтра с более чем одним выходным закреплением.</span><span class="sxs-lookup"><span data-stu-id="cc482-177">[**CSourceSeeking**](csourceseeking.md) is not recommended for a filter with more than one output pin.</span></span> <span data-ttu-id="cc482-178">Основной проблемой является то, что только один ПИН-код должен отвечать на запросы на поиск.</span><span class="sxs-lookup"><span data-stu-id="cc482-178">The main issue is that only one pin should respond to seeking requests.</span></span> <span data-ttu-id="cc482-179">Обычно для этого требуется обмен данными между контактами и фильтром.</span><span class="sxs-lookup"><span data-stu-id="cc482-179">Typically this requires communication among the pins and the filter.</span></span>

 

<span data-ttu-id="cc482-180">Класс [**ксаурцесикинг**](csourceseeking.md) управляет скоростью воспроизведения, временем начала, временем окончания и длительностью.</span><span class="sxs-lookup"><span data-stu-id="cc482-180">The [**CSourceSeeking**](csourceseeking.md) class manages the playback rate, start time, stop time, and duration.</span></span> <span data-ttu-id="cc482-181">Производный класс должен установить начальное время и длительность окончания.</span><span class="sxs-lookup"><span data-stu-id="cc482-181">Your derived class should set the initial stop time and duration.</span></span> <span data-ttu-id="cc482-182">При каждом изменении одного из этих значений вызывается метод [**ксаурцесикинг:: чанжерате**](csourceseeking-changerate.md), [**Ксаурцесикинг:: чанжестарт**](csourceseeking-changestart.md)или [**ксаурцесикинг:: чанжестоп**](csourceseeking-changestop.md) .</span><span class="sxs-lookup"><span data-stu-id="cc482-182">Whenever one of these values changes, the [**CSourceSeeking::ChangeRate**](csourceseeking-changerate.md), [**CSourceSeeking::ChangeStart**](csourceseeking-changestart.md), or [**CSourceSeeking::ChangeStop**](csourceseeking-changestop.md) method is called, as appropriate.</span></span> <span data-ttu-id="cc482-183">Методы — это все чистые виртуальные методы.</span><span class="sxs-lookup"><span data-stu-id="cc482-183">The methods are all pure virtual methods.</span></span> <span data-ttu-id="cc482-184">Класс производного ПИН-кода переопределяет эти методы, чтобы сделать следующее:</span><span class="sxs-lookup"><span data-stu-id="cc482-184">The derived pin class overrides these methods to do the following:</span></span>

1.  <span data-ttu-id="cc482-185">Вызовите [**Ипин:: бегинфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) в нисходящем ПИН-коде.</span><span class="sxs-lookup"><span data-stu-id="cc482-185">Call [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) on the downstream pin.</span></span> <span data-ttu-id="cc482-186">Это приводит к тому, что нисходящие фильтры приводят к выпуску образцов, которые они записывают и отклоняют.</span><span class="sxs-lookup"><span data-stu-id="cc482-186">This causes downstream filters to release samples they are holding and reject new samples.</span></span>
2.  <span data-ttu-id="cc482-187">Вызовите метод [**ксаурцестреам:: останавливаться**](csourcestream-stop.md) , чтобы прерывать поток потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="cc482-187">Call [**CSourceStream::Stop**](csourcestream-stop.md) to stop the streaming thread.</span></span> <span data-ttu-id="cc482-188">Фильтр источников приостанавливает создание новых данных.</span><span class="sxs-lookup"><span data-stu-id="cc482-188">The source filter suspends producing new data.</span></span>
3.  <span data-ttu-id="cc482-189">Вызовите [**Ипин:: ендфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) в нисходящем ПИН-коде.</span><span class="sxs-lookup"><span data-stu-id="cc482-189">Call [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) on the downstream pin.</span></span> <span data-ttu-id="cc482-190">Это сигнализирует нисходящим фильтрам принять новые данные.</span><span class="sxs-lookup"><span data-stu-id="cc482-190">This signals the downstream filters to accept new data.</span></span>
4.  <span data-ttu-id="cc482-191">Вызовите [**Ипин:: невсегмент**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment) с новым временем начала и окончания и скоростью.</span><span class="sxs-lookup"><span data-stu-id="cc482-191">Call [**IPin::NewSegment**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment) with the new start and stop times and rate.</span></span>
5.  <span data-ttu-id="cc482-192">Задайте свойство ненепрерывности в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="cc482-192">Set the discontinuity property on the next sample.</span></span>

<span data-ttu-id="cc482-193">Дополнительные сведения см. [в разделе Поддержка поиска в фильтре источника](supporting-seeking-in-a-source-filter.md).</span><span class="sxs-lookup"><span data-stu-id="cc482-193">For more information, see [Supporting Seeking in a Source Filter](supporting-seeking-in-a-source-filter.md).</span></span>

<span data-ttu-id="cc482-194">Если фильтр поддерживает поиск, расположение потока теперь не зависит от времени презентации.</span><span class="sxs-lookup"><span data-stu-id="cc482-194">If your filter supports seeking, the stream position is now independent of the presentation time.</span></span> <span data-ttu-id="cc482-195">После поиска метки времени сбрасываются в ноль.</span><span class="sxs-lookup"><span data-stu-id="cc482-195">After a seek, time stamps reset to zero.</span></span> <span data-ttu-id="cc482-196">Общая формула для меток времени:</span><span class="sxs-lookup"><span data-stu-id="cc482-196">The general formula for time stamps is:</span></span>

-   <span data-ttu-id="cc482-197">время начала выборки = прошедшее время или скорость воспроизведения</span><span class="sxs-lookup"><span data-stu-id="cc482-197">sample start time = time elapsed / playback rate</span></span>
-   <span data-ttu-id="cc482-198">время окончания выборки = пример времени начала + (время на кадр/скорость воспроизведения)</span><span class="sxs-lookup"><span data-stu-id="cc482-198">sample end time = sample start time + (time per frame / playback rate)</span></span>

<span data-ttu-id="cc482-199">*время истечения* времени — это время, истекшее с момента запуска фильтра или с момента последнего выполнения команды Seek.</span><span class="sxs-lookup"><span data-stu-id="cc482-199">where *time elapsed* is the time that has elapsed since the filter started running or since the last seek command.</span></span>

### <a name="time-formats-for-seeking"></a><span data-ttu-id="cc482-200">Форматы времени для поиска</span><span class="sxs-lookup"><span data-stu-id="cc482-200">Time Formats for Seeking</span></span>

<span data-ttu-id="cc482-201">По умолчанию команды поиска находятся в единицах 100-наносекундах.</span><span class="sxs-lookup"><span data-stu-id="cc482-201">By default, seek commands are in units of 100-nanoseconds.</span></span> <span data-ttu-id="cc482-202">Фильтр источников может поддерживать дополнительные форматы времени, например поиск по номеру кадра.</span><span class="sxs-lookup"><span data-stu-id="cc482-202">Your source filter can support additional time formats, such as seeking by frame number.</span></span> <span data-ttu-id="cc482-203">Каждый формат времени идентифицируется по идентификатору GUID; см. раздел [**идентификаторы GUID формата времени**](time-format-guids.md).</span><span class="sxs-lookup"><span data-stu-id="cc482-203">Each time format is identified by a GUID; see [**Time Format GUIDs**](time-format-guids.md).</span></span>

<span data-ttu-id="cc482-204">Для поддержки дополнительных форматов времени необходимо реализовать следующие методы для ПИН-кода вывода:</span><span class="sxs-lookup"><span data-stu-id="cc482-204">To support additional time formats, you must implement the following methods on your output pin:</span></span>

-   [<span data-ttu-id="cc482-205">**Имедиасикинг:: Конверттимеформат**</span><span class="sxs-lookup"><span data-stu-id="cc482-205">**IMediaSeeking::ConvertTimeFormat**</span></span>](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-converttimeformat)
-   [<span data-ttu-id="cc482-206">**Имедиасикинг:: Жеттимеформат**</span><span class="sxs-lookup"><span data-stu-id="cc482-206">**IMediaSeeking::GetTimeFormat**</span></span>](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-gettimeformat)
-   [<span data-ttu-id="cc482-207">**Имедиасикинг:: Исформатсуппортед**</span><span class="sxs-lookup"><span data-stu-id="cc482-207">**IMediaSeeking::IsFormatSupported**</span></span>](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-isformatsupported)
-   [<span data-ttu-id="cc482-208">**Имедиасикинг:: Исусингтимеформат**</span><span class="sxs-lookup"><span data-stu-id="cc482-208">**IMediaSeeking::IsUsingTimeFormat**</span></span>](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-isusingtimeformat)
-   [<span data-ttu-id="cc482-209">**Имедиасикинг:: Куерипреферредформат**</span><span class="sxs-lookup"><span data-stu-id="cc482-209">**IMediaSeeking::QueryPreferredFormat**</span></span>](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-querypreferredformat)
-   [<span data-ttu-id="cc482-210">**Имедиасикинг:: Сеттимеформат**</span><span class="sxs-lookup"><span data-stu-id="cc482-210">**IMediaSeeking::SetTimeFormat**</span></span>](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-settimeformat)

<span data-ttu-id="cc482-211">Если приложение устанавливает новый формат времени, все параметры положения в методах [**имедиасикинг**](/windows/desktop/api/Strmif/nn-strmif-imediaseeking) будут интерпретированы с точки зрения нового формата времени.</span><span class="sxs-lookup"><span data-stu-id="cc482-211">If the application sets a new time format, all of the position parameters in the [**IMediaSeeking**](/windows/desktop/api/Strmif/nn-strmif-imediaseeking) methods are interpreted in terms of the new time format.</span></span> <span data-ttu-id="cc482-212">Например, если формат времени — Frames, метод [**имедиасикинг::**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-getduration) noreturn должен возвращать длительность в кадрах.</span><span class="sxs-lookup"><span data-stu-id="cc482-212">For example, if the time format is frames, the [**IMediaSeeking::GetDuration**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-getduration) method must return the duration in frames.</span></span>

<span data-ttu-id="cc482-213">На практике некоторые фильтры DirectShow поддерживают дополнительные форматы времени, и в результате некоторые приложения DirectShow используют эту возможность.</span><span class="sxs-lookup"><span data-stu-id="cc482-213">In practice, few DirectShow filters support additional time formats, and as a result, few DirectShow applications make use of this capability.</span></span>

## <a name="related-topics"></a><span data-ttu-id="cc482-214">См. также</span><span class="sxs-lookup"><span data-stu-id="cc482-214">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="cc482-215">Запись фильтров источника</span><span class="sxs-lookup"><span data-stu-id="cc482-215">Writing Source Filters</span></span>](writing-source-filters.md)
</dt> </dl>

 

 




