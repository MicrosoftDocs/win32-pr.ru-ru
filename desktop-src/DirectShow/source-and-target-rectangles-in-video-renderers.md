---
description: Исходные и целевые прямоугольники в модулях подготовки видео
ms.assetid: fdddbffb-c44f-4364-9e2e-b721ba39c74f
title: Исходные и целевые прямоугольники в модулях подготовки видео
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 556aea6aad22e5ea6df61c74ed0a46d2e3984d67
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104537556"
---
# <a name="source-and-target-rectangles-in-video-renderers"></a><span data-ttu-id="52263-103">Исходные и целевые прямоугольники в модулях подготовки видео</span><span class="sxs-lookup"><span data-stu-id="52263-103">Source and Target Rectangles in Video Renderers</span></span>

<span data-ttu-id="52263-104">В структурах форматов видео [**видеоинфо**](/previous-versions/windows/desktop/api/amvideo/ns-amvideo-videoinfo), [**видеоинфохеадер**](/previous-versions/windows/desktop/api/amvideo/ns-amvideo-videoinfoheader)и [**VIDEOINFOHEADER2**](/previous-versions/windows/desktop/api/dvdmedia/ns-dvdmedia-videoinfoheader2) есть три размера.</span><span class="sxs-lookup"><span data-stu-id="52263-104">There are three sizes found in the [**VIDEOINFO**](/previous-versions/windows/desktop/api/amvideo/ns-amvideo-videoinfo), [**VIDEOINFOHEADER**](/previous-versions/windows/desktop/api/amvideo/ns-amvideo-videoinfoheader), and [**VIDEOINFOHEADER2**](/previous-versions/windows/desktop/api/dvdmedia/ns-dvdmedia-videoinfoheader2) format structures of video media types.</span></span> <span data-ttu-id="52263-105">В этой статье объясняется, что они представляют, и как они работают.</span><span class="sxs-lookup"><span data-stu-id="52263-105">This article explains what they are and how they work.</span></span>

<span data-ttu-id="52263-106">Во-первых, в этих структурах имеется размер **бмихеадер** .</span><span class="sxs-lookup"><span data-stu-id="52263-106">First, there is a size in the **bmiHeader** member of these structures.</span></span> <span data-ttu-id="52263-107">Элемент **бмихеадер** представляет собой структуру [**битмапинфохеадер**](/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader) с собственными элементами Width и Height, **бмихеадер. бивидс** и **бмихеадер. бихеигхт**.</span><span class="sxs-lookup"><span data-stu-id="52263-107">The **bmiHeader** member is a [**BITMAPINFOHEADER**](/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader) structure with its own width and height members, **bmiHeader.biWidth** and **bmiHeader.biHeight**.</span></span>

<span data-ttu-id="52263-108">Во-вторых, в элементе **рксаурце** этих структур есть прямоугольник. и наконец, в элементе **рктаржет** этих структур есть прямоугольник.</span><span class="sxs-lookup"><span data-stu-id="52263-108">Second, there is a rectangle in the **rcSource** member of these structures; and last, there is a rectangle in the **rcTarget** member of these structures.</span></span>

<span data-ttu-id="52263-109">Предположим, что у вас есть два фильтра: A и B, и что эти фильтры соединены друг с другом (слева или вверх, а б — в правой или нисходящей) с определенным типом видеоклипа.</span><span class="sxs-lookup"><span data-stu-id="52263-109">Assume you have two filters, A and B, and that these filters are connected to each other (A on the left, or upstream, and B on the right, or downstream) with a certain video media type.</span></span>

<span data-ttu-id="52263-110">Буферы, которые проходят между фильтрами A и B, имеют размер (**бмихеадер. бивидс**, **бмихеадер. бихеигхт**).</span><span class="sxs-lookup"><span data-stu-id="52263-110">The buffers that pass between filters A and B have the size (**bmiHeader.biWidth**, **bmiHeader.biHeight**).</span></span> <span data-ttu-id="52263-111">Фильтр должен принимать часть входного видео, определенную **рксаурце** , и растягивать его для заполнения **рктаржет** части буфера.</span><span class="sxs-lookup"><span data-stu-id="52263-111">Filter A should take a portion of its input video determined by **rcSource** and stretch that video to fill the **rcTarget** portion of the buffer.</span></span> <span data-ttu-id="52263-112">Часть входного видео, используемая для использования, зависит от того, как **рксаурце** сравнивается с размером (**бивидс**, **бихеигхт**) типа носителя, который фильтрует A и B в первоначальном соединении с.</span><span class="sxs-lookup"><span data-stu-id="52263-112">The portion of the input video to use is based on how **rcSource** compares to the (**biWidth**, **biHeight**) size of the media type that filters A and B originally connected with.</span></span> <span data-ttu-id="52263-113">Если **рксаурце** является пустым, то фильтр A использует все входное видео.</span><span class="sxs-lookup"><span data-stu-id="52263-113">If **rcSource** is empty, filter A uses its entire input video.</span></span> <span data-ttu-id="52263-114">Если **рктаржет** является пустым, фильтр заполняет весь выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="52263-114">If **rcTarget** is empty, filter A fills the entire output buffer.</span></span>

<span data-ttu-id="52263-115">Например, пусть фильтр A получает данные видео, 160 x 120 пикселей.</span><span class="sxs-lookup"><span data-stu-id="52263-115">For example, assume filter A is receiving video data that is 160 x 120 pixels.</span></span> <span data-ttu-id="52263-116">Предположим также, что фильтр A подключен к фильтру б со следующим типом носителя.</span><span class="sxs-lookup"><span data-stu-id="52263-116">Assume also that filter A is connected to filter B with the following media type.</span></span>

-   <span data-ttu-id="52263-117">(**бивидс**, **бихеигхт**): 320, 240</span><span class="sxs-lookup"><span data-stu-id="52263-117">(**biWidth**, **biHeight**): 320, 240</span></span>
-   <span data-ttu-id="52263-118">**рксаурце**: (0, 0, 0, 0)</span><span class="sxs-lookup"><span data-stu-id="52263-118">**rcSource**: (0, 0, 0, 0)</span></span>
-   <span data-ttu-id="52263-119">**рктаржет**: (0, 0, 0, 0)</span><span class="sxs-lookup"><span data-stu-id="52263-119">**rcTarget**: (0, 0, 0, 0)</span></span>

<span data-ttu-id="52263-120">Это означает, что фильтр будет растягивать видео, получаемое по 2 в направлениях x и y, и заполнить выходной буфер 320 x 240.</span><span class="sxs-lookup"><span data-stu-id="52263-120">This means that filter A will stretch the video it receives by 2 in both the x and y directions, and fill a 320 x 240 output buffer.</span></span>

<span data-ttu-id="52263-121">В качестве другого примера предположим, что фильтр A получает видео-данные 160 x 120 и подключен к фильтру B со следующим типом носителя.</span><span class="sxs-lookup"><span data-stu-id="52263-121">As another example, assume filter A is receiving 160 x 120 video data, and that it is connected to filter B with the following media type.</span></span>

-   <span data-ttu-id="52263-122">(**бивидс**, **бихеигхт**): 320, 240</span><span class="sxs-lookup"><span data-stu-id="52263-122">(**biWidth**, **biHeight**): 320, 240</span></span>
-   <span data-ttu-id="52263-123">**рксаурце**: (0, 0, 160, 240)</span><span class="sxs-lookup"><span data-stu-id="52263-123">**rcSource**: (0, 0, 160, 240)</span></span>
-   <span data-ttu-id="52263-124">**рктаржет**: (0, 0, 0, 0)</span><span class="sxs-lookup"><span data-stu-id="52263-124">**rcTarget**: (0, 0, 0, 0)</span></span>

<span data-ttu-id="52263-125">Элемент **рксаурце** задается относительно размера подключенного буфера 320, 240.</span><span class="sxs-lookup"><span data-stu-id="52263-125">The **rcSource** member is relative to the connected buffer size of 320, 240.</span></span> <span data-ttu-id="52263-126">Так как указанный **рксаурце** (0, 0, 160, 240) — левая половина буфера, фильтр A примет левую половину его входного видео или часть (0, 0, 80, 120) и растягивает видео до размера (320, 240) (на 4 в направлении x и на 2 в направлении по оси y) и заполнит буфер вывода 320 x 240.</span><span class="sxs-lookup"><span data-stu-id="52263-126">Because the specified **rcSource** (0, 0, 160, 240) is the left half of the buffer, filter A will take the left half of its input video, or the (0, 0, 80, 120) portion, and stretch the video to a size of (320, 240) (by 4 in the x direction, and by 2 in the y direction) and filling the 320 x 240 output buffer.</span></span>

<span data-ttu-id="52263-127">Теперь предположим, что фильтру A вызывает [**кбасеаллокатор::-buffer**](cbaseallocator-getbuffer.md), а возвращаемый пример носителя имеет присоединенный к нему тип мультимедиа, что означает, что фильтр б хочет фильтровать A, чтобы предоставить другой размер или тип видео, чем было предоставлено ранее.</span><span class="sxs-lookup"><span data-stu-id="52263-127">Now assume that filter A calls [**CBaseAllocator::GetBuffer**](cbaseallocator-getbuffer.md), and the media sample returned has a media type attached to it, signifying that filter B wants filter A to provide a different size or kind of video than it has previously been providing.</span></span> <span data-ttu-id="52263-128">Предположим, что новый тип носителя:</span><span class="sxs-lookup"><span data-stu-id="52263-128">Assume the new media type is:</span></span>

-   <span data-ttu-id="52263-129">(**бивидс**, **бихеигхт**): 640, 480</span><span class="sxs-lookup"><span data-stu-id="52263-129">(**biWidth**, **biHeight**): 640, 480</span></span>
-   <span data-ttu-id="52263-130">**рксаурце**: (0, 0, 160, 120)</span><span class="sxs-lookup"><span data-stu-id="52263-130">**rcSource**: (0, 0, 160, 120)</span></span>
-   <span data-ttu-id="52263-131">**рктаржет**: (0, 0, 80, 60)</span><span class="sxs-lookup"><span data-stu-id="52263-131">**rcTarget**: (0, 0, 80, 60)</span></span>

<span data-ttu-id="52263-132">Это означает, что пример носителя имеет буфер размером 640 x 480.</span><span class="sxs-lookup"><span data-stu-id="52263-132">This means that the media sample has a buffer that is 640 x 480 in size.</span></span> <span data-ttu-id="52263-133">Элемент **рксаурце** относится к исходному подключенному типу носителя (320, 240), а не к новому типу носителя (640, 480), поэтому **рксаурце** указывает, что левый верхний угол (25%) входного видео для использования.</span><span class="sxs-lookup"><span data-stu-id="52263-133">The **rcSource** member is relative to the original connected media type (320, 240) not to the new media type of (640, 480), so **rcSource** specifies that the top-left corner (25%) of the input video is to be used.</span></span> <span data-ttu-id="52263-134">Эта часть входного видео помещается в верхнюю левую (80, 60) пикселях выходного буфера 640 x 480, как указано в **рктаржет** (0, 0, 80, 60).</span><span class="sxs-lookup"><span data-stu-id="52263-134">This portion of the input video is placed in the top-left (80, 60) pixels of the 640 x 480 output buffer, as specified by **rcTarget** of (0, 0, 80, 60).</span></span> <span data-ttu-id="52263-135">Поскольку фильтр A получает видео 160 x 120, левый верхний угол входного видео — это элемент (80, 60), тот же размер выходного растрового изображения и не требуется растяжение.</span><span class="sxs-lookup"><span data-stu-id="52263-135">Because filter A is receiving 160 x 120 video, the top-left corner of the input video is an (80, 60) piece, the same size of the output bitmap, and no stretching is required.</span></span>

<span data-ttu-id="52263-136">Фильтр не помещает данные в другие Пиксели выходного буфера и оставляет эти биты нетронутыми.</span><span class="sxs-lookup"><span data-stu-id="52263-136">Filter A will place no data in the other pixels of the output buffer, and will leave those bits untouched.</span></span> <span data-ttu-id="52263-137">Элемент **рксаурце** ограничен **бивидс** и **бихеигхт** исходного типа подключенного носителя между фильтрами A и B, а **рктаржет** ограничен новыми **бивидс** и **бихеигхт** в примере носителя.</span><span class="sxs-lookup"><span data-stu-id="52263-137">The **rcSource** member is bounded by the **biWidth** and **biHeight** of the original connected media type between filters A and B, and **rcTarget** is bounded by the new **biWidth** and **biHeight** of the media sample.</span></span> <span data-ttu-id="52263-138">В предыдущем примере **рксаурце** не удалось выйти за пределы границ (0, 0, 320, 240), и **рктаржет** не удалось выйти за пределы границ (0, 0, 640, 480).</span><span class="sxs-lookup"><span data-stu-id="52263-138">In the preceding example, **rcSource** could not go outside the boundaries of (0, 0, 320, 240) and **rcTarget** could not go outside the boundaries of (0, 0, 640, 480).</span></span>

 

 



