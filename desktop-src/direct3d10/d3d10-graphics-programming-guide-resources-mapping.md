---
description: Копирование и доступ к данным ресурсов (Direct3D 10)
ms.assetid: 34fd4d15-ee64-4acf-967d-a4afb6f26329
title: Копирование и доступ к данным ресурсов (Direct3D 10)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 38bd075585ee3123e163075a50b06b53a77a214c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "103807540"
---
# <a name="copying-and-accessing-resource-data-direct3d-10"></a><span data-ttu-id="a9bc3-103">Копирование и доступ к данным ресурсов (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="a9bc3-103">Copying and Accessing Resource Data (Direct3D 10)</span></span>

<span data-ttu-id="a9bc3-104">Больше не нужно думать о ресурсах, создаваемых в видеопамяти или системной памяти.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-104">It is no longer necessary to think about resources as being created in either video memory or system memory.</span></span> <span data-ttu-id="a9bc3-105">А также вне зависимости от того, должна ли среда выполнения управлять памятью.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-105">Or whether or not the runtime should manage the memory.</span></span> <span data-ttu-id="a9bc3-106">Благодаря архитектуре новой модели WDDM (модель Windows для видеодрайверов) приложения теперь создают ресурсы Direct3D 10 с различными флагами [**использования**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) для указания того, как приложение планирует использовать данные ресурсов.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-106">Thanks to the architecture of the new WDDM (Windows Display Driver Model), applications now create Direct3D 10 resources with different [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) flags to indicate how the application intends on using the resource data.</span></span> <span data-ttu-id="a9bc3-107">Новая модель драйвера используется для виртуализации памяти, используемой ресурсами. Затем она отвечает за использование операционной системы, драйвера или диспетчера памяти для размещения ресурсов в наиболее производительной области памяти с учетом ожидаемого использования.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-107">The new driver model virtualizes the memory used by resources; it then becomes the responsibility of the operating system/driver/memory manager to place resources in the most performant area of memory possible given the expected usage.</span></span>

<span data-ttu-id="a9bc3-108">Сценарий по умолчанию подразумевает доступность ресурсов графическому процессору.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-108">The default case is for resources to be available to the GPU.</span></span> <span data-ttu-id="a9bc3-109">Конечно, есть случаи, когда данные ресурсов должны быть доступны для ЦП.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-109">Of course, having said that, there are times when the resource data needs to be available to the CPU.</span></span> <span data-ttu-id="a9bc3-110">Чтобы копировать данные ресурсов из разных расположений, чтобы соответствующий процессор мог осуществлять к ним доступ, не влияя на производительность, требует определенных знаний о принципах работы методов API.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-110">Copying resource data around so that the appropriate processor can access it without impacting performance requires some knowledge of how the API methods work.</span></span>

-   [<span data-ttu-id="a9bc3-111">Копирование данных ресурсов</span><span class="sxs-lookup"><span data-stu-id="a9bc3-111">Copying Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)
-   [<span data-ttu-id="a9bc3-112">Доступ к данным ресурсов</span><span class="sxs-lookup"><span data-stu-id="a9bc3-112">Accessing Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)

## <a name="copying-resource-data"></a><span data-ttu-id="a9bc3-113">Копирование данных ресурсов</span><span class="sxs-lookup"><span data-stu-id="a9bc3-113">Copying Resource Data</span></span>

<span data-ttu-id="a9bc3-114">Ресурсы создаются в памяти, когда Direct3D вызывает метод Create.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-114">Resources are created in memory when Direct3D executes a Create call.</span></span> <span data-ttu-id="a9bc3-115">Они могут создаваться в видеопамяти, системной памяти и любой другой памяти.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-115">They can be created in video memory, system memory, or any other kind of memory.</span></span> <span data-ttu-id="a9bc3-116">Поскольку модель драйвера WDDM виртуализирует эту память, приложениям больше не нужно отслеживать, в какой памяти создаются ресурсы.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-116">Since WDDM driver model virtualizes this memory, applications no longer need to keep track of what kind of memory resources are created in.</span></span>

<span data-ttu-id="a9bc3-117">В идеале все ресурсы должны быть размещены в видеопамяти и быть мгновенно доступны для графического процессора.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-117">Ideally, all resources would be located in video memory so that the GPU can have immediate access to them.</span></span> <span data-ttu-id="a9bc3-118">Однако иногда нужно, чтобы ЦП считал данные ресурсов или графический процессор осуществил доступ к данным ресурсов, в которые был записан ЦП.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-118">However, it is sometimes necessary for the CPU to read the resource data or for the GPU to access resource data the CPU has written to.</span></span> <span data-ttu-id="a9bc3-119">Direct3D 10 обрабатывает эти различные сценарии, запросив приложение указать использование, а затем предлагает несколько методов копирования данных ресурсов при необходимости.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-119">Direct3D 10 handles these different scenarios by requesting the application specify a usage, and then offers several methods for copying resource data when necessary.</span></span>

<span data-ttu-id="a9bc3-120">В зависимости от того как был создан ресурс, не всегда возможно осуществить прямой доступ к базовым данным.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-120">Depending on how the resource was created, it is not always possible to directly access the underlying data.</span></span> <span data-ttu-id="a9bc3-121">Это может подразумевать необходимость копирования данных ресурса из исходного ресурса в другой, доступный соответствующему процессору.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-121">This may mean that the resource data must be copied from the source resource to another resource that is accessible by the appropriate processor.</span></span> <span data-ttu-id="a9bc3-122">С точки зрения Direct3D 10 доступ к ресурсам по умолчанию можно получить напрямую с помощью GPU, динамическое и промежуточное ресурсы могут получить прямой доступ к ресурсам ЦП.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-122">In terms of Direct3D 10, default resources can be accessed directly by the GPU, dynamic and staging resources can be directly accessed by the CPU.</span></span>

<span data-ttu-id="a9bc3-123">После создания ресурса его [**Использование**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) невозможно изменить.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-123">Once a resource has been created, its [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) cannot be changed.</span></span> <span data-ttu-id="a9bc3-124">Вместо этого необходимо копировать содержимое одного ресурса в другой, созданный с другим использованием.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-124">Instead, copy the contents of one resource to another resource that was created with a different usage.</span></span> <span data-ttu-id="a9bc3-125">Direct3D 10 предоставляет эту функцию с помощью трех различных методов.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-125">Direct3D 10 provides this functionality with three different methods.</span></span> <span data-ttu-id="a9bc3-126">Первые два метода ( [**ID3D10Device:: копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) и [**ID3D10Device:: кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) предназначены для копирования данных ресурсов из одного ресурса в другой.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-126">The first two methods( [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) are designed to copy resource data from one resource to another.</span></span> <span data-ttu-id="a9bc3-127">Третий метод ([**ID3D10Device:: упдатесубресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) предназначен для копирования данных из памяти в ресурс.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-127">The third method ([**ID3D10Device::UpdateSubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) is designed to copy data from memory to a resource.</span></span>

<span data-ttu-id="a9bc3-128">Существует два основных типа ресурсов: сопоставляемые и несопоставляемые.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-128">There are two main kinds of resources: mappable and non-mappable.</span></span> <span data-ttu-id="a9bc3-129">Ресурсы, созданные с динамическим или промежуточным использованием, сопоставимы, в то время как ресурсы, созданные с использованием по умолчанию или неизменяемым использованием, не сопоставляются.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-129">Resources created with dynamic or staging usages are mappable, while resources created with default or immutable usages are non-mappable.</span></span>

<span data-ttu-id="a9bc3-130">Копирование данных между несопоставляемыми ресурсами выполняется очень быстро, потому что это наиболее распространенный сценарий, выполнение которого максимально оптимизировано.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-130">Copying data among non-mappable resources is very fast because this is the most common case and has been optimized to perform well.</span></span> <span data-ttu-id="a9bc3-131">Так как эти ресурсы недоступны непосредственно ЦП, они оптимизированы таким образом, чтобы графический процессор мог быстро выполнять с ними различные операции.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-131">Since these resources are not directly accessible by the CPU, they are optimized so that the GPU can manipulate them quickly.</span></span>

<span data-ttu-id="a9bc3-132">Копирование данных среди сопоставляемых ресурсов является более проблематичным, поскольку производительность будет зависеть от использования, назначенного ресурсу при создании.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-132">Copying data among mappable resources is more problematic because the performance will depend on the usage the resource was created with.</span></span> <span data-ttu-id="a9bc3-133">Например, графический процессор может считывать динамический ресурс относительно быстро, но не может выполнять в него запись. Кроме того, графический процессор не может выполнять запись напрямую в промежуточные ресурсы или чтение из них.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-133">For example, the GPU can read a dynamic resource fairly quickly but cannot write to them, and the GPU cannot read or write to staging resources directly.</span></span>

<span data-ttu-id="a9bc3-134">Приложения, которые хотят копировать данные из ресурса с использованием по умолчанию к ресурсу с использованием промежуточного хранения (чтобы ресурсы ЦП могли считывать данные, т. е. проблема реадбакк GPU), должны делать это с осторожностью.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-134">Applications that wish to copy data from a resource with default usage to a resource with staging usage (to allow the CPU to read the data -- i.e. the GPU readback problem) must do so with care.</span></span> <span data-ttu-id="a9bc3-135">Дополнительные сведения об этом последнем случае см. в разделе [доступ к данным ресурсов](#copying-and-accessing-resource-data-direct3d-10) .</span><span class="sxs-lookup"><span data-stu-id="a9bc3-135">See [Accessing Resource Data](#copying-and-accessing-resource-data-direct3d-10) for more details on this last case.</span></span>

## <a name="accessing-resource-data"></a><span data-ttu-id="a9bc3-136">Доступ к данным ресурсов</span><span class="sxs-lookup"><span data-stu-id="a9bc3-136">Accessing Resource Data</span></span>

<span data-ttu-id="a9bc3-137">Доступ к ресурсу требует сопоставления ресурса; по сути, сопоставление означает, что приложение пытается предоставить ЦП доступ к памяти.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-137">Accessing a resource requires mapping the resource; mapping essentially means the application is trying to give the CPU access to memory.</span></span> <span data-ttu-id="a9bc3-138">Сопоставление ресурса с тем, чтобы ЦП мог осуществлять доступ к базовой памяти, может вызывать "узкие места" производительности. По этой причине эту задачу нужно выполнять с большой осторожностью и тщательно выбирать время.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-138">The process of mapping a resource so that the CPU can access the underlying memory can cause some performance bottlenecks and for this reason, care must be taken as to how and when to perform this task.</span></span>

<span data-ttu-id="a9bc3-139">Производительность может упасть до нуля, если приложение попытается сопоставить ресурс в неподходящее время.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-139">Performance can grind to a halt if the application tries to map a resource at the wrong time.</span></span> <span data-ttu-id="a9bc3-140">Если приложение пытается осуществить доступ к результатам операции до того, как она будет завершена, произойдет зависание конвейера.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-140">If the application tries to access the results of an operation before that operation is finished, a pipeline stall will occur.</span></span>

<span data-ttu-id="a9bc3-141">Выполнение операции сопоставления в неподходящее время может вызвать серьезное падение производительности, поскольку графический процессор и ЦП будут вынуждены синхронизироваться друг с другом.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-141">Performing a map operation at the wrong time could potentially cause a severe drop in performance by forcing the GPU and the CPU to synchronize with each other.</span></span> <span data-ttu-id="a9bc3-142">Синхронизация произойдет, если приложение хочет осуществлять доступ к ресурсу до того, как графический процессор завершит копирование ресурса в ресурс, доступный для сопоставления ЦП.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-142">This synchronization will occur if the application wants to access a resource before the GPU is finished copying it into a resource the CPU can map.</span></span>

<span data-ttu-id="a9bc3-143">ЦП может считывать данные только из ресурсов, созданных с помощью \_ \_ флага промежуточного использования D3D10.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-143">The CPU can only read from resources created with the D3D10\_USAGE\_STAGING flag.</span></span> <span data-ttu-id="a9bc3-144">Так как ресурсы, созданные с помощью этого флага, не могут быть установлены в качестве выходных данных конвейера, если ЦП хочет считывать данные в ресурсе, созданном GPU, данные должны быть скопированы в ресурс, созданный с помощью флага промежуточного хранения.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-144">Since resources created with this flag cannot be set as outputs of the pipeline, if the CPU wants to read the data in a resource generated by the GPU, the data must be copied to a resource created with the staging flag.</span></span> <span data-ttu-id="a9bc3-145">Приложение может сделать это с помощью методов [**ID3D10Device:: копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) или [**ID3D10Device:: кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) , чтобы скопировать содержимое одного ресурса в другой.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-145">The application may do this by using the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods to copy the contents of one resource to another.</span></span> <span data-ttu-id="a9bc3-146">Затем приложение может получить доступ к этому ресурсу, вызвав соответствующий метод Map.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-146">The application can then gain access to this resource by calling the appropriate Map method.</span></span> <span data-ttu-id="a9bc3-147">Если доступ к ресурсу больше не нужен, приложение должно вызвать соответствующий метод сопоставления.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-147">When access to the resource is no longer needed, the application should then call the corresponding Unmap method.</span></span> <span data-ttu-id="a9bc3-148">Например, [**ID3D10Texture2D:: Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) и [**ID3D10Texture2D::**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap)unотмена сопоставления.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-148">For example, [**ID3D10Texture2D::Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) and [**ID3D10Texture2D::Unmap**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap).</span></span> <span data-ttu-id="a9bc3-149">Различные методы Map возвращают определенные значения в зависимости от входных флагов.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-149">The different Map methods return some specific values depending on the input flags.</span></span> <span data-ttu-id="a9bc3-150">Дополнительные сведения см. в [**разделе "Примечания к карте"**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) .</span><span class="sxs-lookup"><span data-stu-id="a9bc3-150">See [**Map Remarks section**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) for details.</span></span>

> [!Note]  
> <span data-ttu-id="a9bc3-151">Когда приложение вызывает метод Map, оно получает указатель на данные ресурса для доступа.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-151">When the application calls the Map method, it receives a pointer to the resource data to access.</span></span> <span data-ttu-id="a9bc3-152">Среда выполнения гарантирует, что указатель имеет определенное выравнивание, в зависимости от [уровня компонента](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md).</span><span class="sxs-lookup"><span data-stu-id="a9bc3-152">The runtime ensures that the pointer has a specific alignment, depending on [feature level](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md).</span></span> <span data-ttu-id="a9bc3-153">Для [**D3D- \_ компонента \_ уровня \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) и выше указатель выдается по 16 байтам.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-153">For [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) and higher, the pointer is aligned to 16 bytes.</span></span> <span data-ttu-id="a9bc3-154">Для менее чем [**D3D \_ \_ уровня компонентов \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level)указатель выдается по 4 байтам.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-154">For lower than [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level), the pointer is aligned to 4 bytes.</span></span> <span data-ttu-id="a9bc3-155">16-байтное выравнивание позволяет приложению выполнять оптимизированные для [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))операции с данными в собственном режиме без повторного выравнивания или копирования.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-155">The 16-byte alignment allows the application to perform [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))-optimized operations on the data natively, without realignment or copy.</span></span>

 

### <a name="performance-considerations"></a><span data-ttu-id="a9bc3-156">Вопросы производительности</span><span class="sxs-lookup"><span data-stu-id="a9bc3-156">Performance Considerations</span></span>

<span data-ttu-id="a9bc3-157">Лучше всего воспринимать ПК как устройство, функционирующее в виде параллельной архитектуры с двумя основными типами процессоров: один или несколько ЦП и один или несколько графических процессоров.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-157">It is best to think of a PC as a machine running as a parallel architecture with two main types of processors: one or more CPU's and one or more GPU's.</span></span> <span data-ttu-id="a9bc3-158">Как и в любой параллельной архитектуре, оптимальная производительность достигается, если для каждого процессора запланировано достаточно задач, чтобы не дать ему простаивать, и когда работе одного процессора не приходится ждать завершения работы другого.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-158">As in any parallel architecture, the best performance is achieved when each processor is scheduled with enough tasks to prevent it from going idle and when the work of one processor is not waiting on the work of another.</span></span>

<span data-ttu-id="a9bc3-159">В самом худшем сценарии параллелизма графического процессора и ЦП один процессор вынужден ждать результаты работы другого.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-159">The worst-case scenario for GPU/CPU parallelism is the need to force one processor to wait for the results of work done by another.</span></span> <span data-ttu-id="a9bc3-160">Direct3D 10 пытается устранить эту стоимость, делая асинхронными методы [**ID3D10Device:: копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) и [**ID3D10Device:: кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) . копирование не обязательно выполнялось в момент возвращения метода.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-160">Direct3D 10 tries to remove this cost by making the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods asynchronous; the copy has not necessarily executed by the time the method returns.</span></span> <span data-ttu-id="a9bc3-161">Преимущество такого подхода в том, что производительность приложения не снижается из-за фактического копирования данных до тех пор, пока ЦП не осуществит доступ к данным, то есть во время вызова метода Map.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-161">The benefit of this is that the application does not pay the performance cost of actually copying the data until the CPU accesses the data, which is when Map is called.</span></span> <span data-ttu-id="a9bc3-162">Если метод Map вызывается после фактического копирования данных, потерь производительности не происходит.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-162">If the Map method is called after the data has actually been copied, no performance loss occurs.</span></span> <span data-ttu-id="a9bc3-163">С другой стороны, если метод Map вызывается до копирования данных, произойдет зависание конвейера.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-163">On the other hand, if the Map method is called before the data has been copied, then a pipeline stall will occur.</span></span>

<span data-ttu-id="a9bc3-164">Асинхронные вызовы в Direct3D 10 (которые являются подавляющим большинством методов и особенно вызовами отрисовки) хранятся в том, что называется буфером команд.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-164">Asynchronous calls in Direct3D 10 (which are the vast majority of methods, and especially rendering calls) are stored in what is called a command buffer.</span></span> <span data-ttu-id="a9bc3-165">Этот буфер является внутренним по отношению к графическому драйверу и используется для объединения в пакеты вызовов, адресованных базовому оборудованию, чтобы затратное переключение из режима пользователя в режим ядра в Microsoft Windows осуществлялось как можно реже.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-165">This buffer is internal to the graphics driver and is used to batch calls to the underlying hardware so that the costly switch from user mode to kernel mode in Microsoft Windows occurs as rarely as possible.</span></span>

<span data-ttu-id="a9bc3-166">Буфер команд очищается, вызывая переключение между режимом пользователя и режимом ядра, в одной из следующих четырех ситуаций.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-166">The command buffer is flushed, thus causing a user/kernel mode switch, in one of four situations, which are as follows.</span></span>

1.  <span data-ttu-id="a9bc3-167">Вызывается метод [**Present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) .</span><span class="sxs-lookup"><span data-stu-id="a9bc3-167">[**Present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) is called.</span></span>
2.  <span data-ttu-id="a9bc3-168">Вызывается [**ID3D10Device:: Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) .</span><span class="sxs-lookup"><span data-stu-id="a9bc3-168">[**ID3D10Device::Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) is called.</span></span>
3.  <span data-ttu-id="a9bc3-169">Буфер команд заполнен; его размер является динамичным и контролируется операционной системой и графическим драйвером.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-169">The command buffer is full; its size is dynamic and is controlled by the Operating System and the graphics driver.</span></span>
4.  <span data-ttu-id="a9bc3-170">ЦП требует доступа к результатам команды, дожидаясь выполнения в буфере команд.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-170">The CPU requires access to the results of a command waiting to execute in the command buffer.</span></span>

<span data-ttu-id="a9bc3-171">Из четырех ситуаций последняя является наиболее неблагоприятной для производительности.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-171">Of the four situations above, number four is the most critical to performance.</span></span> <span data-ttu-id="a9bc3-172">Если приложение выдает вызов [**ID3D10Device:: копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) или [**ID3D10Device:: кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) , этот вызов помещается в буфер команд.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-172">If the application issues a [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) call, this call is queued in the command buffer.</span></span> <span data-ttu-id="a9bc3-173">Если приложение пытается сопоставлять промежуточный ресурс, который был целевым объектом вызова копирования до того, как буфер команд будет сброшен, произойдет ожидание конвейера, поскольку не только вызов метода Copy должен выполняться, но все остальные буферизованные команды в буфере команд также должны выполняться.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-173">If the application then tries to map the staging resource that was the target of the copy call before the command buffer has been flushed, a pipeline stall will occur because not only does the Copy method call need to execute, but all other buffered commands in the command buffer must execute as well.</span></span> <span data-ttu-id="a9bc3-174">Это вызовет синхронизацию графического процессора и ЦП, поскольку ЦП будет ждать доступа к промежуточному ресурсу, пока графический процессор очищает буфер команд и, наконец, заполняет необходимый ЦП ресурс.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-174">This will cause the GPU and CPU to synchronize because the CPU will be waiting to access the staging resource while the GPU is emptying the command buffer and finally filling the resource the CPU needs.</span></span> <span data-ttu-id="a9bc3-175">После того как графический процессор завершит копирование, ЦП начнет осуществлять доступ к промежуточному ресурсу, однако в это время графический процессор будет находиться в состоянии простоя.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-175">Once the GPU finishes the copy, the CPU will begin accessing the staging resource, but during this time, the GPU will be sitting idle.</span></span>

<span data-ttu-id="a9bc3-176">Если делать так часто во время выполнения, производительность существенно снизится.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-176">Doing this frequently at runtime will severely degrade performance.</span></span> <span data-ttu-id="a9bc3-177">По этой причине сопоставление ресурсов, созданных с использованием по умолчанию, должно выполняться осторожно.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-177">For that reason, mapping of resources created with default usage should be done with care.</span></span> <span data-ttu-id="a9bc3-178">Приложению придется достаточно долго ожидать очищения буфера команд и завершения выполнения всех этих команд, прежде чем приложение попытается сопоставить соответствующий промежуточный ресурс.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-178">The application needs to wait long enough for the command buffer to be emptied and thus have all of those commands finish executing before it tries to map the corresponding staging resource.</span></span> <span data-ttu-id="a9bc3-179">Сколько должно ждать приложение?</span><span class="sxs-lookup"><span data-stu-id="a9bc3-179">How long should the application wait?</span></span> <span data-ttu-id="a9bc3-180">По меньшей мере два кадра, поскольку это позволит максимально эффективно использовать параллелизм между ЦП и графическим процессором.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-180">At least two frames because this will enable parallelism between the CPU(s) and the GPU to be maximally leveraged.</span></span> <span data-ttu-id="a9bc3-181">Как работает графический процессор: в то время как приложение обрабатывает кадр N, отправляя вызовы в буфер команд, графический процессор выполняет вызовы из предыдущего кадра, N-1.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-181">The way the GPU works is that while the application is processing frame N by submitting calls to the command buffer, the GPU is busy executing the calls from the previous frame, N-1.</span></span>

<span data-ttu-id="a9bc3-182">Таким образом, если приложению требуется связать ресурс, который является видеопамятью, и вызвать [**ID3D10Device:: копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) или [**ID3D10Device:: кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) в кадре n, этот вызов начнет выполняться в кадре n + 1, когда приложение отправляет вызовы для следующего кадра.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-182">So if an application wants to map a resource that originates in video memory and calls [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) at frame N, this call will actually begin to execute at frame N+1, when the application is submitting calls for the next frame.</span></span> <span data-ttu-id="a9bc3-183">Копирование необходимо завершить, когда приложение обрабатывает кадр N+2.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-183">The copy should be finished when the application is processing frame N+2.</span></span>



<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="a9bc3-184">Frame</span><span class="sxs-lookup"><span data-stu-id="a9bc3-184">Frame</span></span></th>
<th><span data-ttu-id="a9bc3-185">Состояние графического процессора/ЦП</span><span class="sxs-lookup"><span data-stu-id="a9bc3-185">GPU/CPU Status</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span data-ttu-id="a9bc3-186">Нет</span><span class="sxs-lookup"><span data-stu-id="a9bc3-186">N</span></span></td>
<td><ul>
<li><span data-ttu-id="a9bc3-187">ЦП создает вызовы отрисовки для текущего кадра.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-187">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="a9bc3-188">N+1</span><span class="sxs-lookup"><span data-stu-id="a9bc3-188">N+1</span></span></td>
<td><ul>
<li><span data-ttu-id="a9bc3-189">Графический процессор выполняет вызовы, отправленные из ЦП во время кадра N.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-189">GPU executing calls sent from CPU during frame N.</span></span></li>
<li><span data-ttu-id="a9bc3-190">ЦП создает вызовы отрисовки для текущего кадра.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-190">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="a9bc3-191">N+2</span><span class="sxs-lookup"><span data-stu-id="a9bc3-191">N+2</span></span></td>
<td><ul>
<li><span data-ttu-id="a9bc3-192">Графический процессор завершает выполнение вызовов, отправленных из ЦП во время кадра N. Результаты готовы.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-192">GPU finished executing calls sent from CPU during frame N. Results ready.</span></span></li>
<li><span data-ttu-id="a9bc3-193">Графический процессор выполняет вызовы, отправленные из ЦП во время кадра N+1.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-193">GPU executing calls sent from CPU during frame N+1.</span></span></li>
<li><span data-ttu-id="a9bc3-194">ЦП создает вызовы отрисовки для текущего кадра.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-194">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="a9bc3-195">N+3</span><span class="sxs-lookup"><span data-stu-id="a9bc3-195">N+3</span></span></td>
<td><ul>
<li><span data-ttu-id="a9bc3-196">Графический процессор завершает выполнение вызовов, отправленных из ЦП во время кадра N+1.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-196">GPU finished executing calls sent from CPU during frame N+1.</span></span> <span data-ttu-id="a9bc3-197">Результаты готовы.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-197">Results ready.</span></span></li>
<li><span data-ttu-id="a9bc3-198">Графический процессор выполняет вызовы, отправленные из ЦП во время кадра N+2.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-198">GPU executing calls sent from CPU during frame N+2.</span></span></li>
<li><span data-ttu-id="a9bc3-199">ЦП создает вызовы отрисовки для текущего кадра.</span><span class="sxs-lookup"><span data-stu-id="a9bc3-199">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="a9bc3-200">N+4</span><span class="sxs-lookup"><span data-stu-id="a9bc3-200">N+4</span></span></td>
<td><span data-ttu-id="a9bc3-201">...</span><span class="sxs-lookup"><span data-stu-id="a9bc3-201">...</span></span></td>
</tr>
</tbody>
</table>



 

## <a name="related-topics"></a><span data-ttu-id="a9bc3-202">См. также</span><span class="sxs-lookup"><span data-stu-id="a9bc3-202">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="a9bc3-203">Ресурсы (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="a9bc3-203">Resources (Direct3D 10)</span></span>](d3d10-graphics-programming-guide-resources.md)
</dt> </dl>

 

 
