---
title: Рекомендации по графической инфраструктуре DirectX (DXGI)
description: В этой статье обсуждаются проблемы с переносом ключей.
ms.assetid: 2df92ffe-1bfc-d682-2770-20cf0c831c9b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f576368674d05af74e3161d4251301ebc066a489
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104413418"
---
# <a name="directx-graphics-infrastructure-dxgi-best-practices"></a><span data-ttu-id="f7d0c-103">Графическая инфраструктура DirectX (DXGI): рекомендации</span><span class="sxs-lookup"><span data-stu-id="f7d0c-103">DirectX Graphics Infrastructure (DXGI): Best Practices</span></span>

<span data-ttu-id="f7d0c-104">Microsoft DirectX Graphics Infrastructure (DXGI) — это новая подсистема, впервые появившаяся в Windows Vista, которая инкапсулирует некоторые задачи низкого уровня, необходимые Direct3D 10 10.1, 11 и 11.1.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-104">Microsoft DirectX Graphics Infrastructure (DXGI) is a new subsystem that was introduced with Windows Vista that encapsulates some of the low-level tasks that are needed by Direct3D 10, 10.1, 11, and 11.1.</span></span> <span data-ttu-id="f7d0c-105">С точки зрения программиста Direct3D 9, DXGI охватывает большую часть кода для перечисления, создания цепочки замены и представления, которые ранее были упакованы в интерфейсы API Direct3D 9.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-105">From the perspective of a Direct3D 9 programmer, DXGI encompasses most of the code for enumeration, swap-chain creation, and presentation that previously was packed into the Direct3D 9 APIs.</span></span> <span data-ttu-id="f7d0c-106">При переносе приложения на DXGI и Direct3D 10. x и Direct3D 11. x необходимо принять во внимание некоторые аспекты, чтобы обеспечить бесперебойную работу процесса.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-106">When you port an app to DXGI and Direct3D 10.x and Direct3D 11.x, you need to take some considerations into account to ensure that the process runs smoothly.</span></span>

<span data-ttu-id="f7d0c-107">В этой статье обсуждаются проблемы с переносом ключей.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-107">This article discusses key porting issues.</span></span>

-   [<span data-ttu-id="f7d0c-108">Проблемы во всех окнах</span><span class="sxs-lookup"><span data-stu-id="f7d0c-108">Full-Screen Issues</span></span>](#full-screen-issues)
-   [<span data-ttu-id="f7d0c-109">Несколько мониторов</span><span class="sxs-lookup"><span data-stu-id="f7d0c-109">Multiple Monitors</span></span>](#multiple-monitors)
-   [<span data-ttu-id="f7d0c-110">Стили окна и DXGI</span><span class="sxs-lookup"><span data-stu-id="f7d0c-110">Window Styles and DXGI</span></span>](#window-styles-and-dxgi)
-   [<span data-ttu-id="f7d0c-111">Многопоточность и DXGI</span><span class="sxs-lookup"><span data-stu-id="f7d0c-111">Multithreading and DXGI</span></span>](#multithreading-and-dxgi)
-   [<span data-ttu-id="f7d0c-112">Гамма и DXGI</span><span class="sxs-lookup"><span data-stu-id="f7d0c-112">Gamma and DXGI</span></span>](#gamma-and-dxgi)
-   [<span data-ttu-id="f7d0c-113">DXGI 1,1</span><span class="sxs-lookup"><span data-stu-id="f7d0c-113">DXGI 1.1</span></span>](#dxgi-11)
-   [<span data-ttu-id="f7d0c-114">DXGI 1,2</span><span class="sxs-lookup"><span data-stu-id="f7d0c-114">DXGI 1.2</span></span>](#dxgi-12)

## <a name="full-screen-issues"></a><span data-ttu-id="f7d0c-115">Проблемы Full-Screen</span><span class="sxs-lookup"><span data-stu-id="f7d0c-115">Full-Screen Issues</span></span>

<span data-ttu-id="f7d0c-116">При переносе от Direct3D 9 к DXGI и до Direct3D 10. x или Direct3D 11. x проблемы, связанные с переходом от окон к полноэкранному режиму, часто могут вызвать головную боль разработчиков.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-116">In porting from Direct3D 9 to DXGI and to Direct3D 10.x or Direct3D 11.x, issues associated with moving from windowing to full-screen mode often may cause headaches for developers.</span></span> <span data-ttu-id="f7d0c-117">Основные проблемы возникают из-за того, что приложения Direct3D 9, в отличие от приложений DXGI, используют более практичный подход к отслеживанию стилей окон и состояний окон.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-117">The main problems arise because Direct3D 9 applications, unlike DXGI applications, require a more hands-on approach to tracking window styles and window states.</span></span> <span data-ttu-id="f7d0c-118">Если код, меняющийся в режиме, переносится для выполнения на DXGI, это часто приводит к непредвиденному поведению.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-118">When the mode-changing code is ported to run on DXGI, it often causes unexpected behavior.</span></span>

<span data-ttu-id="f7d0c-119">Как правило, приложения Direct3D 9 обрабатывали переход в полноэкранный режим, устанавливая разрешение переднего буфера, принудительно переключая устройство в полноэкранный режим монопольного доступа, а затем устанавливая разрешения заднего буфера в соответствие.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-119">Often, Direct3D 9 applications handled the transition into full-screen mode by setting the resolution of the front buffer, forcing the device into full-screen exclusive mode, and then setting the back buffer resolutions to match.</span></span> <span data-ttu-id="f7d0c-120">Для изменения размера окна использовался отдельный путь, так как им пришлось управлять из процесса окна, когда приложение получило \_ сообщение о размере WM.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-120">A separate path was used for changes to window size because they had to be managed from the window process whenever the application received a WM\_SIZE message.</span></span>

<span data-ttu-id="f7d0c-121">DXGI пытается упростить этот подход, объединив два варианта.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-121">DXGI attempts to simplify this approach by combining the two cases.</span></span> <span data-ttu-id="f7d0c-122">Например, при перетаскивании границы окна в оконном режиме приложение получает \_ сообщение о размере WM.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-122">For example, when the window border is dragged in windowed mode, the application receives a WM\_SIZE message.</span></span> <span data-ttu-id="f7d0c-123">DXGI перехватывает это сообщение и автоматически изменяет размер переднего буфера.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-123">DXGI intercepts this message and automatically resizes the front buffer.</span></span> <span data-ttu-id="f7d0c-124">Все, что требуется приложению — это вызвать [**идксгисвапчаин:: ресизебуфферс**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizebuffers) , чтобы изменить размер заднего буфера до размера, переданного в качестве параметров в \_ размерах WM.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-124">All that the application needs to do is call [**IDXGISwapChain::ResizeBuffers**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizebuffers) to resize the back buffer to the size that was passed as parameters in WM\_SIZE.</span></span> <span data-ttu-id="f7d0c-125">Аналогично, когда приложению нужно переключаться между полноэкранным и оконным режимом, приложение может просто вызвать [**идксгисвапчаин:: сетфуллскринстате**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate).</span><span class="sxs-lookup"><span data-stu-id="f7d0c-125">Similarly, when the application needs to switch between full-screen and windowed mode, the application can simply call [**IDXGISwapChain::SetFullscreenState**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate).</span></span> <span data-ttu-id="f7d0c-126">DXGI изменяет размер переднего буфера в соответствии с только что выбранным полноэкранным режимом и отправляет \_ приложению сообщение о размере WM.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-126">DXGI resizes the front buffer to match the newly selected full-screen mode, and it sends a WM\_SIZE message to the application.</span></span> <span data-ttu-id="f7d0c-127">Приложение снова вызывает **ресизебуфферс**, точно так же, как если бы граница окна была перемещена.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-127">The application again calls **ResizeBuffers**, just as it would if the window border was dragged.</span></span>

<span data-ttu-id="f7d0c-128">Методология предыдущего объяснения соответствует определенному пути.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-128">The methodology of the preceding explanation follows a very particular path.</span></span> <span data-ttu-id="f7d0c-129">По умолчанию DXGI устанавливает разрешение в полноэкранном режиме для разрешения рабочего стола.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-129">DXGI set the full-screen resolution to the desktop resolution by default.</span></span> <span data-ttu-id="f7d0c-130">Однако многие приложения переключаются на предпочтительное полноэкранное разрешение.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-130">Many applications, however, switch to a preferred full-screen resolution.</span></span> <span data-ttu-id="f7d0c-131">В этом случае DXGI предоставляет [**идксгисвапчаин:: ресизетаржет**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget).</span><span class="sxs-lookup"><span data-stu-id="f7d0c-131">In such a case, DXGI provides [**IDXGISwapChain::ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget).</span></span> <span data-ttu-id="f7d0c-132">Этот метод должен быть вызван перед вызовом [**сетфуллскринстате**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate).</span><span class="sxs-lookup"><span data-stu-id="f7d0c-132">This should be called before calling [**SetFullscreenState**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate).</span></span> <span data-ttu-id="f7d0c-133">Несмотря на то, что эти методы можно вызывать в обратном порядке (сначала **сетфуллскринстате** , за которым следует **ресизетаржет**), это приводит к тому, что в \_ приложение отправляется дополнительное сообщение о размере WM.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-133">Although these methods can be called in the opposite order (**SetFullscreenState** first, followed by **ResizeTarget**), doing so causes an extra WM\_SIZE message to be sent to the application.</span></span> <span data-ttu-id="f7d0c-134">(Это также может вызвать мерцание, так как DXGI может принудительно выполнить два изменения режима.) После вызова **сетфуллскринстате** рекомендуется вызвать **ресизетаржет** еще раз с членом **рефрешрате** в [**\_ режиме DXGI \_ DESC**](/previous-versions/windows/desktop/legacy/bb173064(v=vs.85)) zerod. Это количество для инструкции без операций в DXGI, но оно может избежать проблем с частотой обновления, которые обсуждаются далее.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-134">(Doing so can also cause flickering, since DXGI could be forced to perform two mode changes.) After calling **SetFullscreenState**, it is advisable to call **ResizeTarget** again with the **RefreshRate** member of [**DXGI\_MODE\_DESC**](/previous-versions/windows/desktop/legacy/bb173064(v=vs.85)) zeroed out. This amounts to a no-operation instruction in DXGI, but it can avoid issues with the refresh rate, which are discussed next.</span></span>

<span data-ttu-id="f7d0c-135">В полноэкранном режиме диспетчер окон рабочего стола (DWM) отключен.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-135">When in full-screen mode, the Desktop Window Manager (DWM) is disabled.</span></span> <span data-ttu-id="f7d0c-136">DXGI может выполнить перелистывание, чтобы отобразить содержимое заднего буфера вместо выполнения Блит, которое было бы выполнено в оконном режиме.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-136">DXGI can perform a flip to present the back buffer contents instead of doing a blit, which it would do in windowed mode.</span></span> <span data-ttu-id="f7d0c-137">Однако это повышение производительности можно отменить, если определенные требования не выполнены.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-137">This performance gain can be undone, however, if certain requirements are not met.</span></span> <span data-ttu-id="f7d0c-138">Чтобы убедиться, что объект DXGI выполняет перелистывание вместо Блит, размер переднего буфера и заднего буфера должен быть одинаковым.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-138">To ensure that DXGI does a flip instead of a blit, the front buffer and back buffer must be sized identically.</span></span> <span data-ttu-id="f7d0c-139">Если приложение правильно обрабатывает \_ сообщения размером WM, это не должно быть проблемой.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-139">If the application correctly handles its WM\_SIZE messages, this should not be a problem.</span></span> <span data-ttu-id="f7d0c-140">Кроме того, форматы должны быть одинаковыми.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-140">Also, the formats must be identical.</span></span>

<span data-ttu-id="f7d0c-141">Проблема для большинства приложений заключается в частоте обновления.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-141">The problem for most applications is the refresh rate.</span></span> <span data-ttu-id="f7d0c-142">Частота обновления, указанная в вызове [**ресизетаржет**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) , должна быть частотой обновления, перечисленной объектом [**идксгиаутпут**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) , используемым цепочкой подкачки.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-142">The refresh rate that is specified in the call to [**ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) must be a refresh rate that is enumerated by the [**IDXGIOutput**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) object that the swap chain is using.</span></span> <span data-ttu-id="f7d0c-143">DXGI может автоматически вычислить это значение, если приложение отнулиет член **рефрешрате** в [**\_ режиме DXGI \_ DESC**](/previous-versions/windows/desktop/legacy/bb173064(v=vs.85)) , переданном в **ресизетаржет**.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-143">DXGI can automatically calculate this value if the application zeroes out the **RefreshRate** member of [**DXGI\_MODE\_DESC**](/previous-versions/windows/desktop/legacy/bb173064(v=vs.85)) that is passed into **ResizeTarget**.</span></span> <span data-ttu-id="f7d0c-144">Важно не рассчитывать, что определенные частоты обновления всегда будут поддерживаться и просто жестко закодировать значение.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-144">It is important not to assume that certain refresh rates will always be supported and to simply hard-code a value.</span></span> <span data-ttu-id="f7d0c-145">Часто разработчики выбирают в качестве частоты обновления 60 Гц, не зная, что частота обновления с монитора составляет приблизительно 60 000/1 001 Гц от монитора.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-145">Often, developers choose 60 Hz as the refresh rate, not knowing that the enumerated refresh rate from the monitor is approximately 60,000 / 1,001 Hz from the monitor.</span></span> <span data-ttu-id="f7d0c-146">Если частота обновления не совпадает с ожидаемой частотой обновления 60, то DXGI вынуждена выполнить Блит в полноэкранном режиме, а не в виде зеркального отображения.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-146">If the refresh rate does not match the expected refresh rate of 60, DXGI is forced to perform a blit in full-screen mode instead of a flip.</span></span>

<span data-ttu-id="f7d0c-147">Последней проблемой, которую часто сталкиваются разработчики, является изменение разрешения полноэкранного режима в полноэкранном режиме.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-147">The last issue that developers often face is how to change full-screen resolutions while remaining in full-screen mode.</span></span> <span data-ttu-id="f7d0c-148">Иногда вызов [**ресизетаржет**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) и [**сетфуллскринстате**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate) происходит с ошибкой, но полное разрешение экрана остается разрешением рабочего стола.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-148">Calling [**ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) and [**SetFullscreenState**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate) sometimes succeeds, but the full-screen resolution remains the desktop resolution.</span></span> <span data-ttu-id="f7d0c-149">Кроме того, разработчики могут создать цепочку полноэкранного буфера обмена и дать определенное разрешение, чтобы обнаружить, что DXGI по умолчанию имеет разрешение рабочего стола, независимо от числа переданных.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-149">Also, developers may create a full-screen swap chain and give a specific resolution, only to find that DXGI defaults to the desktop resolution regardless of the numbers passed in.</span></span> <span data-ttu-id="f7d0c-150">Если не указано иное, в режиме DXGI по умолчанию используется разрешение рабочего стола для всех цепочек подкачки.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-150">Unless otherwise instructed, DXGI defaults to the desktop resolution for full-screen swap chains.</span></span> <span data-ttu-id="f7d0c-151">При создании цепи подкачки для полноэкранного режима элемент **flags** в [**\_ \_ цепочке \_ перекачки DXGI**](/windows/desktop/api/dxgi/ns-dxgi-dxgi_swap_chain_desc) имеет значение, чтобы [**\_ \_ \_ \_ \_ \_ Переключить**](/windows/desktop/api/dxgi/ne-dxgi-dxgi_swap_chain_flag) поведение DXGI по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-151">When creating a full-screen swap chain, the **Flags** member of the [**DXGI\_SWAP\_CHAIN\_DESC**](/windows/desktop/api/dxgi/ns-dxgi-dxgi_swap_chain_desc) structure must be set to [**DXGI\_SWAP\_CHAIN\_FLAG\_ALLOW\_MODE\_SWITCH**](/windows/desktop/api/dxgi/ne-dxgi-dxgi_swap_chain_flag) to override DXGI's default behavior.</span></span> <span data-ttu-id="f7d0c-152">Этот флаг также можно передать в **ресизетаржет** , чтобы включить или отключить эту функцию динамически.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-152">This flag also can be passed to **ResizeTarget** to enable or disable this functionality dynamically.</span></span>

## <a name="multiple-monitors"></a><span data-ttu-id="f7d0c-153">Несколько мониторов</span><span class="sxs-lookup"><span data-stu-id="f7d0c-153">Multiple Monitors</span></span>

<span data-ttu-id="f7d0c-154">При использовании DXGI с несколькими мониторами необходимо выполнить два правила.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-154">When using DXGI with multiple monitors, there are two rules to follow.</span></span>

<span data-ttu-id="f7d0c-155">Первое правило применяется к созданию двух или более цепочек подкачки в полноэкранном режиме на нескольких мониторах.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-155">The first rule applies to the creation of two or more full-screen swap chains on multiple monitors.</span></span> <span data-ttu-id="f7d0c-156">При создании таких цепочек подкачки лучше всего создать все цепочки подкачки в окне, а затем установить их в полноэкранном режиме.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-156">When creating such swap chains, it is best to create all swap chains as windowed, and then to set them to full-screen.</span></span> <span data-ttu-id="f7d0c-157">Если цепочки буферов размещаются в полноэкранном режиме, создание второй цепочки подкачки приведет к отправке изменения режима в первую цепочку буферов, что может привести к завершению полноэкранного режима.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-157">If swap chains are created in full-screen mode, the creation of a second swap chain causes a mode change to be sent to the first swap chain, which could cause termination of full-screen mode.</span></span>

<span data-ttu-id="f7d0c-158">Второе правило применяется к выходам.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-158">The second rule applies to outputs.</span></span> <span data-ttu-id="f7d0c-159">Ватчфул выходные данные, используемые при создании цепочек подкачки.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-159">Be watchful of outputs used when creating swap chains.</span></span> <span data-ttu-id="f7d0c-160">С помощью DXGI объект [**идксгиаутпут**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) управляет тем, какой монитор использует цепочка буферов, когда становится полноэкранным.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-160">With DXGI, the [**IDXGIOutput**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) object controls which monitor the swap chain uses when becoming full-screen.</span></span> <span data-ttu-id="f7d0c-161">В отличие от DXGI, Direct3D 9 не имел концепции выходов.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-161">Unlike DXGI, Direct3D 9 had no concept of outputs.</span></span>

## <a name="window-styles-and-dxgi"></a><span data-ttu-id="f7d0c-162">Стили окна и DXGI</span><span class="sxs-lookup"><span data-stu-id="f7d0c-162">Window Styles and DXGI</span></span>

<span data-ttu-id="f7d0c-163">Приложениям Direct3D 9 во время переключения между полноэкранными и оконными режимами было много работы.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-163">Direct3D 9 applications had a lot of work to do when switching between full-screen and windowed modes.</span></span> <span data-ttu-id="f7d0c-164">Большая часть этой работы включала изменение стилей окна для добавления и удаления границ, добавления полос прокрутки и т. д.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-164">Much of this work involved changing window styles to add and remove borders, to add scrollbars, and so on.</span></span> <span data-ttu-id="f7d0c-165">При переносе приложений в DXGI и Direct3D 10. x или Direct3D 11. x этот код часто остается на месте.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-165">When applications are ported to DXGI and Direct3D 10.x or Direct3D 11.x, this code often is left in place.</span></span> <span data-ttu-id="f7d0c-166">В зависимости от сделанных изменений переключение между режимами может привести к непредвиденному поведению.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-166">Depending on the changes being made, switching between modes can cause unexpected behavior.</span></span> <span data-ttu-id="f7d0c-167">Например, при переключении в оконный режим приложение может больше не иметь границы окна или окна, несмотря на наличие кода, который специально задает эти стили.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-167">For example, when switching to windowed mode, the application might no longer have a window frame or window border despite having code that specifically sets these styles.</span></span> <span data-ttu-id="f7d0c-168">Это происходит потому, что DXGI теперь обрабатывает большую часть этого стиля, изменяемую самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-168">This occurs because DXGI now handles much of this style changing on its own.</span></span> <span data-ttu-id="f7d0c-169">Настройка стилей окна вручную может помешать работе DXGI, и это может привести к непредвиденному поведению.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-169">Manual setting of window styles can interfere with DXGI, and this can cause unexpected behavior.</span></span>

<span data-ttu-id="f7d0c-170">Рекомендуется сделать как можно меньше работы и позволить DXGI работать с окнами большей части взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-170">The recommended behavior is to do as little work as possible, and to let DXGI handle most of the interaction with the windows.</span></span> <span data-ttu-id="f7d0c-171">Однако если приложению требуется обрабатывать собственное поведение окон, [**идксгифактори:: макевиндовассоЦиатион**](/windows/desktop/api/dxgi/nf-dxgi-idxgifactory-makewindowassociation) можно использовать, чтобы сообщить DXGI о необходимости отключить часть ее автоматической обработки окон.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-171">However, if the application needs to handle its own windowing behavior, [**IDXGIFactory::MakeWindowAssociation**](/windows/desktop/api/dxgi/nf-dxgi-idxgifactory-makewindowassociation) can be used to tell DXGI to disable some of its automatic window handling.</span></span>

## <a name="multithreading-and-dxgi"></a><span data-ttu-id="f7d0c-172">Многопоточность и DXGI</span><span class="sxs-lookup"><span data-stu-id="f7d0c-172">Multithreading and DXGI</span></span>

<span data-ttu-id="f7d0c-173">В многопоточных приложениях использовать DXGI необходимо с особой осторожностью во избежание возникновения взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-173">Special care must be taken when using DXGI in a multithreaded application to ensure that deadlocks do not occur.</span></span> <span data-ttu-id="f7d0c-174">Из-за того, что в связи с тем, что взаимодействие с приложением DXGI связано с окнами, оно иногда отправляет сообщения окна в соответствующее окно приложения.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-174">Because of DXGI's close interaction with windowing, it occasionally sends window messages to the associated application window.</span></span> <span data-ttu-id="f7d0c-175">Для выполнения функции DXGI необходимо, чтобы изменения происходили до того, как они будут продолжены, поэтому он будет использовать [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage), который является синхронным вызовом.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-175">DXGI needs the windowing changes to occur before it can continue, so it will use [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage), which is a synchronous call.</span></span> <span data-ttu-id="f7d0c-176">Приложение должно обработать сообщение окна перед возвратом **SendMessage** .</span><span class="sxs-lookup"><span data-stu-id="f7d0c-176">The application must process the window message before **SendMessage** returns.</span></span>

<span data-ttu-id="f7d0c-177">В приложении, в котором вызовы DXGI и конвейер сообщений находятся в одном потоке (или в приложении с одним потоком), необходимо выполнить небольшие действия.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-177">In an application where DXGI calls and the message pump are on the same thread (or a single-threaded application), little needs to be done.</span></span> <span data-ttu-id="f7d0c-178">Когда вызов DXGI находится в том же потоке, что и конвейер сообщений, [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) вызывает [*WindowProc*](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85))окна.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-178">When the DXGI call is on the same thread as the message pump, [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) calls the window's [*WindowProc*](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)).</span></span> <span data-ttu-id="f7d0c-179">Это обходит конвейер сообщений и позволяет продолжить выполнение после вызова **SendMessage**.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-179">This bypasses the message pump, and allows execution to continue after the call to **SendMessage**.</span></span> <span data-ttu-id="f7d0c-180">Помните, что вызовы [**идксгисвапчаин**](/windows/desktop/api/dxgi/nn-dxgi-idxgiswapchain) , такие как [**идксгисвапчаин::P**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-present)повторной отправки, также считаются вызовами DXGI. DXGI может отложить работу от [**ресизебуфферс**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizebuffers) или [**Ресизетаржет**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) до вызова **Present** .</span><span class="sxs-lookup"><span data-stu-id="f7d0c-180">Remember that [**IDXGISwapChain**](/windows/desktop/api/dxgi/nn-dxgi-idxgiswapchain) calls, such as [**IDXGISwapChain::Present**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-present), are also considered DXGI calls; DXGI may defer work from [**ResizeBuffers**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizebuffers) or [**ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) until **Present** is called.</span></span>

<span data-ttu-id="f7d0c-181">Если вызов и генератор сообщений DXGI находятся в разных потоках, необходимо соблюдать осторожность, чтобы избежать взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-181">If the DXGI call and message pump are on different threads, care must be taken to avoid deadlocks.</span></span> <span data-ttu-id="f7d0c-182">Когда конвейер сообщений и SendMessage находятся в разных потоках, [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) добавляет сообщение в очередь сообщений окна и ожидает, пока окно не обработает это сообщение.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-182">When the message pump and SendMessage are on different threads, [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) adds a message to the window's message queue, and waits for the window to process that message.</span></span> <span data-ttu-id="f7d0c-183">Если процедура окна занята или не вызвана конвейером сообщений, сообщение может быть не обработано, а DXGI будет ждать бесконечно.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-183">If the window procedure is busy or is not called by the message pump, the message may never get processed and DXGI will wait indefinitely.</span></span>

<span data-ttu-id="f7d0c-184">Например, если приложение с конвейером сообщений находится в одном потоке и его отрисовке на другом, может потребоваться изменить режимы.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-184">For example, if an application that has its message pump on one thread and its rendering on another, it may want to change modes.</span></span> <span data-ttu-id="f7d0c-185">Поток конвейера сообщений сообщает потоку отрисовки об изменении режимов и ожидает завершения изменения режима.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-185">The message pump thread tells the rendering thread to change modes, and waits until the mode change is complete.</span></span> <span data-ttu-id="f7d0c-186">Однако поток отрисовки вызывает функции DXGI, которые, в свою очередь, вызывают [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage), которые блокируют, пока конвейер сообщений не обработает сообщение.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-186">However, the rendering thread calls DXGI functions, which in turn call [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage), which blocks until the message pump processes the message.</span></span> <span data-ttu-id="f7d0c-187">Взаимоблокировка возникает потому, что оба потока заблокированы и ожидают друг друга.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-187">A deadlock occurs because both threads now are blocked, and are waiting on each other.</span></span> <span data-ttu-id="f7d0c-188">Чтобы избежать этого, никогда не блокируйте конвейер сообщений.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-188">To avoid this, never block the message pump.</span></span> <span data-ttu-id="f7d0c-189">Если блок недоступен, все взаимодействие с DXGI должно выполняться в том же потоке, что и конвейер сообщений.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-189">If a block is unavoidable, then all DXGI interaction should occur on the same thread as the message pump.</span></span>

## <a name="gamma-and-dxgi"></a><span data-ttu-id="f7d0c-190">Гамма и DXGI</span><span class="sxs-lookup"><span data-stu-id="f7d0c-190">Gamma and DXGI</span></span>

<span data-ttu-id="f7d0c-191">Хотя гамма может быть лучше обработана в Direct3D 10. x или Direct3D 11. x с помощью текстур SRGB, гамма-шкала все еще может быть полезной для разработчиков, которым требуется другое значение гаммы, чем 2,2, или использование формата целевого объекта прорисовки, не поддерживающего SRGB.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-191">Although gamma may be best handled in Direct3D 10.x or Direct3D 11.x by using SRGB textures, the gamma ramp still can be useful to developers who want a different gamma value than 2.2 or who are using a render target format that does not support SRGB.</span></span> <span data-ttu-id="f7d0c-192">При настройке гамма-шкалы с помощью DXGI необходимо учитывать две проблемы.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-192">Be aware of two issues when setting the gamma ramp through DXGI.</span></span> <span data-ttu-id="f7d0c-193">Первая причина заключается в том, что значения пандуса, передаваемые в [**идксгиаутпут:: сетгаммаконтрол**](/windows/desktop/api/dxgi/nf-dxgi-idxgioutput-setgammacontrol) , являются значениями с плавающей запятой, а не значениями **слов** .</span><span class="sxs-lookup"><span data-stu-id="f7d0c-193">The first issue is that the ramp values passed into [**IDXGIOutput::SetGammaControl**](/windows/desktop/api/dxgi/nf-dxgi-idxgioutput-setgammacontrol) are float values, not **WORD** values.</span></span> <span data-ttu-id="f7d0c-194">Кроме того, убедитесь, что код, перенесенный с Direct3D 9, не пытается преобразовать их в значения **слов** , прежде чем передавать их в **сетгаммаконтрол**.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-194">Also, ensure that code ported from Direct3D 9 does not try to convert to **WORD** values before passing these to **SetGammaControl**.</span></span>

<span data-ttu-id="f7d0c-195">Вторая ситуация заключается в том, что после перехода на полноэкранный режим [**сетгаммаконтрол**](/windows/desktop/api/dxgi/nf-dxgi-idxgioutput-setgammacontrol) может не работать, в зависимости от используемого объекта [**идксгиаутпут**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) .</span><span class="sxs-lookup"><span data-stu-id="f7d0c-195">The second issue is that, after changing to full-screen mode, [**SetGammaControl**](/windows/desktop/api/dxgi/nf-dxgi-idxgioutput-setgammacontrol) may not appear to work, dependent on the [**IDXGIOutput**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) object being used.</span></span> <span data-ttu-id="f7d0c-196">При переходе на полноэкранный режим DXGI создает новый выходной объект и использует объект для всех последующих операций с выходными данными.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-196">When changing to full-screen mode, DXGI creates a new output object, and uses the object for all subsequent operations on the output.</span></span> <span data-ttu-id="f7d0c-197">При вызове **сетгаммаконтрол** для выходных данных, перечисленных перед переключением в полноэкранный режим, вызов не направлен к выходным данным, используемым DXGI в данный момент.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-197">If calling **SetGammaControl** on an output that is enumerated before a full-screen mode switch, the call is not directed toward the output that DXGI is using currently.</span></span> <span data-ttu-id="f7d0c-198">Чтобы избежать этого, вызовите метод [**идксгисвапчаин:: жетконтаинингаутпут**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-getcontainingoutput) , чтобы получить текущие выходные данные, а затем вызовите **сетгаммаконтрол** из этих выходных данных, чтобы получить правильное поведение.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-198">To avoid this, call [**IDXGISwapChain::GetContainingOutput**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-getcontainingoutput) to get the current output, and then call **SetGammaControl** off this output to get the correct behavior.</span></span>

<span data-ttu-id="f7d0c-199">Сведения об использовании гамма-коррекции см. [в разделе Использование гамма-коррекции](/windows/desktop/direct3ddxgi/using-gamma-correction).</span><span class="sxs-lookup"><span data-stu-id="f7d0c-199">For info about using gamma correction, see [Using gamma correction](/windows/desktop/direct3ddxgi/using-gamma-correction).</span></span>

## <a name="dxgi-11"></a><span data-ttu-id="f7d0c-200">DXGI 1,1</span><span class="sxs-lookup"><span data-stu-id="f7d0c-200">DXGI 1.1</span></span>

<span data-ttu-id="f7d0c-201">Среда выполнения Direct3D 11, включенная в Windows 7 и установленная на Windows Vista (см. [KB971644](https://support.microsoft.com/kb/971644)), включает в себя версию 1,1 для DXGI.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-201">The Direct3D 11 runtime included in Windows 7 and installed onto Windows Vista (see [KB971644](https://support.microsoft.com/kb/971644)) includes version 1.1 of DXGI.</span></span> <span data-ttu-id="f7d0c-202">Это обновление добавляет определения для ряда новых форматов (особенно BGRA, 10-разрядного смещения x2 и BC6H и BC7 для сжатия текстур Direct3D 11), а также новую версию фабрики DXGI и интерфейсов адаптеров ([**CreateDXGIFactory1**](/windows/desktop/api/dxgi/nf-dxgi-createdxgifactory1), [**IDXGIFactory1**](/windows/desktop/api/dxgi/nn-dxgi-idxgifactory1), [**IDXGIAdapter1**](/windows/desktop/api/dxgi/nn-dxgi-idxgiadapter1)) для перечисления подключений к удаленному рабочему столу.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-202">This update adds definitions for a number of new formats (particularly BGRA, 10-bit X2 bias, and Direct3D 11's BC6H and BC7 texture compression), as well as a new version of the DXGI factory and adapter interfaces ([**CreateDXGIFactory1**](/windows/desktop/api/dxgi/nf-dxgi-createdxgifactory1), [**IDXGIFactory1**](/windows/desktop/api/dxgi/nn-dxgi-idxgifactory1), [**IDXGIAdapter1**](/windows/desktop/api/dxgi/nn-dxgi-idxgiadapter1)) for enumerating remote desktop connections.</span></span>

<span data-ttu-id="f7d0c-203">При использовании Direct3D 11 среда выполнения по умолчанию будет использовать DXGI 1,1 при вызове [**D3D11CreateDevice**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdevice) или [**D3D11CreateDeviceAndSwapChain**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdeviceandswapchain) с пустым указателем [**идксгиадаптер**](/windows/desktop/api/dxgi/nn-dxgi-idxgiadapter) .</span><span class="sxs-lookup"><span data-stu-id="f7d0c-203">When you use Direct3D 11, the runtime will use DXGI 1.1 by default when calling [**D3D11CreateDevice**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdevice) or [**D3D11CreateDeviceAndSwapChain**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdeviceandswapchain) with a NULL [**IDXGIAdapter**](/windows/desktop/api/dxgi/nn-dxgi-idxgiadapter) pointer.</span></span> <span data-ttu-id="f7d0c-204">Смешивание использования DXGI 1,0 и DXGI 1,1 в одном процессе не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-204">Mixing use of DXGI 1.0 and DXGI 1.1 in the same process is not supported.</span></span> <span data-ttu-id="f7d0c-205">Смешивание экземпляров объектов DXGI из разных фабрик в одном процессе также не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-205">Mixing DXGI object instances from different factories in the same process also is not supported.</span></span> <span data-ttu-id="f7d0c-206">Таким образом, при использовании DirectX 11 любое явное использование интерфейсов DXGI использует [**IDXGIFactory1**](/windows/desktop/api/dxgi/nn-dxgi-idxgifactory1) , созданную точкой входа [**CreateDXGIFactory1**](/windows/desktop/api/dxgi/nf-dxgi-createdxgifactory1) в "DXGI.DLL", чтобы гарантировать, что приложение всегда использует DXGI 1,1.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-206">Therefore, when you use DirectX 11, any explicit use of the DXGI interfaces uses a [**IDXGIFactory1**](/windows/desktop/api/dxgi/nn-dxgi-idxgifactory1) created by the [**CreateDXGIFactory1**](/windows/desktop/api/dxgi/nf-dxgi-createdxgifactory1) entry-point in “DXGI.DLL” to ensure the application is always using DXGI 1.1.</span></span>

## <a name="dxgi-12"></a><span data-ttu-id="f7d0c-207">DXGI 1,2</span><span class="sxs-lookup"><span data-stu-id="f7d0c-207">DXGI 1.2</span></span>

<span data-ttu-id="f7d0c-208">Среда выполнения Direct3D 11,1, входящая в состав Windows 8, также включает версию 1,2 для DXGI.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-208">The Direct3D 11.1 runtime that is included in Windows 8 also includes version 1.2 of DXGI.</span></span>

<span data-ttu-id="f7d0c-209">DXGI 1,2 включает следующие функции.</span><span class="sxs-lookup"><span data-stu-id="f7d0c-209">DXGI 1.2 enables these features:</span></span>

-   <span data-ttu-id="f7d0c-210">стерео отрисовка</span><span class="sxs-lookup"><span data-stu-id="f7d0c-210">stereo rendering</span></span>
-   <span data-ttu-id="f7d0c-211">16-разрядные форматы на пиксель</span><span class="sxs-lookup"><span data-stu-id="f7d0c-211">16 bit-per-pixel formats</span></span>

    -   <span data-ttu-id="f7d0c-212">\_Формат DXGI \_ B5G6R5 \_ UNORM и DXGI \_ \_ B5G5R5A1 \_ UNORM теперь полностью поддерживаются</span><span class="sxs-lookup"><span data-stu-id="f7d0c-212">DXGI\_FORMAT\_B5G6R5\_UNORM and DXGI\_FORMAT\_B5G5R5A1\_UNORM are now fully supported</span></span>
    -   <span data-ttu-id="f7d0c-213">\_ \_ добавлен новый \_ Формат B5G5R5A1 UNORM в формате DXGI</span><span class="sxs-lookup"><span data-stu-id="f7d0c-213">a new DXGI\_FORMAT\_B5G5R5A1\_UNORM format was added</span></span>

-   <span data-ttu-id="f7d0c-214">форматы видео</span><span class="sxs-lookup"><span data-stu-id="f7d0c-214">video formats</span></span>
-   <span data-ttu-id="f7d0c-215">новые интерфейсы DXGI</span><span class="sxs-lookup"><span data-stu-id="f7d0c-215">new DXGI interfaces</span></span>

<span data-ttu-id="f7d0c-216">Дополнительные сведения о возможностях DXGI 1,2 см. в разделе [улучшения dxgi 1,2](/windows/desktop/direct3ddxgi/dxgi-1-2-improvements).</span><span class="sxs-lookup"><span data-stu-id="f7d0c-216">For more info about DXGI 1.2 features, see [DXGI 1.2 Improvements](/windows/desktop/direct3ddxgi/dxgi-1-2-improvements).</span></span>

 

 