---
title: Использование шейдеров в Direct3D 9
description: Использование шейдеров в Direct3D 9
ms.assetid: 8d8f5124-fbf3-4af5-8399-43ba28aa6eb9
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 6455b47d24c1c83683ce8b85c48990bb32e221ae
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104997047"
---
# <a name="using-shaders-in-direct3d-9"></a><span data-ttu-id="66900-103">Использование шейдеров в Direct3D 9</span><span class="sxs-lookup"><span data-stu-id="66900-103">Using Shaders in Direct3D 9</span></span>

-   [<span data-ttu-id="66900-104">Компиляция шейдера для определенного оборудования</span><span class="sxs-lookup"><span data-stu-id="66900-104">Compiling a Shader for Specific Hardware</span></span>](#compiling-a-shader-for-specific-hardware)
-   [<span data-ttu-id="66900-105">Инициализация констант шейдера</span><span class="sxs-lookup"><span data-stu-id="66900-105">Initializing Shader Constants</span></span>](#initializing-shader-constants)
-   [<span data-ttu-id="66900-106">Привязка параметра шейдера к определенному регистру</span><span class="sxs-lookup"><span data-stu-id="66900-106">Binding a Shader Parameter to a Particular Register</span></span>](#binding-a-shader-parameter-to-a-particular-register)
-   [<span data-ttu-id="66900-107">Визуализация программируемого шейдера</span><span class="sxs-lookup"><span data-stu-id="66900-107">Rendering a Programmable Shader</span></span>](#rendering-a-programmable-shader)
-   [<span data-ttu-id="66900-108">Отладка шейдеров</span><span class="sxs-lookup"><span data-stu-id="66900-108">Debugging Shaders</span></span>](#debugging-shaders)
-   [<span data-ttu-id="66900-109">См. также</span><span class="sxs-lookup"><span data-stu-id="66900-109">Related topics</span></span>](#related-topics)

## <a name="compiling-a-shader-for-specific-hardware"></a><span data-ttu-id="66900-110">Компиляция шейдера для определенного оборудования</span><span class="sxs-lookup"><span data-stu-id="66900-110">Compiling a Shader for Specific Hardware</span></span>

<span data-ttu-id="66900-111">Шейдеры впервые были добавлены в Microsoft DirectX в DirectX 8,0.</span><span class="sxs-lookup"><span data-stu-id="66900-111">Shaders were first added to Microsoft DirectX in DirectX 8.0.</span></span> <span data-ttu-id="66900-112">В этот момент было определено несколько виртуальных машин шейдеров, каждое из которых примерно соответствует конкретному графическому процессору, созданному ведущими поставщиками трехмерной графики.</span><span class="sxs-lookup"><span data-stu-id="66900-112">At that time, several virtual shader machines were defined, each roughly corresponding to a particular graphics processor produced by the top 3D graphics vendors.</span></span> <span data-ttu-id="66900-113">Для каждого из этих виртуальных машин шейдеров был разработан язык сборки.</span><span class="sxs-lookup"><span data-stu-id="66900-113">For each of these virtual shader machines, an assembly language was designed.</span></span> <span data-ttu-id="66900-114">Программы, написанные на моделях шейдеров (имена VS 1 \_ \_ и PS \_ 1 \_ 1-PS \_ 1 \_ 4) относительно короткие и обычно пишутся разработчиками непосредственно на соответствующем языке ассемблера.</span><span class="sxs-lookup"><span data-stu-id="66900-114">Programs written to the shader models (names vs\_1\_1 and ps\_1\_1 - ps\_1\_4) were relatively short and were generally written by developers directly in the appropriate assembly language.</span></span> <span data-ttu-id="66900-115">Приложение передает этот код на языке ассемблера в библиотеку D3DX с помощью [**D3DXAssembleShader**](/windows/desktop/direct3d9/d3dxassembleshader) и возвращает обратное двоичное представление шейдера, который, в свою очередь, передается с помощью [**креатевертексшадер**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexshader) или [**креатепикселшадер**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createpixelshader).</span><span class="sxs-lookup"><span data-stu-id="66900-115">The application would pass this human-readable assembly language code to the D3DX library using [**D3DXAssembleShader**](/windows/desktop/direct3d9/d3dxassembleshader) and get back a binary representation of the shader which would in turn get passed using [**CreateVertexShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexshader) or [**CreatePixelShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createpixelshader).</span></span> <span data-ttu-id="66900-116">Дополнительные сведения см. в разделе пакет средств разработки программного обеспечения (SDK).</span><span class="sxs-lookup"><span data-stu-id="66900-116">For more detail, see the software development kit (SDK).</span></span>

<span data-ttu-id="66900-117">Ситуация в Direct3D 9 аналогична.</span><span class="sxs-lookup"><span data-stu-id="66900-117">The situation in Direct3D 9 is similar.</span></span> <span data-ttu-id="66900-118">Приложение передает Шейдер HLSL в D3DX с помощью [**D3DXCompileShader**](/windows/desktop/direct3d9/d3dxcompileshader) и возвращает двоичное представление скомпилированного шейдера, которое, в свою очередь, передается в Microsoft Direct3D с помощью [**креатепикселшадер**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createpixelshader) или [**креатевертексшадер**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexshader).</span><span class="sxs-lookup"><span data-stu-id="66900-118">An application passes an HLSL shader to D3DX using [**D3DXCompileShader**](/windows/desktop/direct3d9/d3dxcompileshader) and gets back a binary representation of the compiled shader which in turn is passed to Microsoft Direct3D using [**CreatePixelShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createpixelshader) or [**CreateVertexShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexshader).</span></span> <span data-ttu-id="66900-119">Среда выполнения не знает ничего о HLSL, а только в двоичные модели шейдера сборки.</span><span class="sxs-lookup"><span data-stu-id="66900-119">The runtime does not know anything about HLSL, only the binary assembly shader models.</span></span> <span data-ttu-id="66900-120">Это замечательно, так как это означает, что компилятор HLSL можно обновить независимо от среды выполнения Direct3D.</span><span class="sxs-lookup"><span data-stu-id="66900-120">This is nice because it means that the HLSL compiler can be updated independent of the Direct3D runtime.</span></span> <span data-ttu-id="66900-121">Шейдеры можно также компилировать в автономном режиме с помощью [fxc](/windows/desktop/direct3dtools/fxc).</span><span class="sxs-lookup"><span data-stu-id="66900-121">You can also compile shaders offline using [fxc](/windows/desktop/direct3dtools/fxc).</span></span>

<span data-ttu-id="66900-122">Помимо разработки компилятора HLSL, Direct3D 9 также представил модели шейдеров на уровне сборки, чтобы предоставить функциональные возможности новейшего поколения графического оборудования.</span><span class="sxs-lookup"><span data-stu-id="66900-122">In addition to the development of the HLSL compiler, Direct3D 9 also introduced the assembly-level shader models to expose the functionality of the latest generation of graphics hardware.</span></span> <span data-ttu-id="66900-123">Разработчики приложений могут работать в сборке для этих новых моделей (VS \_ 2 \_ 0, VS \_ 3 \_ 0, PS \_ 2 \_ 0, PS \_ 3 \_ 0), но мы планируем, чтобы большинство разработчиков переместились на HLSL для разработки шейдеров.</span><span class="sxs-lookup"><span data-stu-id="66900-123">Application developers can work in assembly for these new models (vs\_2\_0, vs\_3\_0, ps\_2\_0, ps\_3\_0) but we expect most developers to move to HLSL for shader development.</span></span>

<span data-ttu-id="66900-124">Разумеется, возможность написания программы HLSL для выражения определенного алгоритма затенения не позволяет автоматически запускать его на любом конкретном оборудовании.</span><span class="sxs-lookup"><span data-stu-id="66900-124">Of course, the ability to write an HLSL program to express a particular shading algorithm does not automatically enable it to run on any given hardware.</span></span> <span data-ttu-id="66900-125">Приложение вызывает D3DX для компиляции шейдера в двоичный код сборки с помощью [**D3DXCompileShader**](/windows/desktop/direct3d9/d3dxcompileshader).</span><span class="sxs-lookup"><span data-stu-id="66900-125">An application calls D3DX to compile a shader into binary assembly code with [**D3DXCompileShader**](/windows/desktop/direct3d9/d3dxcompileshader).</span></span> <span data-ttu-id="66900-126">Одним из ограничений этой точки входа является параметр, определяющий, какие модели уровня сборки (или цели компиляции) компилятор HLSL должен использовать для выражения окончательного кода шейдера.</span><span class="sxs-lookup"><span data-stu-id="66900-126">One of the limitations with this entry point is a parameter that defines which of the assembly-level models (or compilation targets) the HLSL compiler should use to express the final shader code.</span></span> <span data-ttu-id="66900-127">Если приложение выполняет компиляцию шейдера HLSL во время выполнения (в отличие от времени компиляции или вне сети), приложение может проверить возможности устройства Direct3D и выбрать цель компиляции для сопоставления.</span><span class="sxs-lookup"><span data-stu-id="66900-127">If an application is doing HLSL shader compilation at run time (as opposed to compile time or offline), the application could examine the capabilities of the Direct3D device and select the compilation target to match.</span></span> <span data-ttu-id="66900-128">Если алгоритм, выраженный в шейдере HLSL, слишком сложен для выполнения в выбранном целевом объекте компиляции, произойдет сбой компиляции.</span><span class="sxs-lookup"><span data-stu-id="66900-128">If the algorithm expressed in the HLSL shader is too complex to execute on the selected compilation target, compilation will fail.</span></span> <span data-ttu-id="66900-129">Это означает, что хотя HLSL является огромным преимуществом для разработки шейдеров, он не позволяет разработчикам из реалииных игр в целевую аудиторию с графическими устройствами с различной функциональностью.</span><span class="sxs-lookup"><span data-stu-id="66900-129">This means that while HLSL is a huge benefit to shader development, it does not free developers from the realities of shipping games to a target audience with graphics devices of varying capabilities.</span></span> <span data-ttu-id="66900-130">Разработчику игр по-прежнему приходится управлять многоуровневый подход к визуальным элементам. Это означает написание лучших шейдеров для более производительных графических карт и написание более базовых версий для старых карточек.</span><span class="sxs-lookup"><span data-stu-id="66900-130">As a game developer, you still have to manage a tiered approach to your visuals; this means writing better shaders for more capable graphics cards and writing more basic versions for older cards.</span></span> <span data-ttu-id="66900-131">Тем не менее, с хорошо написанными HLSLами эта нагрузка может быть значительно облегчилоа.</span><span class="sxs-lookup"><span data-stu-id="66900-131">With well written HLSL, however, this burden can be eased significantly.</span></span>

<span data-ttu-id="66900-132">Вместо того, чтобы компилировать HLSL шейдеры с помощью D3DX на компьютере клиента во время загрузки приложения или при первом использовании, многие разработчики выбирают компиляцию своего шейдера из HLSL в двоичный код сборки до того, как они будут даже поставляться.</span><span class="sxs-lookup"><span data-stu-id="66900-132">Rather than compile HLSL shaders using D3DX on the customer's machine at application load time or on first use, many developers choose to compile their shader from HLSL to binary assembly code before they even ship.</span></span> <span data-ttu-id="66900-133">Это оставляет свой исходный код HLSL от любопытныхных глаз, а также гарантирует, что все построители шейдеров, которые их приложение запускали, будут проделаны в рамках внутреннего процесса контроля качества.</span><span class="sxs-lookup"><span data-stu-id="66900-133">This keeps their HLSL source code away from prying eyes and also ensures that all the shaders their application will ever run have gone through their internal quality assurance process.</span></span> <span data-ttu-id="66900-134">Для автономного компилирования шейдеров используется удобная программа [fxc](/windows/desktop/direct3dtools/fxc).</span><span class="sxs-lookup"><span data-stu-id="66900-134">A convenient utility for compiling shaders offline is [fxc](/windows/desktop/direct3dtools/fxc).</span></span> <span data-ttu-id="66900-135">Это средство имеет ряд параметров, которые можно использовать для компиляции кода для указанного целевого объекта компиляции.</span><span class="sxs-lookup"><span data-stu-id="66900-135">This tool has a number of options that you can use to compile code for the specified compile target.</span></span> <span data-ttu-id="66900-136">Изучите собранные выходные данные во время разработки, если вы хотите оптимизировать шейдеры или просто узнаете о возможностях виртуального шейдера на более детальном уровне.</span><span class="sxs-lookup"><span data-stu-id="66900-136">Studying the disassembled output can be very educational during development if you want to optimize your shaders or just generally get to know the virtual shader machine's capabilities at a more detailed level.</span></span> <span data-ttu-id="66900-137">Ниже приведены эти параметры.</span><span class="sxs-lookup"><span data-stu-id="66900-137">These options are summarized below:</span></span>

## <a name="initializing-shader-constants"></a><span data-ttu-id="66900-138">Инициализация констант шейдера</span><span class="sxs-lookup"><span data-stu-id="66900-138">Initializing Shader Constants</span></span>

<span data-ttu-id="66900-139">Константы шейдеров содержатся в таблице констант.</span><span class="sxs-lookup"><span data-stu-id="66900-139">Shader constants are contained in the constant table.</span></span> <span data-ttu-id="66900-140">Доступ к этому интерфейсу можно получить с помощью интерфейса [**ID3DXConstantTable**](/windows/desktop/direct3d9/id3dxconstanttable) .</span><span class="sxs-lookup"><span data-stu-id="66900-140">This can be accessed with the [**ID3DXConstantTable**](/windows/desktop/direct3d9/id3dxconstanttable) interface.</span></span> <span data-ttu-id="66900-141">Глобальные переменные шейдеров можно инициализировать в коде шейдера.</span><span class="sxs-lookup"><span data-stu-id="66900-141">Global shader variables can be initialized in shader code.</span></span> <span data-ttu-id="66900-142">Они инициализируются во время выполнения путем вызова [**SetDefaults**](/windows/desktop/direct3d9/id3dxconstanttable--setdefaults).</span><span class="sxs-lookup"><span data-stu-id="66900-142">These are initialized at run time by calling [**SetDefaults**](/windows/desktop/direct3d9/id3dxconstanttable--setdefaults).</span></span>

## <a name="binding-a-shader-parameter-to-a-particular-register"></a><span data-ttu-id="66900-143">Привязка параметра шейдера к определенному регистру</span><span class="sxs-lookup"><span data-stu-id="66900-143">Binding a Shader Parameter to a Particular Register</span></span>

<span data-ttu-id="66900-144">Компилятор будет автоматически назначать регистры глобальным переменным.</span><span class="sxs-lookup"><span data-stu-id="66900-144">The compiler will automatically assign registers to global variables.</span></span> <span data-ttu-id="66900-145">Компилятор будет назначать окружение для образца Register S0, Спаркленоисе на выборку регистра S1, а k \_ s — константе Register C0 (при условии, что никакие другие регистры выборки или постоянного регистра уже назначены) для следующих трех глобальных переменных:</span><span class="sxs-lookup"><span data-stu-id="66900-145">The compiler would assign Environment to sampler register s0, SparkleNoise to sampler register s1, and k\_s to constant register c0 (assuming no other sampler or constant registers were already assigned) for the following three global variables:</span></span>


```
sampler Environment;
sampler SparkleNoise;
float4 k_s;
```



<span data-ttu-id="66900-146">Можно также привязать переменные к конкретному регистру.</span><span class="sxs-lookup"><span data-stu-id="66900-146">It is also possible to bind variables to a specific register.</span></span> <span data-ttu-id="66900-147">Чтобы принудительно назначить компилятору определенный регистр, используйте следующий синтаксис:</span><span class="sxs-lookup"><span data-stu-id="66900-147">To force the compiler to assign to a particular register, use the following syntax:</span></span>


```
register(RegisterName)
```



<span data-ttu-id="66900-148">где RegisterName — имя конкретного регистра.</span><span class="sxs-lookup"><span data-stu-id="66900-148">where RegisterName is the name of the specific register.</span></span> <span data-ttu-id="66900-149">В следующих примерах демонстрируется конкретный синтаксис назначения регистров, в котором среда выборки будет привязана к регистру образцов S1, Спаркленоисе будет привязан к образцу реестра S0, а k \_ s будет привязан к константе Register C12:</span><span class="sxs-lookup"><span data-stu-id="66900-149">The following examples demonstrate the specific register assignment syntax, where the sampler Environment will be bound to sampler register s1, SparkleNoise will be bound to sampler register s0, and k\_s will be bound to constant register c12:</span></span>


```
sampler Environment : register(s1);
sampler SparkleNoise : register(s0);
float4 k_s : register(c12);
```



## <a name="rendering-a-programmable-shader"></a><span data-ttu-id="66900-150">Визуализация программируемого шейдера</span><span class="sxs-lookup"><span data-stu-id="66900-150">Rendering a Programmable Shader</span></span>

<span data-ttu-id="66900-151">Шейдер визуализируется путем установки текущего шейдера на устройстве, инициализации констант шейдера, указания устройства, откуда поступают различные входные данные, и, наконец, отрисовки примитивов.</span><span class="sxs-lookup"><span data-stu-id="66900-151">A shader is rendered by setting the current shader in the device, initializing the shader constants, telling the device where the varying input data is coming from, and finally rendering the primitives.</span></span> <span data-ttu-id="66900-152">Каждое из них можно реализовать, вызвав следующие методы соответственно:</span><span class="sxs-lookup"><span data-stu-id="66900-152">Each of these can be accomplished by calling the following methods respectively:</span></span>

-   [<span data-ttu-id="66900-153">**сетвертексшадер**</span><span class="sxs-lookup"><span data-stu-id="66900-153">**SetVertexShader**</span></span>](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setvertexshader)
-   [<span data-ttu-id="66900-154">**сетвертексшадерконстантф**</span><span class="sxs-lookup"><span data-stu-id="66900-154">**SetVertexShaderConstantF**</span></span>](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setvertexshaderconstantf)
-   [<span data-ttu-id="66900-155">**сетстреамсаурце**</span><span class="sxs-lookup"><span data-stu-id="66900-155">**SetStreamSource**</span></span>](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setstreamsource)
-   [<span data-ttu-id="66900-156">**дравпримитиве**</span><span class="sxs-lookup"><span data-stu-id="66900-156">**DrawPrimitive**</span></span>](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-drawprimitive)

## <a name="debugging-shaders"></a><span data-ttu-id="66900-157">Отладка шейдеров</span><span class="sxs-lookup"><span data-stu-id="66900-157">Debugging Shaders</span></span>

<span data-ttu-id="66900-158">Расширение DirectX для Microsoft Visual Studio .NET предоставляет полностью интегрированный отладчик HLSL в интегрированной среде разработки (IDE) Visual Studio .NET.</span><span class="sxs-lookup"><span data-stu-id="66900-158">The DirectX extension for Microsoft Visual Studio .NET is provides a fully integrated HLSL debugger within the Visual Studio .NET Integrated Development Environment (IDE).</span></span> <span data-ttu-id="66900-159">Чтобы подготовиться к отладке шейдера, необходимо установить нужные инструменты на компьютере (см. раздел [Отладка шейдеров в Visual Studio (Direct3D 9)](dx-graphics-hlsl-debug-visual-studio.md)).</span><span class="sxs-lookup"><span data-stu-id="66900-159">In order to prepare for shader debugging, you must install the right tools on your machine (see [Debugging Shaders in Visual Studio (Direct3D 9)](dx-graphics-hlsl-debug-visual-studio.md)).</span></span>

## <a name="related-topics"></a><span data-ttu-id="66900-160">См. также</span><span class="sxs-lookup"><span data-stu-id="66900-160">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="66900-161">Руководство по программированию для HLSL</span><span class="sxs-lookup"><span data-stu-id="66900-161">Programming Guide for HLSL</span></span>](dx-graphics-hlsl-pguide.md)
</dt> </dl>

 

 