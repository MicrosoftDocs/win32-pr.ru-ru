---
title: Использование шейдеров в Direct3D 10
description: Использование шейдеров в Direct3D 10
ms.assetid: cff6f901-cb9b-44d5-a75b-9a4029a37215
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 0e19275532ce8fd034813d8574f6bdc04d72f966
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104337537"
---
# <a name="using-shaders-in-direct3d-10"></a>Использование шейдеров в Direct3D 10

Конвейер имеет три этапа шейдера, и каждый из них программируется с помощью шейдера HLSL. Все шейдеры Direct3D 10 написаны на HLSL, нацеливание на модель шейдера 4.



|                                                                                                                                                                                                                                                                                                                                                |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Различия между Direct3D 9 и Direct3D 10:<br/> В отличие от моделей шейдера Direct3D 9, которые могут быть созданы на промежуточном языке сборки, шейдеры Shader Model 4,0 созданы только в HLSL. Автономная компиляция шейдеров в байт-код с возможностью использования устройства по-прежнему поддерживается и рекомендуется для большинства сценариев.<br/> |



 

В этом примере используется только шейдер вершин. Поскольку все шейдеры основаны на стандартном ядре шейдера, изучение использования шейдера вершин очень похоже на использование геометрии или шейдера пикселей.

После создания шейдера HLSL (в этом примере используется Вершинный шейдер Хлслвисаутфкс. ВШ) необходимо подготовить его к конкретному этапу конвейера, который будет его использовать. Для этого необходимо выполнить следующие действия.

-   [Компиляция шейдера](#compile-a-shader)
-   [Создание объекта шейдера](#create-a-shader-object)
-   [Задание объекта шейдера](#set-the-shader-object)
-   [Повторить для всех 3 этапов шейдера](#repeat-for-all-3-shader-stages)

Эти шаги необходимо повторить для каждого шейдера в конвейере.

## <a name="compile-a-shader"></a>Компиляция шейдера

Первым шагом является компиляция шейдера для проверки правильности кодирования инструкций HLSL. Это делается путем вызова D3D10CompileShader и передачи его с несколькими параметрами, как показано ниже:


```
    IPD3D10Blob * pBlob;
    
        
    // Compile the vertex shader from the file
    D3D10CompileShader( strPath, strlen( strPath ), "HLSLWithoutFX.vsh", 
        NULL, NULL, "Ripple", "vs_4_0", dwShaderFlags, &pBlob, NULL );
```



Эта функция принимает следующие параметры:

-   Имя файла (и длина строки имени в байтах), которая содержит шейдер. В этом примере используется только шейдер вершин (в файле Хлслвисаутфкс. ВШ, где расширение файла. ВШ — это сокращение для шейдера вершин).
-   Имя функции шейдера. В этом примере компилируется шейдер вершин из функции Ripple, которая принимает один вход и возвращает выходную структуру (функция из примера Хлслвисаутфкс):
    ```
    VS_OUTPUT Ripple( in float2 vPosition : POSITION )
    ```

    

-   Указатель на все макросы, используемые шейдером. \_ \_ Чтобы определить макросы, используйте макрос шейдера D3D10. просто создайте строку имени, содержащую все имена макросов (с именами, разделенными пробелами), и строку определения (с каждым телом макроса, разделенного пробелом). Обе строки должны завершаться нулем.
-   Указатель на любые другие файлы, которые необходимо добавить, чтобы получить возможность скомпилировать шейдер. В этом случае используется интерфейс ID3D10Include, который имеет два реализованных пользователем метода: Open и Close. Чтобы сделать это, необходимо реализовать тело методов Open и Close. в методе Open добавьте код, который будет использоваться для открытия любого включаемого файла. в функции Close добавьте код для закрытия файлов по завершении работы с ними.
-   Имя компилируемой функции шейдера. Этот шейдер компилирует функцию Ripple.
-   Профиль шейдера, предназначенный для целевого объекта при компиляции. Поскольку вы можете компилировать функцию в вершину, геометрию или шейдер пикселей, профиль сообщает компилятору, какой тип шейдера и какая модель шейдеров следует сравнить с кодом.
-   Флаги компилятора шейдеров. Эти флаги указывают компилятору, какую информацию следует поместить в скомпилированный результат, а также способ оптимизации исходящего кода: для скорости, для отладки и т. д. Список доступных флагов см. в разделе [константы эффектов (Direct3D 10)](/windows/desktop/direct3d10/d3d10-graphics-reference-effect-constants) . Этот пример содержит код, который можно использовать для задания значений флагов компилятора для проекта. это главным образом вопрос, нужно ли создавать отладочную информацию.
-   Указатель на буфер, содержащий скомпилированный код шейдера. Кроме того, буфер содержит все внедренные сведения об отладке и таблице символов, запрошенные флагами компилятора.
-   Указатель на буфер, содержащий список ошибок и предупреждений, обнаруженных во время компиляции. это те же сообщения, которые отображаются в выходных данных отладки, если при компиляции шейдера выполнялся отладчик. Значение **null** является допустимым, если не нужно, чтобы ошибки возвращались в буфер.

Если шейдер успешно компилируется, указатель на код шейдера возвращается в виде интерфейса ID3D10Blob. Он называется интерфейсом больших двоичных объектов, так как указатель находится в расположении в памяти, которое состоит из массива DWORD. Интерфейс предоставляется таким образом, чтобы можно было получить указатель на скомпилированный шейдер, который потребуется на следующем шаге.

Начиная с пакета SDK 2006 декабря, компилятор HLSL DirectX 10 теперь является компилятором по умолчанию как в DirectX 9, так и в DirectX 10. Дополнительные сведения см. в разделе [средство компилятора Effect](/windows/desktop/direct3dtools/fxc) .

### <a name="get-a-pointer-to-a-compiled-shader"></a>Получение указателя на скомпилированный шейдер

Для нескольких методов API требуется указатель на скомпилированный шейдер. Этот аргумент обычно называется *пшадербитекоде* , так как он указывает на скомпилированный шейдер, представленный в виде последовательности байтовых кодов. Чтобы получить указатель на скомпилированный шейдер, сначала Скомпилируйте шейдер путем вызова [**D3D10CompileShader**](/windows/desktop/api/d3d10shader/nf-d3d10shader-d3d10compileshader) или аналогичной функции. Если компиляция прошла успешно, то Скомпилированный шейдер возвращается в интерфейсе [**ID3D10Blob**](/windows/desktop/api/d3dcommon/nn-d3dcommon-id3d10blob) . Наконец, используйте метод [**жетбуфферпоинтер**](/windows/desktop/api/d3dcommon/nf-d3dcommon-id3d10blob-getbufferpointer) для возврата указателя.

## <a name="create-a-shader-object"></a>Создание объекта шейдера

После компиляции шейдера вызовите Креатевертексшадер, чтобы создать объект шейдера:


```
    ID3D10VertexShader ** ppVertexShader
    ID3D10Blob pBlob;


    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( (DWORD*)pBlob->GetBufferPointer(),
        pBlob->GetBufferSize(), &ppVertexShader );

    // Release the pointer to the compiled shader once you are done with it
    pBlob->Release();
```



Чтобы создать объект шейдера, передайте указатель на скомпилированный шейдер в Креатевертексшадер. Так как вам пришлось успешно скомпилировать шейдер, этот вызов почти наверняка будет пройден, если на компьютере не возникла проблема с памятью.

Вы можете создать столько объектов шейдера, сколько вам нравится, и просто сохраним указатели на них. Этот же механизм работает для геометрических и пиксельных шейдеров, предполагая, что вы сопоставляете профили шейдеров (при вызове метода Compile) в именах интерфейсов (при вызове метода Create).

## <a name="set-the-shader-object"></a>Задание объекта шейдера

На последнем шаге задается шейдер на этапе конвейера. Так как в конвейере есть три этапа шейдера, необходимо сделать три вызова API, по одному для каждого этапа.


```
    // Set a vertex shader
    pd3dDevice->VSSetShader( g_pVS10 );
```



Вызов Вссетшадер принимает указатель на шейдер вершин, созданный на шаге 1. Это задает шейдер на устройстве. Этап шейдера вершин теперь инициализируется с помощью кода шейдера вершин, все, что остается, — инициализация всех переменных шейдера.

## <a name="repeat-for-all-3-shader-stages"></a>Повторить для всех 3 этапов шейдера

Повторите тот же набор шагов, чтобы создать любой вершинный или пиксельный шейдер или даже шейдер Geometry, который выводит данные в шейдер пикселей.

## <a name="related-topics"></a>См. также

[Компиляция шейдеров](dx-graphics-hlsl-part1.md)


## <a name="related-topics"></a>См. также

<dl> <dt>

[Руководство по программированию для HLSL](dx-graphics-hlsl-pguide.md)
</dt> </dl>

 

