---
title: текскурд-PS
description: Интерпретирует данные координаты текстуры (UVW1) как данные цвета (RGBA).
ms.assetid: 0f79a62c-1142-4dcd-aa2f-a5bd1c369ffc
ms.topic: reference
ms.date: 05/31/2018
topic_type:
- apiref
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 9e871d1f91d89d0eb0ddadee34b5ac215916d0af
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "103792193"
---
# <a name="texcoord---ps"></a>текскурд-PS

Интерпретирует данные координаты текстуры (UVW1) как данные цвета (RGBA).

## <a name="syntax"></a>Синтаксис



| текскурд DST |
|--------------|



 

где

-   DST — это регистр назначения.

## <a name="remarks"></a>Примечания



| Версии шейдеров пикселей | 1\_1 | 1\_2 | 1 \_ 3 | 1\_4 | 2 \_ 0 | 2 \_ x | 2 \_ SW | 3 \_ 0 | 3 \_ SW |
|-----------------------|------|------|------|------|------|------|-------|------|-------|
| текскурд              | x    | x    | x    |      |      |      |       |      |       |



 

Эта инструкция интерпретирует набор координат текстуры (UVW1), соответствующий номеру регистра назначения, как данные цвета (RGBA). Если набор координат текстуры содержит менее трех компонентов, отсутствующие компоненты имеют значение 0. Четвертый компонент всегда имеет значение 1. Все значения отправляются между 0 и 1.

Преимущество текскурд заключается в том, что он предоставляет способ передачи данных вершин с высокой точностью непосредственно в шейдер пикселей. Однако если данные записываются в регистр назначения, то в зависимости от количества бит, используемых оборудованием для регистров, будет потеряна какая-либо точность.

Эта инструкция не демонстрирует выборку текстуры. Только координаты текстуры, заданные на этом этапе текстуры, являются релевантными.

Любые данные текстуры (такие как положение, нормальное и светлое направление источника) могут быть сопоставлены шейдером вершин в координатах текстуры. Для этого необходимо связать текстуру с регистром текстуры с помощью [**сеттекстуре**](/windows/desktop/direct3d9/id3dxbaseeffect--settexture) и указать, как выборка текстур выполняется с помощью [**сеттекстурестажестате**](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexturestagestate). Если используется фиксированный конвейер функции, обязательно укажите \_ флаг Тсс текскурдиндекс.

Эта инструкция используется следующим образом:


```
texcoord tn
```



[Регистр координат текстуры](dx9-graphics-reference-asm-ps-registers-texture-coordinate.md) (тн) содержит четыре значения цвета (RGBA). Данные также можно рассматривать как векторные данные (ксизв). текскурд получит три из этих значений (XYZ) из набора координат текстуры x, а четвертый компонент (w) имеет значение 1. Адрес текстуры копируется из набора координат текстуры n. Результат находится в диапазоне от 0 до 1.

Данный пример служит только для демонстрационных целей. Код C, сопровождающий шейдер, не оптимизирован для повышения производительности.

Ниже приведен пример шейдера с использованием текскурд.


```
ps_1_1        ; version instruction
texcoord t0   ; declare t0 hold texture coordinates, 
              ; which represent rgba values in this example
mov r0, t0    ; move the color in t0 to output register r0
```



Отображаемые выходные данные шейдера пикселей показаны на следующем рисунке. Значения координат (u, v, w, 1) сопоставляются с каналами (RGB). Для альфа-канала задано значение 1. На углах иллюстрации координаты (0,0, 0, 0, 1) интерпретируется как черный; (1, 0, 0, 1) — красный; (0, 1, 0, 1) является зеленым; и (1, 1, 0, 1) содержит зеленый и красный цвета, выдавая желтый цвет.

![Иллюстрация отображаемых выходных данных примера шейдера пикселей](images/pstexcoord.jpg)

Для использования шейдера требуется дополнительный код, а пример сценария показан ниже.


```
// This code creates the shader from a file. The contents of  
// the shader file can also be supplied as a text string.
LPD3DXBUFFER        pCode;

// Assemble the vertex shader from the file
D3DXAssembleShaderFromFile(strPShaderPath, 0, NULL, &pCode, NULL);
m_pd3dDevice->CreatePixelShader((DWORD*)pCode->GetBufferPointer(),
                   &m_hPixelShader);
pCode->Release();

// This code defines the object vertex data
struct CUSTOMVERTEX
{
    FLOAT x, y, z;
    FLOAT tu1, tv1;
};

#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_TEX1|TEXCOORD2(0))

static CUSTOMVERTEX g_Vertices[]=
{
    //  x      y     z     u1    v1   
    { -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, },
    { +1.0f, -1.0f, 0.0f, 1.0f, 0.0f, },
    { +1.0f, +1.0f, 0.0f, 1.0f, 1.0f, },
    { -1.0f, +1.0f, 0.0f, 0.0f, 1.0f, },
};
```



## <a name="related-topics"></a>См. также

<dl> <dt>

[Инструкции шейдера пикселей](dx9-graphics-reference-asm-ps-instructions.md)
</dt> </dl>

 

 