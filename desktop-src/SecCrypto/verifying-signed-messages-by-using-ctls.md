---
description: Одним из преимуществ использования списков доверия сертификатов (CTL) является возможность разработки приложений, которые могут автоматически проверять подписанные сообщения от доверенных сертификатов, не требуя от пользователя диалоговых окон.
ms.assetid: e45ea3ae-52bc-49d3-8144-f3becc254f53
title: Проверка подписанных сообщений с помощью списков CTL
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1624a132ed976800d1c8a8ab0dcd878f533f0d0b947879e87e3e8dc21ccff51a
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118896235"
---
# <a name="verifying-signed-messages-by-using-ctls"></a>Проверка подписанных сообщений с помощью списков CTL

Одним из преимуществ использования [*списков доверия сертификатов*](../secgloss/c-gly.md) (CTL) является возможность разработки приложений, которые могут автоматически проверять подписанные сообщения от доверенных сертификатов, не требуя от пользователя диалоговых окон. Он также дает администратору сети контроль над доверенными источниками.

Следующую процедуру можно использовать для проверки подписи подписанного сообщения с помощью списка доверия сертификатов.

**Проверка подписанного сообщения с помощью списка доверия сертификатов**

1.  Декодировать сообщение следующим образом:

    1.  Получение указателя на полученное сообщение (закодированный BLOB- [*объект*](../secgloss/b-gly.md)).
    2.  Вызовите [**криптмсгопентодекоде**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgopentodecode), передав необходимые аргументы.
    3.  Вызовите [**криптмсгупдате**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgupdate) один раз, передав маркер, полученный на шаге b, и указатель на данные, которые необходимо декодировать. Это приводит к тому, что в зависимости от типа сообщений в сообщении будут выполняться соответствующие действия.

2.  Проверка подписи декодированного подписанного сообщения и получение указателя на [**\_ контекст сертификата**](/windows/desktop/api/Wincrypt/ns-wincrypt-cert_context)подписавшего.

    Это можно сделать, вызвав [**криптмсгжетандверифисигнер**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsggetandverifysigner), передав полученный в шаге 1C маркер сообщения в качестве параметра *хкриптмсг* . Если вызов функции возвращает **значение true**, то сигнатура была проверена, а в параметре *ппсигнер* возвращается указатель на [**\_ контекст пкцерт**](/windows/desktop/api/Wincrypt/ns-wincrypt-cert_context) подписи.

3.  Убедитесь, что подписавший является надежным источником, как показано ниже.

    1.  Откройте хранилище сертификатов, содержащее соответствующий список доверия сертификатов.
    2.  Получите указатель на [**\_ контекст CTL**](/windows/desktop/api/Wincrypt/ns-wincrypt-ctl_context) , вызвав [**цертфиндктлинсторе**](/windows/desktop/api/Wincrypt/nf-wincrypt-certfindctlinstore).
    3.  Чтобы убедиться, что подписавший является надежным источником, вызовите [**цертфиндсубжектинктл**](/windows/desktop/api/Wincrypt/nf-wincrypt-certfindsubjectinctl), передав указатель, полученный на предыдущем шаге, в параметре *пктлконтекст* , \_ \_ Тип субъекта сертификата CTL \_ в параметре *двсубжекттипе* и указатель на [**\_ контекст сертификата**](/windows/desktop/api/Wincrypt/ns-wincrypt-cert_context) , полученный на шаге 2 в параметре *пвсубжект* . Если вызов функции возвращает **значение true**, то **\_ контекст сертификата** , переданный в функцию, является надежным источником в списке доверия (CTL).

 

 
