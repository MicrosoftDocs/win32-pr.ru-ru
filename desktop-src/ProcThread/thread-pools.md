---
description: Пул потоков — это коллекция рабочих потоков, которые эффективно выполняют асинхронные обратные вызовы от имени приложения.
ms.assetid: abe0798a-0b60-4bdb-a61e-45393f1e958d
title: Пулы потоков
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d7918a0f6f0b881233ebea8e664d6e743a7bff105e265270063b08af313417e7
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120081264"
---
# <a name="thread-pools"></a>Пулы потоков

*Пул потоков* — это коллекция рабочих потоков, которые эффективно выполняют асинхронные обратные вызовы от имени приложения. Пул потоков в основном используется для сокращения числа потоков приложения и обеспечения управления рабочими потоками. Приложения могут ставить в очередь рабочие элементы, связывать работу с ожидающими дескрипторами, автоматически ставить в очередь на основе таймера и выполнять привязку с помощью операций ввода-вывода.

## <a name="thread-pool-architecture"></a>Архитектура пула потоков

Использование пула потоков может быть выгодным для следующих приложений:

-   Приложение, которое имеет высокую степень параллельности и может асинхронно отправлять большое количество небольших рабочих элементов (например, Поиск распределенных индексов или сетевой ввод-вывод).
-   Приложение, которое создает и уничтожает большое количество потоков, каждый из которых выполняется в течение короткого промежутка времени. Использование пула потоков может снизить сложность управления потоками и издержки, связанные с созданием и уничтожением потоков.
-   Приложение, которое обрабатывает независимые рабочие элементы в фоновом режиме и параллельно (например, Загрузка нескольких вкладок).
-   Приложение, которое должно выполнять эксклюзивное ожидание объектов ядра или блокировать входящие события объекта. Использование пула потоков может снизить сложность управления потоком и повысить производительность, уменьшая число переключений контекста.
-   Приложение, которое создает пользовательские потоки ожидания для ожидания событий.

исходный пул потоков был полностью изменен в Windows Vista. Новый пул потоков улучшен, так как он предоставляет один тип рабочего потока (поддерживает операции ввода-вывода и без ввода-вывода), не использует поток таймера, предоставляет одну очередь таймера и предоставляет выделенный постоянный поток. Он также предоставляет группы очистки, более высокую производительность, несколько пулов для каждого процесса, которые планируются независимо, и новый API пула потоков.

Архитектура пула потоков состоит из следующих компонентов:

-   Рабочие потоки, выполняющие функции обратного вызова
-   Потоки ожидания, ожидающие нескольких дескрипторов ожидания
-   Рабочая очередь
-   Пул потоков по умолчанию для каждого процесса
-   Рабочая фабрика, управляющая рабочими потоками

## <a name="best-practices"></a>Советы и рекомендации

Новый [API пула потоков](thread-pool-api.md) обеспечивает большую гибкость и управление, чем [Исходный API пула потоков](thread-pooling.md). Однако существует несколько незначительных, но важных отличий. В исходном API ожидание сброса было автоматическим; в новом API ожидание должно быть явным образом сброшено каждый раз. Исходный API, автоматически обрабатывающий олицетворение, передает контекст безопасности вызывающего процесса в поток. В новом API приложение должно явно задать контекст безопасности.

Ниже приведены рекомендации по использованию пула потоков.

-   Потоки процесса совместно используют пул потоков. Один рабочий поток может выполнять несколько функций обратного вызова по одной за раз. Эти рабочие потоки управляются пулом потоков. Поэтому не следует завершать поток из пула потоков путем вызова [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) в потоке или путем вызова [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) из функции обратного вызова.
-   Запрос ввода-вывода может выполняться в любом потоке в пуле потоков. Для отмены ввода-вывода в потоке пула потоков требуется синхронизация, поскольку функция Cancel может выполняться в потоке, отличном от потока, обрабатывающего запрос ввода-вывода, что может привести к отмене неизвестной операции. Чтобы избежать этого, всегда выполняйте [**перекрывающиеся**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) структуры, с помощью которых был инициирован запрос ввода-вывода при вызове [**канцелиоекс**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) для асинхронного ввода-вывода, или используйте собственную синхронизацию, чтобы гарантировать, что никакие другие операции ввода-вывода не могут быть запущены в целевом потоке перед вызовом функции [**канцелсинчронаусио**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio) или **канцелиоекс** .
-   Очистите все ресурсы, созданные в функции обратного вызова перед возвратом из функции. К ним относятся TLS, контексты безопасности, приоритет потоков и регистрация COM. Функции обратного вызова также должны восстанавливать состояние потока перед возвратом.
-   Отслеживайте дескрипторы ожидания и связанные с ними объекты до тех пор, пока пул потоков не сообщит о завершении дескриптора.
-   Пометьте все потоки, ожидающие длительные операции (такие как очистка ввода-вывода или очистка ресурсов), чтобы пул потоков мог выделить новые потоки вместо ожидания этого.
-   Перед выгрузкой библиотеки DLL, использующей пул потоков, отмените все рабочие элементы, операции ввода-вывода, ожидания и таймеры и дождитесь завершения выполнения ответных вызовов.
-   Избегайте взаимоблокировок, удалив зависимости между рабочими элементами и обратными вызовами, убедившись, что обратный вызов не ждет завершения и, сохраняя приоритет потока.
-   Не ставить слишком много элементов слишком быстро в процесс с другими компонентами, использующими пул потоков по умолчанию. Существует один пул потоков по умолчанию для каждого процесса, включая Svchost.exe. По умолчанию каждый пул потоков имеет максимум 500 рабочих потоков. Пул потоков пытается создать больше рабочих потоков, когда число рабочих потоков в состоянии "Готово" или "выполняется" должно быть меньше числа процессоров.
-   Избегайте модели однопотокового апартамента COM, так как она несовместима с пулом потоков. STA создает состояние потока, которое может повлиять на следующий рабочий элемент для потока. Как правило, STA является длительным и имеет сходство потоков, что является противоположностью пула потоков.
-   Создание нового пула потоков для управления приоритетом и изоляцией потоков, создание пользовательских характеристик и, возможно, повышение скорости реагирования. Однако для дополнительных пулов потоков требуются дополнительные системные ресурсы (потоки, память ядра). Слишком большое количество пулов повышает вероятность состязаний за использование ЦП.
-   По возможности используйте ожидающий объект, а не механизм на основе APC для сигнализации потока пула потоков. APC не работают с потоками пула потоков в качестве других механизмов сигнализации, поскольку система управляет временем существования потоков пула потоков, поэтому поток может быть завершен до доставки уведомления.
-   Используйте расширение отладчика пула потоков,! TP. Эта команда имеет следующие сведения об использовании:

    -   *Флаги* *адреса* пула
    -   *Флаги* *адреса* obj
    -   *Флаги* *адреса* Tне
    -   *адрес* ожидания
    -   *адрес* рабочего процесса

    Для пула, ожидания и рабочей роли, если адрес равен нулю, команда создает дампы всех объектов. Для ожидающих и рабочих ролей пропуск адреса в дампе текущего потока. Определены следующие флаги: 0x1 (однострочный вывод), 0x2 (элементы дампа) и 0x4 (Рабочая очередь пула дампа).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[API пула потоков](thread-pool-api.md)
</dt> <dt>

[Использование функций пула потоков](using-the-thread-pool-functions.md)
</dt> </dl>

 

 
