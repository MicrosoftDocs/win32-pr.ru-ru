---
description: Пул потоков — это коллекция рабочих потоков, которые эффективно выполняют асинхронные обратные вызовы от имени приложения.
ms.assetid: abe0798a-0b60-4bdb-a61e-45393f1e958d
title: Пулы потоков
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 690aa3eb6fd3ce7a99d71e0f57118529ef79113f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105673893"
---
# <a name="thread-pools"></a><span data-ttu-id="4f3f9-103">Пулы потоков</span><span class="sxs-lookup"><span data-stu-id="4f3f9-103">Thread Pools</span></span>

<span data-ttu-id="4f3f9-104">*Пул потоков* — это коллекция рабочих потоков, которые эффективно выполняют асинхронные обратные вызовы от имени приложения.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-104">A *thread pool* is a collection of worker threads that efficiently execute asynchronous callbacks on behalf of the application.</span></span> <span data-ttu-id="4f3f9-105">Пул потоков в основном используется для сокращения числа потоков приложения и обеспечения управления рабочими потоками.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-105">The thread pool is primarily used to reduce the number of application threads and provide management of the worker threads.</span></span> <span data-ttu-id="4f3f9-106">Приложения могут ставить в очередь рабочие элементы, связывать работу с ожидающими дескрипторами, автоматически ставить в очередь на основе таймера и выполнять привязку с помощью операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-106">Applications can queue work items, associate work with waitable handles, automatically queue based on a timer, and bind with I/O.</span></span>

## <a name="thread-pool-architecture"></a><span data-ttu-id="4f3f9-107">Архитектура пула потоков</span><span class="sxs-lookup"><span data-stu-id="4f3f9-107">Thread Pool Architecture</span></span>

<span data-ttu-id="4f3f9-108">Использование пула потоков может быть выгодным для следующих приложений:</span><span class="sxs-lookup"><span data-stu-id="4f3f9-108">The following applications can benefit from using a thread pool:</span></span>

-   <span data-ttu-id="4f3f9-109">Приложение, которое имеет высокую степень параллельности и может асинхронно отправлять большое количество небольших рабочих элементов (например, Поиск распределенных индексов или сетевой ввод-вывод).</span><span class="sxs-lookup"><span data-stu-id="4f3f9-109">An application that is highly parallel and can dispatch a large number of small work items asynchronously (such as distributed index search or network I/O).</span></span>
-   <span data-ttu-id="4f3f9-110">Приложение, которое создает и уничтожает большое количество потоков, каждый из которых выполняется в течение короткого промежутка времени.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-110">An application that creates and destroys a large number of threads that each run for a short time.</span></span> <span data-ttu-id="4f3f9-111">Использование пула потоков может снизить сложность управления потоками и издержки, связанные с созданием и уничтожением потоков.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-111">Using the thread pool can reduce the complexity of thread management and the overhead involved in thread creation and destruction.</span></span>
-   <span data-ttu-id="4f3f9-112">Приложение, которое обрабатывает независимые рабочие элементы в фоновом режиме и параллельно (например, Загрузка нескольких вкладок).</span><span class="sxs-lookup"><span data-stu-id="4f3f9-112">An application that processes independent work items in the background and in parallel (such as loading multiple tabs).</span></span>
-   <span data-ttu-id="4f3f9-113">Приложение, которое должно выполнять эксклюзивное ожидание объектов ядра или блокировать входящие события объекта.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-113">An application that must perform an exclusive wait on kernel objects or block on incoming events on an object.</span></span> <span data-ttu-id="4f3f9-114">Использование пула потоков может снизить сложность управления потоком и повысить производительность, уменьшая число переключений контекста.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-114">Using the thread pool can reduce the complexity of thread management and increase performance by reducing the number of context switches.</span></span>
-   <span data-ttu-id="4f3f9-115">Приложение, которое создает пользовательские потоки ожидания для ожидания событий.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-115">An application that creates custom waiter threads to wait on events.</span></span>

<span data-ttu-id="4f3f9-116">Исходный пул потоков был полностью изменен в Windows Vista.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-116">The original thread pool has been completely rearchitected in Windows Vista.</span></span> <span data-ttu-id="4f3f9-117">Новый пул потоков улучшен, так как он предоставляет один тип рабочего потока (поддерживает операции ввода-вывода и без ввода-вывода), не использует поток таймера, предоставляет одну очередь таймера и предоставляет выделенный постоянный поток.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-117">The new thread pool is improved because it provides a single worker thread type (supports both I/O and non-I/O), does not use a timer thread, provides a single timer queue, and provides a dedicated persistent thread.</span></span> <span data-ttu-id="4f3f9-118">Он также предоставляет группы очистки, более высокую производительность, несколько пулов для каждого процесса, которые планируются независимо, и новый API пула потоков.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-118">It also provides clean-up groups, higher performance, multiple pools per process that are scheduled independently, and a new thread pool API.</span></span>

<span data-ttu-id="4f3f9-119">Архитектура пула потоков состоит из следующих компонентов:</span><span class="sxs-lookup"><span data-stu-id="4f3f9-119">The thread pool architecture consists of the following:</span></span>

-   <span data-ttu-id="4f3f9-120">Рабочие потоки, выполняющие функции обратного вызова</span><span class="sxs-lookup"><span data-stu-id="4f3f9-120">Worker threads that execute the callback functions</span></span>
-   <span data-ttu-id="4f3f9-121">Потоки ожидания, ожидающие нескольких дескрипторов ожидания</span><span class="sxs-lookup"><span data-stu-id="4f3f9-121">Waiter threads that wait on multiple wait handles</span></span>
-   <span data-ttu-id="4f3f9-122">Рабочая очередь</span><span class="sxs-lookup"><span data-stu-id="4f3f9-122">A work queue</span></span>
-   <span data-ttu-id="4f3f9-123">Пул потоков по умолчанию для каждого процесса</span><span class="sxs-lookup"><span data-stu-id="4f3f9-123">A default thread pool for each process</span></span>
-   <span data-ttu-id="4f3f9-124">Рабочая фабрика, управляющая рабочими потоками</span><span class="sxs-lookup"><span data-stu-id="4f3f9-124">A worker factory that manages the worker threads</span></span>

## <a name="best-practices"></a><span data-ttu-id="4f3f9-125">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="4f3f9-125">Best Practices</span></span>

<span data-ttu-id="4f3f9-126">Новый [API пула потоков](thread-pool-api.md) обеспечивает большую гибкость и управление, чем [Исходный API пула потоков](thread-pooling.md).</span><span class="sxs-lookup"><span data-stu-id="4f3f9-126">The new [thread pool API](thread-pool-api.md) provides more flexibility and control than the [original thread pool API](thread-pooling.md).</span></span> <span data-ttu-id="4f3f9-127">Однако существует несколько незначительных, но важных отличий.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-127">However, there are a few subtle but important differences.</span></span> <span data-ttu-id="4f3f9-128">В исходном API ожидание сброса было автоматическим; в новом API ожидание должно быть явным образом сброшено каждый раз.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-128">In the original API, the wait reset was automatic; in the new API, the wait must be explicitly reset each time.</span></span> <span data-ttu-id="4f3f9-129">Исходный API, автоматически обрабатывающий олицетворение, передает контекст безопасности вызывающего процесса в поток.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-129">The original API handled impersonation automatically, transferring the security context of the calling process to the thread.</span></span> <span data-ttu-id="4f3f9-130">В новом API приложение должно явно задать контекст безопасности.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-130">With the new API, the application must explicitly set the security context.</span></span>

<span data-ttu-id="4f3f9-131">Ниже приведены рекомендации по использованию пула потоков.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-131">The following are best practices when using a thread pool:</span></span>

-   <span data-ttu-id="4f3f9-132">Потоки процесса совместно используют пул потоков.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-132">The threads of a process share the thread pool.</span></span> <span data-ttu-id="4f3f9-133">Один рабочий поток может выполнять несколько функций обратного вызова по одной за раз.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-133">A single worker thread can execute multiple callback functions, one at a time.</span></span> <span data-ttu-id="4f3f9-134">Эти рабочие потоки управляются пулом потоков.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-134">These worker threads are managed by the thread pool.</span></span> <span data-ttu-id="4f3f9-135">Поэтому не следует завершать поток из пула потоков путем вызова [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) в потоке или путем вызова [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) из функции обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-135">Therefore, do not terminate a thread from the thread pool by calling [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) on the thread or by calling [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) from a callback function.</span></span>
-   <span data-ttu-id="4f3f9-136">Запрос ввода-вывода может выполняться в любом потоке в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-136">An I/O request can run on any thread in the thread pool.</span></span> <span data-ttu-id="4f3f9-137">Для отмены ввода-вывода в потоке пула потоков требуется синхронизация, поскольку функция Cancel может выполняться в потоке, отличном от потока, обрабатывающего запрос ввода-вывода, что может привести к отмене неизвестной операции.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-137">Canceling I/O on a thread pool thread requires synchronization because the cancel function might run on a different thread than the one that is handling the I/O request, which can result in cancellation of an unknown operation.</span></span> <span data-ttu-id="4f3f9-138">Чтобы избежать этого, всегда выполняйте [**перекрывающиеся**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) структуры, с помощью которых был инициирован запрос ввода-вывода при вызове [**канцелиоекс**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) для асинхронного ввода-вывода, или используйте собственную синхронизацию, чтобы гарантировать, что никакие другие операции ввода-вывода не могут быть запущены в целевом потоке перед вызовом функции [**канцелсинчронаусио**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio) или **канцелиоекс** .</span><span class="sxs-lookup"><span data-stu-id="4f3f9-138">To avoid this, always provide the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure with which an I/O request was initiated when calling [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) for asynchronous I/O, or use your own synchronization to ensure that no other I/O can be started on the target thread before calling either the [**CancelSynchronousIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio) or **CancelIoEx** function.</span></span>
-   <span data-ttu-id="4f3f9-139">Очистите все ресурсы, созданные в функции обратного вызова перед возвратом из функции.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-139">Clean up all resources created in the callback function before returning from the function.</span></span> <span data-ttu-id="4f3f9-140">К ним относятся TLS, контексты безопасности, приоритет потоков и регистрация COM.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-140">These include TLS, security contexts, thread priority, and COM registration.</span></span> <span data-ttu-id="4f3f9-141">Функции обратного вызова также должны восстанавливать состояние потока перед возвратом.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-141">Callback functions must also restore the thread state before returning.</span></span>
-   <span data-ttu-id="4f3f9-142">Отслеживайте дескрипторы ожидания и связанные с ними объекты до тех пор, пока пул потоков не сообщит о завершении дескриптора.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-142">Keep wait handles and their associated objects alive until the thread pool has signaled that it is finished with the handle.</span></span>
-   <span data-ttu-id="4f3f9-143">Пометьте все потоки, ожидающие длительные операции (такие как очистка ввода-вывода или очистка ресурсов), чтобы пул потоков мог выделить новые потоки вместо ожидания этого.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-143">Mark all threads that are waiting on lengthy operations (such as I/O flushes or resource cleanup) so that the thread pool can allocate new threads instead of waiting for this one.</span></span>
-   <span data-ttu-id="4f3f9-144">Перед выгрузкой библиотеки DLL, использующей пул потоков, отмените все рабочие элементы, операции ввода-вывода, ожидания и таймеры и дождитесь завершения выполнения ответных вызовов.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-144">Before unloading a DLL that uses the thread pool, cancel all work items, I/O, wait operations, and timers, and wait for executing callbacks to complete.</span></span>
-   <span data-ttu-id="4f3f9-145">Избегайте взаимоблокировок, удалив зависимости между рабочими элементами и обратными вызовами, убедившись, что обратный вызов не ждет завершения и, сохраняя приоритет потока.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-145">Avoid deadlocks by eliminating dependencies between work items and between callbacks, by ensuring a callback is not waiting for itself to complete, and by preserving the thread priority.</span></span>
-   <span data-ttu-id="4f3f9-146">Не ставить слишком много элементов слишком быстро в процесс с другими компонентами, использующими пул потоков по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-146">Do not queue too many items too quickly in a process with other components using the default thread pool.</span></span> <span data-ttu-id="4f3f9-147">Существует один пул потоков по умолчанию для каждого процесса, включая Svchost.exe.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-147">There is one default thread pool per process, including Svchost.exe.</span></span> <span data-ttu-id="4f3f9-148">По умолчанию каждый пул потоков имеет максимум 500 рабочих потоков.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-148">By default, each thread pool has a maximum of 500 worker threads.</span></span> <span data-ttu-id="4f3f9-149">Пул потоков пытается создать больше рабочих потоков, когда число рабочих потоков в состоянии "Готово" или "выполняется" должно быть меньше числа процессоров.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-149">The thread pool attempts to create more worker threads when the number of worker threads in the ready/running state must be less than the number of processors.</span></span>
-   <span data-ttu-id="4f3f9-150">Избегайте модели однопотокового апартамента COM, так как она несовместима с пулом потоков.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-150">Avoid the COM single-threaded apartment model, as it is incompatible with the thread pool.</span></span> <span data-ttu-id="4f3f9-151">STA создает состояние потока, которое может повлиять на следующий рабочий элемент для потока.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-151">STA creates thread state which can affect the next work item for the thread.</span></span> <span data-ttu-id="4f3f9-152">Как правило, STA является длительным и имеет сходство потоков, что является противоположностью пула потоков.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-152">STA is generally long-lived and has thread affinity, which is the opposite of the thread pool.</span></span>
-   <span data-ttu-id="4f3f9-153">Создание нового пула потоков для управления приоритетом и изоляцией потоков, создание пользовательских характеристик и, возможно, повышение скорости реагирования.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-153">Create a new thread pool to control thread priority and isolation, create custom characteristics, and possibly improve responsiveness.</span></span> <span data-ttu-id="4f3f9-154">Однако для дополнительных пулов потоков требуются дополнительные системные ресурсы (потоки, память ядра).</span><span class="sxs-lookup"><span data-stu-id="4f3f9-154">However, additional thread pools require more system resources (threads, kernel memory).</span></span> <span data-ttu-id="4f3f9-155">Слишком большое количество пулов повышает вероятность состязаний за использование ЦП.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-155">Too many pools increases the potential for CPU contention.</span></span>
-   <span data-ttu-id="4f3f9-156">По возможности используйте ожидающий объект, а не механизм на основе APC для сигнализации потока пула потоков.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-156">If possible, use a waitable object instead of an APC-based mechanism to signal a thread pool thread.</span></span> <span data-ttu-id="4f3f9-157">APC не работают с потоками пула потоков в качестве других механизмов сигнализации, поскольку система управляет временем существования потоков пула потоков, поэтому поток может быть завершен до доставки уведомления.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-157">APCs do not work as well with thread pool threads as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span>
-   <span data-ttu-id="4f3f9-158">Используйте расширение отладчика пула потоков,! TP.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-158">Use the thread pool debugger extension, !tp.</span></span> <span data-ttu-id="4f3f9-159">Эта команда имеет следующие сведения об использовании:</span><span class="sxs-lookup"><span data-stu-id="4f3f9-159">This command has the following usage:</span></span>

    -   <span data-ttu-id="4f3f9-160">*Флаги* *адреса* пула</span><span class="sxs-lookup"><span data-stu-id="4f3f9-160">pool *address* *flags*</span></span>
    -   <span data-ttu-id="4f3f9-161">*Флаги* *адреса* obj</span><span class="sxs-lookup"><span data-stu-id="4f3f9-161">obj *address* *flags*</span></span>
    -   <span data-ttu-id="4f3f9-162">*Флаги* *адреса* Tне</span><span class="sxs-lookup"><span data-stu-id="4f3f9-162">tqueue *address* *flags*</span></span>
    -   <span data-ttu-id="4f3f9-163">*адрес* ожидания</span><span class="sxs-lookup"><span data-stu-id="4f3f9-163">waiter *address*</span></span>
    -   <span data-ttu-id="4f3f9-164">*адрес* рабочего процесса</span><span class="sxs-lookup"><span data-stu-id="4f3f9-164">worker *address*</span></span>

    <span data-ttu-id="4f3f9-165">Для пула, ожидания и рабочей роли, если адрес равен нулю, команда создает дампы всех объектов.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-165">For pool, waiter, and worker, if the address is zero, the command dumps all objects.</span></span> <span data-ttu-id="4f3f9-166">Для ожидающих и рабочих ролей пропуск адреса в дампе текущего потока.</span><span class="sxs-lookup"><span data-stu-id="4f3f9-166">For waiter and worker, omitting the address dumps the current thread.</span></span> <span data-ttu-id="4f3f9-167">Определены следующие флаги: 0x1 (однострочный вывод), 0x2 (элементы дампа) и 0x4 (Рабочая очередь пула дампа).</span><span class="sxs-lookup"><span data-stu-id="4f3f9-167">The following flags are defined: 0x1 (single-line output), 0x2 (dump members), and 0x4 (dump pool work queue).</span></span>

## <a name="related-topics"></a><span data-ttu-id="4f3f9-168">См. также</span><span class="sxs-lookup"><span data-stu-id="4f3f9-168">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="4f3f9-169">API пула потоков</span><span class="sxs-lookup"><span data-stu-id="4f3f9-169">Thread Pool API</span></span>](thread-pool-api.md)
</dt> <dt>

[<span data-ttu-id="4f3f9-170">Использование функций пула потоков</span><span class="sxs-lookup"><span data-stu-id="4f3f9-170">Using the Thread Pool Functions</span></span>](using-the-thread-pool-functions.md)
</dt> </dl>

 

 
