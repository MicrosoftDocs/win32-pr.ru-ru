---
description: Чтобы избежать состояний гонки и взаимоблокировок, необходимо синхронизировать доступ нескольких потоков к общим ресурсам. Синхронизация также необходима, чтобы обеспечить выполнение взаимозависимого кода в соответствующей последовательности.
ms.assetid: 74af0502-dae1-438c-8e4b-7663093b3fe3
title: Синхронизация выполнения нескольких потоков
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c6a1b3dd51d666d507771476792e679f7980fab8
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "105673734"
---
# <a name="synchronizing-execution-of-multiple-threads"></a><span data-ttu-id="58672-104">Синхронизация выполнения нескольких потоков</span><span class="sxs-lookup"><span data-stu-id="58672-104">Synchronizing Execution of Multiple Threads</span></span>

<span data-ttu-id="58672-105">Чтобы избежать состояний гонки и взаимоблокировок, необходимо синхронизировать доступ нескольких потоков к общим ресурсам.</span><span class="sxs-lookup"><span data-stu-id="58672-105">To avoid race conditions and deadlocks, it is necessary to synchronize access by multiple threads to shared resources.</span></span> <span data-ttu-id="58672-106">Синхронизация также необходима, чтобы обеспечить выполнение взаимозависимого кода в соответствующей последовательности.</span><span class="sxs-lookup"><span data-stu-id="58672-106">Synchronization is also necessary to ensure that interdependent code is executed in the proper sequence.</span></span>

<span data-ttu-id="58672-107">Существует несколько объектов, дескрипторы которых можно использовать для синхронизации нескольких потоков.</span><span class="sxs-lookup"><span data-stu-id="58672-107">There are a number of objects whose handles can be used to synchronize multiple threads.</span></span> <span data-ttu-id="58672-108">К этим объектам относятся:</span><span class="sxs-lookup"><span data-stu-id="58672-108">These objects include:</span></span>

-   <span data-ttu-id="58672-109">Входные буферы консоли</span><span class="sxs-lookup"><span data-stu-id="58672-109">Console input buffers</span></span>
-   <span data-ttu-id="58672-110">События</span><span class="sxs-lookup"><span data-stu-id="58672-110">Events</span></span>
-   <span data-ttu-id="58672-111">Mutexes</span><span class="sxs-lookup"><span data-stu-id="58672-111">Mutexes</span></span>
-   <span data-ttu-id="58672-112">Процессы</span><span class="sxs-lookup"><span data-stu-id="58672-112">Processes</span></span>
-   <span data-ttu-id="58672-113">Семафоры</span><span class="sxs-lookup"><span data-stu-id="58672-113">Semaphores</span></span>
-   <span data-ttu-id="58672-114">Потоки</span><span class="sxs-lookup"><span data-stu-id="58672-114">Threads</span></span>
-   <span data-ttu-id="58672-115">Таймеры</span><span class="sxs-lookup"><span data-stu-id="58672-115">Timers</span></span>

<span data-ttu-id="58672-116">Состояние каждого из этих объектов — «сигнальный» или «не сигнальный».</span><span class="sxs-lookup"><span data-stu-id="58672-116">The state of each of these objects is either signaled or not signaled.</span></span> <span data-ttu-id="58672-117">При указании дескриптора любого из этих объектов в вызове одной из [функций ожидания](../sync/wait-functions.md)выполнение вызывающего потока блокируется до тех пор, пока состояние указанного объекта не станет сигнальным.</span><span class="sxs-lookup"><span data-stu-id="58672-117">When you specify a handle to any of these objects in a call to one of the [wait functions](../sync/wait-functions.md), the execution of the calling thread is blocked until the state of the specified object becomes signaled.</span></span>

<span data-ttu-id="58672-118">Некоторые из этих объектов полезны при блокировании потока, пока не произойдет некоторое событие.</span><span class="sxs-lookup"><span data-stu-id="58672-118">Some of these objects are useful in blocking a thread until some event occurs.</span></span> <span data-ttu-id="58672-119">Например, дескриптор входного буфера консоли получает сигнал при наличии непрочтенных входных данных, таких как нажатие клавиши или нажатия кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="58672-119">For example, a console input buffer handle is signaled when there is unread input, such as a keystroke or mouse button click.</span></span> <span data-ttu-id="58672-120">Дескрипторы процессов и потоков получают сигнал при завершении процесса или потока.</span><span class="sxs-lookup"><span data-stu-id="58672-120">Process and thread handles are signaled when the process or thread terminates.</span></span> <span data-ttu-id="58672-121">Это позволяет процессу, например, создать дочерний процесс, а затем блокировать его выполнение до завершения нового процесса.</span><span class="sxs-lookup"><span data-stu-id="58672-121">This allows a process, for example, to create a child process and then block its own execution until the new process has terminated.</span></span>

<span data-ttu-id="58672-122">Другие объекты полезны при защите общих ресурсов от одновременного доступа.</span><span class="sxs-lookup"><span data-stu-id="58672-122">Other objects are useful in protecting shared resources from simultaneous access.</span></span> <span data-ttu-id="58672-123">Например, каждый поток может иметь обработчик для объекта мьютекса.</span><span class="sxs-lookup"><span data-stu-id="58672-123">For example, multiple threads can each have a handle to a mutex object.</span></span> <span data-ttu-id="58672-124">Перед доступом к общему ресурсу потоки должны вызвать одну из [функций ожидания](../sync/wait-functions.md) , чтобы дождаться сигнала состояния мьютекса.</span><span class="sxs-lookup"><span data-stu-id="58672-124">Before accessing a shared resource, the threads must call one of the [wait functions](../sync/wait-functions.md) to wait for the state of the mutex to be signaled.</span></span> <span data-ttu-id="58672-125">Когда мьютекс становится сигнальным, освобождается только один ожидающий поток для доступа к ресурсу.</span><span class="sxs-lookup"><span data-stu-id="58672-125">When the mutex becomes signaled, only one waiting thread is released to access the resource.</span></span> <span data-ttu-id="58672-126">Состояние мьютекса немедленно сбрасывается, чтобы не сигнализировать, чтобы все ожидающие потоки оставались заблокированными.</span><span class="sxs-lookup"><span data-stu-id="58672-126">The state of the mutex is immediately reset to not signaled so any other waiting threads remain blocked.</span></span> <span data-ttu-id="58672-127">Когда поток завершит работу с ресурсом, он должен установить состояние мьютекса в сигнальном состоянии, чтобы разрешить другим потокам доступ к ресурсу.</span><span class="sxs-lookup"><span data-stu-id="58672-127">When the thread is finished with the resource, it must set the state of the mutex to signaled to allow other threads to access the resource.</span></span>

<span data-ttu-id="58672-128">Для потоков одного процесса объекты критической секции предоставляют более эффективные средства синхронизации, чем мьютексы.</span><span class="sxs-lookup"><span data-stu-id="58672-128">For the threads of a single process, critical-section objects provide a more efficient means of synchronization than mutexes.</span></span> <span data-ttu-id="58672-129">Критическая секция используется как мьютекс, чтобы разрешить одному потоку за раз использовать защищенный ресурс.</span><span class="sxs-lookup"><span data-stu-id="58672-129">A critical section is used like a mutex to enable one thread at a time to use the protected resource.</span></span> <span data-ttu-id="58672-130">Поток может использовать функцию [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) для запроса владения критическим разделом.</span><span class="sxs-lookup"><span data-stu-id="58672-130">A thread can use the [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) function to request ownership of a critical section.</span></span> <span data-ttu-id="58672-131">Если он уже принадлежит другому потоку, то запрашивающий поток блокируется.</span><span class="sxs-lookup"><span data-stu-id="58672-131">If it is already owned by another thread, the requesting thread is blocked.</span></span> <span data-ttu-id="58672-132">Поток может использовать функцию [**трентеркритикалсектион**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) для запроса владения критическим разделом, не блокируя при сбое получения критического раздела.</span><span class="sxs-lookup"><span data-stu-id="58672-132">A thread can use the [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) function to request ownership of a critical section, without blocking upon failure to obtain the critical section.</span></span> <span data-ttu-id="58672-133">После получения владения поток может свободно использовать защищенный ресурс.</span><span class="sxs-lookup"><span data-stu-id="58672-133">After it receives ownership, the thread is free to use the protected resource.</span></span> <span data-ttu-id="58672-134">Выполнение других потоков процесса не затрагивается, пока не попытается войти в тот же самый критический раздел.</span><span class="sxs-lookup"><span data-stu-id="58672-134">The execution of the other threads of the process is not affected unless they attempt to enter the same critical section.</span></span>

<span data-ttu-id="58672-135">Функция [**ваитфоринпутидле**](/windows/desktop/api/Winuser/nf-winuser-waitforinputidle) делает поток ожидающим, пока заинициализируется указанный процесс, и ожидает ввода данных пользователем, не ожидая ввода.</span><span class="sxs-lookup"><span data-stu-id="58672-135">The [**WaitForInputIdle**](/windows/desktop/api/Winuser/nf-winuser-waitforinputidle) function makes a thread wait until a specified process is initialized and waiting for user input with no input pending.</span></span> <span data-ttu-id="58672-136">Вызов **ваитфоринпутидле** может быть полезен для синхронизации родительских и дочерних процессов, так как функция [**CreateProcess**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) возвращает, не дожидаясь завершения инициализации дочернего процесса.</span><span class="sxs-lookup"><span data-stu-id="58672-136">Calling **WaitForInputIdle** can be useful for synchronizing parent and child processes, because [**CreateProcess**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) returns without waiting for the child process to complete its initialization.</span></span>

<span data-ttu-id="58672-137">Дополнительные сведения см. в разделе [Синхронизация](../sync/synchronization.md).</span><span class="sxs-lookup"><span data-stu-id="58672-137">For more information, see [Synchronization](../sync/synchronization.md).</span></span>

 

 
