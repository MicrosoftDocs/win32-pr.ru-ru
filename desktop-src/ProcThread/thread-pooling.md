---
description: Существует множество приложений, которые создают потоки, которые тратят много времени в спящем режиме, ожидая возникновения события.
ms.assetid: a5e52080-35d4-47f5-9050-90889e3bf2f8
title: Группировка потоков в пул
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bcf3565401dc57b077e333043861d42b683e810c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "103909667"
---
# <a name="thread-pooling"></a><span data-ttu-id="782b3-103">Группировка потоков в пул</span><span class="sxs-lookup"><span data-stu-id="782b3-103">Thread Pooling</span></span>

<span data-ttu-id="782b3-104">Существует множество приложений, которые создают потоки, которые тратят много времени в спящем режиме, ожидая возникновения события.</span><span class="sxs-lookup"><span data-stu-id="782b3-104">There are many applications that create threads that spend a great deal of time in the sleeping state waiting for an event to occur.</span></span> <span data-ttu-id="782b3-105">Другие потоки могут войти в спящее состояние только для периодического опроса на наличие изменений или сведений о состоянии обновления.</span><span class="sxs-lookup"><span data-stu-id="782b3-105">Other threads may enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="782b3-106">*Пул потоков* позволяет более эффективно использовать потоки, предоставляя приложению пул рабочих потоков, управляемых системой.</span><span class="sxs-lookup"><span data-stu-id="782b3-106">*Thread pooling* enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="782b3-107">По крайней мере один поток отслеживает состояние всех операций ожидания, поставленных в очередь пула потоков.</span><span class="sxs-lookup"><span data-stu-id="782b3-107">At least one thread monitors the status of all wait operations queued to the thread pool.</span></span> <span data-ttu-id="782b3-108">По завершении операции ожидания рабочий поток из пула потоков выполняет соответствующую функцию обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="782b3-108">When a wait operation has completed, a worker thread from the thread pool executes the corresponding callback function.</span></span>

<span data-ttu-id="782b3-109">В этом разделе описывается исходный API пула потоков.</span><span class="sxs-lookup"><span data-stu-id="782b3-109">This topic describes the original thread pool API.</span></span> <span data-ttu-id="782b3-110">API пула потоков, появившийся в Windows Vista, более простой, более надежный, имеет лучшую производительность и обеспечивает большую гибкость для разработчиков.</span><span class="sxs-lookup"><span data-stu-id="782b3-110">The thread pool API introduced in Windows Vista is simpler, more reliable, has better performance, and provides more flexibility for developers.</span></span> <span data-ttu-id="782b3-111">Сведения о текущем API пула потоков см. в разделе [Пулы потоков](thread-pools.md).</span><span class="sxs-lookup"><span data-stu-id="782b3-111">For information on the current thread pool API, see [Thread Pools](thread-pools.md).</span></span>

<span data-ttu-id="782b3-112">Кроме того, можно ставить в очередь рабочие элементы, не связанные с операцией ожидания, в пул потоков.</span><span class="sxs-lookup"><span data-stu-id="782b3-112">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="782b3-113">Чтобы запросить обработку рабочего элемента потоком в пуле потоков, вызовите функцию [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) .</span><span class="sxs-lookup"><span data-stu-id="782b3-113">To request that a work item be handled by a thread in the thread pool, call the [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) function.</span></span> <span data-ttu-id="782b3-114">Эта функция принимает в функцию параметр, который будет вызываться потоком, выбранным из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="782b3-114">This function takes a parameter to the function that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="782b3-115">Невозможно отменить рабочий элемент после его постановки в очередь.</span><span class="sxs-lookup"><span data-stu-id="782b3-115">There is no way to cancel a work item after it has been queued.</span></span>

<span data-ttu-id="782b3-116">Таймеры [очереди](../sync/timer-queues.md) и [зарегистрированные операции ожидания](../sync/wait-functions.md) также используют пул потоков.</span><span class="sxs-lookup"><span data-stu-id="782b3-116">[Timer-queue timers](../sync/timer-queues.md) and [registered wait operations](../sync/wait-functions.md) also use the thread pool.</span></span> <span data-ttu-id="782b3-117">Функции обратного вызова помещаются в очередь пула потоков.</span><span class="sxs-lookup"><span data-stu-id="782b3-117">Their callback functions are queued to the thread pool.</span></span> <span data-ttu-id="782b3-118">Можно также использовать функцию [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) для выполнения операций асинхронного ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="782b3-118">You can also use the [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) function to post asynchronous I/O operations.</span></span> <span data-ttu-id="782b3-119">По завершении операции ввода-вывода обратный вызов выполняется потоком пула потоков.</span><span class="sxs-lookup"><span data-stu-id="782b3-119">On completion of the I/O , the callback is executed by a thread pool thread.</span></span>

<span data-ttu-id="782b3-120">Пул потоков создается при первом вызове метода [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) или [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), а также когда таймер очереди таймера или зарегистрированная операция ожидания помещает функцию обратного вызова в очередь.</span><span class="sxs-lookup"><span data-stu-id="782b3-120">The thread pool is created the first time you call [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) or [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), or when a timer-queue timer or registered wait operation queues a callback function.</span></span> <span data-ttu-id="782b3-121">По умолчанию число потоков, которые могут быть созданы в пуле потоков, составляет примерно 500.</span><span class="sxs-lookup"><span data-stu-id="782b3-121">By default, the number of threads that can be created in the thread pool is about 500.</span></span> <span data-ttu-id="782b3-122">Каждый поток использует размер стека по умолчанию и выполняется с приоритетом по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="782b3-122">Each thread uses the default stack size and runs at the default priority.</span></span>

<span data-ttu-id="782b3-123">В пуле потоков существует два типа рабочих потоков: операции ввода-вывода и неоперации ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="782b3-123">There are two types of worker threads in the thread pool: I/O and non-I/O.</span></span> <span data-ttu-id="782b3-124">*Рабочий поток ввода-вывода* — это поток, который ожидает состояния ожидания с оповещением.</span><span class="sxs-lookup"><span data-stu-id="782b3-124">An *I/O worker thread* is a thread that waits in an alertable wait state.</span></span> <span data-ttu-id="782b3-125">Рабочие элементы помещаются в очередь рабочих потоков ввода-вывода в виде асинхронных вызовов процедур (APC).</span><span class="sxs-lookup"><span data-stu-id="782b3-125">Work items are queued to I/O worker threads as asynchronous procedure calls (APC).</span></span> <span data-ttu-id="782b3-126">Необходимо поместить рабочий элемент в очередь в рабочий поток ввода-вывода, если он должен выполняться в потоке, который ожидает оповещения в состоянии.</span><span class="sxs-lookup"><span data-stu-id="782b3-126">You should queue a work item to an I/O worker thread if it should be executed in a thread that waits in an alertable state.</span></span>

<span data-ttu-id="782b3-127">*Рабочий поток, не связанный с вводом-выводом* , ожидает порты завершения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="782b3-127">A *non-I/O worker thread* waits on I/O completion ports.</span></span> <span data-ttu-id="782b3-128">Использование рабочих потоков, не связанных с вводом-выводом, является более эффективным, чем использование рабочих потоков ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="782b3-128">Using non-I/O worker threads is more efficient than using I/O worker threads.</span></span> <span data-ttu-id="782b3-129">Поэтому, когда это возможно, следует использовать рабочие потоки, не являющиеся операциями ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="782b3-129">Therefore, you should use non-I/O worker threads whenever possible.</span></span> <span data-ttu-id="782b3-130">Рабочие потоки ввода-вывода и не-O не завершают работу, если ожидаются асинхронные запросы ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="782b3-130">Both I/O and non-I/O worker threads do not exit if there are pending asynchronous I/O requests.</span></span> <span data-ttu-id="782b3-131">Оба типа потоков могут использоваться рабочими элементами, которые инициируют асинхронные запросы на завершение операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="782b3-131">Both types of threads can be used by work items that initiate asynchronous I/O completion requests.</span></span> <span data-ttu-id="782b3-132">Однако следует избегать выполнения асинхронных запросов на завершение операций ввода-вывода в рабочих потоках, не относящихся к операции ввода-вывода, если это может занять много времени.</span><span class="sxs-lookup"><span data-stu-id="782b3-132">However, avoid posting asynchronous I/O completion requests in non-I/O worker threads if they could take a long time to complete.</span></span>

<span data-ttu-id="782b3-133">Для использования пула потоков рабочие элементы и все функции, которые они вызывают, должны быть надежными в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="782b3-133">To use thread pooling, the work items and all the functions they call must be thread-pool safe.</span></span> <span data-ttu-id="782b3-134">В защищенной функции не предполагается, что поток, выполняющий эту функцию, является выделенным или постоянным потоком.</span><span class="sxs-lookup"><span data-stu-id="782b3-134">A safe function does not assume that the thread executing it is a dedicated or persistent thread.</span></span> <span data-ttu-id="782b3-135">Как правило, следует избегать использования [локального хранилища потока](thread-local-storage.md) или асинхронного вызова, требующего постоянного потока, например функции [**регнотифичанжекэйвалуе**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) .</span><span class="sxs-lookup"><span data-stu-id="782b3-135">In general, you should avoid using [thread local storage](thread-local-storage.md) or making an asynchronous call that requires a persistent thread, such as the [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) function.</span></span> <span data-ttu-id="782b3-136">Однако такие функции могут вызываться для выделенного потока (созданного приложением) или помещены в очередь постоянного рабочего потока (с помощью [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) с \_ параметром WT ексекутеинперсистентсреад).</span><span class="sxs-lookup"><span data-stu-id="782b3-136">However, such functions can be called on a dedicated thread (created by the application) or queued to a persistent worker thread (using [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) with the WT\_EXECUTEINPERSISTENTTHREAD option).</span></span>

## <a name="related-topics"></a><span data-ttu-id="782b3-137">См. также</span><span class="sxs-lookup"><span data-stu-id="782b3-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="782b3-138">Ввод-вывод с оповещением</span><span class="sxs-lookup"><span data-stu-id="782b3-138">Alertable I/O</span></span>](../fileio/alertable-i-o.md)
</dt> <dt>

[<span data-ttu-id="782b3-139">Асинхронные вызовы процедур</span><span class="sxs-lookup"><span data-stu-id="782b3-139">Asynchronous Procedure Calls</span></span>](../sync/asynchronous-procedure-calls.md)
</dt> <dt>

[<span data-ttu-id="782b3-140">Порты завершения ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="782b3-140">I/O Completion Ports</span></span>](../fileio/i-o-completion-ports.md)
</dt> <dt>

[<span data-ttu-id="782b3-141">Пулы потоков</span><span class="sxs-lookup"><span data-stu-id="782b3-141">Thread Pools</span></span>](thread-pools.md)
</dt> </dl>

 

 
