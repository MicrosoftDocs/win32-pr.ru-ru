---
description: Начиная с Windows 8.1 кодек Windows Imaging Component (WIC) JPEG поддерживает чтение и запись данных изображений в собственной форме Икбкр.
ms.assetid: 50B89A96-72E8-4771-9109-207F4CDD06CB
title: Поддержка Икбкр JPEG
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b6a8f05fe55e724a12513f24fc7401d277ebf097
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "103998576"
---
# <a name="jpeg-ycbcr-support"></a><span data-ttu-id="63129-103">Поддержка Икбкр JPEG</span><span class="sxs-lookup"><span data-stu-id="63129-103">JPEG YCbCr Support</span></span>

<span data-ttu-id="63129-104">Начиная с Windows 8.1 кодек [Windows Imaging Component (WIC)](-wic-about-windows-imaging-codec.md) JPEG поддерживает чтение и запись данных изображений в собственной форме Yc<sub>b</sub>C<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-104">Starting with Windows 8.1, the [Windows Imaging Component (WIC)](-wic-about-windows-imaging-codec.md) JPEG codec supports reading and writing image data in its native YC<sub>b</sub>C<sub>r</sub> form.</span></span> <span data-ttu-id="63129-105">Поддержка WIC YC<sub>b</sub>c<sub>r</sub> может использоваться вместе с [DIRECT2D](../direct2d/direct2d-portal.md) для отрисовки данных Yc<sub>b</sub>C<sub>r</sub> пикселей с помощью эффектов изображения.</span><span class="sxs-lookup"><span data-stu-id="63129-105">WIC YC<sub>b</sub>C<sub>r</sub> support can be used in conjunction with [Direct2D](../direct2d/direct2d-portal.md) to render YC<sub>b</sub>C<sub>r</sub> pixel data with an image effect.</span></span> <span data-ttu-id="63129-106">Кроме того, кодек WIC JPEG может использовать данные YC<sub>b</sub>C<sub>r</sub> Pixel, созданные определенными драйверами камеры с помощью Media Foundation.</span><span class="sxs-lookup"><span data-stu-id="63129-106">In addition, the WIC JPEG codec can consume YC<sub>b</sub>C<sub>r</sub> pixel data produced by certain camera drivers via Media Foundation.</span></span>

<span data-ttu-id="63129-107">YC<sub>b</sub>C<sub>r</sub> пиксель Data потребляет значительно меньше памяти, чем стандартные форматы пикселей BGRA.</span><span class="sxs-lookup"><span data-stu-id="63129-107">YC<sub>b</sub>C<sub>r</sub> pixel data consumes significantly less memory than standard BGRA pixel formats.</span></span> <span data-ttu-id="63129-108">Кроме того, доступ к данным YC<sub>b</sub>C<sub>r</sub> позволяет разгрузить некоторые этапы конвейера декодирования и кодирования JPEG в DIRECT2D, который поддерживает процессор с ускорителем.</span><span class="sxs-lookup"><span data-stu-id="63129-108">In addition, accessing YC<sub>b</sub>C<sub>r</sub> data allows you to offload some stages of the JPEG decode/encode pipeline to Direct2D which is GPU accelerated.</span></span> <span data-ttu-id="63129-109">С помощью YC<sub>b</sub>C<sub>r</sub>приложение может сократить потребление памяти JPEG и время загрузки для тех же образов размеров и качества.</span><span class="sxs-lookup"><span data-stu-id="63129-109">By using YC<sub>b</sub>C<sub>r</sub>, your app can reduce JPEG memory consumption and load times for the same size and quality images.</span></span> <span data-ttu-id="63129-110">Или приложение может использовать более высокое разрешение изображений JPEG, не низкий от потерь производительности.</span><span class="sxs-lookup"><span data-stu-id="63129-110">Or, your app can use more, higher resolution JPEG images without suffering from performance penalties.</span></span>

<span data-ttu-id="63129-111">В этом разделе описывается, как работают данные YC<sub>b</sub>C<sub>r</sub> и как использовать их в WIC и Direct2D.</span><span class="sxs-lookup"><span data-stu-id="63129-111">This topic describes how YC<sub>b</sub>C<sub>r</sub> data works and how to use it in WIC and Direct2D.</span></span>

-   [<span data-ttu-id="63129-112">О формате JPEG YC<sub>b</sub>C<sub>r</sub> Data</span><span class="sxs-lookup"><span data-stu-id="63129-112">About JPEG YC<sub>b</sub>C<sub>r</sub> Data</span></span>](#about-jpeg-ycbcr-data)
    -   [<span data-ttu-id="63129-113">Цветовая модель YC<sub>b</sub>C<sub>r</sub></span><span class="sxs-lookup"><span data-stu-id="63129-113">YC<sub>b</sub>C<sub>r</sub> Color Model</span></span>](#ycbcr-color-model)
    -   [<span data-ttu-id="63129-114">Плоские и чередующиеся макеты памяти</span><span class="sxs-lookup"><span data-stu-id="63129-114">Planar Versus Interleaved Memory Layouts</span></span>](#planar-versus-interleaved-memory-layouts)
    -   [<span data-ttu-id="63129-115">Подвыборка чрома</span><span class="sxs-lookup"><span data-stu-id="63129-115">Chroma Subsampling</span></span>](#chroma-subsampling)
    -   [<span data-ttu-id="63129-116">Использование JPEG для YC<sub>b</sub>C<sub>r</sub></span><span class="sxs-lookup"><span data-stu-id="63129-116">JPEG Usage of YC<sub>b</sub>C<sub>r</sub></span></span>](#jpeg-usage-of-ycbcr)
-   [<span data-ttu-id="63129-117">Использование JPEG YC<sub>b</sub>C<sub>r</sub> Data</span><span class="sxs-lookup"><span data-stu-id="63129-117">Using JPEG YC<sub>b</sub>C<sub>r</sub> Data</span></span>](#using-jpeg-ycbcr-data)
    -   [<span data-ttu-id="63129-118">Использование изображений в формате JPEG YC<sub>b</sub>C<sub>r</sub></span><span class="sxs-lookup"><span data-stu-id="63129-118">Using YC<sub>b</sub>C<sub>r</sub> JPEG images</span></span>](#using-ycbcr-jpeg-images)
    -   [<span data-ttu-id="63129-119">API компонентов работы с образами Windows</span><span class="sxs-lookup"><span data-stu-id="63129-119">Windows Imaging Component APIs</span></span>](#windows-imaging-component-apis)
    -   [<span data-ttu-id="63129-120">API-интерфейсы Direct2D</span><span class="sxs-lookup"><span data-stu-id="63129-120">Direct2D APIs</span></span>](#direct2d-apis)
    -   [<span data-ttu-id="63129-121">Определение, поддерживается ли конфигурация YC<sub>b</sub>C<sub>r</sub></span><span class="sxs-lookup"><span data-stu-id="63129-121">Determining if the YC<sub>b</sub>C<sub>r</sub> Configuration is Supported</span></span>](#determining-if-the-ycbcr-configuration-is-supported)
    -   [<span data-ttu-id="63129-122">Декодирование данных YC<sub>b</sub>C<sub>r</sub> Pixel</span><span class="sxs-lookup"><span data-stu-id="63129-122">Decoding YC<sub>b</sub>C<sub>r</sub> Pixel Data</span></span>](#decoding-ycbcr-pixel-data)
    -   [<span data-ttu-id="63129-123">Преобразование данных YC<sub>b</sub>C<sub>r</sub> Pixel</span><span class="sxs-lookup"><span data-stu-id="63129-123">Transforming YC<sub>b</sub>C<sub>r</sub> Pixel Data</span></span>](#transforming-ycbcr-pixel-data)
    -   [<span data-ttu-id="63129-124">Кодирование YC<sub>b</sub>C<sub>r</sub> пиксель Data</span><span class="sxs-lookup"><span data-stu-id="63129-124">Encoding YC<sub>b</sub>C<sub>r</sub> Pixel Data</span></span>](#encoding-ycbcr-pixel-data)
    -   [<span data-ttu-id="63129-125">Декодирование данных YC<sub>b</sub>C<sub>r</sub> Pixel в Windows 10</span><span class="sxs-lookup"><span data-stu-id="63129-125">Decoding YC<sub>b</sub>C<sub>r</sub> pixel data in Windows 10</span></span>](#decoding-ycbcr-pixel-data-in-windows-10)
-   [<span data-ttu-id="63129-126">См. также</span><span class="sxs-lookup"><span data-stu-id="63129-126">Related topics</span></span>](#related-topics)

## <a name="about-jpeg-ycsubbsubcsubrsub-data"></a><span data-ttu-id="63129-127">О формате JPEG YC<sub>b</sub>C<sub>r</sub> Data</span><span class="sxs-lookup"><span data-stu-id="63129-127">About JPEG YC<sub>b</sub>C<sub>r</sub> Data</span></span>

<span data-ttu-id="63129-128">В этом разделе объясняются некоторые основные понятия, необходимые для понимания того, как работает YC<sub>b</sub>C<sub>r</sub> в WIC и его основные преимущества.</span><span class="sxs-lookup"><span data-stu-id="63129-128">This section explains some key concepts necessary to understand how YC<sub>b</sub>C<sub>r</sub> support in WIC works and its key benefits.</span></span>

### <a name="ycsubbsubcsubrsub-color-model"></a><span data-ttu-id="63129-129">Цветовая модель YC<sub>b</sub>C<sub>r</sub></span><span class="sxs-lookup"><span data-stu-id="63129-129">YC<sub>b</sub>C<sub>r</sub> Color Model</span></span>

<span data-ttu-id="63129-130">Компонент WIC в Windows 8 и более ранних версий поддерживает четыре различные [цветовые модели](-wic-codec-native-pixel-formats.md), наиболее распространенный из которых — RGB/BGR.</span><span class="sxs-lookup"><span data-stu-id="63129-130">WIC in Windows 8 and earlier supports four different [color models](-wic-codec-native-pixel-formats.md), the most common of which is RGB/BGR.</span></span> <span data-ttu-id="63129-131">Эта цветовая модель определяет цвет данных с помощью красного, зеленого и синего компонентов; также можно использовать Четвертый альфа-компонент.</span><span class="sxs-lookup"><span data-stu-id="63129-131">This color model defines color data using red, green and blue components; a fourth alpha component may also be used.</span></span>

<span data-ttu-id="63129-132">Ниже приведено изображение, разстоящее в красном, зеленом и синем компонентах.</span><span class="sxs-lookup"><span data-stu-id="63129-132">Here is an image decomposed into its red, green and blue components.</span></span>

![изображение, разстоящее в красно, зеленом и синем компонентах.](graphics/ycbcr1.png)

<span data-ttu-id="63129-134">YC<sub>b</sub>C<sub>r</sub> — это альтернативная цветовая модель, определяющая цветовые данные с помощью компонента освещенности (Y) и двух компонентов чроминанце (c<sub>b</sub> и c<sub>r</sub>).</span><span class="sxs-lookup"><span data-stu-id="63129-134">YC<sub>b</sub>C<sub>r</sub> is an alternate color model that defines color data using a luminance component (Y) and two chrominance components (C<sub>b</sub> and C<sub>r</sub>).</span></span> <span data-ttu-id="63129-135">Она обычно используется в сценариях работы с цифровыми изображениями и видео.</span><span class="sxs-lookup"><span data-stu-id="63129-135">It is commonly used in digital imaging and video scenarios.</span></span> <span data-ttu-id="63129-136">Термин YC<sub>b</sub>C<sub>r</sub> часто используется с YUV, хотя эти два являются неизменными.</span><span class="sxs-lookup"><span data-stu-id="63129-136">The term YC<sub>b</sub>C<sub>r</sub> is often used interchangeably with YUV, although the two are technically distinct.</span></span>

<span data-ttu-id="63129-137">Существует несколько разновидностей YC<sub>b</sub>C<sub>r</sub> , которые отличаются цветовым пространством и динамическими определениями диапазонов — WIC специально поддерживает JPEG JFIF Yc<sub>b</sub>C<sub>r</sub> Data.</span><span class="sxs-lookup"><span data-stu-id="63129-137">There are several variations of YC<sub>b</sub>C<sub>r</sub> which differ in color space and dynamic range definitions – WIC specifically supports JPEG JFIF YC<sub>b</sub>C<sub>r</sub> data.</span></span> <span data-ttu-id="63129-138">Дополнительные сведения см. в [спецификации JPEG ITU-T81](https://www.w3.org/Graphics/JPEG/itu-t81.pdf).</span><span class="sxs-lookup"><span data-stu-id="63129-138">For more information, refer to the [JPEG ITU-T81 specification](https://www.w3.org/Graphics/JPEG/itu-t81.pdf).</span></span>

<span data-ttu-id="63129-139">Ниже приведен образ, состоящий из компонентов Y, C<sub>b</sub>и c<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-139">Here is an image decomposed into its Y, C<sub>b</sub>, and C<sub>r</sub> components.</span></span>

![изображение, разстоящее в компонентах y, CB и CR.](graphics/ycbcr2.png)

### <a name="planar-versus-interleaved-memory-layouts"></a><span data-ttu-id="63129-141">Плоские и чередующиеся макеты памяти</span><span class="sxs-lookup"><span data-stu-id="63129-141">Planar Versus Interleaved Memory Layouts</span></span>

<span data-ttu-id="63129-142">В этом разделе описываются некоторые различия между доступом и хранением данных пикселей RGB в памяти и YC<sub>b</sub>C<sub>r</sub> Data.</span><span class="sxs-lookup"><span data-stu-id="63129-142">This section describes some differences between accessing and storing RGB pixel data in memory versus YC<sub>b</sub>C<sub>r</sub> data.</span></span>

<span data-ttu-id="63129-143">Данные пикселей RGB обычно хранятся с использованием чередования макета памяти.</span><span class="sxs-lookup"><span data-stu-id="63129-143">RGB pixel data is typically stored using an interleaved memory layout.</span></span> <span data-ttu-id="63129-144">Это означает, что данные для одного компонента цвета чередуются между пикселями, и каждый пиксель хранится непрерывно в памяти.</span><span class="sxs-lookup"><span data-stu-id="63129-144">This means that data for a single color component is interleaved between pixels, and each pixel is stored contiguously in memory.</span></span>

<span data-ttu-id="63129-145">Ниже приведен рисунок, показывающий пиксельные данные типа RGBA, хранящиеся в макете памяти с чередованием.</span><span class="sxs-lookup"><span data-stu-id="63129-145">Here is a figure showing RGBA pixel data stored in an interleaved memory layout.</span></span>

![Рисунок, показывающий пиксельные данные типа RGBA, хранящиеся в макете памяти с чередованием.](graphics/ycbcr3.png)

<span data-ttu-id="63129-147">Данные YC<sub>b</sub>C<sub>r</sub> обычно хранятся с помощью плоского макета памяти.</span><span class="sxs-lookup"><span data-stu-id="63129-147">YC<sub>b</sub>C<sub>r</sub> data is typically stored using a planar memory layout.</span></span> <span data-ttu-id="63129-148">Это означает, что каждый компонент цвета хранится отдельно в отдельной непрерывной плоскости для всего трех плоскостей.</span><span class="sxs-lookup"><span data-stu-id="63129-148">This means that each color component is stored separately in its own contiguous plane, for a total of three planes.</span></span> <span data-ttu-id="63129-149">В другой распространенной конфигурации компоненты C<sub>b</sub> и c<sub>r</sub> чередуются и хранятся вместе, а компонент Y остается в собственной плоскости, что составляет всего две плоскости.</span><span class="sxs-lookup"><span data-stu-id="63129-149">In another common configuration, the C<sub>b</sub> and C<sub>r</sub> components are interleaved and stored together, while the Y component remains in its own plane, for a total of two planes.</span></span>

<span data-ttu-id="63129-150">Ниже приведена фигура с плоской Y и чередованием данных<sub>в пикселах на c</sub> <sub>b</sub>c в виде общей структуры памяти Yc<sub>b</sub>c<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-150">Here is a figure showing planar Y and interleaved C<sub>b</sub>C<sub>r</sub> pixel data, a common YC<sub>b</sub>C<sub>r</sub> memory layout.</span></span>

![Рисунок, показывающий плоские и чередующиеся кбкр данные пикселей, общий макет памяти икбкр.](graphics/ycbcr4.png)

<span data-ttu-id="63129-152">В WIC и Direct2D Каждая цветовая палитра рассматривается как отдельный отдельный объект ( [IWICBitmapSource](-wic-imp-iwicbitmapsource.md) или [**ID2D1Bitmap**](/windows/win32/api/d2d1/nn-d2d1-id2d1bitmap)), и вместе эти плоскости формируют резервные данные для изображения Yc <sub>b</sub>C <sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-152">In both WIC and Direct2D, each color plane is treated as its own distinct object (either an [IWICBitmapSource](-wic-imp-iwicbitmapsource.md) or [**ID2D1Bitmap**](/windows/win32/api/d2d1/nn-d2d1-id2d1bitmap)), and collectively these planes form the backing data for a YC<sub>b</sub>C<sub>r</sub> image.</span></span>

<span data-ttu-id="63129-153">Хотя компонент WIC поддерживает доступ к данным YC<sub>b</sub>C<sub>r</sub> в конфигурациях плоскости 2 и 3, Direct2D поддерживает только бывшие первые (Y и c<sub>b</sub>c<sub>r</sub>).</span><span class="sxs-lookup"><span data-stu-id="63129-153">While WIC supports accessing YC<sub>b</sub>C<sub>r</sub> data in both the 2 and 3 plane configurations, Direct2D only supports the former (Y and C<sub>b</sub>C<sub>r</sub>).</span></span> <span data-ttu-id="63129-154">Поэтому при совместном использовании WIC и Direct2D следует всегда использовать конфигурацию 2 плоскости YC<sub>b</sub>C<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-154">Therefore, when using WIC and Direct2D together you should always use the 2 plane YC<sub>b</sub>C<sub>r</sub> configuration.</span></span>

### <a name="chroma-subsampling"></a><span data-ttu-id="63129-155">Подвыборка чрома</span><span class="sxs-lookup"><span data-stu-id="63129-155">Chroma Subsampling</span></span>

<span data-ttu-id="63129-156">Цветовая модель YC<sub>b</sub>C<sub>r</sub> хорошо подходит для сценариев работы с цифровыми образами, поскольку она может использовать преимущества некоторых аспектов системы человеческого визуального элемента.</span><span class="sxs-lookup"><span data-stu-id="63129-156">The YC<sub>b</sub>C<sub>r</sub> color model is well suited for digital imaging scenarios because it can take advantage of certain aspects of the human visual system.</span></span> <span data-ttu-id="63129-157">В частности, люди более чувствительны к изменениям светимости (яркости) изображения и менее чувствительны к чроминанце (цвету).</span><span class="sxs-lookup"><span data-stu-id="63129-157">In particular, humans are more sensitive to changes in the luminance (brightness) of an image and less sensitive to chrominance (color).</span></span> <span data-ttu-id="63129-158">Разделив данные цвета на отдельные компоненты светимости и чроминанце, можно выборочно сжимать только компоненты чроминанце, чтобы добиться экономии места с минимальной потерей качества.</span><span class="sxs-lookup"><span data-stu-id="63129-158">By splitting the color data into separate luminance and chrominance components, we can selectively compress just the chrominance components to achieve space savings with a minimal loss in quality.</span></span>

<span data-ttu-id="63129-159">Один из способов сделать это называется подвыборкой чрома.</span><span class="sxs-lookup"><span data-stu-id="63129-159">One technique for doing this is called chroma subsampling.</span></span> <span data-ttu-id="63129-160">Плоскости C<sub>b</sub> и c<sub>r</sub> являются подвыборкой (довнскалед) в одном или обоих горизонтальных и вертикальных измерениях.</span><span class="sxs-lookup"><span data-stu-id="63129-160">The C<sub>b</sub> and C<sub>r</sub> planes are subsampled (downscaled) in one or both of the horizontal and vertical dimensions.</span></span> <span data-ttu-id="63129-161">По историческим причинам каждый чрома режим подвыборки часто именуется с использованием трех частей Ж:а: b.</span><span class="sxs-lookup"><span data-stu-id="63129-161">For historical reasons, each chroma subsampling mode is commonly referred to using a three part J:a:b ratio.</span></span>



| <span data-ttu-id="63129-162">Режим подвыборки</span><span class="sxs-lookup"><span data-stu-id="63129-162">Subsampling mode</span></span> | <span data-ttu-id="63129-163">Горизонтальное довнскале</span><span class="sxs-lookup"><span data-stu-id="63129-163">Horizontal downscale</span></span> | <span data-ttu-id="63129-164">Вертикальный довнскале</span><span class="sxs-lookup"><span data-stu-id="63129-164">Vertical downscale</span></span> | <span data-ttu-id="63129-165">Бит на пиксель\*</span><span class="sxs-lookup"><span data-stu-id="63129-165">Bits per pixel\*</span></span> |
|------------------|----------------------|--------------------|------------------|
| <span data-ttu-id="63129-166">4:4:4</span><span class="sxs-lookup"><span data-stu-id="63129-166">4:4:4</span></span>            | <span data-ttu-id="63129-167">1x</span><span class="sxs-lookup"><span data-stu-id="63129-167">1x</span></span>                   | <span data-ttu-id="63129-168">1x</span><span class="sxs-lookup"><span data-stu-id="63129-168">1x</span></span>                 | <span data-ttu-id="63129-169">24</span><span class="sxs-lookup"><span data-stu-id="63129-169">24</span></span>               |
| <span data-ttu-id="63129-170">4:2:2</span><span class="sxs-lookup"><span data-stu-id="63129-170">4:2:2</span></span>            | <span data-ttu-id="63129-171">2x</span><span class="sxs-lookup"><span data-stu-id="63129-171">2x</span></span>                   | <span data-ttu-id="63129-172">1x</span><span class="sxs-lookup"><span data-stu-id="63129-172">1x</span></span>                 | <span data-ttu-id="63129-173">16</span><span class="sxs-lookup"><span data-stu-id="63129-173">16</span></span>               |
| <span data-ttu-id="63129-174">4:4:0</span><span class="sxs-lookup"><span data-stu-id="63129-174">4:4:0</span></span>            | <span data-ttu-id="63129-175">1x</span><span class="sxs-lookup"><span data-stu-id="63129-175">1x</span></span>                   | <span data-ttu-id="63129-176">2x</span><span class="sxs-lookup"><span data-stu-id="63129-176">2x</span></span>                 | <span data-ttu-id="63129-177">16</span><span class="sxs-lookup"><span data-stu-id="63129-177">16</span></span>               |
| <span data-ttu-id="63129-178">4:2:0</span><span class="sxs-lookup"><span data-stu-id="63129-178">4:2:0</span></span>            | <span data-ttu-id="63129-179">2x</span><span class="sxs-lookup"><span data-stu-id="63129-179">2x</span></span>                   | <span data-ttu-id="63129-180">2x</span><span class="sxs-lookup"><span data-stu-id="63129-180">2x</span></span>                 | <span data-ttu-id="63129-181">12</span><span class="sxs-lookup"><span data-stu-id="63129-181">12</span></span>               |



 

<span data-ttu-id="63129-182">\* Включает данные Y.</span><span class="sxs-lookup"><span data-stu-id="63129-182">\* Includes Y data.</span></span>

<span data-ttu-id="63129-183">В приведенной выше таблице при использовании YC<sub>b</sub>C<sub>r</sub> для хранения несжатых данных изображения можно добиться экономии памяти от 25% до 62,5% относительно 32 бит на пиксельные данные RGBA в зависимости от того, какой режим подвыборки чрома используется.</span><span class="sxs-lookup"><span data-stu-id="63129-183">From the above table, if you use YC<sub>b</sub>C<sub>r</sub> to store uncompressed image data you can achieve a memory savings of 25% to 62.5% versus 32 bit per pixel RGBA data, depending on which chroma subsampling mode is used.</span></span>

### <a name="jpeg-usage-of-ycsubbsubcsubrsub"></a><span data-ttu-id="63129-184">Использование JPEG для YC<sub>b</sub>C<sub>r</sub></span><span class="sxs-lookup"><span data-stu-id="63129-184">JPEG Usage of YC<sub>b</sub>C<sub>r</sub></span></span>

<span data-ttu-id="63129-185">На высоком уровне конвейер распаковки JPEG состоит из следующих этапов:</span><span class="sxs-lookup"><span data-stu-id="63129-185">At a high level, the JPEG decompression pipeline consists of the following stages:</span></span>

1.  <span data-ttu-id="63129-186">Выполнить распаковку (например, Хаффмана)</span><span class="sxs-lookup"><span data-stu-id="63129-186">Perform entropy (e.g. Huffman) decompression</span></span>
2.  <span data-ttu-id="63129-187">Выполнение декуантизатион</span><span class="sxs-lookup"><span data-stu-id="63129-187">Perform dequantization</span></span>
3.  <span data-ttu-id="63129-188">Выполнить обратное дискретное преобразование косинуса</span><span class="sxs-lookup"><span data-stu-id="63129-188">Perform inverse discrete cosine transform</span></span>
4.  <span data-ttu-id="63129-189">Выполнить чроманую выборку данных на C<sub>b</sub>c<sub>r</sub></span><span class="sxs-lookup"><span data-stu-id="63129-189">Perform chroma upsampling on C<sub>b</sub>C<sub>r</sub> data</span></span>
5.  <span data-ttu-id="63129-190">Преобразование данных YC<sub>b</sub>C<sub>r</sub> в RGBA (при необходимости)</span><span class="sxs-lookup"><span data-stu-id="63129-190">Convert YC<sub>b</sub>C<sub>r</sub> data to RGBA (if needed)</span></span>

<span data-ttu-id="63129-191">Если кодек JPEG создает данные YC<sub>b</sub>C<sub>r</sub> , мы можем избежать заключительных двух этапов процесса декодирования или отложить их на GPU.</span><span class="sxs-lookup"><span data-stu-id="63129-191">By having the JPEG codec produce YC<sub>b</sub>C<sub>r</sub> data, we can avoid the final two steps of the decode process, or defer them to the GPU.</span></span> <span data-ttu-id="63129-192">Помимо экономии памяти, приведенной в предыдущем разделе, это значительно сокращает общее время, необходимое для декодирования изображения.</span><span class="sxs-lookup"><span data-stu-id="63129-192">In addition to the memory savings listed in the previous section, this significantly reduces overall time needed to decode the image.</span></span> <span data-ttu-id="63129-193">Такая же экономия применяется при кодировании данных YC<sub>b</sub>C<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-193">The same savings apply when encoding YC<sub>b</sub>C<sub>r</sub> data.</span></span>

## <a name="using-jpeg-ycsubbsubcsubrsub-data"></a><span data-ttu-id="63129-194">Использование JPEG YC<sub>b</sub>C<sub>r</sub> Data</span><span class="sxs-lookup"><span data-stu-id="63129-194">Using JPEG YC<sub>b</sub>C<sub>r</sub> Data</span></span>

<span data-ttu-id="63129-195">В этом разделе объясняется, как использовать WIC и Direct2D для работы с данными YC<sub>b</sub>C<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-195">This section explains how to use WIC and Direct2D to operate on YC<sub>b</sub>C<sub>r</sub> data.</span></span>

<span data-ttu-id="63129-196">Рекомендации из этого документа, используемые на практике, см. в разделе [Оптимизация Икбкр JPEG в Direct2D и WIC пример](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Official%20Windows%20Platform%20Sample/JPEG%20YCbCr%20optimizations%20in%20Direct2D%20and%20WIC%20sample) , демонстрирующий все шаги, необходимые для декодирования и визуализации содержимого Yc<sub>b</sub>C<sub>r</sub> в приложении Direct2D.</span><span class="sxs-lookup"><span data-stu-id="63129-196">To see the guidance from this document used in practice, see the [JPEG YCbCr optimizations in Direct2D and WIC sample](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Official%20Windows%20Platform%20Sample/JPEG%20YCbCr%20optimizations%20in%20Direct2D%20and%20WIC%20sample) which demonstrates all of the steps needed to decode and render YC<sub>b</sub>C<sub>r</sub> content in a Direct2D app.</span></span>

### <a name="using-ycsubbsubcsubrsub-jpeg-images"></a><span data-ttu-id="63129-197">Использование изображений в формате JPEG YC<sub>b</sub>C<sub>r</sub></span><span class="sxs-lookup"><span data-stu-id="63129-197">Using YC<sub>b</sub>C<sub>r</sub> JPEG images</span></span>

<span data-ttu-id="63129-198">Подавляющее большинство изображений JPEG хранится в виде YC<sub>b</sub>C<sub>r</sub>.</span><span class="sxs-lookup"><span data-stu-id="63129-198">The vast majority of JPEG images are stored as YC<sub>b</sub>C<sub>r</sub>.</span></span> <span data-ttu-id="63129-199">Некоторые файлы JPEG содержат данные CMYK или градации серого и не используют YC<sub>b</sub>C<sub>r</sub>.</span><span class="sxs-lookup"><span data-stu-id="63129-199">Some JPEGs contain CMYK or grayscale data and do not use YC<sub>b</sub>C<sub>r</sub>.</span></span> <span data-ttu-id="63129-200">Это означает, что обычно, но не всегда, может напрямую использовать уже существующее содержимое JPEG без каких-либо изменений.</span><span class="sxs-lookup"><span data-stu-id="63129-200">This means that you typically, but not always, can directly use pre-existing JPEG content without any modifications.</span></span>

<span data-ttu-id="63129-201">WIC и Direct2D не поддерживают все возможные конфигурации YC<sub>b</sub>c<sub>r</sub> , а поддержка Yc<sub>b</sub>c<sub>r</sub> в Direct2D зависит от базового графического оборудования и драйвера.</span><span class="sxs-lookup"><span data-stu-id="63129-201">WIC and Direct2D do not support every possible YC<sub>b</sub>C<sub>r</sub> configuration, and YC<sub>b</sub>C<sub>r</sub> support in Direct2D is dependent upon the underlying graphics hardware and driver.</span></span> <span data-ttu-id="63129-202">По этой причине конвейер создания образов общего назначения должен быть устойчивым к изображениям, которые не используют YC<sub>b</sub>C<sub>r</sub> (включая другие распространенные форматы изображений, например PNG или BMP), а также в случаях, когда поддержка Yc<sub>b</sub>c<sub>r</sub> недоступна.</span><span class="sxs-lookup"><span data-stu-id="63129-202">Because of this, a general purpose imaging pipeline needs to be robust to images that do not use YC<sub>b</sub>C<sub>r</sub> (including other common image formats such as PNG or BMP) or to cases where YC<sub>b</sub>C<sub>r</sub> support is not available.</span></span> <span data-ttu-id="63129-203">Мы рекомендуем использовать существующий конвейер создания образов на основе BGRA и включить YC<sub>b</sub>C<sub>r</sub> в качестве оптимизации производительности, если это возможно.</span><span class="sxs-lookup"><span data-stu-id="63129-203">We recommend that you keep your existing BGRA based imaging pipeline and enable YC<sub>b</sub>C<sub>r</sub> as a performance optimization when available.</span></span>

### <a name="windows-imaging-component-apis"></a><span data-ttu-id="63129-204">API компонентов работы с образами Windows</span><span class="sxs-lookup"><span data-stu-id="63129-204">Windows Imaging Component APIs</span></span>

<span data-ttu-id="63129-205">WIC в Windows 8.1 добавляет три новых интерфейса для предоставления доступа к данным JPEG YC<sub>b</sub>C<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-205">WIC in Windows 8.1 adds three new interfaces to provide access to JPEG YC<sub>b</sub>C<sub>r</sub> data.</span></span>

### <a name="iwicplanarbitmapsourcetransform"></a><span data-ttu-id="63129-206">ивикпланарбитмапсаурцетрансформ</span><span class="sxs-lookup"><span data-stu-id="63129-206">IWICPlanarBitmapSourceTransform</span></span>

<span data-ttu-id="63129-207">[**Ивикпланарбитмапсаурцетрансформ**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapsourcetransform) является аналогом [**ивикбитмапсаурцетрансформ**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapsourcetransform), за исключением того, что он создает Пиксели в плоской конфигурации, включая Yc <sub>b</sub>C <sub>r</sub> Data.</span><span class="sxs-lookup"><span data-stu-id="63129-207">[**IWICPlanarBitmapSourceTransform**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapsourcetransform) is analogous to [**IWICBitmapSourceTransform**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapsourcetransform), except that it produces pixels in a planar configuration, including YC<sub>b</sub>C<sub>r</sub> data.</span></span> <span data-ttu-id="63129-208">Этот интерфейс можно получить путем вызова QueryInterface в реализации [**IWICBitmapSource**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapsource) , которая поддерживает плоский доступ.</span><span class="sxs-lookup"><span data-stu-id="63129-208">You can obtain this interface by calling QueryInterface on an implementation of [**IWICBitmapSource**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapsource) that supports planar access.</span></span> <span data-ttu-id="63129-209">Сюда входит реализация [**IWICBitmapFrameDecode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframedecode) КОДЕка JPEG, а также [**ивикбитмапскалер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapscaler), [**ивикбитмапфлипротатор**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapfliprotator)и [**ивикколортрансформ**](/windows/desktop/api/Wincodec/nn-wincodec-iwiccolortransform).</span><span class="sxs-lookup"><span data-stu-id="63129-209">This includes the JPEG codec’s implementation of [**IWICBitmapFrameDecode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframedecode) as well as [**IWICBitmapScaler**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapscaler), [**IWICBitmapFlipRotator**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapfliprotator), and [**IWICColorTransform**](/windows/desktop/api/Wincodec/nn-wincodec-iwiccolortransform).</span></span>

### <a name="iwicplanarbitmapframeencode"></a><span data-ttu-id="63129-210">ивикпланарбитмапфраминкоде</span><span class="sxs-lookup"><span data-stu-id="63129-210">IWICPlanarBitmapFrameEncode</span></span>

<span data-ttu-id="63129-211">[**Ивикпланарбитмапфраминкоде**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapframeencode) предоставляет возможность кодирования плоских данных пикселей, в том числе Yc <sub>b</sub>C <sub>r</sub> Data.</span><span class="sxs-lookup"><span data-stu-id="63129-211">[**IWICPlanarBitmapFrameEncode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapframeencode) provides the ability to encode planar pixel data, including YC<sub>b</sub>C<sub>r</sub> data.</span></span> <span data-ttu-id="63129-212">Этот интерфейс можно получить, вызвав QueryInterface в реализации [**ивикбитмапфраминкоде**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode)кодека JPEG.</span><span class="sxs-lookup"><span data-stu-id="63129-212">You can obtain this interface by calling QueryInterface on the JPEG codec’s implementation of [**IWICBitmapFrameEncode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode).</span></span>

### <a name="iwicplanarformatconverter"></a><span data-ttu-id="63129-213">ивикпланарформатконвертер</span><span class="sxs-lookup"><span data-stu-id="63129-213">IWICPlanarFormatConverter</span></span>

<span data-ttu-id="63129-214">[**Ивикпланарформатконвертер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarformatconverter) позволяет [**ивикформатконвертер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicformatconverter) использовать данные плоской точки, включая Yc <sub>b</sub>C <sub>r</sub>, и преобразовывать их в формат пикселей с чередованием.</span><span class="sxs-lookup"><span data-stu-id="63129-214">[**IWICPlanarFormatConverter**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarformatconverter) allows [**IWICFormatConverter**](/windows/desktop/api/Wincodec/nn-wincodec-iwicformatconverter) to consume planar pixel data, including YC<sub>b</sub>C<sub>r</sub>, and convert it to an interleaved pixel format.</span></span> <span data-ttu-id="63129-215">Он не предоставляет возможность преобразования чередующихся данных пикселей в плоский формат.</span><span class="sxs-lookup"><span data-stu-id="63129-215">It does not expose the ability to convert interleaved pixel data to a planar format.</span></span> <span data-ttu-id="63129-216">Этот интерфейс можно получить, вызвав QueryInterface в реализации **ивикформатконвертер**, предоставляемой Windows.</span><span class="sxs-lookup"><span data-stu-id="63129-216">You can obtain this interface by calling QueryInterface on the Windows provided implementation of **IWICFormatConverter**.</span></span>

### <a name="direct2d-apis"></a><span data-ttu-id="63129-217">API-интерфейсы Direct2D</span><span class="sxs-lookup"><span data-stu-id="63129-217">Direct2D APIs</span></span>

<span data-ttu-id="63129-218">Direct2D в Windows 8.1 поддерживает данные о YC<sub>b</sub>c<sub>в плоском</sub> пикселе с новым результатом создания изображения Yc<sub>b</sub>c<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-218">Direct2D in Windows 8.1 supports YC<sub>b</sub>C<sub>r</sub> planar pixel data with the new YC<sub>b</sub>C<sub>r</sub> image effect .</span></span> <span data-ttu-id="63129-219">Этот результат дает возможность визуализировать данные YC<sub>b</sub>C<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-219">This effect provides the ability to render YC<sub>b</sub>C<sub>r</sub> data.</span></span> <span data-ttu-id="63129-220">Этот результат принимает в качестве входных двух интерфейсов [**ID2D1Bitmap**](/windows/win32/api/d2d1/nn-d2d1-id2d1bitmap) : один, содержащий плоские данные Y в формате DXGI \_ \_ R8 \_ UNORM, и один, содержащий чередующиеся кбкр данные в формате DXGI \_ \_ R8G8 \_ UNORM.</span><span class="sxs-lookup"><span data-stu-id="63129-220">The effect takes as input two [**ID2D1Bitmap**](/windows/win32/api/d2d1/nn-d2d1-id2d1bitmap) interfaces: one containing planar Y data in the DXGI\_FORMAT\_R8\_UNORM format, and one containing interleaved CbCr data in the DXGI\_FORMAT\_R8G8\_UNORM format.</span></span> <span data-ttu-id="63129-221">Обычно этот результат используется вместо **ID2D1Bitmap** , который СОДЕРЖАЛ данные BGRA пикселей.</span><span class="sxs-lookup"><span data-stu-id="63129-221">You typically use this effect in place of the **ID2D1Bitmap** that would have contained BGRA pixel data.</span></span>

<span data-ttu-id="63129-222">Изображение YC<sub>b</sub>c на языке<sub>r</sub> предназначено для использования в сочетании<sub>с API-</sub> интерфейсами WIC Yc<sub>b</sub>c, которые предоставляют данные Yc<sub>b</sub>c<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-222">The YC<sub>b</sub>C<sub>r</sub> image effect is intended to be used in conjunction with the WIC YC<sub>b</sub>C<sub>r</sub> APIs which provide the YC<sub>b</sub>C<sub>r</sub> data.</span></span> <span data-ttu-id="63129-223">Это эффективно отвечает за отправку некоторых операций декодирования от ЦП к GPU, где он может обрабатываться намного быстрее и параллельно.</span><span class="sxs-lookup"><span data-stu-id="63129-223">This effectively acts to offload some of the decode work from the CPU to the GPU, where it can be processed much quicker and in parallel.</span></span>

### <a name="determining-if-the-ycsubbsubcsubrsub-configuration-is-supported"></a><span data-ttu-id="63129-224">Определение, поддерживается ли конфигурация YC<sub>b</sub>C<sub>r</sub></span><span class="sxs-lookup"><span data-stu-id="63129-224">Determining if the YC<sub>b</sub>C<sub>r</sub> Configuration is Supported</span></span>

<span data-ttu-id="63129-225">Как отмечалось ранее, приложение должно быть устойчивым к случаям, когда поддержка YC<sub>b</sub>C<sub>r</sub> недоступна.</span><span class="sxs-lookup"><span data-stu-id="63129-225">As noted before, your app should be robust to cases where YC<sub>b</sub>C<sub>r</sub> support is not available.</span></span> <span data-ttu-id="63129-226">В этом разделе обсуждаются условия, которые должно проверить приложение.</span><span class="sxs-lookup"><span data-stu-id="63129-226">This section discusses the conditions that your app should check for.</span></span> <span data-ttu-id="63129-227">При сбое любой из следующих проверок приложение должно вернуться к стандартному конвейеру на основе BGRA.</span><span class="sxs-lookup"><span data-stu-id="63129-227">If any of the following checks fail, your app should fall back to a standard BGRA-based pipeline.</span></span>

### <a name="does-the-wic-component-support-ycsubbsubcsubrsub-data-access"></a><span data-ttu-id="63129-228">Поддерживает ли компонент WIC доступ к данным YC<sub>b</sub>C<sub>r</sub> ?</span><span class="sxs-lookup"><span data-stu-id="63129-228">Does the WIC component support YC<sub>b</sub>C<sub>r</sub> data access?</span></span>

<span data-ttu-id="63129-229">Только предоставляемый Windows кодек JPEG и определенные преобразования WIC поддерживают доступ к данным YC<sub>b</sub>C<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-229">Only the Windows provided JPEG codec and certain WIC transforms support YC<sub>b</sub>C<sub>r</sub> data access.</span></span> <span data-ttu-id="63129-230">Полный список см. в разделе [API компонента Windows Imaging Component](#windows-imaging-component-apis) .</span><span class="sxs-lookup"><span data-stu-id="63129-230">For a complete list, refer to the [Windows Imaging Component APIs](#windows-imaging-component-apis) section.</span></span>

<span data-ttu-id="63129-231">Чтобы получить один из интерфейсов YC<sub>b</sub>C<sub>r</sub> , вызовите QueryInterface в исходном интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="63129-231">To obtain one of the planar YC<sub>b</sub>C<sub>r</sub> interfaces, call QueryInterface on the original interface.</span></span> <span data-ttu-id="63129-232">Это приведет к сбою, если компонент не поддерживает доступ к данным YC<sub>b</sub>C<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-232">This will fail if the component does not support YC<sub>b</sub>C<sub>r</sub> data access.</span></span>

### <a name="is-the-requested-wic-transform-supported-for-ycsubbsubcsubrsub"></a><span data-ttu-id="63129-233">Поддерживается ли запрошенное преобразование WIC для YC<sub>b</sub>C<sub>r</sub>?</span><span class="sxs-lookup"><span data-stu-id="63129-233">Is the requested WIC transform supported for YC<sub>b</sub>C<sub>r</sub>?</span></span>

<span data-ttu-id="63129-234">После получения [**ивикпланарбитмапсаурцетрансформ**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapsourcetransform)необходимо сначала вызвать [**доессуппорттрансформ**](/windows/desktop/api/Wincodec/nf-wincodec-iwicplanarbitmapsourcetransform-doessupporttransform).</span><span class="sxs-lookup"><span data-stu-id="63129-234">After obtaining an [**IWICPlanarBitmapSourceTransform**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapsourcetransform), you should first call [**DoesSupportTransform**](/windows/desktop/api/Wincodec/nf-wincodec-iwicplanarbitmapsourcetransform-doessupporttransform).</span></span> <span data-ttu-id="63129-235">Этот метод принимает в качестве входных параметров полный набор преобразований, которые необходимо применить к YC<sub>b</sub>C<sub>r</sub> -данным, и возвращает логическое значение, обозначающее поддержку, а также ближайшие измерения с запрошенным размером, который может быть возвращен.</span><span class="sxs-lookup"><span data-stu-id="63129-235">This method takes as input parameters the complete set of transforms that you want to be applied to the planar YC<sub>b</sub>C<sub>r</sub> data, and returns a Boolean indicating support, as well as the closest dimensions to the requested size that can be returned.</span></span> <span data-ttu-id="63129-236">Прежде чем обращаться к данным пикселей с помощью [**ивикпланарбитмапсаурцетрансформ:: CopyPixels**](/windows/desktop/api/Wincodec/nf-wincodec-iwicplanarbitmapsourcetransform-copypixels), необходимо проверить все три значения.</span><span class="sxs-lookup"><span data-stu-id="63129-236">You should check all three values before accessing the pixel data with [**IWICPlanarBitmapSourceTransform::CopyPixels**](/windows/desktop/api/Wincodec/nf-wincodec-iwicplanarbitmapsourcetransform-copypixels).</span></span>

<span data-ttu-id="63129-237">Этот шаблон аналогичен использованию [**ивикбитмапсаурцетрансформ**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapsourcetransform) .</span><span class="sxs-lookup"><span data-stu-id="63129-237">This pattern is similar to how [**IWICBitmapSourceTransform**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapsourcetransform) is used.</span></span>

### <a name="does-the-graphics-driver-support-the-features-necessary-to-use-ycsubbsubcsubrsub-with-direct2d"></a><span data-ttu-id="63129-238">Поддерживает ли графический драйвер функции, необходимые для использования YC<sub>b</sub>C<sub>r</sub> с Direct2D?</span><span class="sxs-lookup"><span data-stu-id="63129-238">Does the graphics driver support the features necessary to use YC<sub>b</sub>C<sub>r</sub> with Direct2D?</span></span>

<span data-ttu-id="63129-239">Эта проверка необходима только в том случае, если вы используете Direct2D YC<sub>b</sub>c<sub>r</sub> для визуализации содержимого Yc<sub>b</sub>c<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-239">This check is only necessary if you are using the Direct2D YC<sub>b</sub>C<sub>r</sub> effect to render YC<sub>b</sub>C<sub>r</sub> content.</span></span> <span data-ttu-id="63129-240">Direct2D сохраняет данные<sub>Yc в</sub>C<sub>r</sub> с помощью \_ формата DXGI \_ R8 \_ UNORM и \_ формата DXGI \_ R8G8 \_ UNORM пикселей, которые недоступны во всех графических драйверах.</span><span class="sxs-lookup"><span data-stu-id="63129-240">Direct2D stores YC<sub>b</sub>C<sub>r</sub> data using the DXGI\_FORMAT\_R8\_UNORM and DXGI\_FORMAT\_R8G8\_UNORM pixel formats, which are not available from all graphics drivers.</span></span>

<span data-ttu-id="63129-241">Перед использованием изображения YC <sub>b</sub>C в формате <sub>r</sub> необходимо вызвать [**ID2D1DeviceContext:: исдксгиформатсуппортед**](/windows/win32/api/d2d1_1/nf-d2d1_1-id2d1devicecontext-isdxgiformatsupported) , чтобы убедиться, что оба формата поддерживаются драйвером.</span><span class="sxs-lookup"><span data-stu-id="63129-241">Before using the YC <sub>b</sub>C <sub>r</sub> image effect, you should call [**ID2D1DeviceContext::IsDxgiFormatSupported**](/windows/win32/api/d2d1_1/nf-d2d1_1-id2d1devicecontext-isdxgiformatsupported) to ensure that both formats are supported by the driver.</span></span>

### <a name="sample-code"></a><span data-ttu-id="63129-242">Пример кода</span><span class="sxs-lookup"><span data-stu-id="63129-242">Sample code</span></span>

<span data-ttu-id="63129-243">Ниже приведен пример кода, демонстрирующий Рекомендуемые проверки.</span><span class="sxs-lookup"><span data-stu-id="63129-243">Below is a code example demonstrating the recommended checks.</span></span> <span data-ttu-id="63129-244">Этот пример взят из [оптимизации Икбкр JPEG в примере Direct2D и WIC](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Official%20Windows%20Platform%20Sample/JPEG%20YCbCr%20optimizations%20in%20Direct2D%20and%20WIC%20sample).</span><span class="sxs-lookup"><span data-stu-id="63129-244">This example was taken from the [JPEG YCbCr optimizations in Direct2D and WIC sample](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Official%20Windows%20Platform%20Sample/JPEG%20YCbCr%20optimizations%20in%20Direct2D%20and%20WIC%20sample).</span></span>


```C++
bool DirectXSampleRenderer::DoesWicSupportRequestedYCbCr()
{
    ComPtr<IWICPlanarBitmapSourceTransform> wicPlanarSource;
    HRESULT hr = m_wicScaler.As(&wicPlanarSource);
    if (SUCCEEDED(hr))
    {
        BOOL isTransformSupported;
        uint32 supportedWidth = m_cachedBitmapPixelWidth;
        uint32 supportedHeight = m_cachedBitmapPixelHeight;
        DX::ThrowIfFailed(
            wicPlanarSource->DoesSupportTransform(
                &supportedWidth,
                &supportedHeight,
                WICBitmapTransformRotate0,
                WICPlanarOptionsDefault,
                SampleConstants::WicYCbCrFormats,
                m_planeDescriptions,
                SampleConstants::NumPlanes,
                &isTransformSupported
                )
            );

        // The returned width and height may be larger if IWICPlanarBitmapSourceTransform does not
        // exactly support what is requested.
        if ((isTransformSupported == TRUE) &&
            (supportedWidth == m_cachedBitmapPixelWidth) &&
            (supportedHeight == m_cachedBitmapPixelHeight))
        {
            return true;
        }
    }

    return false;
}

bool DirectXSampleRenderer::DoesDriverSupportYCbCr()
{
    auto d2dContext = m_deviceResources->GetD2DDeviceContext();

    return (d2dContext->IsDxgiFormatSupported(DXGI_FORMAT_R8_UNORM)) &&
        (d2dContext->IsDxgiFormatSupported(DXGI_FORMAT_R8G8_UNORM));
}
```



### <a name="decoding-ycsubbsubcsubrsub-pixel-data"></a><span data-ttu-id="63129-245">Декодирование данных YC<sub>b</sub>C<sub>r</sub> Pixel</span><span class="sxs-lookup"><span data-stu-id="63129-245">Decoding YC<sub>b</sub>C<sub>r</sub> Pixel Data</span></span>

<span data-ttu-id="63129-246">Если вы хотите получить данные о точках YC <sub>b</sub>C <sub>r</sub> , необходимо вызвать [**ивикпланарбитмапсаурцетрансформ:: CopyPixels**](/windows/desktop/api/Wincodec/nf-wincodec-iwicplanarbitmapsourcetransform-copypixels).</span><span class="sxs-lookup"><span data-stu-id="63129-246">If you want to obtain YC <sub>b</sub>C <sub>r</sub> pixel data you should call [**IWICPlanarBitmapSourceTransform::CopyPixels**](/windows/desktop/api/Wincodec/nf-wincodec-iwicplanarbitmapsourcetransform-copypixels).</span></span> <span data-ttu-id="63129-247">Этот метод копирует пиксельные данные в массив [**викбитмаппланеных**](/windows/desktop/api/Wincodec/ns-wincodec-wicbitmapplane) структур, по одному для каждой плоскости данных (например, Y и c <sub>b</sub>c <sub>r</sub>).</span><span class="sxs-lookup"><span data-stu-id="63129-247">This method copies pixel data into an array of filled-out [**WICBitmapPlane**](/windows/desktop/api/Wincodec/ns-wincodec-wicbitmapplane) structures, one for each plane of data you want (for example, Y and C<sub>b</sub>C<sub>r</sub>).</span></span> <span data-ttu-id="63129-248">**Викбитмапплане** содержит сведения о точках данных и указывает на буфер памяти, который будет принимать данные.</span><span class="sxs-lookup"><span data-stu-id="63129-248">A **WICBitmapPlane** contains info about the pixel data and points to the memory buffer that will receive the data.</span></span>

<span data-ttu-id="63129-249">Если вы хотите использовать данные YC <sub>b</sub>C <sub>r</sub> x в других API-интерфейсах WIC, следует создать соответствующим образом настроенный [**ивикбитмап**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmap), вызвать [**блокировку**](/windows/desktop/api/Wincodec/nf-wincodec-iwicbitmap-lock) , чтобы получить базовый буфер памяти, и связать буфер с [**викбитмапплане**](/windows/desktop/api/Wincodec/ns-wincodec-wicbitmapplane) , который использовался для получения данных Yc <sub>b</sub>на <sub>r</sub> пиксель.</span><span class="sxs-lookup"><span data-stu-id="63129-249">If you want to use the YC <sub>b</sub>C <sub>r</sub> pixel data with other WIC APIs you should create an appropriately configured [**IWICBitmap**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmap), call [**Lock**](/windows/desktop/api/Wincodec/nf-wincodec-iwicbitmap-lock) to obtain the underlying memory buffer, and associate the buffer with the [**WICBitmapPlane**](/windows/desktop/api/Wincodec/ns-wincodec-wicbitmapplane) used to receive the YC<sub>b</sub>C<sub>r</sub> pixel data.</span></span> <span data-ttu-id="63129-250">Затем можно использовать [ивикбитмап](-wic-imp-iwicbitmapdecoder.md) в обычном режиме.</span><span class="sxs-lookup"><span data-stu-id="63129-250">You can then use the [IWICBitmap](-wic-imp-iwicbitmapdecoder.md) normally.</span></span>

<span data-ttu-id="63129-251">Наконец, если вы хотите визуализировать данные YC <sub>b</sub>c <sub>r</sub> в Direct2D, необходимо создать [**ID2D1Bitmap**](/windows/win32/api/d2d1/nn-d2d1-id2d1bitmap) из каждого [**ивикбитмап**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmap) и использовать их в качестве источника для изображения Yc <sub>b</sub>C <sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-251">Finally, if you want to render the YC <sub>b</sub>C <sub>r</sub> data in Direct2D, you should create an [**ID2D1Bitmap**](/windows/win32/api/d2d1/nn-d2d1-id2d1bitmap) from each [**IWICBitmap**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmap) and use them as source for the YC<sub>b</sub>C<sub>r</sub> image effect.</span></span> <span data-ttu-id="63129-252">Компонент WIC позволяет запрашивать несколько плоских конфигураций.</span><span class="sxs-lookup"><span data-stu-id="63129-252">WIC allows you to request multiple planar configurations.</span></span> <span data-ttu-id="63129-253">При взаимодействии с Direct2D необходимо запросить две плоскости, одну с идентификаторами GUID \_ WICPixelFormat8bppY, а другую — с помощью идентификатора GUID \_ WICPixelFormat16bppCbCr, так как это ожидаемая конфигурация Direct2D.</span><span class="sxs-lookup"><span data-stu-id="63129-253">When interoperating with Direct2D you should request two planes, one using GUID\_WICPixelFormat8bppY and the other using GUID\_WICPixelFormat16bppCbCr, as this is the configuration expected by Direct2D.</span></span>

### <a name="code-sample"></a><span data-ttu-id="63129-254">Образец кода</span><span class="sxs-lookup"><span data-stu-id="63129-254">Code Sample</span></span>

<span data-ttu-id="63129-255">Ниже приведен пример кода, демонстрирующий действия по декодированию и визуализации данных YC<sub>b</sub>C<sub>r</sub> в Direct2D.</span><span class="sxs-lookup"><span data-stu-id="63129-255">Below is a code example demonstrating the steps to decode and render YC<sub>b</sub>C<sub>r</sub> data in Direct2D.</span></span> <span data-ttu-id="63129-256">Этот пример взят из [оптимизации Икбкр JPEG в примере Direct2D и WIC](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Official%20Windows%20Platform%20Sample/JPEG%20YCbCr%20optimizations%20in%20Direct2D%20and%20WIC%20sample).</span><span class="sxs-lookup"><span data-stu-id="63129-256">This example was taken from the [JPEG YCbCr optimizations in Direct2D and WIC sample](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Official%20Windows%20Platform%20Sample/JPEG%20YCbCr%20optimizations%20in%20Direct2D%20and%20WIC%20sample).</span></span>


```C++
void DirectXSampleRenderer::CreateYCbCrDeviceResources()
{
    auto wicFactory = m_deviceResources->GetWicImagingFactory();
    auto d2dContext = m_deviceResources->GetD2DDeviceContext();

    ComPtr<IWICPlanarBitmapSourceTransform> wicPlanarSource;
    DX::ThrowIfFailed(
        m_wicScaler.As(&wicPlanarSource)
        );

    ComPtr<IWICBitmap> bitmaps[SampleConstants::NumPlanes];
    ComPtr<IWICBitmapLock> locks[SampleConstants::NumPlanes];
    WICBitmapPlane planes[SampleConstants::NumPlanes];

    for (uint32 i = 0; i < SampleConstants::NumPlanes; i++)
    {
        DX::ThrowIfFailed(
            wicFactory->CreateBitmap(
                m_planeDescriptions[i].Width,
                m_planeDescriptions[i].Height,
                m_planeDescriptions[i].Format,
                WICBitmapCacheOnLoad,
                &bitmaps[i]
                )
            );

        LockBitmap(bitmaps[i].Get(), WICBitmapLockWrite, nullptr, &locks[i], &planes[i]);
    }

    DX::ThrowIfFailed(
        wicPlanarSource->CopyPixels(
            nullptr, // Copy the entire source region.
            m_cachedBitmapPixelWidth,
            m_cachedBitmapPixelHeight,
            WICBitmapTransformRotate0,
            WICPlanarOptionsDefault,
            planes,
            SampleConstants::NumPlanes
            )
        );

    DX::ThrowIfFailed(d2dContext->CreateEffect(CLSID_D2D1YCbCr, &m_d2dYCbCrEffect));

    ComPtr<ID2D1Bitmap1> d2dBitmaps[SampleConstants::NumPlanes];
    for (uint32 i = 0; i < SampleConstants::NumPlanes; i++)
    {
        // IWICBitmapLock must be released before using the IWICBitmap.
        locks[i] = nullptr;

        // First ID2D1Bitmap1 is DXGI_FORMAT_R8 (Y), second is DXGI_FORMAT_R8G8 (CbCr).
        DX::ThrowIfFailed(d2dContext->CreateBitmapFromWicBitmap(bitmaps[i].Get(), &d2dBitmaps[i]));
        m_d2dYCbCrEffect->SetInput(i, d2dBitmaps[i].Get());
    }
}

void DirectXSampleRenderer::LockBitmap(
    _In_ IWICBitmap *pBitmap,
    DWORD bitmapLockFlags,
    _In_opt_ const WICRect *prcSource,
    _Outptr_ IWICBitmapLock **ppBitmapLock,
    _Out_ WICBitmapPlane *pPlane
    )
{
    // ComPtr guarantees the IWICBitmapLock is released if an exception is thrown.
    ComPtr<IWICBitmapLock> lock;
    DX::ThrowIfFailed(pBitmap->Lock(prcSource, bitmapLockFlags, &lock));
    DX::ThrowIfFailed(lock->GetStride(&pPlane->cbStride));
    DX::ThrowIfFailed(lock->GetDataPointer(&pPlane->cbBufferSize, &pPlane->pbBuffer));
    DX::ThrowIfFailed(lock->GetPixelFormat(&pPlane->Format));
    *ppBitmapLock = lock.Detach();
}
```



### <a name="transforming-ycsubbsubcsubrsub-pixel-data"></a><span data-ttu-id="63129-257">Преобразование данных YC<sub>b</sub>C<sub>r</sub> Pixel</span><span class="sxs-lookup"><span data-stu-id="63129-257">Transforming YC<sub>b</sub>C<sub>r</sub> Pixel Data</span></span>

<span data-ttu-id="63129-258">Преобразование данных YC <sub>b</sub>C <sub>r</sub> практически идентично декодированию, как и в случае с [**ивикпланарбитмапсаурцетрансформ**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapsourcetransform).</span><span class="sxs-lookup"><span data-stu-id="63129-258">Transforming YC <sub>b</sub>C <sub>r</sub> data is nearly identical to decoding, as both involve [**IWICPlanarBitmapSourceTransform**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapsourcetransform).</span></span> <span data-ttu-id="63129-259">Единственное отличие заключается в том, какой объект WIC получил интерфейс.</span><span class="sxs-lookup"><span data-stu-id="63129-259">The only difference is which WIC object you obtained the interface from.</span></span> <span data-ttu-id="63129-260">Подсистема Windows, перевернутая по мере вращения и преобразования цветов, поддерживает доступ к YC<sub>b</sub>C<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-260">The Windows provided scaler, flip rotator and color transform all support YC<sub>b</sub>C<sub>r</sub> access.</span></span>

### <a name="chaining-transforms-together"></a><span data-ttu-id="63129-261">Объединение преобразований</span><span class="sxs-lookup"><span data-stu-id="63129-261">Chaining Transforms Together</span></span>

<span data-ttu-id="63129-262">WIC поддерживает понятие объединения нескольких преобразований.</span><span class="sxs-lookup"><span data-stu-id="63129-262">WIC supports the notion of chaining together multiple transforms.</span></span> <span data-ttu-id="63129-263">Например, можно создать следующий конвейер WIC:</span><span class="sxs-lookup"><span data-stu-id="63129-263">For example, you can create the following WIC pipeline:</span></span>

![Схема конвейера WIC, начиная с декодера JPEG.](graphics/ycbcr5.png)

<span data-ttu-id="63129-265">Затем можно вызвать QueryInterface в [**ивикколортрансформ**](/windows/desktop/api/Wincodec/nn-wincodec-iwiccolortransform) , чтобы получить [**ивикпланарбитмапсаурцетрансформ**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapsourcetransform).</span><span class="sxs-lookup"><span data-stu-id="63129-265">You can then call QueryInterface on the [**IWICColorTransform**](/windows/desktop/api/Wincodec/nn-wincodec-iwiccolortransform) to obtain [**IWICPlanarBitmapSourceTransform**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapsourcetransform).</span></span> <span data-ttu-id="63129-266">Преобразование цветов может взаимодействовать с предыдущими преобразованиями и может предоставлять агрегатные возможности каждого этапа в конвейере.</span><span class="sxs-lookup"><span data-stu-id="63129-266">The color transform can communicate with the preceding transforms and can expose the aggregate capabilities of every stage in the pipeline.</span></span> <span data-ttu-id="63129-267">Компонент WIC гарантирует, что данные YC<sub>b</sub>C<sub>r</sub> сохраняются во всем процессе.</span><span class="sxs-lookup"><span data-stu-id="63129-267">WIC ensures that the YC<sub>b</sub>C<sub>r</sub> data is preserved through the entire process.</span></span> <span data-ttu-id="63129-268">Эта цепочка работает только при использовании компонентов, поддерживающих доступ к YC<sub>b</sub>C<sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-268">This chaining only works when using components that support YC<sub>b</sub>C<sub>r</sub> access.</span></span>

### <a name="jpeg-codec-optimizations"></a><span data-ttu-id="63129-269">Оптимизация кодека JPEG</span><span class="sxs-lookup"><span data-stu-id="63129-269">JPEG Codec Optimizations</span></span>

<span data-ttu-id="63129-270">Как и при декодировании в формате JPEG, реализация [**ивикбитмапсаурцетрансформ**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapsourcetransform), декодирование кадров JPEG, реализованная в [**ивикпланарбитмапсаурцетрансформ**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapsourcetransform) , поддерживает собственное масштабирование и поворот домена в формате JPEG ДКТ.</span><span class="sxs-lookup"><span data-stu-id="63129-270">Similar to the JPEG frame decode implementation of [**IWICBitmapSourceTransform**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapsourcetransform), the JPEG frame decode implementation of [**IWICPlanarBitmapSourceTransform**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapsourcetransform) supports native JPEG DCT domain scaling and rotation.</span></span> <span data-ttu-id="63129-271">Вы можете запросить мощь двух довнскале или вращения непосредственно из декодера JPEG.</span><span class="sxs-lookup"><span data-stu-id="63129-271">You can request a power of two downscale or a rotation directly from the JPEG decoder.</span></span> <span data-ttu-id="63129-272">Это обычно приводит к более высокому качеству и производительности, чем использование дискретных преобразований.</span><span class="sxs-lookup"><span data-stu-id="63129-272">This typically results in higher quality and performance than using the discrete transforms.</span></span>

<span data-ttu-id="63129-273">Кроме того, при сцеплении одного или нескольких преобразований WIC после декодера JPEG он может использовать собственное масштабирование и вращение JPEG для удовлетворения запрошенной операции агрегирования.</span><span class="sxs-lookup"><span data-stu-id="63129-273">In addition, when you chain one or more WIC transforms after the JPEG decoder, it can leverage native JPEG scaling and rotation to satisfy the aggregate requested operation.</span></span>

### <a name="format-conversions"></a><span data-ttu-id="63129-274">Преобразования формата</span><span class="sxs-lookup"><span data-stu-id="63129-274">Format Conversions</span></span>

<span data-ttu-id="63129-275">Используйте [**ивикпланарформатконвертер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarformatconverter) для преобразования плоских данных Yc <sub>b</sub><sub>в C пикселей</sub> в формат ПИКСЕЛЕЙ с чередованием, например GUID \_ WICPixelFormat32bppPBGRA.</span><span class="sxs-lookup"><span data-stu-id="63129-275">Use [**IWICPlanarFormatConverter**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarformatconverter) to convert planar YC<sub>b</sub>C<sub>r</sub> pixel data to an interleaved pixel format such as GUID\_WICPixelFormat32bppPBGRA.</span></span> <span data-ttu-id="63129-276">WIC в Windows 8.1 не обеспечивает возможность преобразования в плоский YC<sub>b</sub><sub>C в</sub> формате пикселей.</span><span class="sxs-lookup"><span data-stu-id="63129-276">WIC in Windows 8.1 does not provide the ability to convert to a planar YC<sub>b</sub>C<sub>r</sub> pixel format.</span></span>

### <a name="encoding-ycsubbsubcsubrsub-pixel-data"></a><span data-ttu-id="63129-277">Кодирование YC<sub>b</sub>C<sub>r</sub> пиксель Data</span><span class="sxs-lookup"><span data-stu-id="63129-277">Encoding YC<sub>b</sub>C<sub>r</sub> Pixel Data</span></span>

<span data-ttu-id="63129-278">Используйте [**ивикпланарбитмапфраминкоде**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapframeencode) для кодирования данных Yc <sub>b</sub>C <sub>r</sub> x в кодировщик JPEG.</span><span class="sxs-lookup"><span data-stu-id="63129-278">Use [**IWICPlanarBitmapFrameEncode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapframeencode) to encode YC<sub>b</sub>C<sub>r</sub> pixel data to the JPEG encoder.</span></span> <span data-ttu-id="63129-279">Кодировка YC <sub>b</sub>Data **ивикпланарбитмапфраминкоде** похожа, но не идентична кодированию <sub>данных с</sub> чередованием с помощью [**ивикбитмапфраминкоде**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode).</span><span class="sxs-lookup"><span data-stu-id="63129-279">Encoding YC <sub>b</sub>C <sub>r</sub> data **IWICPlanarBitmapFrameEncode** is similar but not identical to encoding interleaved data using [**IWICBitmapFrameEncode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode).</span></span> <span data-ttu-id="63129-280">Плоский интерфейс предоставляет возможность записи данных изображения с плоскими кадрами, поэтому следует продолжать использовать интерфейс кодирования фрейма для установки метаданных или эскиза и фиксации в конце операции.</span><span class="sxs-lookup"><span data-stu-id="63129-280">The planar interface only exposes the ability to write planar frame image data, and you should continue to use the frame encode interface to set metadata or a thumbnail and to commit at the end of the operation.</span></span>

<span data-ttu-id="63129-281">В типичном случае необходимо выполнить следующие действия.</span><span class="sxs-lookup"><span data-stu-id="63129-281">For the typical case, you should follow these steps:</span></span>

1.  <span data-ttu-id="63129-282">Получите [**ивикбитмапфраминкоде**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode) как обычную.</span><span class="sxs-lookup"><span data-stu-id="63129-282">Obtain the [**IWICBitmapFrameEncode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode) as normal.</span></span> <span data-ttu-id="63129-283">Если вы хотите настроить подвыборку чрома, задайте параметр кодировщика [**жпегикркбсубсамплинг**](/windows/desktop/api/Wincodec/ne-wincodec-wicjpegycrcbsubsamplingoption) при создании рамки.</span><span class="sxs-lookup"><span data-stu-id="63129-283">If you want to configure chroma subsampling, set the [**JpegYCrCbSubsampling**](/windows/desktop/api/Wincodec/ne-wincodec-wicjpegycrcbsubsamplingoption) encoder option when creating the frame.</span></span>
2.  <span data-ttu-id="63129-284">Если необходимо задать метаданные или эскиз, сделайте это с помощью [**ивикбитмапфраминкоде**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode) в качестве обычного.</span><span class="sxs-lookup"><span data-stu-id="63129-284">If you need to set metadata or a thumbnail, do this using [**IWICBitmapFrameEncode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode) as normal.</span></span>
3.  <span data-ttu-id="63129-285">QueryInterface для [**ивикпланарбитмапфраминкоде**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapframeencode).</span><span class="sxs-lookup"><span data-stu-id="63129-285">QueryInterface for the [**IWICPlanarBitmapFrameEncode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicplanarbitmapframeencode).</span></span>
4.  <span data-ttu-id="63129-286">Задайте YC <sub>b</sub>C <sub>r</sub> пиксель Data с помощью [**Ивикпланарбитмапфраминкоде:: Вритесаурце**](/windows/desktop/api/Wincodec/nf-wincodec-iwicplanarbitmapframeencode-writesource) или [**ивикпланарбитмапфраминкоде:: WritePixels**](/windows/desktop/api/Wincodec/nf-wincodec-iwicplanarbitmapframeencode-writepixels).</span><span class="sxs-lookup"><span data-stu-id="63129-286">Set the YC <sub>b</sub>C <sub>r</sub> pixel data using [**IWICPlanarBitmapFrameEncode::WriteSource**](/windows/desktop/api/Wincodec/nf-wincodec-iwicplanarbitmapframeencode-writesource) or [**IWICPlanarBitmapFrameEncode::WritePixels**](/windows/desktop/api/Wincodec/nf-wincodec-iwicplanarbitmapframeencode-writepixels).</span></span> <span data-ttu-id="63129-287">В отличие от своих [**ивикбитмапфраминкоденых**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode) аналогов, вы предоставляете эти методы с массивом [**IWICBitmapSource**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapsource) или [**ВИКБИТМАППЛАНЕ**](/windows/desktop/api/Wincodec/ns-wincodec-wicbitmapplane) , которые содержат плоскости Yc <sub>b</sub>C <sub>r</sub> Pixel.</span><span class="sxs-lookup"><span data-stu-id="63129-287">Unlike with their [**IWICBitmapFrameEncode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode) counterparts, you provide these methods with an array of [**IWICBitmapSource**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapsource) or [**WICBitmapPlane**](/windows/desktop/api/Wincodec/ns-wincodec-wicbitmapplane) which contain the YC<sub>b</sub>C<sub>r</sub> pixel planes.</span></span>
5.  <span data-ttu-id="63129-288">По завершении вызовите метод [**ивикбитмапфраминкоде:: Commit**](/windows/desktop/api/Wincodec/nf-wincodec-iwicbitmapframeencode-commit).</span><span class="sxs-lookup"><span data-stu-id="63129-288">When you are finished, call [**IWICBitmapFrameEncode::Commit**](/windows/desktop/api/Wincodec/nf-wincodec-iwicbitmapframeencode-commit).</span></span>

### <a name="decoding-ycsubbsubcsubrsub-pixel-data-in-windows-10"></a><span data-ttu-id="63129-289">Декодирование данных YC<sub>b</sub>C<sub>r</sub> Pixel в Windows 10</span><span class="sxs-lookup"><span data-stu-id="63129-289">Decoding YC<sub>b</sub>C<sub>r</sub> pixel data in Windows 10</span></span>

<span data-ttu-id="63129-290">Начиная с Windows 10 Build 1507, Direct2D предоставляет [**ID2D1ImageSourceFromWic**](/windows/win32/api/d2d1_3/nn-d2d1_3-id2d1imagesourcefromwic), более простой способ декодирования JPEG-файлов в Direct2D при использовании оптимизации Yc <sub>b</sub>C <sub>r</sub> .</span><span class="sxs-lookup"><span data-stu-id="63129-290">Starting in Windows 10 build 1507, Direct2D provides [**ID2D1ImageSourceFromWic**](/windows/win32/api/d2d1_3/nn-d2d1_3-id2d1imagesourcefromwic), a simpler way to decode JPEGs into Direct2D while leveraging YC<sub>b</sub>C<sub>r</sub> optimizations.</span></span> <span data-ttu-id="63129-291">**ID2D1ImageSourceFromWic** автоматически выполняет все необходимые проверки возможностей <sub>r</sub> в Yc <sub>b</sub>. по возможности он использует оптимизированную коду, и в противном случае использует резервный.</span><span class="sxs-lookup"><span data-stu-id="63129-291">**ID2D1ImageSourceFromWic** automatically performs all of the necessary YC<sub>b</sub>C<sub>r</sub> capability checks for you; it uses the optimized codepath when possible, and uses a fallback otherwise.</span></span> <span data-ttu-id="63129-292">Он также позволяет выполнять новые оптимизации, такие как кэширование только подобластей изображения, которые необходимы за раз.</span><span class="sxs-lookup"><span data-stu-id="63129-292">It also enables new optimizations such as only caching subregions of the image that are needed at a time.</span></span>

<span data-ttu-id="63129-293">Дополнительные сведения об использовании [**ID2D1ImageSourceFromWic**](/windows/win32/api/d2d1_3/nn-d2d1_3-id2d1imagesourcefromwic)см. в [образце](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/D2DPhotoAdjustment)пакета SDK Direct2D Photo корректировок.</span><span class="sxs-lookup"><span data-stu-id="63129-293">For more information about using [**ID2D1ImageSourceFromWic**](/windows/win32/api/d2d1_3/nn-d2d1_3-id2d1imagesourcefromwic), refer to the Direct2D Photo Adjustment SDK [sample](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/D2DPhotoAdjustment).</span></span>

## <a name="related-topics"></a><span data-ttu-id="63129-294">См. также</span><span class="sxs-lookup"><span data-stu-id="63129-294">Related topics</span></span>

* [<span data-ttu-id="63129-295">Оптимизация Икбкр JPEG в примерах Direct2D и WIC</span><span class="sxs-lookup"><span data-stu-id="63129-295">JPEG YCbCr optimizations in Direct2D and WIC sample</span></span>](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Official%20Windows%20Platform%20Sample/JPEG%20YCbCr%20optimizations%20in%20Direct2D%20and%20WIC%20sample)
