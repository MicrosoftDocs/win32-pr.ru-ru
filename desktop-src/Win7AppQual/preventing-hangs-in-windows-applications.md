---
description: Узнайте, как предотвратить зависание в приложениях Windows для платформ Windows 7 и Windows Server 2008 R2.
ms.assetid: 698a046b-1934-49cd-a717-d61e7e1ec534
title: Предотвращение зависаний в приложениях для Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 35a2d8fac95039f20c8c684c50138933c54750c3
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "104081664"
---
# <a name="preventing-hangs-in-windows-applications"></a><span data-ttu-id="5b7f6-103">Предотвращение зависаний в приложениях для Windows</span><span class="sxs-lookup"><span data-stu-id="5b7f6-103">Preventing Hangs in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="5b7f6-104">Затронутые платформы</span><span class="sxs-lookup"><span data-stu-id="5b7f6-104">Affected Platforms</span></span>

<span data-ttu-id="5b7f6-105">**Клиенты** — Windows 7</span><span class="sxs-lookup"><span data-stu-id="5b7f6-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="5b7f6-106">**Серверы** — Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="5b7f6-106">**Servers** - Windows Server 2008 R2</span></span>  









## <a name="description"></a><span data-ttu-id="5b7f6-107">Описание</span><span class="sxs-lookup"><span data-stu-id="5b7f6-107">Description</span></span>

<span data-ttu-id="5b7f6-108">**Зависания — перспектива пользователя**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-108">**Hangs - User Perspective**</span></span>

<span data-ttu-id="5b7f6-109">Пользователи, например реагирующие приложения.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-109">Users like responsive applications.</span></span> <span data-ttu-id="5b7f6-110">При щелчке меню они хотят, чтобы приложение реагировало мгновенно, даже если в данный момент он печатает свою работу.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-110">When they click a menu, they want the application to react instantly, even if it is currently printing their work.</span></span> <span data-ttu-id="5b7f6-111">При сохранении длинного документа в своем любимом текстовом процессоре они хотят продолжать ввод, пока диск все еще вращается.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-111">When they save a lengthy document in their favorite word processor, they want to continue typing while the disk is still spinning.</span></span> <span data-ttu-id="5b7f6-112">Пользователи получают неограниченный доступ, когда приложение не реагирует на них своевременно.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-112">Users get impatient rather quickly when the application does not react in a timely fashion to their input.</span></span>

<span data-ttu-id="5b7f6-113">Программист может распознавать множество законных причин, чтобы приложение не было мгновенно реагировать на вводимые пользователем данные.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-113">A programmer might recognize many legitimate reasons for an application not to instantly respond to user input.</span></span> <span data-ttu-id="5b7f6-114">Приложение может быть занято перерасчетом некоторых данных или просто ожиданием завершения операций дискового ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-114">The application might be busy recalculating some data, or simply waiting for its disk I/O to complete.</span></span> <span data-ttu-id="5b7f6-115">Однако при исследовании пользователей мы понимаем, что пользователи получают раздражен и разочарованы через несколько секунд с момента реагирования.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-115">However, from user research, we know that users get annoyed and frustrated after just a couple of seconds of unresponsiveness.</span></span> <span data-ttu-id="5b7f6-116">Через 5 секунд они попытаются завершить зависание приложения.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-116">After 5 seconds, they will try to terminate a hung application.</span></span> <span data-ttu-id="5b7f6-117">Как правило, зависание приложений является наиболее распространенным источником сбоев пользователей при работе с приложениями Win32.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-117">Next to crashes, application hangs are the most common source of user disruption when working with Win32 applications.</span></span>

<span data-ttu-id="5b7f6-118">Существует множество разных основных причин зависания приложения, а не все они сами по себе переносятся в Неотвечающий пользовательский интерфейс.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-118">There are many different root causes for application hangs, and not all of them manifest themselves in an unresponsive UI.</span></span> <span data-ttu-id="5b7f6-119">Однако Неотвечающий пользовательский интерфейс — это один из наиболее распространенных ситуаций зависания, и в настоящее время этот сценарий получает максимальную поддержку операционной системы как для обнаружения, так и для восстановления.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-119">However, an unresponsive UI is one of the most common hang experiences, and this scenario currently receives the most operating system support for both detection as well as recovery.</span></span> <span data-ttu-id="5b7f6-120">Windows автоматически обнаруживает, собирает сведения об отладке и при необходимости завершает или перезапускает зависание приложений.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-120">Windows automatically detects, collects debug information, and optionally terminates or restarts hung applications.</span></span> <span data-ttu-id="5b7f6-121">В противном случае пользователю может потребоваться перезагрузить компьютер, чтобы восстановить зависание приложения.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-121">Otherwise, the user might have to restart the machine in order to recover a hung application.</span></span>

<span data-ttu-id="5b7f6-122">**Зависание — перспектива операционной системы**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-122">**Hangs - Operating System Perspective**</span></span>

<span data-ttu-id="5b7f6-123">Когда приложение (или точнее, поток) создает окно на рабочем столе, оно переходит в неявный контракт с диспетчер окон рабочего стола (DWM) для своевременной обработки сообщений окна.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-123">When an application (or more accurately, a thread) creates a window on the desktop, it enters into an implicit contract with the Desktop Window Manager (DWM) to process window messages in a timely fashion.</span></span> <span data-ttu-id="5b7f6-124">DWM отправляет сообщения (ввод с клавиатуры и с помощью мыши и сообщения из других окон, а также саму себя) в очередь сообщений конкретного потока.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-124">The DWM posts messages (keyboard/mouse input and messages from other windows, as well as itself) into the thread-specific message queue.</span></span> <span data-ttu-id="5b7f6-125">Поток извлекает и отправляет эти сообщения через очередь сообщений.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-125">The thread retrieves and dispatches those messages via its message queue.</span></span> <span data-ttu-id="5b7f6-126">Если поток не обрабатывает очередь, вызывая метод "onmessage ()", сообщения не обрабатываются и окно зависает: оно не может ни перерисовывать, ни принимать входные данные от пользователя.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-126">If the thread does not service the queue by calling GetMessage(), messages are not processed, and the window hangs: it can neither redraw nor can it accept input from the user.</span></span> <span data-ttu-id="5b7f6-127">Операционная система обнаруживает это состояние, подключив таймер к ожидающим сообщениям в очереди сообщений.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-127">The operating system detects this state by attaching a timer to pending messages in the message queue.</span></span> <span data-ttu-id="5b7f6-128">Если сообщение не было получено в течение 5 секунд, DWM объявляет окно как зависло.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-128">If a message has not been retrieved within 5 seconds, the DWM declares the window to be hung.</span></span> <span data-ttu-id="5b7f6-129">Это конкретное состояние окна можно запросить с помощью API Ишунгаппвиндов ().</span><span class="sxs-lookup"><span data-stu-id="5b7f6-129">You can query this particular window state via the IsHungAppWindow() API.</span></span>

<span data-ttu-id="5b7f6-130">Обнаружение — это только первый шаг.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-130">Detection is only the first step.</span></span> <span data-ttu-id="5b7f6-131">На этом этапе пользователь по-прежнему даже не может завершить работу приложения. нажатие кнопки X (Close) приведет к появлению \_ сообщения о закрытии WM, которое будет задержано в очереди сообщений, как и любое другое сообщение.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-131">At this point, the user still cannot even terminate the application - clicking the X (Close) button would result in a WM\_CLOSE message, which would be stuck in the message queue just like any other message.</span></span> <span data-ttu-id="5b7f6-132">Диспетчер окон рабочего стола помогает легко скрывать и заменять зависание окна с копией "фантомной" копии, отображающей растровое изображение предыдущей клиентской области исходного окна (и добавляя "не отвечает" на строку заголовка).</span><span class="sxs-lookup"><span data-stu-id="5b7f6-132">The Desktop Window Manager assists by seamlessly hiding and then replacing the hung window with a 'ghost' copy displaying a bitmap of the original window's previous client area (and adding "Not Responding" to the title bar).</span></span> <span data-ttu-id="5b7f6-133">Пока поток исходного окна не извлекает сообщения, DWM управляет обеими окнами одновременно, но позволяет пользователю взаимодействовать только с фантомной копией.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-133">As long as the original window's thread does not retrieve messages, the DWM manages both windows simultaneously, but allows the user to interact only with the ghost copy.</span></span> <span data-ttu-id="5b7f6-134">С помощью этого несинхронизированного окна пользователь может только перемещать, сокращать и, что самое важное, закрыть приложение, не отвечающее на запросы, но не изменять его внутреннее состояние.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-134">Using this ghost window, the user can only move, minimize, and - most importantly - close the unresponsive application, but not change its internal state.</span></span>

<span data-ttu-id="5b7f6-135">Весь процесс Ghost выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="5b7f6-135">The whole ghost experience looks like this:</span></span>

![Снимок экрана, на котором показано диалоговое окно "Блокнот не отвечает".](images/preventinghangs-ghostwindow.gif)

<span data-ttu-id="5b7f6-137">Диспетчер окон рабочего стола выполняет одно последнее действие; Он интегрируется с отчеты об ошибках Windows, позволяя пользователю не только закрывать и при необходимости перезапускать приложение, но и передавать ценные данные отладки в корпорацию Майкрософт.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-137">The Desktop Window Manager does one last thing; it integrates with Windows Error Reporting, allowing the user to not only close and optionally restart the application, but also send valuable debugging data back to Microsoft.</span></span> <span data-ttu-id="5b7f6-138">Вы можете получить эти данные о зависании для своих приложений, зарегистрировавшись на веб-сайте Винкуал.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-138">You can get this hang data for your own applications by signing up at the Winqual website.</span></span>

<span data-ttu-id="5b7f6-139">В Windows 7 для этого интерфейса добавлена одна новая функция.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-139">Windows 7 added one new feature to this experience.</span></span> <span data-ttu-id="5b7f6-140">Операционная система анализирует зависание приложения и при определенных обстоятельствах дает пользователю возможность отменить блокировку и снова заставить приложение реагировать на запросы.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-140">The operating system analyzes the hung application and, under certain circumstances, gives the user the option to cancel a blocking operation and make the application responsive again.</span></span> <span data-ttu-id="5b7f6-141">Текущая реализация поддерживает отмену блокирующих вызовов сокета; в будущих выпусках больше операций будет отменено пользователем.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-141">The current implementation supports cancellation of blocking Socket calls; more operations will be user-cancelable in future releases.</span></span>

<span data-ttu-id="5b7f6-142">Чтобы интегрировать приложение с процессом восстановления после зависания и максимально использовать доступные данные, выполните следующие действия.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-142">To integrate your application with the hang recovery experience and to make the most out of the available data, follow these steps:</span></span>

-   <span data-ttu-id="5b7f6-143">Убедитесь, что приложение регистрируется для перезапуска и восстановления, что делает зависание как можно более свободным для пользователя.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-143">Ensure that your application registers for restart and recovery, making a hang as pain-free as possible to the user.</span></span> <span data-ttu-id="5b7f6-144">Правильно зарегистрированное приложение может автоматически перезапуститься с большей частью несохраненных данных.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-144">A properly registered application can automatically restart with most of its unsaved data intact.</span></span> <span data-ttu-id="5b7f6-145">Это работает как для зависаний приложений, так и для сбоев.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-145">This works for both application hangs and crashes.</span></span>
-   <span data-ttu-id="5b7f6-146">Получите сведения о частоте, а также об отладке данных для зависших и аварийно завершенных приложений с веб-сайта Винкуал.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-146">Get frequency information as well as debugging data for your hung and crashed applications from the Winqual website.</span></span> <span data-ttu-id="5b7f6-147">Эти сведения можно использовать даже во время бета-тестирования, чтобы улучшить код.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-147">You can use this information even during your Beta to improve your code.</span></span> <span data-ttu-id="5b7f6-148">Краткий обзор см. в разделе "Введение в отчеты об ошибках Windows".</span><span class="sxs-lookup"><span data-stu-id="5b7f6-148">See "Introducing Windows Error Reporting" for a brief overview.</span></span>
-   <span data-ttu-id="5b7f6-149">Функцию дублирования можно отключить в приложении с помощью вызова Дисаблепроцессвиндовсгхостинг ().</span><span class="sxs-lookup"><span data-stu-id="5b7f6-149">You can disable the ghosting feature in your application via a call to DisableProcessWindowsGhosting ().</span></span> <span data-ttu-id="5b7f6-150">Однако это не даст пользователю среднего времени закрывать и перезапускать зависание приложение и часто завершает перезагрузку.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-150">However, this prevents the average user from closing and restarting a hung application and often ends in a reboot.</span></span>

<span data-ttu-id="5b7f6-151">**Зависания — перспектива разработчика**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-151">**Hangs - Developer Perspective**</span></span>

<span data-ttu-id="5b7f6-152">Операционная система определяет зависание приложения как поток пользовательского интерфейса, который не обрабатывал сообщения по крайней мере 5 секунд.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-152">The operating system defines an application hang as a UI thread that has not processed messages for at least 5 seconds.</span></span> <span data-ttu-id="5b7f6-153">Очевидные ошибки вызывают некоторые зависания, например поток, ожидающий события, который никогда не оповещается, и два потока, удерживающих блокировку и пытающиеся получить другие.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-153">Obvious bugs cause some hangs, for example, a thread waiting for an event that is never signaled, and two threads each holding a lock and trying to acquire the others.</span></span> <span data-ttu-id="5b7f6-154">Эти ошибки можно устранить без чрезмерного объема усилий.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-154">You can fix those bugs without too much effort.</span></span> <span data-ttu-id="5b7f6-155">Однако многие зависания не настолько очевидны.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-155">However, many hangs are not so clear.</span></span> <span data-ttu-id="5b7f6-156">Да, поток пользовательского интерфейса не получает сообщения, но он по-другому занят выполнением других важных действий и в конечном итоге вернется к обработке сообщений.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-156">Yes, the UI thread is not retrieving messages - but it is equally busy doing other 'important' work and will eventually come back to processing messages.</span></span>

<span data-ttu-id="5b7f6-157">Однако пользователь воспринимает это как ошибку.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-157">However, the user perceives this as a bug.</span></span> <span data-ttu-id="5b7f6-158">Проект должен соответствовать ожиданиям пользователя.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-158">The design should match the user's expectations.</span></span> <span data-ttu-id="5b7f6-159">Если проект приложения ведет к неотвечающему приложению, проект придется изменить.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-159">If the application's design leads to an unresponsive application, the design will have to change.</span></span> <span data-ttu-id="5b7f6-160">И, наконец, это важно, поэтому невозможность реагирования не может быть исправлена как ошибка в коде. на этапе проектирования требуется предварительная работа.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-160">Finally, and this is important, unresponsiveness cannot be fixed like a code bug; it requires upfront work during the design phase.</span></span> <span data-ttu-id="5b7f6-161">Попытка модифицировать существующую базу кода приложения, чтобы сделать пользовательский интерфейс более быстрым реагированием, часто слишком дорого.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-161">Trying to retrofit an application's existing code base to make the UI more responsive is often too expensive.</span></span> <span data-ttu-id="5b7f6-162">Могут помочь следующие рекомендации по проектированию.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-162">The following design guidelines might help.</span></span>

-   <span data-ttu-id="5b7f6-163">Обеспечьте скорость реагирования пользовательского интерфейса требованием верхнего уровня; пользователь всегда должен иметь контроль над вашим приложением</span><span class="sxs-lookup"><span data-stu-id="5b7f6-163">Make UI responsiveness a top-level requirement; the user should always feel in control of your application</span></span>
-   <span data-ttu-id="5b7f6-164">Убедитесь, что пользователи могут отменять операции, выполнение которых занимает больше одной секунды, а также выполнять операции в фоновом режиме. При необходимости укажите соответствующий пользовательский интерфейс хода выполнения</span><span class="sxs-lookup"><span data-stu-id="5b7f6-164">Ensure that users can cancel operations that take longer than one second to complete and/or that operations can complete in the background; provide appropriate progress UI if necessary</span></span>

![Снимок экрана, на котором показано диалоговое окно "копирование элементов".](images/preventinghangs-progressbar.gif)

-   <span data-ttu-id="5b7f6-166">Очередь длительных или блокирующих операций в качестве фоновых задач (для этого требуется хорошо продуманный механизм обмена сообщениями для информирования потока пользовательского интерфейса о завершении работы).</span><span class="sxs-lookup"><span data-stu-id="5b7f6-166">Queue long-running or blocking operations as background tasks (this requires a well-thought out messaging mechanism to inform the UI thread when work has been completed)</span></span>
-   <span data-ttu-id="5b7f6-167">Обеспечьте простоту кода для потоков пользовательского интерфейса; Удалите столько блокирующих вызовов API, сколько возможно</span><span class="sxs-lookup"><span data-stu-id="5b7f6-167">Keep the code for UI threads simple; remove as many blocking API calls as possible</span></span>
-   <span data-ttu-id="5b7f6-168">Отображать окна и диалоговые окна, только когда они готовы и полностью работоспособны.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-168">Show windows and dialogs only when they are ready and fully operational.</span></span> <span data-ttu-id="5b7f6-169">Если в диалоговом окне необходимо отобразить сведения, требующие слишком большого количества ресурсов для вычисления, сначала покажите некоторые общие сведения и обновите ее на лету, когда становятся доступными дополнительные данные.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-169">If the dialog needs to display information that is too resource-intensive to calculate, show some generic information first and update it on the fly when more data becomes available.</span></span> <span data-ttu-id="5b7f6-170">Хорошим примером является диалоговое окно Свойства папки в проводнике Windows.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-170">A good example is the folder properties dialog from Windows Explorer.</span></span> <span data-ttu-id="5b7f6-171">Он должен отображать общий размер папки, сведения, недоступные в файловой системе.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-171">It needs to display the folder's total size, information that is not readily available from the file system.</span></span> <span data-ttu-id="5b7f6-172">Диалоговое окно сразу же появляется, и поле "размер" обновляется из рабочего потока:</span><span class="sxs-lookup"><span data-stu-id="5b7f6-172">The dialog shows up right away and the "size" field is updated from a worker thread:</span></span>

![Снимок экрана, на котором показана страница "Общие" свойств Windows с текстом "размер", "размер на диске" и "содержит" в кружке.](images/preventinghangs-updatingdialog.gif)

<span data-ttu-id="5b7f6-174">К сожалению, не существует простого способа проектирования и написания реагирующего приложения.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-174">Unfortunately, there is no simple way to design and write a responsive application.</span></span> <span data-ttu-id="5b7f6-175">Windows не предоставляет простую асинхронную платформу, которая позволяет легко планировать блокирование или выполнение длительных операций.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-175">Windows does not provide a simple asynchronous framework that would allow for easy scheduling of blocking or long-running operations.</span></span> <span data-ttu-id="5b7f6-176">В следующих разделах представлены некоторые рекомендации по предотвращению зависаний и выделению некоторых распространенных ловушек.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-176">The following sections introduce some of the best practices in preventing hangs and highlight some of the common pitfalls.</span></span>

## <a name="best-practices"></a><span data-ttu-id="5b7f6-177">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="5b7f6-177">Best Practices</span></span>

<span data-ttu-id="5b7f6-178">**Упрощение потока пользовательского интерфейса**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-178">**Keep the UI Thread Simple**</span></span>

<span data-ttu-id="5b7f6-179">Основной обязанностью потока пользовательского интерфейса является получение и отправка сообщений.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-179">The UI thread's primary responsibility is to retrieve and dispatch messages.</span></span> <span data-ttu-id="5b7f6-180">Любые другие виды работы представляют риск зависания окон, принадлежащих данному потоку.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-180">Any other kind of work introduces the risk of hanging the windows owned by this thread.</span></span>

<span data-ttu-id="5b7f6-181">**Запреща**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-181">**Do:**</span></span>

-   <span data-ttu-id="5b7f6-182">Перемещение ресурсоемких или неограниченных алгоритмов, которые приводят к созданию долго выполняющихся операций в рабочих потоках</span><span class="sxs-lookup"><span data-stu-id="5b7f6-182">Move resource-intensive or unbounded algorithms that result in long-running operations to worker threads</span></span>
-   <span data-ttu-id="5b7f6-183">Определите столько блокирующих вызовов функций, сколько возможно, и попытайтесь переместить их в рабочие потоки. любой вызов функции в другую библиотеку DLL должен быть подозрительным</span><span class="sxs-lookup"><span data-stu-id="5b7f6-183">Identify as many blocking function calls as possible and try to move them to worker threads; any function calling into another DLL should be suspicious</span></span>
-   <span data-ttu-id="5b7f6-184">Сделайте дополнительные усилия, чтобы удалить все вызовы API файлового ввода-вывода и сетевых интерфейсов из рабочего потока.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-184">Make an extra effort to remove all file I/O and networking API calls from your worker thread.</span></span> <span data-ttu-id="5b7f6-185">Эти функции могут блокироваться в течение нескольких секунд, если не минут.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-185">These functions can block for many seconds if not minutes.</span></span> <span data-ttu-id="5b7f6-186">Если вам нужно выполнять операции ввода-вывода в потоке пользовательского интерфейса, рассмотрите возможность использования асинхронного ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="5b7f6-186">If you need to do any kind of I/O in the UI thread, consider using asynchronous I/O</span></span>
-   <span data-ttu-id="5b7f6-187">Имейте в виду, что поток пользовательского интерфейса также обслуживает все серверы COM, размещенные в одном потоке (STA), размещаемые в процессе. Если вы сделаете вызов блокировки, эти серверы COM не будут отвечать, пока очередь сообщений не будет обслуживаться повторно.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-187">Be aware that your UI thread is also servicing all single-threaded apartment (STA) COM servers hosted by your process; if you make a blocking call, these COM servers will be unresponsive until you service the message queue again</span></span>

<span data-ttu-id="5b7f6-188">**Чего не следует делать:**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-188">**Do not:**</span></span>

-   <span data-ttu-id="5b7f6-189">Дождитесь любого объекта ядра (например, события или мьютекса) в течение слишком короткого промежутка времени; Если нужно подождать все, попробуйте использовать Мсгваитформултиплеобжектс (), который будет разблокирован при поступлении нового сообщения</span><span class="sxs-lookup"><span data-stu-id="5b7f6-189">Wait on any kernel object (like Event or Mutex) for more than a very short amount of time; if you have to wait at all, consider using MsgWaitForMultipleObjects(), which will unblock when a new message arrives</span></span>
-   <span data-ttu-id="5b7f6-190">Совместное использование очереди сообщений окна потока с другим потоком с помощью функции Аттачсреадинпут ().</span><span class="sxs-lookup"><span data-stu-id="5b7f6-190">Share a thread's window message queue with another thread by using the AttachThreadInput() function.</span></span> <span data-ttu-id="5b7f6-191">Это не только чрезвычайно сложно правильно синхронизировать доступ к очереди, но и может помешать операционной системе Windows правильно обнаружить зависание окна</span><span class="sxs-lookup"><span data-stu-id="5b7f6-191">It is not only extremely difficult to properly synchronize access to the queue, it also can prevent the Windows operating system from properly detecting a hung window</span></span>
-   <span data-ttu-id="5b7f6-192">Используйте TerminateThread () в любом из рабочих потоков.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-192">Use TerminateThread() on any of your worker threads.</span></span> <span data-ttu-id="5b7f6-193">Таким образом, завершение потока не позволит ему выпустить блокировки или события сигнала и легко привести к потере потерянных объектов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-193">Terminating a thread in this way will not allow it to release locks or signal events and can easily result in orphaned synchronization objects</span></span>
-   <span data-ttu-id="5b7f6-194">Вызовите любой "Неизвестный" код из потока пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-194">Call into any 'unknown' code from your UI thread.</span></span> <span data-ttu-id="5b7f6-195">Это особенно верно, если приложение имеет модель расширяемости. нет никакой гарантии, что код третьей стороны следует правилам реагирования.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-195">This is especially true if your application has an extensibility model; there is no guarantee that 3rd-party code follows your responsiveness guidelines</span></span>
-   <span data-ttu-id="5b7f6-196">Сделайте любой разновидность блокирующего широковещательного вызова. SendMessage ( \_ рассылка HWND) помещает вас в милость каждого некорректно написанного приложения, которое в настоящее время выполняется</span><span class="sxs-lookup"><span data-stu-id="5b7f6-196">Make any kind of blocking broadcast call; SendMessage(HWND\_BROADCAST) puts you at the mercy of every ill-written application currently running</span></span>

<span data-ttu-id="5b7f6-197">**Реализация асинхронных шаблонов**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-197">**Implement Asynchronous Patterns**</span></span>

<span data-ttu-id="5b7f6-198">Удаление длительных или блокирующих операций из потока пользовательского интерфейса требует реализации асинхронной платформы, которая позволяет разгрузить эти операции в рабочие потоки.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-198">Removing long-running or blocking operations from the UI thread requires implementing an asynchronous framework that allows offloading those operations to worker threads.</span></span>

<span data-ttu-id="5b7f6-199">**Запреща**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-199">**Do:**</span></span>

-   <span data-ttu-id="5b7f6-200">Используйте асинхронные API-интерфейсы оконных сообщений в потоке пользовательского интерфейса, особенно путем замены SendMessage на один из неблокирующих одноранговых узлов: i Message, Сенднотифимессаже или Сендмессажекаллбакк</span><span class="sxs-lookup"><span data-stu-id="5b7f6-200">Use asynchronous window message APIs in your UI thread, especially by replacing SendMessage with one of its non-blocking peers: PostMessage, SendNotifyMessage, or SendMessageCallback</span></span>
-   <span data-ttu-id="5b7f6-201">Используйте фоновые потоки для выполнения длительных или блокирующих задач.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-201">Use background threads to execute long-running or blocking tasks.</span></span> <span data-ttu-id="5b7f6-202">Использование нового API пула потоков для реализации рабочих потоков</span><span class="sxs-lookup"><span data-stu-id="5b7f6-202">Use the new thread pool API to implement your worker threads</span></span>
-   <span data-ttu-id="5b7f6-203">Предоставление поддержки отмены для длительных фоновых задач.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-203">Provide cancellation support for long-running background tasks.</span></span> <span data-ttu-id="5b7f6-204">Для блокировки операций ввода-вывода Используйте отмену ввода-вывода, но только в качестве последнего средства. отменить операцию "Right" непросто.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-204">For blocking I/O operations, use I/O cancellation, but only as a last resort; it's not easy to cancel the 'right' operation</span></span>
-   <span data-ttu-id="5b7f6-205">Реализация асинхронного проектирования для управляемого кода с помощью шаблона IAsyncResult или с помощью событий</span><span class="sxs-lookup"><span data-stu-id="5b7f6-205">Implement an asynchronous design for managed code by using the IAsyncResult pattern or by using Events</span></span>

<span data-ttu-id="5b7f6-206">**Разумное использование блокировок**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-206">**Use Locks Wisely**</span></span>

<span data-ttu-id="5b7f6-207">Приложению или библиотеке DLL требуются блокировки для синхронизации доступа к внутренним структурам данных.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-207">Your application or DLL needs locks to synchronize access to its internal data structures.</span></span> <span data-ttu-id="5b7f6-208">Использование нескольких блокировок повышает параллелизм и делает приложение более быстрым реагированием.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-208">Using multiple locks increases parallelism and makes your application more responsive.</span></span> <span data-ttu-id="5b7f6-209">Однако использование нескольких блокировок также повышает вероятность получения этих блокировок в различных заказах и вызовет взаимоблокировку потоков.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-209">However, using multiple locks also increases the chance of acquiring those locks in different orders and causing your threads to deadlock.</span></span> <span data-ttu-id="5b7f6-210">Если два потока содержат блокировку, а затем пытаются получить блокировку другого потока, их операции формируют циклическое ожидание, блокирующее все данные о ходе выполнения этих потоков вперед.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-210">If two threads each hold a lock and then try to acquire the other thread's lock, their operations will form a circular wait that blocks any forward progress for these threads.</span></span> <span data-ttu-id="5b7f6-211">Эту взаимоблокировку можно избежать, убедившись, что все потоки в приложении всегда получают все блокировки в одном и том же порядке.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-211">You can avoid this deadlock only by ensuring that all threads in the application always acquire all locks in the same order.</span></span> <span data-ttu-id="5b7f6-212">Однако не всегда удается получить блокировки в прямом порядке.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-212">However, it isn't always easy to acquire locks in the 'right' order.</span></span> <span data-ttu-id="5b7f6-213">Программные компоненты могут быть составлены, но получение блокировок не может быть разрешено.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-213">Software components can be composed, but lock acquisitions cannot.</span></span> <span data-ttu-id="5b7f6-214">Если ваш код вызывает какой-либо другой компонент, блокировки этого компонента теперь становятся частью неявного порядка блокировки, даже если эти блокировки не видны.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-214">If your code calls some other component, that component's locks now become part of your implicit lock order - even if you have no visibility into those locks.</span></span>

<span data-ttu-id="5b7f6-215">Все еще сложнее, так как операции блокировки включают гораздо больше обычных функций для критических секций, мьютексов и других традиционных блокировок.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-215">Things get even harder because locking operations include far more than the usual functions for Critical Sections, Mutexes, and other traditional locks.</span></span> <span data-ttu-id="5b7f6-216">Любой вызов блокировки, пересекающий границы потоков, имеет свойства синхронизации, которые могут привести к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-216">Any blocking call that crosses thread boundaries has synchronization properties that can result in a deadlock.</span></span> <span data-ttu-id="5b7f6-217">Вызывающий поток выполняет операцию с семантикой "получить" и не может разблокировать, пока целевой поток выполнит вызов.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-217">The calling thread performs an operation with 'acquire' semantics and cannot unblock until the target thread 'releases' that call.</span></span> <span data-ttu-id="5b7f6-218">Очень несколько функций user32 (например, SendMessage), а также множество блокирующих вызовов COM, попадающие в эту категорию.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-218">Quite a few User32 functions (for example SendMessage), as well as many blocking COM calls fall into this category.</span></span>

<span data-ttu-id="5b7f6-219">Что еще хуже, операционная система имеет собственную внутреннюю блокировку конкретного процесса, которая иногда удерживается во время выполнения кода.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-219">Worse yet, the operating system has its own internal process-specific lock that sometimes is held while your code executes.</span></span> <span data-ttu-id="5b7f6-220">Эта блокировка запрашивается при загрузке библиотек DLL в процесс и поэтому называется блокировкой загрузчика.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-220">This lock is acquired when DLLs are loaded into the process, and is therefore called the 'loader lock.'</span></span> <span data-ttu-id="5b7f6-221">Функция DllMain всегда выполняется при блокировке загрузчика; При получении каких-либо блокировок в DllMain (и не следует) необходимо сделать блокировку загрузчика частью порядка блокировки.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-221">The DllMain function always executes under the loader lock; if you acquire any locks in DllMain (and you should not), you need to make the loader lock part of your lock order.</span></span> <span data-ttu-id="5b7f6-222">Вызов некоторых API-интерфейсов Win32 может также получить блокировку загрузчика от своих функций, таких как LoadLibraryEx, ошибка GetModuleHandle и особенно CoCreateInstance.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-222">Calling certain Win32 APIs might also acquire the loader lock on your behalf - functions like LoadLibraryEx, GetModuleHandle, and especially CoCreateInstance.</span></span>

<span data-ttu-id="5b7f6-223">Чтобы связать все это вместе, Взгляните на пример кода ниже.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-223">To tie all of this together, look at the sample code below.</span></span> <span data-ttu-id="5b7f6-224">Эта функция получает несколько объектов синхронизации и неявно определяет порядок блокировки, что не обязательно очевидно при проверке курсора.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-224">This function acquires multiple synchronization objects and implicitly defines a lock order, something that is not necessarily obvious on cursory inspection.</span></span> <span data-ttu-id="5b7f6-225">При вводе функции код получает критическую секцию и не освобождает его до выхода из функции, тем самым делая его верхним узлом в нашей иерархии блокировок.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-225">On function entry, the code acquires a Critical Section and does not release it until function exit, thereby making it the top node in our lock hierarchy.</span></span> <span data-ttu-id="5b7f6-226">Затем код вызывает функцию Win32 Лоадикон (), которая, в своюмся, может вызвать загрузчик операционной системы для загрузки этого двоичного файла.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-226">The code then calls the Win32 function LoadIcon(), which under the covers might call into the Operating System Loader to load this binary.</span></span> <span data-ttu-id="5b7f6-227">Эта операция получит блокировку загрузчика, которая теперь также становится частью этой иерархии блокировок (убедитесь, что функция DllMain не получает \_ блокировку g CS).</span><span class="sxs-lookup"><span data-stu-id="5b7f6-227">This operation would acquire the loader lock, which now also becomes part of this lock hierarchy (make sure the DllMain function does not acquire the g\_cs lock).</span></span> <span data-ttu-id="5b7f6-228">Далее код вызывает SendMessage (), блокируя межпотоковую операцию, которая не будет возвращаться, если поток пользовательского интерфейса не ответит.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-228">Next the code calls SendMessage(), a blocking cross-thread operation, which will not return unless the UI thread responds.</span></span> <span data-ttu-id="5b7f6-229">Опять же, убедитесь, что поток пользовательского интерфейса никогда не получает g \_ CS.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-229">Again, make sure that the UI thread never acquires g\_cs.</span></span>

```
bool foo::bar (char* buffer)  
{  
      EnterCriticalSection(&g_cs);  
      // Get 'new data' icon  
      this.m_Icon = LoadIcon(hInst, MAKEINTRESOURCE(5));  
      // Let UI thread know to update icon SendMessage(hWnd,WM_COMMAND,IDM_ICON,NULL);  
      this.m_Params = GetParams(buffer);  
      LeaveCriticalSection(&g_cs);
      return true;  
}  
```

<span data-ttu-id="5b7f6-230">Просмотрев этот код, кажется ясно, что мы неявно сделали g \_ CS для блокировки верхнего уровня в нашей иерархии блокировок, даже если нам нужно синхронизировать доступ к переменным-членам класса.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-230">Looking at this code it seems clear that we implicitly made g\_cs the top-level lock in our lock hierarchy, even if we only wanted to synchronize access to the class member variables.</span></span>

<span data-ttu-id="5b7f6-231">**Запреща**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-231">**Do:**</span></span>

-   <span data-ttu-id="5b7f6-232">Разработайте иерархию блокировок и подчиняюте ее.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-232">Design a lock hierarchy and obey it.</span></span> <span data-ttu-id="5b7f6-233">Добавьте все необходимые блокировки.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-233">Add all the necessary locks.</span></span> <span data-ttu-id="5b7f6-234">Существует гораздо больше примитивов синхронизации, чем только мьютексы и Критикалсектионс; Все они должны быть добавлены.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-234">There are many more synchronization primitives than just Mutex and CriticalSections; they all need to be included.</span></span> <span data-ttu-id="5b7f6-235">Включить блокировку загрузчика в иерархию, если вы принимаете какие-либо блокировки в DllMain ()</span><span class="sxs-lookup"><span data-stu-id="5b7f6-235">Include the loader lock in your hierarchy if you take any locks in DllMain()</span></span>
-   <span data-ttu-id="5b7f6-236">Согласование протокола блокировки с зависимостями.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-236">Agree on locking protocol with your dependencies.</span></span> <span data-ttu-id="5b7f6-237">Любой код, который вызывает приложение или который может вызвать ваше приложение, должен использовать одну и ту же иерархию блокировки</span><span class="sxs-lookup"><span data-stu-id="5b7f6-237">Any code your application calls or that might call your application needs to share the same lock hierarchy</span></span>
-   <span data-ttu-id="5b7f6-238">Структуры данных блокировки не являются функциями.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-238">Lock data structures not functions.</span></span> <span data-ttu-id="5b7f6-239">Перемещение блокировок от точек входа функций и защита доступа к данным только с помощью блокировок.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-239">Move lock acquisitions away from function entry points and guard only data access with locks.</span></span> <span data-ttu-id="5b7f6-240">Если меньше кода работает при блокировке, то существует меньше шансов на взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-240">If less code operates under a lock, there is less of a chance for deadlocks</span></span>
-   <span data-ttu-id="5b7f6-241">Анализ приобретений и выпусков блокировок в коде обработки ошибок.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-241">Analyze lock acquisitions and releases in your error handling code.</span></span> <span data-ttu-id="5b7f6-242">Часто при попытке восстановления после возникновения ошибки иерархия блокировок забывает.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-242">Often the lock hierarchy if forgotten when trying to recover from an error condition</span></span>
-   <span data-ttu-id="5b7f6-243">Замена вложенных блокировок на счетчики ссылок — они не могут быть взаимоблокировками.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-243">Replace nested locks with reference counters - they cannot deadlock.</span></span> <span data-ttu-id="5b7f6-244">Независимые элементы в списках и таблицах являются хорошими кандидатами</span><span class="sxs-lookup"><span data-stu-id="5b7f6-244">Individually locked elements in lists and tables are good candidates</span></span>
-   <span data-ttu-id="5b7f6-245">Будьте внимательны при ожидании обработки потока из библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-245">Be careful when waiting on a thread handle from a DLL.</span></span> <span data-ttu-id="5b7f6-246">Всегда считайте, что код может быть вызван при блокировке загрузчика.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-246">Always assume that your code could be called under the loader lock.</span></span> <span data-ttu-id="5b7f6-247">Лучше сослаться на ресурсы и позволить рабочему потоку выполнять собственную очистку (а затем использовать Фрилибраряндекситсреад для корректного завершения).</span><span class="sxs-lookup"><span data-stu-id="5b7f6-247">It's better to reference-count your resources and let the worker thread do its own cleanup (and then use FreeLibraryAndExitThread to terminate cleanly)</span></span>
-   <span data-ttu-id="5b7f6-248">Используйте API обхода цепочки ожидания, если хотите диагностировать собственные взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-248">Use the Wait Chain Traversal API if you want to diagnose your own deadlocks</span></span>

<span data-ttu-id="5b7f6-249">**Чего не следует делать:**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-249">**Do not:**</span></span>

-   <span data-ttu-id="5b7f6-250">Выполните любые действия, отличные от очень простых операций инициализации в функции DllMain ().</span><span class="sxs-lookup"><span data-stu-id="5b7f6-250">Do anything other than very simple initialization work in your DllMain() function.</span></span> <span data-ttu-id="5b7f6-251">Дополнительные сведения см. в разделе Функция обратного вызова функции DllMain.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-251">See DllMain Callback Function for more details.</span></span> <span data-ttu-id="5b7f6-252">Особенно не вызывайте LoadLibraryEx или CoCreateInstance</span><span class="sxs-lookup"><span data-stu-id="5b7f6-252">Especially do not call LoadLibraryEx or CoCreateInstance</span></span>
-   <span data-ttu-id="5b7f6-253">Напишите собственные примитивы блокировки.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-253">Write your own locking primitives.</span></span> <span data-ttu-id="5b7f6-254">Пользовательский код синхронизации может легко ввести в базу кода небольшие ошибки.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-254">Custom synchronization code can easily introduce subtle bugs into your code base.</span></span> <span data-ttu-id="5b7f6-255">Вместо этого используйте Расширенный выбор объектов синхронизации операционной системы.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-255">Use the rich selection of operating system synchronization objects instead</span></span>
-   <span data-ttu-id="5b7f6-256">Выполнять любые действия в конструкторах и деструкторах для глобальных переменных, они выполняются при блокировке загрузчика</span><span class="sxs-lookup"><span data-stu-id="5b7f6-256">Do any work in the constructors and destructors for global variables, they are executed under the loader lock</span></span>

<span data-ttu-id="5b7f6-257">**Будьте внимательны с исключениями**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-257">**Be Careful with Exceptions**</span></span>

<span data-ttu-id="5b7f6-258">Исключения позволяют разделить нормальную последовательность программ и обработку ошибок.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-258">Exceptions allow the separation of normal program flow and error handling.</span></span> <span data-ttu-id="5b7f6-259">В связи с этим разделение может быть трудно понять точное состояние программы до исключения, а обработчик исключений может пропустить важные шаги в восстановлении допустимого состояния.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-259">Because of this separation, it can be difficult to know the precise state of the program prior to the exception and the exception handler might miss crucial steps in restoring a valid state.</span></span> <span data-ttu-id="5b7f6-260">Это особенно справедливо для получения блокировок, которые необходимо освободить в обработчике, чтобы предотвратить дальнейшие взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-260">This is especially true for lock acquisitions that need to be released in the handler to prevent future deadlocks.</span></span>

<span data-ttu-id="5b7f6-261">Эта проблема показана в приведенном ниже образце кода.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-261">The sample code below illustrates this issue.</span></span> <span data-ttu-id="5b7f6-262">Неограниченный доступ к переменной "buffer" иногда приводит к нарушению прав доступа (AV).</span><span class="sxs-lookup"><span data-stu-id="5b7f6-262">The unbounded access to the "buffer" variable will occasionally result in an access violation (AV).</span></span> <span data-ttu-id="5b7f6-263">Эта антивирусная программа перехвачена собственным обработчиком исключений, но не имеет простого способа определить, была ли критическая секция уже получена во время исключения (антивирусная программа, возможно, даже заняла место в коде EnterCriticalSection).</span><span class="sxs-lookup"><span data-stu-id="5b7f6-263">This AV is caught by the native exception handler, but it has no easy way of determining if the critical section was already acquired at the time of the exception (the AV could even have taken place somewhere in the EnterCriticalSection code).</span></span>

```
 BOOL bar (char* buffer)  
{  
   BOOL rc = FALSE;  
   __try {  
      EnterCriticalSection(&cs);  
      while (*buffer++ != '&') ;  
      rc = GetParams(buffer);  
      LeaveCriticalSection(&cs);  
   } __except (EXCEPTION_EXECUTE_HANDLER)  
   {  
      return FALSE;  
   } 
   return rc;  
}  
```

<span data-ttu-id="5b7f6-264">**Запреща**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-264">**Do:**</span></span>

-   <span data-ttu-id="5b7f6-265">Удалить \_ \_ try и \_ \_ EXCEPT, если это возможно; не использовать сетунхандледексцептионфилтер</span><span class="sxs-lookup"><span data-stu-id="5b7f6-265">Remove \_\_try/\_\_except whenever possible; do not use SetUnhandledExceptionFilter</span></span>
-   <span data-ttu-id="5b7f6-266">Если вы используете исключения C++, заключите свои блокировки в пользовательские шаблоны автозамены, \_ такие как.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-266">Wrap your locks in custom auto\_ptr-like templates if you use C++ exceptions.</span></span> <span data-ttu-id="5b7f6-267">Блокировка должна быть освобождена в деструкторе.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-267">The lock should be released in the destructor.</span></span> <span data-ttu-id="5b7f6-268">Для собственных исключений Освободите блокировки в \_ \_ операторе Finally.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-268">For native exceptions release the locks in your \_\_finally statement</span></span>
-   <span data-ttu-id="5b7f6-269">Будьте внимательны при работе с кодом, который выполняется в собственном обработчике исключений; исключение могло привести к утечке множества блокировок, поэтому обработчик не должен получить</span><span class="sxs-lookup"><span data-stu-id="5b7f6-269">Be careful with the code executing in a native exception handler; the exception might have leaked many locks, so your handler should not acquire any</span></span>

<span data-ttu-id="5b7f6-270">**Чего не следует делать:**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-270">**Do not:**</span></span>

-   <span data-ttu-id="5b7f6-271">Обрабатывайте собственные исключения, если они не нужны или не требуются для API-интерфейсов Win32.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-271">Handle native exceptions if not necessary or required by the Win32 APIs.</span></span> <span data-ttu-id="5b7f6-272">При использовании собственных обработчиков исключений для создания отчетов или восстановления данных после разрушительных сбоев рассмотрите возможность использования механизма операционной системы по умолчанию отчеты об ошибках Windows</span><span class="sxs-lookup"><span data-stu-id="5b7f6-272">If you use native exception handlers for reporting or data recovery after catastrophic failures, consider using the default operating system mechanism of Windows Error Reporting instead</span></span>
-   <span data-ttu-id="5b7f6-273">Используйте исключения C++ с любым кодом пользовательского интерфейса (User32). исключение, создаваемое в обратном вызове, передается через уровни кода на языке C, предоставленные операционной системой.</span><span class="sxs-lookup"><span data-stu-id="5b7f6-273">Use C++ exceptions with any kind of UI (user32) code; an exception thrown in a callback will travel through layers of C code provided by the operating system.</span></span> <span data-ttu-id="5b7f6-274">Этот код не знает о семантике отката C++</span><span class="sxs-lookup"><span data-stu-id="5b7f6-274">That code does not know about C++ unroll semantics</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="5b7f6-275">Ссылки на ресурсы</span><span class="sxs-lookup"><span data-stu-id="5b7f6-275">Links to Resources</span></span>

-   [<span data-ttu-id="5b7f6-276">Отчеты об ошибках Windows</span><span class="sxs-lookup"><span data-stu-id="5b7f6-276">Windows Error Reporting</span></span>](../wer/windows-error-reporting.md)
-   <span data-ttu-id="5b7f6-277">[Асинхронная разработка](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="5b7f6-277">[Asynchronous Design](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)</span></span>
-   [<span data-ttu-id="5b7f6-278">Асинхронный ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="5b7f6-278">Asynchronous I/O</span></span>](../fileio/synchronous-and-asynchronous-i-o.md)
-   [<span data-ttu-id="5b7f6-279">**Функция Аттачсреадинпут**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-279">**AttachThreadInput Function**</span></span>](/windows/win32/api/winuser/nf-winuser-attachthreadinput)
-   <span data-ttu-id="5b7f6-280">[**Автоматический \_ класс PTR**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="5b7f6-280">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="5b7f6-281">**Функция Дисаблепроцессвиндовсгхостинг**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-281">**DisableProcessWindowsGhosting Function**</span></span>](/windows/win32/api/winuser/nf-winuser-disableprocesswindowsghosting)
-   [<span data-ttu-id="5b7f6-282">**Функция обратного вызова функции DllMain**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-282">**DllMain Callback Function**</span></span>](../dlls/dllmain.md)
-   <span data-ttu-id="5b7f6-283">[События](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="5b7f6-283">[Events](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)</span></span>
-   [<span data-ttu-id="5b7f6-284">**Функция onmessage**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-284">**GetMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-getmessage)
-   [<span data-ttu-id="5b7f6-285">Отмена ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="5b7f6-285">I/O cancellation</span></span>](../fileio/canceling-pending-i-o-operations.md)
-   [<span data-ttu-id="5b7f6-286">**Функция Ишунгаппвиндов**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-286">**IsHungAppWindow Function**</span></span>](/windows/win32/api/winuser/nf-winuser-ishungappwindow)
-   [<span data-ttu-id="5b7f6-287">Очередь сообщений</span><span class="sxs-lookup"><span data-stu-id="5b7f6-287">Message Queue</span></span>](../winmsg/using-messages-and-message-queues.md)
-   [<span data-ttu-id="5b7f6-288">**Функция Мсгваитформултиплеобжектс**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-288">**MsgWaitForMultipleObjects Function**</span></span>](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects)
-   [<span data-ttu-id="5b7f6-289">Новый API пула потоков</span><span class="sxs-lookup"><span data-stu-id="5b7f6-289">New Thread Pool API</span></span>](../procthread/thread-pool-api.md)
-   [<span data-ttu-id="5b7f6-290">**Функция onmessage**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-290">**PostMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-postmessagea)
-   [<span data-ttu-id="5b7f6-291">Перезагрузка и восстановление</span><span class="sxs-lookup"><span data-stu-id="5b7f6-291">Restart and Recovery</span></span>](../recovery/registering-for-application-restart.md)
-   [<span data-ttu-id="5b7f6-292">**Функция Сендмессажекаллбакк**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-292">**SendMessageCallback Function**</span></span>](/windows/win32/api/winuser/nf-winuser-sendmessagecallbacka)
-   [<span data-ttu-id="5b7f6-293">**Функция Сенднотифимессаже**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-293">**SendNotifyMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-sendnotifymessagea)
-   [<span data-ttu-id="5b7f6-294">Объекты синхронизации</span><span class="sxs-lookup"><span data-stu-id="5b7f6-294">Synchronization Objects</span></span>](../sync/about-synchronization.md)
-   [<span data-ttu-id="5b7f6-295">**TerminateThread, функция**</span><span class="sxs-lookup"><span data-stu-id="5b7f6-295">**TerminateThread Function**</span></span>](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread)
-   [<span data-ttu-id="5b7f6-296">Отчеты об ошибках Windows</span><span class="sxs-lookup"><span data-stu-id="5b7f6-296">Windows Error Reporting</span></span>](../wer/windows-error-reporting.md)
-   [<span data-ttu-id="5b7f6-297">винкуал</span><span class="sxs-lookup"><span data-stu-id="5b7f6-297">Winqual</span></span>](/windows-hardware/drivers/dashboard/winqual-submission-tool--winqualexe-)

 

 
