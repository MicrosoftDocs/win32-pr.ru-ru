---
title: Обработка инерции в неуправляемом коде
description: В этом разделе объясняется, как использовать интерфейс IInertiaProcessor для обработки инерции в неуправляемом коде.
ms.assetid: 3261b461-add2-4e92-9a51-b2d46630fb4f
keywords:
- Касание Windows, инерция
- Windows Touch, процессор манипуляции
- инерция, неуправляемый код
- инерция, интерфейс IInertiaProcessor
- инерция, процессор манипуляции
- процессор манипуляции, инерция
- Интерфейс IInertiaProcessor, неуправляемый код
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3de56d06547f426de252a89ef5172df3fe4ca439
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "104067457"
---
# <a name="handling-inertia-in-unmanaged-code"></a><span data-ttu-id="fb8e6-110">Обработка инерции в неуправляемом коде</span><span class="sxs-lookup"><span data-stu-id="fb8e6-110">Handling Inertia in Unmanaged Code</span></span>

<span data-ttu-id="fb8e6-111">В этом разделе объясняется, как использовать интерфейс [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) для обработки инерции в неуправляемом коде.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-111">This section explains how to use the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface for handling inertia in unmanaged code.</span></span>

## <a name="overview"></a><span data-ttu-id="fb8e6-112">Обзор</span><span class="sxs-lookup"><span data-stu-id="fb8e6-112">Overview</span></span>

<span data-ttu-id="fb8e6-113">Чтобы использовать инерцию в неуправляемом коде, необходимо реализовать приемники событий как для обработчика манипуляции, так и для обработчика инерции.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-113">To use inertia in unmanaged code, you must implement event sinks both for the manipulation processor and the inertia processor.</span></span> <span data-ttu-id="fb8e6-114">Начните с добавления поддержки манипуляции в приложение, как описано в разделе [Добавление поддержки манипуляций в неуправляемый код](adding-manipulation-support-in-unmanaged-code.md).</span><span class="sxs-lookup"><span data-stu-id="fb8e6-114">Start by adding manipulation support to your application as described in the section [Adding Manipulation Support to Unmanaged Code](adding-manipulation-support-in-unmanaged-code.md).</span></span> <span data-ttu-id="fb8e6-115">Обратите внимание, что поддержка манипуляции требует использования сенсорных сообщений вместо сообщений жестов для передачи данных событий обработчику манипуляции.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-115">Note that manipulation support requires that you use touch messages rather than gesture messages to feed event data to the manipulation processor.</span></span> <span data-ttu-id="fb8e6-116">После обработки работы необходимо также реализовать второй приемник событий для событий, которые будет создавать интерфейс [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) , или потребуется изменить существующий приемник событий, чтобы он соответствовал обоим событиям, создаваемым интерфейсами **IInertiaProcessor** и [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fb8e6-116">After you have manipulation working, you must also implement a second event sink for the events that the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface will be generating or will need to modify your existing event sink to accommodate both the events generated by the **IInertiaProcessor** and the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) interfaces.</span></span> <span data-ttu-id="fb8e6-117">В этом примере проще начать с приемника событий, созданного для раздела Добавление поддержки манипуляций в неуправляемый код, и добавить второй конструктор, который работает с процессором инерции вместо обработчика манипуляции.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-117">For the purposes of this example, it is easier to start from the event sink created for the section Adding Manipulation Support to Unmanaged Code and add a second constructor that works with the inertia processor instead of the manipulation processor.</span></span> <span data-ttu-id="fb8e6-118">Таким образом, реализация приемника событий может работать либо с обработчиком манипуляции, либо с обработчиком инерции.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-118">This way, the event sink implementation can function for either the manipulation processor or the inertia processor.</span></span> <span data-ttu-id="fb8e6-119">Помимо добавления второго конструктора, приемник событий будет иметь переменную, указывающую, будет ли выполняться операция на основе ввода инерции, а не входных данных.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-119">In addition to adding a second constructor, the event sink will have a variable indicating whether it will perform the operations based on inertia input rather than manipulation input.</span></span>

### <a name="add-inertia-support-to-a-manipulation-processor-event-sink"></a><span data-ttu-id="fb8e6-120">Добавление поддержки инерции в приемник событий обработчика манипуляции</span><span class="sxs-lookup"><span data-stu-id="fb8e6-120">Add Inertia Support to a Manipulation Processor Event Sink</span></span>

<span data-ttu-id="fb8e6-121">В следующем коде показан новый конструктор приемника событий, новые переменные-члены для интерфейса [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) и флаг, указывающий, является ли приемник экстраполяцией для инерции.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-121">The following code shows the new event sink constructor, new member variables for an [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface, and a flag indicating whether the sink is extrapolating for inertia.</span></span>


```C++
    CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd);
    CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd);
```




```C++
    IInertiaProcessor*      m_pInert;
    BOOL fExtrapolating; 
```



<span data-ttu-id="fb8e6-122">После того как Заголовок класса содержит новые конструкторы и флаг, указывающий, выполняется ли экстраполяция, можно реализовать приемник событий, чтобы иметь отдельные блоки обработки для событий [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) и [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fb8e6-122">After your class header has the new constructors and a flag indicating whether you're extrapolating, you can implement your event sink to have separate handling blocks for the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) events and [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) events.</span></span> <span data-ttu-id="fb8e6-123">Конструктор, принимающий **IManipulationProcessor** и **IInertiaProcessor** , должен установить для флага **фекстраполатинг** значение false, означающее, что это обработчик событий **IManipulationProcessor** .</span><span class="sxs-lookup"><span data-stu-id="fb8e6-123">The constructor that accepts an **IManipulationProcessor** and an **IInertiaProcessor** should set the **fExtrapolating** flag to false, which indicates that this is a **IManipulationProcessor** event handler.</span></span> <span data-ttu-id="fb8e6-124">В следующем коде показано, как можно реализовать конструктор для приемника событий, использующего **IManipulationProcessor** .</span><span class="sxs-lookup"><span data-stu-id="fb8e6-124">The following code shows how the constructor for an event sink that uses the **IManipulationProcessor** could be implemented.</span></span>


```C++
CManipulationEventSink::CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=FALSE;

    m_pManip = pManip;
    
    m_pInert = pInert;
    
    m_pManip->put_PivotRadius(-1);

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pManip->QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &spConnectionContainer
        );
    //hr = manip->QueryInterface(&spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit
        
    }

    //Get a connection point.
    hr = spConnectionContainer->FindConnectionPoint(__uuidof(_IManipulationEvents), &m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }

    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint->Advise(this, &dwCookie);
}
```



<span data-ttu-id="fb8e6-125">В следующем коде показано, как можно реализовать конструктор для приемника событий, использующего [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fb8e6-125">The following code shows how the constructor for an event sink that uses the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) could be implemented.</span></span> <span data-ttu-id="fb8e6-126">Этот конструктор устанавливает для флага **фекстраполатинг** значение true, указывающее, что этот экземпляр класса приемника событий будет выполнять экстраполяцию, и будет выполнять любые операции перемещения, которые были выполнены ранее событиями обработчика манипуляции.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-126">This constructor sets the **fExtrapolating** flag to true, indicating that this instance of the event sink class will be performing extrapolation and will perform any movement operations that were performed previously by the manipulation processor events.</span></span>


```C++
CManipulationEventSink::CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    m_pInert = pInert;
    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=TRUE;

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pInert->QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &spConnectionContainer
        );
    //hr = manip->QueryInterface(&spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit        
    }

    //Get a connection point.
    hr = spConnectionContainer->FindConnectionPoint(__uuidof(_IManipulationEvents), &m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }
    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint->Advise(this, &dwCookie);
}   
```



> [!Note]  
> <span data-ttu-id="fb8e6-127">Реализация класса приемника событий из приемника событий обработчика манипуляции повторно используется в качестве приемника событий для обработчика инерции.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-127">The event sink class implementation from the manipulation processor event sink is reused as an event sink for the inertia processor.</span></span>

 

<span data-ttu-id="fb8e6-128">Теперь при создании этого класса **кманипулатионевентсинк** он может быть создан как приемник событий для обработчика манипуляции или как приемник событий для обработчика инерции.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-128">Now when you construct this class, **CManipulationEventSink**, it can either be constructed as an event sink for a manipulation processor or as an event sink for an inertia processor.</span></span> <span data-ttu-id="fb8e6-129">Если он создан как приемник событий обработчика инерции, для флага **фекстраполатинг** будет задано значение true, указывающее на то, что события манипуляции должны быть экстраполяциями.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-129">When it's constructed as an inertia processor event sink, it will have the **fExtrapolating** flag set to true, indicating that manipulation events should be extrapolated.</span></span>

> [!Note]  
> <span data-ttu-id="fb8e6-130">[**ManipulationStarted**](/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted) будет вызываться интерфейсами [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) и [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fb8e6-130">[**ManipulationStarted**](/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted) will be raised by both the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) and [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interfaces.</span></span>

 

<span data-ttu-id="fb8e6-131">При запуске манипуляции задаются свойства интерфейса [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fb8e6-131">When manipulation starts, the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface properties are set.</span></span> <span data-ttu-id="fb8e6-132">В следующем коде показано, как обрабатывается событие Started.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-132">The following code shows how the started event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationStarted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y)
{
    m_cStartedEventCount ++;       

    // set origins in manipulation processor
    m_pInert->put_InitialOriginX(x);
    m_pInert->put_InitialOriginY(y);
    
    RECT screenRect;

    HWND desktop = GetDesktopWindow();
    GetClientRect(desktop, &screenRect);

    // physics settings
    // deceleration is units per square millisecond
    m_pInert->put_DesiredDeceleration(.1f);

    // set the boundaries        
    screenRect.left-= 1024;
    m_pInert->put_BoundaryLeft  ( static_cast<float>(screenRect.left   * 100));
    m_pInert->put_BoundaryTop   ( static_cast<float>(screenRect.top    * 100));
    m_pInert->put_BoundaryRight ( static_cast<float>(screenRect.right  * 100));
    m_pInert->put_BoundaryBottom( static_cast<float>(screenRect.bottom * 100));
    
    
    // Elastic boundaries - I set these to 90% of the screen 
    // so... 5% at left, 95% right, 5% top,  95% bottom
    // Values are whole numbers because units are in centipixels
    m_pInert->put_ElasticMarginLeft  (static_cast<float>(screenRect.left   * 5));
    m_pInert->put_ElasticMarginTop   (static_cast<float>(screenRect.top    * 5));
    m_pInert->put_ElasticMarginRight (static_cast<float>(screenRect.right  * 95));
    m_pInert->put_ElasticMarginBottom(static_cast<float>(screenRect.bottom * 95));
    
    
    return S_OK;
}
```



<span data-ttu-id="fb8e6-133">В этом примере для перемещения окна используются разности манипуляций.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-133">In this example, manipulation deltas are used to move the window around.</span></span> <span data-ttu-id="fb8e6-134">В следующем коде показано, как обрабатывается событие Дельта.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-134">The following code shows how the delta event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationDelta( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT translationDeltaX,
    /* [in] */ FLOAT translationDeltaY,
    /* [in] */ FLOAT scaleDelta,
    /* [in] */ FLOAT expansionDelta,
    /* [in] */ FLOAT rotationDelta,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cDeltaEventCount ++;
        
    RECT rect;
            
    GetWindowRect(m_hWnd, &rect);
        
    int oldWidth =  rect.right-rect.left;
    int oldHeight = rect.bottom-rect.top;            

    // scale and translate the window size / position    
    MoveWindow(m_hWnd,                                              // the window to move
        static_cast<int>(rect.left + (translationDeltaX / 100.0f)), // the x position
        static_cast<int>(rect.top + (translationDeltaY/100.0f)),    // the y position
        static_cast<int>(oldWidth * scaleDelta),                    // width
        static_cast<int>(oldHeight * scaleDelta),                   // height
        TRUE);                                                      // redraw
                     
    return S_OK;
}
```



<span data-ttu-id="fb8e6-135">В этом примере обработка завершенных событий либо запускает, либо останавливает таймер, который будет вызывать [**процесс**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) в интерфейсе [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fb8e6-135">In this example, manipulation completed events either start or stop a timer that will call [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface.</span></span> <span data-ttu-id="fb8e6-136">В следующем коде показано, как обрабатывается завершенное событие манипуляции.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-136">The following code shows how the completed manipulation event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationCompleted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cCompletedEventCount ++;

    m_fX = x;
    m_fY = y;

    // place your code handler here to do any operations based on the manipulation   
    
    if (fExtrapolating){
        //Inertia Complete, stop the timer used for processing      
        KillTimer(m_hWnd,0);        
    }else{ 
        // setup velocities for inertia processor
        float vX = 0.0f;
        float vY = 0.0f;
        float vA = 0.0f;
        m_pManip->GetVelocityX(&vX);
        m_pManip->GetVelocityY(&vY);
        m_pManip->GetAngularVelocity(&vA);

        // complete any previous processing
        m_pInert->Complete();
        
        // Reset sets the  initial timestamp
        m_pInert->Reset();
                
        // 
        m_pInert->put_InitialVelocityX(vX);
        m_pInert->put_InitialVelocityY(vY);        
        
        m_pInert->put_InitialOriginX(x);
        m_pInert->put_InitialOriginY(y);
        
           
        // Start a timer
        SetTimer(m_hWnd,0, 50, 0);        
    }

    return S_OK;
}
```



<span data-ttu-id="fb8e6-137">В следующем коде показано, как можно интерпретировать **сообщения \_ таймера WM** в **WndProc** , чтобы выполнять вызовы для [**обработки**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) в интерфейсе [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fb8e6-137">The following code shows how you could interpret **WM\_TIMER** messages in **WndProc** to perform calls to [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface.</span></span>


```C++
case WM_TIMER:       
  if (g_pIInertProc){
    BOOL b;       
    g_pIInertProc->Process(&b);        
  }
  break;
```



### <a name="coinitialize-the-inertia-processor-and-manipulation-processor-and-initialize-the-event-sinks"></a><span data-ttu-id="fb8e6-138">Выинициализировать обработчик инерции и процессор манипуляции и инициализировать приемники событий</span><span class="sxs-lookup"><span data-stu-id="fb8e6-138">CoInitialize the Inertia Processor and Manipulation Processor and Initialize the Event Sinks</span></span>

<span data-ttu-id="fb8e6-139">После изменения приемника событий для поддержки [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) и [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor)вы можете инициализировать приемники событий и настроить их для запуска из приложения.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-139">After you have your event sink modified to support both the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) and the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor), you are ready to initialize the event sinks and set them up to run from your application.</span></span> <span data-ttu-id="fb8e6-140">В следующем коде показано, как выделяются указатели на интерфейс.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-140">The following code shows how the interface pointers are allocated.</span></span>


```C++
//Include windows.h for touch events
#include "windows.h"  

// Manipulation implementation file
#include <manipulations_i.c>
    
// Smart Pointer to a global reference of a manipulation processor, event sink
IManipulationProcessor* g_pIManipProc;
IInertiaProcessor*      g_pIInertProc;
```



<span data-ttu-id="fb8e6-141">В следующем примере кода показано, как создать экземпляр интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-141">The following code example shows how to instantiate your interfaces.</span></span>


```C++
   HRESULT hr = CoInitialize(0);
        
   hr = CoCreateInstance(CLSID_ManipulationProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&g_pIManipProc)
   );
   
   hr = CoCreateInstance(CLSID_InertiaProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&g_pIInertProc)
   );
```



<span data-ttu-id="fb8e6-142">В следующем примере кода показано, как создать приемники событий с помощью указателей интерфейса и зарегистрировать окно для сенсорного ввода.</span><span class="sxs-lookup"><span data-stu-id="fb8e6-142">The following code example shows how to construct your event sinks given the interface pointers and register the window for touch input.</span></span>


```C++
   g_pManipulationEventSink = new CManipulationEventSink(g_pIManipProc, g_pIInertProc, hWnd);
   g_pManipulationEventSink = new CManipulationEventSink(g_pIInertProc, hWnd);


   RegisterTouchWindow(hWnd, 0);  
```



## <a name="related-topics"></a><span data-ttu-id="fb8e6-143">См. также</span><span class="sxs-lookup"><span data-stu-id="fb8e6-143">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="fb8e6-144">Инерция</span><span class="sxs-lookup"><span data-stu-id="fb8e6-144">Inertia</span></span>](getting-started-with-inertia.md)
</dt> </dl>

 

 




