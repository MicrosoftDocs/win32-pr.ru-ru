---
description: Создание библиотек DLL представляет ряд трудностей для разработчиков.
ms.assetid: 44EFC4B5-7A2F-43A6-914E-D4EB7446AC35
title: Рекомендации по использованию библиотеки Dynamic-Link
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 88aba0999f3d0825c6d2f4df3afe09d766a82232
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105664447"
---
# <a name="dynamic-link-library-best-practices"></a><span data-ttu-id="5ec83-103">Рекомендации по использованию библиотеки Dynamic-Link</span><span class="sxs-lookup"><span data-stu-id="5ec83-103">Dynamic-Link Library Best Practices</span></span>

<span data-ttu-id="5ec83-104">\* \* Обновлено: \* \*</span><span class="sxs-lookup"><span data-stu-id="5ec83-104">\*\*Updated: \*\*</span></span>

-   <span data-ttu-id="5ec83-105">17 мая, 2006</span><span class="sxs-lookup"><span data-stu-id="5ec83-105">May 17, 2006</span></span>

<span data-ttu-id="5ec83-106">**Важные API**</span><span class="sxs-lookup"><span data-stu-id="5ec83-106">**Important APIs**</span></span>

-   [<span data-ttu-id="5ec83-107">**DllMain**</span><span class="sxs-lookup"><span data-stu-id="5ec83-107">**DllMain**</span></span>](dllmain.md)
-   [<span data-ttu-id="5ec83-108">**LoadLibraryEx**</span><span class="sxs-lookup"><span data-stu-id="5ec83-108">**LoadLibraryEx**</span></span>](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)
-   [<span data-ttu-id="5ec83-109">**CreateProcess**</span><span class="sxs-lookup"><span data-stu-id="5ec83-109">**CreateProcess**</span></span>](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)

<span data-ttu-id="5ec83-110">Создание библиотек DLL представляет ряд трудностей для разработчиков.</span><span class="sxs-lookup"><span data-stu-id="5ec83-110">Creating DLLs presents a number of challenges for developers.</span></span> <span data-ttu-id="5ec83-111">Библиотеки DLL не имеют принудительного управления версиями.</span><span class="sxs-lookup"><span data-stu-id="5ec83-111">DLLs do not have system-enforced versioning.</span></span> <span data-ttu-id="5ec83-112">Если в системе существует несколько версий библиотеки DLL, простота переписывания в сочетании с отсутствием схемы управления версиями создает зависимости и конфликты API.</span><span class="sxs-lookup"><span data-stu-id="5ec83-112">When multiple versions of a DLL exist on a system, the ease of being overwritten coupled with the lack of a versioning schema creates dependency and API conflicts.</span></span> <span data-ttu-id="5ec83-113">Сложность среды разработки, реализация загрузчика и зависимости библиотек DLL создавали хрупкости в порядке загрузки и в поведении приложения.</span><span class="sxs-lookup"><span data-stu-id="5ec83-113">Complexity in the development environment, the loader implementation, and the DLL dependencies has created fragility in load order and application behavior.</span></span> <span data-ttu-id="5ec83-114">Наконец, многие приложения используют библиотеки DLL и имеют сложные наборы зависимостей, которые должны учитываться для правильной работы приложений.</span><span class="sxs-lookup"><span data-stu-id="5ec83-114">Lastly, many applications rely on DLLs and have complex sets of dependencies that must be honored for the applications to function properly.</span></span> <span data-ttu-id="5ec83-115">Этот документ содержит рекомендации для разработчиков библиотек DLL, помогающих создавать более надежные, переносимые и расширяемые библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="5ec83-115">This document provides guidelines for DLL developers to help in building more robust, portable, and extensible DLLs.</span></span>

<span data-ttu-id="5ec83-116">Неправильная синхронизация в [**DllMain**](dllmain.md) может привести к взаимоблокировке приложения или доступу к данным или коду в неинициализированной библиотеке DLL.</span><span class="sxs-lookup"><span data-stu-id="5ec83-116">Improper synchronization within [**DllMain**](dllmain.md) can cause an application to deadlock or access data or code in an uninitialized DLL.</span></span> <span data-ttu-id="5ec83-117">Вызов определенных функций из функции **DllMain** вызывает такие проблемы.</span><span class="sxs-lookup"><span data-stu-id="5ec83-117">Calling certain functions from within **DllMain** causes such problems.</span></span>

![что происходит при загрузке библиотеки](images/fig1.png)

## <a name="general-best-practices"></a><span data-ttu-id="5ec83-119">Общие рекомендации</span><span class="sxs-lookup"><span data-stu-id="5ec83-119">General Best Practices</span></span>

<span data-ttu-id="5ec83-120">Функция [**DllMain**](dllmain.md) вызывается во время удержания блокировки загрузчика.</span><span class="sxs-lookup"><span data-stu-id="5ec83-120">[**DllMain**](dllmain.md) is called while the loader-lock is held.</span></span> <span data-ttu-id="5ec83-121">Поэтому в функциях, которые могут вызываться внутри **DllMain**, накладываются значительные ограничения.</span><span class="sxs-lookup"><span data-stu-id="5ec83-121">Therefore, significant restrictions are imposed on the functions that can be called within **DllMain**.</span></span> <span data-ttu-id="5ec83-122">Таким образом, функция **DllMain** предназначена для выполнения минимальных задач инициализации с помощью небольшого подмножества Microsoft® Windows® API.</span><span class="sxs-lookup"><span data-stu-id="5ec83-122">As such, **DllMain** is designed to perform minimal initialization tasks, by using a small subset of the Microsoft® Windows® API.</span></span> <span data-ttu-id="5ec83-123">В **DllMain** нельзя вызывать функцию, которая напрямую или косвенно пытается получить блокировку загрузчика.</span><span class="sxs-lookup"><span data-stu-id="5ec83-123">You cannot call any function in **DllMain** that directly or indirectly tries to acquire the loader lock.</span></span> <span data-ttu-id="5ec83-124">В противном случае будет предпринята возможность возникновения взаимоблокировок или сбоев приложения.</span><span class="sxs-lookup"><span data-stu-id="5ec83-124">Otherwise, you will introduce the possibility that your application deadlocks or crashes.</span></span> <span data-ttu-id="5ec83-125">Ошибка в реализации **DllMain** может подвергнуть риску весь процесс и все его потоки.</span><span class="sxs-lookup"><span data-stu-id="5ec83-125">An error in a **DllMain** implementation can jeopardize the entire process and all of its threads.</span></span>

<span data-ttu-id="5ec83-126">Идеальная функция [**DllMain**](dllmain.md) — это просто пустая заглушка.</span><span class="sxs-lookup"><span data-stu-id="5ec83-126">The ideal [**DllMain**](dllmain.md) would be just an empty stub.</span></span> <span data-ttu-id="5ec83-127">Однако, учитывая сложность многих приложений, обычно это слишком мало.</span><span class="sxs-lookup"><span data-stu-id="5ec83-127">However, given the complexity of many applications, this is generally too restrictive.</span></span> <span data-ttu-id="5ec83-128">Хорошим правилом для функции **DllMain** является отложить как можно больше инициализации.</span><span class="sxs-lookup"><span data-stu-id="5ec83-128">A good rule of thumb for **DllMain** is to postpone as much initialization as possible.</span></span> <span data-ttu-id="5ec83-129">Отложенная инициализация повышает надежность приложения, так как эта инициализация не выполняется во время удержания блокировки загрузчика.</span><span class="sxs-lookup"><span data-stu-id="5ec83-129">Lazy initialization increases robustness of the application because this initialization is not performed while the loader lock is held.</span></span> <span data-ttu-id="5ec83-130">Кроме того, отложенная инициализация позволяет безопасно использовать гораздо больше API Windows.</span><span class="sxs-lookup"><span data-stu-id="5ec83-130">Also, lazy initialization enables you to safely use much more of the Windows API.</span></span>

<span data-ttu-id="5ec83-131">Некоторые задачи инициализации нельзя откладывать.</span><span class="sxs-lookup"><span data-stu-id="5ec83-131">Some initialization tasks cannot be postponed.</span></span> <span data-ttu-id="5ec83-132">Например, Библиотека DLL, которая зависит от файла конфигурации, не должна загружаться, если файл имеет неправильный формат или содержит мусор.</span><span class="sxs-lookup"><span data-stu-id="5ec83-132">For example, a DLL that depends on a configuration file should fail to load if the file is malformed or contains garbage.</span></span> <span data-ttu-id="5ec83-133">Для этого типа инициализации библиотека DLL должна попытаться выполнить действие и быстро завершить работу, а не расходовать ресурсы, выполнив другие действия.</span><span class="sxs-lookup"><span data-stu-id="5ec83-133">For this type of initialization, the DLL should attempt the action and fail quickly rather than waste resources by completing other work.</span></span>

<span data-ttu-id="5ec83-134">В [**DllMain**](dllmain.md)не следует выполнять следующие задачи.</span><span class="sxs-lookup"><span data-stu-id="5ec83-134">You should never perform the following tasks from within [**DllMain**](dllmain.md):</span></span>

-   <span data-ttu-id="5ec83-135">Вызовите [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) или [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (напрямую или косвенно).</span><span class="sxs-lookup"><span data-stu-id="5ec83-135">Call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (either directly or indirectly).</span></span> <span data-ttu-id="5ec83-136">Это может привести к взаимоблокировке или сбою.</span><span class="sxs-lookup"><span data-stu-id="5ec83-136">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="5ec83-137">Вызовите [**жетстрингтипеа**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**жетстрингтипикс**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw)или [**жетстрингтипев**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (прямо или косвенно).</span><span class="sxs-lookup"><span data-stu-id="5ec83-137">Call [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw), or [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (either directly or indirectly).</span></span> <span data-ttu-id="5ec83-138">Это может привести к взаимоблокировке или сбою.</span><span class="sxs-lookup"><span data-stu-id="5ec83-138">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="5ec83-139">Синхронизация с другими потоками.</span><span class="sxs-lookup"><span data-stu-id="5ec83-139">Synchronize with other threads.</span></span> <span data-ttu-id="5ec83-140">Это может привести к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="5ec83-140">This can cause a deadlock.</span></span>
-   <span data-ttu-id="5ec83-141">Получите объект синхронизации, принадлежащий коду, который ожидает получения блокировки загрузчика.</span><span class="sxs-lookup"><span data-stu-id="5ec83-141">Acquire a synchronization object that is owned by code that is waiting to acquire the loader lock.</span></span> <span data-ttu-id="5ec83-142">Это может привести к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="5ec83-142">This can cause a deadlock.</span></span>
-   <span data-ttu-id="5ec83-143">Инициализируйте потоки COM с помощью [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="5ec83-143">Initialize COM threads by using [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="5ec83-144">При определенных условиях эта функция может вызывать [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span><span class="sxs-lookup"><span data-stu-id="5ec83-144">Under certain conditions, this function can call [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span></span>
-   <span data-ttu-id="5ec83-145">Вызовите функции реестра.</span><span class="sxs-lookup"><span data-stu-id="5ec83-145">Call the registry functions.</span></span> <span data-ttu-id="5ec83-146">Эти функции реализуются в Advapi32.dll.</span><span class="sxs-lookup"><span data-stu-id="5ec83-146">These functions are implemented in Advapi32.dll.</span></span> <span data-ttu-id="5ec83-147">Если Advapi32.dll не инициализирован перед библиотекой DLL, Библиотека DLL может получить доступ к неинициализированной памяти и привести к сбою процесса.</span><span class="sxs-lookup"><span data-stu-id="5ec83-147">If Advapi32.dll is not initialized before your DLL, the DLL can access uninitialized memory and cause the process to crash.</span></span>
-   <span data-ttu-id="5ec83-148">Вызовите функцию [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span><span class="sxs-lookup"><span data-stu-id="5ec83-148">Call [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span></span> <span data-ttu-id="5ec83-149">Создание процесса может загрузить другую библиотеку DLL.</span><span class="sxs-lookup"><span data-stu-id="5ec83-149">Creating a process can load another DLL.</span></span>
-   <span data-ttu-id="5ec83-150">Вызовите [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span><span class="sxs-lookup"><span data-stu-id="5ec83-150">Call [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span></span> <span data-ttu-id="5ec83-151">Выход из потока во время отключения библиотеки DLL может привести к повторному получению блокировки загрузчика, что приведет к взаимоблокировке или сбою.</span><span class="sxs-lookup"><span data-stu-id="5ec83-151">Exiting a thread during DLL detach can cause the loader lock to be acquired again, causing a deadlock or a crash.</span></span>
-   <span data-ttu-id="5ec83-152">Вызов функции [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span><span class="sxs-lookup"><span data-stu-id="5ec83-152">Call [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span></span> <span data-ttu-id="5ec83-153">Создание потока может работать, если не выполнить синхронизацию с другими потоками, но это рискованно.</span><span class="sxs-lookup"><span data-stu-id="5ec83-153">Creating a thread can work if you do not synchronize with other threads, but it is risky.</span></span>
-   <span data-ttu-id="5ec83-154">Создайте именованный канал или другой именованный объект (только для Windows 2000).</span><span class="sxs-lookup"><span data-stu-id="5ec83-154">Create a named pipe or other named object (Windows 2000 only).</span></span> <span data-ttu-id="5ec83-155">В Windows 2000 именованные объекты предоставляются библиотекой DLL служб терминалов.</span><span class="sxs-lookup"><span data-stu-id="5ec83-155">In Windows 2000, named objects are provided by the Terminal Services DLL.</span></span> <span data-ttu-id="5ec83-156">Если эта библиотека DLL не инициализирована, вызовы к библиотеке DLL могут привести к сбою процесса.</span><span class="sxs-lookup"><span data-stu-id="5ec83-156">If this DLL is not initialized, calls to the DLL can cause the process to crash.</span></span>
-   <span data-ttu-id="5ec83-157">Используйте функцию управления памятью из динамического Run-Time C (CRT).</span><span class="sxs-lookup"><span data-stu-id="5ec83-157">Use the memory management function from the dynamic C Run-Time (CRT).</span></span> <span data-ttu-id="5ec83-158">Если DLL-библиотека CRT не инициализирована, вызовы этих функций могут привести к сбою процесса.</span><span class="sxs-lookup"><span data-stu-id="5ec83-158">If the CRT DLL is not initialized, calls to these functions can cause the process to crash.</span></span>
-   <span data-ttu-id="5ec83-159">Вызывайте функции в User32.dll или Gdi32.dll.</span><span class="sxs-lookup"><span data-stu-id="5ec83-159">Call functions in User32.dll or Gdi32.dll.</span></span> <span data-ttu-id="5ec83-160">Некоторые функции загружают другую библиотеку DLL, которая не может быть инициализирована.</span><span class="sxs-lookup"><span data-stu-id="5ec83-160">Some functions load another DLL, which may not be initialized.</span></span>
-   <span data-ttu-id="5ec83-161">Использование управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="5ec83-161">Use managed code.</span></span>

<span data-ttu-id="5ec83-162">Следующие задачи являются надежными для выполнения в **DllMain**:</span><span class="sxs-lookup"><span data-stu-id="5ec83-162">The following tasks are safe to perform within **DllMain**:</span></span>

-   <span data-ttu-id="5ec83-163">Инициализируйте статические структуры данных и элементы во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="5ec83-163">Initialize static data structures and members at compile time.</span></span>
-   <span data-ttu-id="5ec83-164">Создание и инициализация объектов синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5ec83-164">Create and initialize synchronization objects.</span></span>
-   <span data-ttu-id="5ec83-165">Выделение памяти и инициализация динамических структур данных (без использования перечисленных выше функций).</span><span class="sxs-lookup"><span data-stu-id="5ec83-165">Allocate memory and initialize dynamic data structures (avoiding the functions listed above.)</span></span>
-   <span data-ttu-id="5ec83-166">Настройте локальную память потока (TLS).</span><span class="sxs-lookup"><span data-stu-id="5ec83-166">Set up thread local storage (TLS).</span></span>
-   <span data-ttu-id="5ec83-167">Открытие, чтение и запись в файлы.</span><span class="sxs-lookup"><span data-stu-id="5ec83-167">Open, read from, and write to files.</span></span>
-   <span data-ttu-id="5ec83-168">Вызывайте функции в Kernel32.dll (за исключением перечисленных выше функций).</span><span class="sxs-lookup"><span data-stu-id="5ec83-168">Call functions in Kernel32.dll (except the functions that are listed above).</span></span>
-   <span data-ttu-id="5ec83-169">Задайте глобальные указатели равными NULL, отключив инициализацию динамических членов.</span><span class="sxs-lookup"><span data-stu-id="5ec83-169">Set global pointers to NULL, putting off the initialization of dynamic members.</span></span> <span data-ttu-id="5ec83-170">В Microsoft Windows Vista™ можно использовать функции однократной инициализации, чтобы блок кода выполнялся в многопоточной среде только один раз.</span><span class="sxs-lookup"><span data-stu-id="5ec83-170">In Microsoft Windows Vista™, you can use the one-time initialization functions to ensure that a block of code is executed only once in a multithreaded environment.</span></span>

## <a name="deadlocks-caused-by-lock-order-inversion"></a><span data-ttu-id="5ec83-171">Взаимоблокировки, вызванные инверсией порядка блокировки</span><span class="sxs-lookup"><span data-stu-id="5ec83-171">Deadlocks Caused by Lock Order Inversion</span></span>

<span data-ttu-id="5ec83-172">При реализации кода, использующего несколько объектов синхронизации, таких как блокировки, важно соблюдать порядок блокировки.</span><span class="sxs-lookup"><span data-stu-id="5ec83-172">When you are implementing code that uses multiple synchronization objects such as locks, it is vital to respect lock order.</span></span> <span data-ttu-id="5ec83-173">Если необходимо получить более одной блокировки за раз, необходимо определить явный приоритет, который называется иерархией блокировок или порядком блокировки.</span><span class="sxs-lookup"><span data-stu-id="5ec83-173">When it is necessary to acquire more than one lock at a time, you must define an explicit precedence that is called a lock hierarchy or lock order.</span></span> <span data-ttu-id="5ec83-174">Например, если блокировка, полученная перед блокировкой б где-то где-то в коде, и блокировка B получена перед блокировкой C в другом месте в коде, то порядок блокировки — A, B, C, и этот порядок должен соблюдаться во всем коде.</span><span class="sxs-lookup"><span data-stu-id="5ec83-174">For example, if lock A is acquired before lock B somewhere in the code, and lock B is acquired before lock C elsewhere in the code, then the lock order is A, B, C and this order should be followed throughout the code.</span></span> <span data-ttu-id="5ec83-175">Инверсия порядка блокировок происходит, когда не выполняется порядок блокировки — например, если блокировка B получена перед блокировкой A. Инверсия порядка блокировок может вызвать взаимоблокировки, которые трудно отладить.</span><span class="sxs-lookup"><span data-stu-id="5ec83-175">Lock order inversion occurs when the locking order is not followed—for example, if lock B is acquired before lock A. Lock order inversion can cause deadlocks that are difficult to debug.</span></span> <span data-ttu-id="5ec83-176">Чтобы избежать подобных проблем, все потоки должны получать блокировки в том же порядке.</span><span class="sxs-lookup"><span data-stu-id="5ec83-176">To avoid such problems, all threads must acquire locks in the same order.</span></span>

<span data-ttu-id="5ec83-177">Важно отметить, что загрузчик вызывает [**DllMain**](dllmain.md) с уже полученной блокировкой загрузчика, поэтому блокировка загрузчика должна иметь наивысший приоритет в иерархии блокировки.</span><span class="sxs-lookup"><span data-stu-id="5ec83-177">It is important to note that the loader calls [**DllMain**](dllmain.md) with the loader lock already acquired, so the loader lock should have the highest precedence in the locking hierarchy.</span></span> <span data-ttu-id="5ec83-178">Также обратите внимание, что код должен получить только те блокировки, которые необходимы для правильной синхронизации. ему не нужно получать все одиночные блокировки, определенные в иерархии.</span><span class="sxs-lookup"><span data-stu-id="5ec83-178">Also note that code only has to acquire the locks it requires for proper synchronization; it does not have to acquire every single lock that is defined in the hierarchy.</span></span> <span data-ttu-id="5ec83-179">Например, если в разделе кода требуется только блокировка A и C для правильной синхронизации, то код должен получить блокировку A перед получением блокировки C; в коде также нет необходимости получать блокировку B. Кроме того, код DLL не может явно получить блокировку загрузчика.</span><span class="sxs-lookup"><span data-stu-id="5ec83-179">For example, if a section of code requires only locks A and C for proper synchronization, then the code should acquire lock A before it acquires lock C; it is not necessary for the code to also acquire lock B. Furthermore, DLL code cannot explicitly acquire the loader lock.</span></span> <span data-ttu-id="5ec83-180">Если код должен вызывать API, например [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) , который может косвенно получить блокировку загрузчика, а код также должен получить закрытую блокировку, то код должен вызвать **GetModuleFileName** до того, как он получит блокировку P, что гарантирует, что порядок загрузки будет соблюдаться.</span><span class="sxs-lookup"><span data-stu-id="5ec83-180">If the code must call an API such as [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) that can indirectly acquire the loader lock and the code must also acquire a private lock, then the code should call **GetModuleFileName** before it acquires lock P, thus ensuring that load order is respected.</span></span>

<span data-ttu-id="5ec83-181">На рис. 2 показан пример инверсии порядка блокировок.</span><span class="sxs-lookup"><span data-stu-id="5ec83-181">Figure 2 is an example that illustrates lock order inversion.</span></span> <span data-ttu-id="5ec83-182">Рассмотрим библиотеку DLL, основной поток которой содержит [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="5ec83-182">Consider a DLL whose main thread contains [**DllMain**](dllmain.md).</span></span> <span data-ttu-id="5ec83-183">Загрузчик библиотеки получает блокировку загрузчика L, а затем вызывает функцию **DllMain**.</span><span class="sxs-lookup"><span data-stu-id="5ec83-183">The library loader acquires the loader lock L and then calls into **DllMain**.</span></span> <span data-ttu-id="5ec83-184">Главный поток создает объекты синхронизации A, B и G для сериализации доступа к его структурам данных, а затем пытается получить блокировку G. Рабочий поток, который уже успешно получил блокировку G, вызывает функцию, такую как ошибка GetModuleHandle, которая пытается получить блокировку в загрузчике L. Таким словами, Рабочий поток блокируется на L, а главный поток блокируется на G, что приводит к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="5ec83-184">The main thread creates synchronization objects A, B, and G to serialize access to its data structures and then tries to acquire lock G. A worker thread that has already successfully acquired lock G then calls a function such as GetModuleHandle that attempts to acquire the loader lock L. Thus, the worker thread is blocked on L and the main thread is blocked on G, resulting in a deadlock.</span></span>

![взаимоблокировка, вызванная инверсией порядка блокировки](images/fig2.png)

<span data-ttu-id="5ec83-186">Чтобы предотвратить взаимоблокировки, вызванные инверсией порядка блокировки, все потоки должны пытаться получить объекты синхронизации в определенном порядке загрузки.</span><span class="sxs-lookup"><span data-stu-id="5ec83-186">To prevent deadlocks that are caused by lock order inversion, all threads should attempt to acquire synchronization objects in the defined load order at all times.</span></span>

## <a name="best-practices-for-synchronization"></a><span data-ttu-id="5ec83-187">Рекомендации по синхронизации</span><span class="sxs-lookup"><span data-stu-id="5ec83-187">Best Practices for Synchronization</span></span>

<span data-ttu-id="5ec83-188">Рассмотрим библиотеку DLL, которая создает рабочие потоки в рамках своей инициализации.</span><span class="sxs-lookup"><span data-stu-id="5ec83-188">Consider a DLL that creates worker threads as part of its initialization.</span></span> <span data-ttu-id="5ec83-189">При очистке библиотеки DLL необходимо выполнить синхронизацию со всеми рабочими потоками, чтобы обеспечить согласованное состояние структур данных, а затем завершить работу рабочих потоков.</span><span class="sxs-lookup"><span data-stu-id="5ec83-189">Upon DLL cleanup, it is necessary to synchronize with all the worker threads to ensure that the data structures are in a consistent state and then terminate the worker threads.</span></span> <span data-ttu-id="5ec83-190">В настоящее время нет удобного способа полностью решить проблему, связанную с аккуратной синхронизацией и завершением работы библиотек DLL в многопоточной среде.</span><span class="sxs-lookup"><span data-stu-id="5ec83-190">Today, there is no straightforward way to completely solve the problem of cleanly synchronizing and shutting down DLLs in a multithreaded environment.</span></span> <span data-ttu-id="5ec83-191">В этом разделе описаны текущие рекомендации по синхронизации потоков во время завершения работы библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="5ec83-191">This section describes the current best practices for thread synchronizing during DLL shutdown.</span></span>

<span data-ttu-id="5ec83-192">Синхронизация потоков в [**DllMain**](dllmain.md) во время выхода из процесса</span><span class="sxs-lookup"><span data-stu-id="5ec83-192">Thread Synchronization in [**DllMain**](dllmain.md) during Process Exit</span></span>

-   <span data-ttu-id="5ec83-193">При вызове функции [**DllMain**](dllmain.md) во время завершения процесса все потоки процесса были принудительно очищены, и существует вероятность несоответствия адресного пространства.</span><span class="sxs-lookup"><span data-stu-id="5ec83-193">By the time [**DllMain**](dllmain.md) is called at process exit, all the process’s threads have been forcibly cleaned up and there is a chance that the address space is inconsistent.</span></span> <span data-ttu-id="5ec83-194">В этом случае синхронизация не требуется.</span><span class="sxs-lookup"><span data-stu-id="5ec83-194">Synchronization is not required in this case.</span></span> <span data-ttu-id="5ec83-195">Иными словами, идеальный \_ \_ обработчик отсоединения процесса DLL пуст.</span><span class="sxs-lookup"><span data-stu-id="5ec83-195">In other words, the ideal DLL\_PROCESS\_DETACH handler is empty.</span></span>
-   <span data-ttu-id="5ec83-196">Windows Vista гарантирует, что основные структуры данных (переменные среды, текущий каталог, куча процесса и т. д.) находятся в стабильном состоянии.</span><span class="sxs-lookup"><span data-stu-id="5ec83-196">Windows Vista ensures that core data structures (environment variables, current directory, process heap, and so on) are in a consistent state.</span></span> <span data-ttu-id="5ec83-197">Однако другие структуры данных могут быть повреждены, поэтому очистка памяти ненадежна.</span><span class="sxs-lookup"><span data-stu-id="5ec83-197">However, other data structures can be corrupted, so cleaning memory is not safe.</span></span>
-   <span data-ttu-id="5ec83-198">Сохраняемое состояние, которое необходимо сохранить, должно быть записано в постоянное хранилище.</span><span class="sxs-lookup"><span data-stu-id="5ec83-198">Persistent state that needs to be saved must be flushed to permanent storage.</span></span>

<span data-ttu-id="5ec83-199">Синхронизация потоков в **DllMain** для \_ отключения потока DLL \_ во время выгрузки DLL</span><span class="sxs-lookup"><span data-stu-id="5ec83-199">Thread Synchronization in **DllMain** for DLL\_THREAD\_DETACH during DLL Unload</span></span>

-   <span data-ttu-id="5ec83-200">При выгрузке библиотеки DLL адресное пространство не создается.</span><span class="sxs-lookup"><span data-stu-id="5ec83-200">When the DLL is unloaded, the address space is not thrown away.</span></span> <span data-ttu-id="5ec83-201">Поэтому библиотека DLL должна выполнить чистое завершение работы.</span><span class="sxs-lookup"><span data-stu-id="5ec83-201">Therefore, the DLL is expected to perform a clean shutdown.</span></span> <span data-ttu-id="5ec83-202">Это включает синхронизацию потоков, открытые дескрипторы, устойчивое состояние и выделенные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="5ec83-202">This includes thread synchronization, open handles, persistent state, and allocated resources.</span></span>
-   <span data-ttu-id="5ec83-203">Синхронизация потоков является сложной задачей, так как ожидание завершения потоков в [**DllMain**](dllmain.md) может привести к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="5ec83-203">Thread synchronization is tricky because waiting on threads to exit in [**DllMain**](dllmain.md) can cause a deadlock.</span></span> <span data-ttu-id="5ec83-204">Например, DLL A содержит блокировку загрузчика.</span><span class="sxs-lookup"><span data-stu-id="5ec83-204">For example, DLL A holds the loader lock.</span></span> <span data-ttu-id="5ec83-205">Он сигнализирует потоку T выйти и ждет завершения потока.</span><span class="sxs-lookup"><span data-stu-id="5ec83-205">It signals thread T to exit and waits for the thread to exit.</span></span> <span data-ttu-id="5ec83-206">Поток T завершает работу, и загрузчик пытается получить блокировку загрузчика для вызова библиотеки DLL A в **DllMain** с \_ \_ отсоединением потока DLL.</span><span class="sxs-lookup"><span data-stu-id="5ec83-206">Thread T exits and the loader tries to acquire the loader lock to call into DLL A’s **DllMain** with DLL\_THREAD\_DETACH.</span></span> <span data-ttu-id="5ec83-207">Это вызывает взаимоблокировку.</span><span class="sxs-lookup"><span data-stu-id="5ec83-207">This causes a deadlock.</span></span> <span data-ttu-id="5ec83-208">Чтобы снизить риск взаимоблокировки:</span><span class="sxs-lookup"><span data-stu-id="5ec83-208">To minimize the risk of a deadlock:</span></span>
    -   <span data-ttu-id="5ec83-209">DLL A получает \_ \_ сообщение об отсоединении потока DLL в своей [**DllMain**](dllmain.md) и задает событие для потока T, чтобы сообщить ему о выходе.</span><span class="sxs-lookup"><span data-stu-id="5ec83-209">DLL A gets a DLL\_THREAD\_DETACH message in its [**DllMain**](dllmain.md) and sets an event for thread T, signaling it to exit.</span></span>
    -   <span data-ttu-id="5ec83-210">Поток T завершает свою текущую задачу, переводит себя в целостное состояние, передает DLL A и ожидает бесконечно.</span><span class="sxs-lookup"><span data-stu-id="5ec83-210">Thread T finishes its current task, brings itself to a consistent state, signals DLL A, and waits infinitely.</span></span> <span data-ttu-id="5ec83-211">Обратите внимание, что подпрограммы проверки согласованности должны следовать тем же ограничениям, что и функция [**DllMain**](dllmain.md) , чтобы избежать взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="5ec83-211">Note that the consistency-checking routines should follow the same restrictions as [**DllMain**](dllmain.md) to avoid deadlocking.</span></span>
    -   <span data-ttu-id="5ec83-212">DLL A завершает T, зная, что она находится в стабильном состоянии.</span><span class="sxs-lookup"><span data-stu-id="5ec83-212">DLL A terminates T, knowing that it is in a consistent state.</span></span>

<span data-ttu-id="5ec83-213">Если библиотека DLL выгружается после создания всех ее потоков, но до начала выполнения, потоки могут завершиться со сбоем.</span><span class="sxs-lookup"><span data-stu-id="5ec83-213">If a DLL is unloaded after all its threads have been created, but before they begin executing, the threads may crash.</span></span> <span data-ttu-id="5ec83-214">Если библиотека DLL создала потоки в своей **DllMain** как часть инициализации, некоторые потоки могли не завершить инициализацию, а сообщение о \_ ПРИСОЕДИНЕНИИ потока библиотеки DLL \_ все еще ожидает доставки в библиотеку DLL.</span><span class="sxs-lookup"><span data-stu-id="5ec83-214">If the DLL created threads in its **DllMain** as part of its initialization, some threads may not have finished initialization and their DLL\_THREAD\_ATTACH message is still waiting to be delivered to the DLL.</span></span> <span data-ttu-id="5ec83-215">В этом случае, если библиотека DLL выгружена, она начнет завершать потоки.</span><span class="sxs-lookup"><span data-stu-id="5ec83-215">In this situation, if the DLL is unloaded, it will begin terminating threads.</span></span> <span data-ttu-id="5ec83-216">Однако некоторые потоки могут блокироваться за блокировкой загрузчика.</span><span class="sxs-lookup"><span data-stu-id="5ec83-216">However, some threads may be blocked behind the loader lock.</span></span> <span data-ttu-id="5ec83-217">\_ \_ Сообщения, присоединенные к ПОТОКу DLL, обрабатываются после того, как библиотека DLL не сопоставлена, что приводит к сбою процесса.</span><span class="sxs-lookup"><span data-stu-id="5ec83-217">Their DLL\_THREAD\_ATTACH messages are processed after the DLL has been unmapped, causing the process to crash.</span></span>

## <a name="recommendations"></a><span data-ttu-id="5ec83-218">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="5ec83-218">Recommendations</span></span>

<span data-ttu-id="5ec83-219">Ниже приведены рекомендуемые рекомендации.</span><span class="sxs-lookup"><span data-stu-id="5ec83-219">The following are recommended guidelines:</span></span>

-   <span data-ttu-id="5ec83-220">Используйте средство проверки приложений для перехвата наиболее распространенных ошибок в [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="5ec83-220">Use Application Verifier to catch the most common errors in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="5ec83-221">При использовании закрытой блокировки в [**DllMain**](dllmain.md)Определите иерархию блокировки и используйте ее постоянно.</span><span class="sxs-lookup"><span data-stu-id="5ec83-221">If using a private lock inside [**DllMain**](dllmain.md), define a locking hierarchy and use it consistently.</span></span> <span data-ttu-id="5ec83-222">Блокировка загрузчика должна находиться в нижней части этой иерархии.</span><span class="sxs-lookup"><span data-stu-id="5ec83-222">The loader lock must be at the bottom of this hierarchy.</span></span>
-   <span data-ttu-id="5ec83-223">Убедитесь, что никакие вызовы не зависят от другой библиотеки DLL, которая, возможно, еще не была полностью загружена.</span><span class="sxs-lookup"><span data-stu-id="5ec83-223">Verify that no calls depend on another DLL that may not have been fully loaded yet.</span></span>
-   <span data-ttu-id="5ec83-224">Выполнять простые инициализации статически во время компиляции, а не в [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="5ec83-224">Perform simple initializations statically at compile time, rather than in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="5ec83-225">Отложите все вызовы функции [**DllMain**](dllmain.md) , которые могут ожидать позже.</span><span class="sxs-lookup"><span data-stu-id="5ec83-225">Defer any calls in [**DllMain**](dllmain.md) that can wait until later.</span></span>
-   <span data-ttu-id="5ec83-226">Откладывание задач инициализации, которые могут дожидаться позже.</span><span class="sxs-lookup"><span data-stu-id="5ec83-226">Defer initialization tasks that can wait until later.</span></span> <span data-ttu-id="5ec83-227">Некоторые условия ошибок должны обнаруживаться на раннем этапе, чтобы приложение могла корректно обрабатывать ошибки.</span><span class="sxs-lookup"><span data-stu-id="5ec83-227">Certain error conditions must be detected early so that the application can handle errors gracefully.</span></span> <span data-ttu-id="5ec83-228">Однако существуют компромиссы между этим ранним выявлением и потерей надежности, которая может возникнуть в результате.</span><span class="sxs-lookup"><span data-stu-id="5ec83-228">However, there are tradeoffs between this early detection and the loss of robustness that can result from it.</span></span> <span data-ttu-id="5ec83-229">Обычно рекомендуется отложить инициализацию.</span><span class="sxs-lookup"><span data-stu-id="5ec83-229">Deferring initialization is often best.</span></span>

 

 
