---
title: Процедуры завершения HTTP
description: Приложения имеют несколько параметров для получения обработок завершения и предоставления некоторой гибкости для разработчиков.
ms.assetid: c48a64d2-b6c8-4694-8600-f84751954bad
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8aee05efc8284cb29130efae4bcaefb4834a3fb4
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2020
ms.locfileid: "103987494"
---
# <a name="http-completion-routines"></a><span data-ttu-id="491e5-103">Процедуры завершения HTTP</span><span class="sxs-lookup"><span data-stu-id="491e5-103">HTTP Completion Routines</span></span>

<span data-ttu-id="491e5-104">Приложения имеют несколько параметров для получения обработок завершения и предоставления некоторой гибкости для разработчиков.</span><span class="sxs-lookup"><span data-stu-id="491e5-104">Applications have several options for receiving completion indications and providing some flexibility for developers.</span></span> <span data-ttu-id="491e5-105">Параметры заблокируются при ожидании завершения вызова API или использования подпрограмм завершения для асинхронных операций.</span><span class="sxs-lookup"><span data-stu-id="491e5-105">The options are to block while waiting for an API call to complete or to use completion routines for asynchronous operations.</span></span> <span data-ttu-id="491e5-106">Преимущество использования асинхронных операций заключается в увеличении скорости реагирования приложения.</span><span class="sxs-lookup"><span data-stu-id="491e5-106">The advantage of using asynchronous operations is an increase in responsiveness of the application.</span></span>

## <a name="blocked-io"></a><span data-ttu-id="491e5-107">Заблокированные операции ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="491e5-107">Blocked I/O</span></span>

<span data-ttu-id="491e5-108">Приложения могут блокироваться при ожидании завершения вызова API путем присвоения структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) **значения NULL**.</span><span class="sxs-lookup"><span data-stu-id="491e5-108">Applications can block while waiting for the API call to complete by setting the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure to **NULL**.</span></span> <span data-ttu-id="491e5-109">Это действительно блокирует все операции в потоке.</span><span class="sxs-lookup"><span data-stu-id="491e5-109">This truly blocks all operations on the thread.</span></span> <span data-ttu-id="491e5-110">Например, при вызове [**хттпваитфордисконнект**](/windows/desktop/api/Http/nf-http-httpwaitfordisconnect)вызов блокируется до тех пор, пока соединение не будет разорвано.</span><span class="sxs-lookup"><span data-stu-id="491e5-110">For example, in calls to [**HttpWaitForDisconnect**](/windows/desktop/api/Http/nf-http-httpwaitfordisconnect), the call blocks until the connection is broken.</span></span>

## <a name="asynchronous-io"></a><span data-ttu-id="491e5-111">Асинхронный ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="491e5-111">Asynchronous I/O</span></span>

<span data-ttu-id="491e5-112">Приложения, которые предпочитают не блокировать блокировку, могут использовать [**перекрывающиеся**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) структуры для получения результатов выполнения.</span><span class="sxs-lookup"><span data-stu-id="491e5-112">Applications that prefer not to block can use the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure to obtain the completion results.</span></span> <span data-ttu-id="491e5-113">Приложение предоставляет указатель на структуру **OVERLAPPED** , которая используется с объектом события или портом завершения.</span><span class="sxs-lookup"><span data-stu-id="491e5-113">The application supplies a pointer to an **OVERLAPPED** structure, which is used with an event object or a completion port.</span></span> <span data-ttu-id="491e5-114">При использовании порта завершения ввода-вывода в качестве файла используется обработчик HTTP, который будет находиться в асинхронной операции файлового ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="491e5-114">With an I/O completion port, an HTTP handle is used as a file handle would be in an asynchronous file I/O operation.</span></span> <span data-ttu-id="491e5-115">В следующей таблице перечислены параметры завершения, доступные для приложений.</span><span class="sxs-lookup"><span data-stu-id="491e5-115">The following table summarizes the completion options available to the applications.</span></span>



| <span data-ttu-id="491e5-116">Перекрывающаяся структура</span><span class="sxs-lookup"><span data-stu-id="491e5-116">Overlapped structure</span></span> | <span data-ttu-id="491e5-117">Объект события</span><span class="sxs-lookup"><span data-stu-id="491e5-117">Event object</span></span>   | <span data-ttu-id="491e5-118">Порт завершения</span><span class="sxs-lookup"><span data-stu-id="491e5-118">Completion port</span></span> | <span data-ttu-id="491e5-119">Completion</span><span class="sxs-lookup"><span data-stu-id="491e5-119">Completion</span></span>                                                                                                   |
|----------------------|----------------|-----------------|--------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="491e5-120">**NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-120">**NULL**</span></span>             | <span data-ttu-id="491e5-121">Не применимо</span><span class="sxs-lookup"><span data-stu-id="491e5-121">Not Applicable</span></span> | <span data-ttu-id="491e5-122">Не учитывается</span><span class="sxs-lookup"><span data-stu-id="491e5-122">Ignored</span></span>         | <span data-ttu-id="491e5-123">Операция завершается синхронно.</span><span class="sxs-lookup"><span data-stu-id="491e5-123">Operation completes synchronously.</span></span>                                                                           |
| <span data-ttu-id="491e5-124">Не **равно NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-124">Non-**NULL**</span></span>         | <span data-ttu-id="491e5-125">Не **равно NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-125">Non-**NULL**</span></span>   | <span data-ttu-id="491e5-126">**NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-126">**NULL**</span></span>        | <span data-ttu-id="491e5-127">Операция завершается асинхронно.</span><span class="sxs-lookup"><span data-stu-id="491e5-127">Operation completes asynchronously.</span></span> <span data-ttu-id="491e5-128">Перекрывающиеся уведомления выполняются с помощью сигнализации объекта события.</span><span class="sxs-lookup"><span data-stu-id="491e5-128">Overlapped notification is performed by signaling an event object.</span></span>       |
| <span data-ttu-id="491e5-129">Не **равно NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-129">Non-**NULL**</span></span>         | <span data-ttu-id="491e5-130">Не учитывается</span><span class="sxs-lookup"><span data-stu-id="491e5-130">Ignored</span></span>        | <span data-ttu-id="491e5-131">Не **равно NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-131">Non-**NULL**</span></span>    | <span data-ttu-id="491e5-132">Операция завершается асинхронно.</span><span class="sxs-lookup"><span data-stu-id="491e5-132">Operation completes asynchronously.</span></span> <span data-ttu-id="491e5-133">Перекрывающиеся уведомления выполняются путем планирования процедуры завершения.</span><span class="sxs-lookup"><span data-stu-id="491e5-133">Overlapped notification is performed by scheduling a completion routine.</span></span> |



 

## <a name="returning-the-number-of-bytes-read"></a><span data-ttu-id="491e5-134">Возвращение числа считанных байтов</span><span class="sxs-lookup"><span data-stu-id="491e5-134">Returning the Number of Bytes Read</span></span>

<span data-ttu-id="491e5-135">Некоторые функции, использующие [**перекрывающиеся**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) структуры для асинхронного завершения, возвращают параметр *Пбитесрецеивед* (или *пбитессент* или *пбитесреад*), который указывает число байтов, передаваемых синхронно.</span><span class="sxs-lookup"><span data-stu-id="491e5-135">Some of the functions that use the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure for asynchronous completion return a *pBytesReceived* (or *pBytesSent* or *pBytesRead*) parameter that indicates the number of bytes transferred synchronously.</span></span> <span data-ttu-id="491e5-136">Для асинхронных вызовов этот параметр должен иметь значение **null**.</span><span class="sxs-lookup"><span data-stu-id="491e5-136">For asynchronous calls, this parameter should be set to **NULL**.</span></span> <span data-ttu-id="491e5-137">Для синхронных вызовов параметр *пбитесрецеивед* является необязательным и может иметь **значение NULL** или не иметь **значение NULL**.</span><span class="sxs-lookup"><span data-stu-id="491e5-137">For synchronous calls, the *pBytesReceived* parameter is optional and can be either **NULL** or non-**NULL**.</span></span>

<span data-ttu-id="491e5-138">Если объект события используется для асинхронного завершения, вызывается функция [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) для определения числа считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="491e5-138">If the event object is used for asynchronous completion, the [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) function is called to determine the number of bytes read.</span></span> <span data-ttu-id="491e5-139">Если используется порт завершения (параметр *hFile* связан с портом завершения ввода-вывода), приложение вызывает функцию [**жеткуеуедкомплетионстатус**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) для определения числа считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="491e5-139">If the completion port is used (the *hFile* parameter is associated with an I/O completion port), the application calls the [**GetQueuedCompletionStatus**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function to determine the number of bytes read.</span></span> <span data-ttu-id="491e5-140">Если асинхронные операции не завершены, приложения могут вызывать функцию [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) для получения расширенных сведений об ошибке.</span><span class="sxs-lookup"><span data-stu-id="491e5-140">If the asynchronous operations have not completed, applications can call the [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) function to obtain extended error information.</span></span>

<span data-ttu-id="491e5-141">В следующей таблице перечислены действия по завершению синхронного и асинхронного завершения в таких функциях, как [**хттпрецеивехттпрекуест**](/windows/desktop/api/Http/nf-http-httpreceivehttprequest) , использующих параметр *пбитесрецеивед* .</span><span class="sxs-lookup"><span data-stu-id="491e5-141">The following table summarizes the completion behavior for synchronous and asynchronous completion in functions such as [**HttpReceiveHttpRequest**](/windows/desktop/api/Http/nf-http-httpreceivehttprequest) that use the *pBytesReceived* parameter.</span></span>



| <span data-ttu-id="491e5-142">пбитесрецеивед\*</span><span class="sxs-lookup"><span data-stu-id="491e5-142">pBytesReceived\*</span></span> | <span data-ttu-id="491e5-143">поверлаппед</span><span class="sxs-lookup"><span data-stu-id="491e5-143">pOverlapped</span></span>  | <span data-ttu-id="491e5-144">Описание</span><span class="sxs-lookup"><span data-stu-id="491e5-144">Description</span></span>                                                                             |
|------------------|--------------|-----------------------------------------------------------------------------------------|
| <span data-ttu-id="491e5-145">**NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-145">**NULL**</span></span>         | <span data-ttu-id="491e5-146">**NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-146">**NULL**</span></span>     | <span data-ttu-id="491e5-147">Приложение не получает сведения о количестве возвращенных байт.</span><span class="sxs-lookup"><span data-stu-id="491e5-147">The application does not receive information on the number of bytes returned.</span></span>           |
| <span data-ttu-id="491e5-148">**NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-148">**NULL**</span></span>         | <span data-ttu-id="491e5-149">Не **равно NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-149">Non-**NULL**</span></span> | <span data-ttu-id="491e5-150">Асинхронная операция, *пбитесрецеивед* не имеет смысла.</span><span class="sxs-lookup"><span data-stu-id="491e5-150">Asynchronous operation, *pBytesReceived* is meaningless.</span></span>                                |
| <span data-ttu-id="491e5-151">Не **равно NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-151">Non-**NULL**</span></span>     | <span data-ttu-id="491e5-152">**NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-152">**NULL**</span></span>     | <span data-ttu-id="491e5-153">Синхронная операция, число байтов, возвращенных в *пбитесрецеивед*.</span><span class="sxs-lookup"><span data-stu-id="491e5-153">Synchronous operation, number of bytes returned in *pBytesReceived*.</span></span>                    |
| <span data-ttu-id="491e5-154">Не **равно NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-154">Non-**NULL**</span></span>     | <span data-ttu-id="491e5-155">Не **равно NULL**</span><span class="sxs-lookup"><span data-stu-id="491e5-155">Non-**NULL**</span></span> | <span data-ttu-id="491e5-156">Асинхронная операция, *пбитесрецеивед* игнорируется, даже если это **значение не равно NULL**.\*\*</span><span class="sxs-lookup"><span data-stu-id="491e5-156">Asynchronous operation, *pBytesReceived* is ignored even though it is not **NULL**.\*\*</span></span> |



 

> [!Note]  
> <span data-ttu-id="491e5-157">\*Этот параметр также может быть *пбитессент* или *пбитесреад*.</span><span class="sxs-lookup"><span data-stu-id="491e5-157">\*This parameter can also be *pBytesSent* or *pBytesRead*.</span></span>

 

> [!Note]  
> <span data-ttu-id="491e5-158">\*\*Рекомендуется, чтобы приложения передавали **значение NULL** в *пбитесрецеивед* для асинхронных операций и получали число байтов, полученных из [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) или [**жеткуеуедкомплетионстатус**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus).</span><span class="sxs-lookup"><span data-stu-id="491e5-158">\*\*It is recommended that applications pass a **NULL** in *pBytesReceived* for asynchronous operations and obtain the number of bytes received from either [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) or [**GetQueuedCompletionStatus**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus).</span></span>

 

## <a name="return-codes"></a><span data-ttu-id="491e5-159">Коды возврата</span><span class="sxs-lookup"><span data-stu-id="491e5-159">Return Codes</span></span>

<span data-ttu-id="491e5-160">API сервера HTTP возвращает три класса кодов для асинхронных вызовов функций.</span><span class="sxs-lookup"><span data-stu-id="491e5-160">The HTTP Server API returns three classes of codes for asynchronous function calls.</span></span>

-   <span data-ttu-id="491e5-161">БЕЗ \_ ошибок</span><span class="sxs-lookup"><span data-stu-id="491e5-161">NO\_ERROR</span></span>
-   <span data-ttu-id="491e5-162">\_Ожидание ввода-вывода при ошибке \_</span><span class="sxs-lookup"><span data-stu-id="491e5-162">ERROR\_IO\_PENDING</span></span>
-   <span data-ttu-id="491e5-163">Любой другой [код системной ошибки](/windows/desktop/Debug/system-error-codes).</span><span class="sxs-lookup"><span data-stu-id="491e5-163">Any other [system error code](/windows/desktop/Debug/system-error-codes).</span></span>

<span data-ttu-id="491e5-164">Если при \_ \_ асинхронном вызове функции не возвращаются сообщения об ошибках ввода-вывода или нет \_ ошибок, то пользователи должны предполагать, что для события или процедуры завершения выдается сигнал.</span><span class="sxs-lookup"><span data-stu-id="491e5-164">When ERROR\_IO\_PENDING or NO\_ERROR are returned from the asynchronous function call, users should expect the event or completion routine to be signaled.</span></span> <span data-ttu-id="491e5-165">Вызов функции [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) для события или функции [**жеткуеуедкомплетионстатус**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) для порта завершения возвращает состояние завершения.</span><span class="sxs-lookup"><span data-stu-id="491e5-165">Calling the [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) function for the event or the [**GetQueuedCompletionStatus**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function for the completion port returns the completion status.</span></span> <span data-ttu-id="491e5-166">Кроме того, если \_ ошибка не возвращается, приложения могут выполнять последующей обработку в том же потоке, который выполнил вызов API.</span><span class="sxs-lookup"><span data-stu-id="491e5-166">In addition, if NO\_ERROR is returned, applications can perform post-processing on the same thread that made the API call.</span></span>

<span data-ttu-id="491e5-167">Если API сервера HTTP возвращает любые данные, отличные от ошибок \_ ввода-вывода с ошибками \_ или без \_ ошибок, из вызова асинхронной функции, подпрограмма завершения не получает сигнал, а ошибка возвращается непосредственно API.</span><span class="sxs-lookup"><span data-stu-id="491e5-167">If the HTTP Server API returns anything other than ERROR\_IO\_PENDING or NO\_ERROR, from the asynchronous function call, the completion routine is not signaled, and the error is directly returned by the API.</span></span>

 

 