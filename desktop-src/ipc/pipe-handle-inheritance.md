---
description: Сервер канала управляет возможностью наследования дескрипторов следующими способами.
ms.assetid: 72302f8b-f3a2-4efc-aab1-e596b8323984
title: Наследование обработчика канала
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 21cf91d4393b43011a2df632806f96da1e713b96
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "103808404"
---
# <a name="pipe-handle-inheritance"></a><span data-ttu-id="7d0ea-103">Наследование обработчика канала</span><span class="sxs-lookup"><span data-stu-id="7d0ea-103">Pipe Handle Inheritance</span></span>

<span data-ttu-id="7d0ea-104">Сервер канала управляет возможностью наследования дескрипторов следующими способами.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-104">The pipe server controls whether its handles can be inherited in the following ways:</span></span>

-   <span data-ttu-id="7d0ea-105">Функция [**креатепипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe) Получает структуру [**\_ атрибутов безопасности**](/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)) .</span><span class="sxs-lookup"><span data-stu-id="7d0ea-105">The [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe) function receives a [**SECURITY\_ATTRIBUTES**](/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)) structure.</span></span> <span data-ttu-id="7d0ea-106">Если сервер канала устанавливает для элемента **бинхерисандле** этой структуры **значение true**, дескрипторы, созданные **креатепипе** , могут быть унаследованы.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-106">If the pipe server sets the **bInheritHandle** member of this structure to **TRUE**, the handles created by **CreatePipe** can be inherited.</span></span>
-   <span data-ttu-id="7d0ea-107">Сервер канала может использовать функцию [**дупликатехандле**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) для изменения наследования обработчика канала.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-107">The pipe server can use the [**DuplicateHandle**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) function to change the inheritance of a pipe handle.</span></span> <span data-ttu-id="7d0ea-108">Сервер канала может создать наследуемый дубликат маркера наследуемого канала или наследуемого дубликата ненаследованного обработчика канала.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-108">The pipe server can create a noninheritable duplicate of an inheritable pipe handle or an inheritable duplicate of a noninheritable pipe handle.</span></span>
-   <span data-ttu-id="7d0ea-109">Функция [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) позволяет серверу канала указать, наследует ли дочерний процесс все его наследуемые дескрипторы или нет.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-109">The [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) function enables the pipe server to specify whether a child process inherits all or none of its inheritable handles.</span></span>

<span data-ttu-id="7d0ea-110">Когда дочерний процесс наследует маркер канала, система предоставляет процессу доступ к каналу.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-110">When a child process inherits a pipe handle, the system enables the process to access the pipe.</span></span> <span data-ttu-id="7d0ea-111">Однако родительский процесс должен передавать значение обработчика дочернему процессу.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-111">However, the parent process must communicate the handle value to the child process.</span></span> <span data-ttu-id="7d0ea-112">Родительский процесс обычно делает это путем перенаправления стандартного выходного маркера в дочерний процесс, как показано в следующих шагах:</span><span class="sxs-lookup"><span data-stu-id="7d0ea-112">The parent process typically does this by redirecting the standard output handle to the child process, as shown in the following steps:</span></span>

1.  <span data-ttu-id="7d0ea-113">Вызовите функцию [**жетстдхандле**](/windows/console/getstdhandle) для получения текущего стандартного выходного маркера. Сохраните этот обработчик, чтобы восстановить исходный стандартный выходной обработчик после создания дочернего процесса.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-113">Call the [**GetStdHandle**](/windows/console/getstdhandle) function to get the current standard output handle; save this handle so you can restore the original standard output handle after the child process has been created.</span></span>
2.  <span data-ttu-id="7d0ea-114">Вызовите функцию [**сетстдхандле**](/windows/console/setstdhandle) , чтобы задать стандартный выходной маркер для маркера записи в канал.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-114">Call the [**SetStdHandle**](/windows/console/setstdhandle) function to set the standard output handle to the write handle to the pipe.</span></span> <span data-ttu-id="7d0ea-115">Теперь родительский процесс может создать дочерний процесс.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-115">Now the parent process can create the child process.</span></span>
3.  <span data-ttu-id="7d0ea-116">Вызовите функцию [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) , чтобы закрыть маркер записи в канал.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-116">Call the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function to close the write handle to the pipe.</span></span> <span data-ttu-id="7d0ea-117">После того как дочерний процесс наследует маркер записи, родительский процесс больше не нуждается в его копии.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-117">After the child process inherits the write handle, the parent process no longer needs its copy.</span></span>
4.  <span data-ttu-id="7d0ea-118">Вызовите [**сетстдхандле**](/windows/console/setstdhandle) для восстановления исходного стандартного выходного маркера.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-118">Call [**SetStdHandle**](/windows/console/setstdhandle) to restore the original standard output handle.</span></span>

<span data-ttu-id="7d0ea-119">Дочерний процесс использует функцию [**жетстдхандле**](/windows/console/getstdhandle) для получения стандартного выходного маркера, который теперь является обработчиком для конца записи канала.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-119">The child process uses the [**GetStdHandle**](/windows/console/getstdhandle) function to get its standard output handle, which is now a handle to the write end of a pipe.</span></span> <span data-ttu-id="7d0ea-120">Затем дочерний процесс использует функцию [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) для отправки выходных данных в канал.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-120">The child process then uses the [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) function to send its output to the pipe.</span></span> <span data-ttu-id="7d0ea-121">Когда дочерний элемент завершает работу с каналом, он должен закрыть обработчик, вызвав [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) или заканчивающийся, который автоматически закрывает этот обработчик.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-121">When the child has finished with the pipe, it should close the pipe handle by calling [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) or by terminating, which automatically closes the handle.</span></span>

<span data-ttu-id="7d0ea-122">Родительский процесс использует функцию [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) для получения входных данных из канала.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-122">The parent process uses the [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) function to receive input from the pipe.</span></span> <span data-ttu-id="7d0ea-123">Данные записываются в анонимный канал в виде потока байтов.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-123">Data is written to an anonymous pipe as a stream of bytes.</span></span> <span data-ttu-id="7d0ea-124">Это означает, что родительский процесс, считывающий из канала, не может различить байты, записанные в отдельных операциях записи, если только родительский и дочерний процессы не используют протокол для указания места завершения операции записи.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-124">This means that the parent process reading from a pipe cannot distinguish between the bytes written in separate write operations, unless both the parent and child processes use a protocol to indicate where the write operation ends.</span></span> <span data-ttu-id="7d0ea-125">Когда все дескрипторы записи в канал закрываются, функция **ReadFile** возвращает ноль.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-125">When all write handles to the pipe are closed, the **ReadFile** function returns zero.</span></span> <span data-ttu-id="7d0ea-126">Важно, чтобы родительский процесс закрыл свой обработчик до конца записи канала перед вызовом **ReadFile**.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-126">It is important for the parent process to close its handle to the write end of the pipe before calling **ReadFile**.</span></span> <span data-ttu-id="7d0ea-127">Если это не сделано, операция **ReadFile** не может вернуть нуль, так как родительский процесс имеет открытый обработчик для конца записи канала.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-127">If this is not done, the **ReadFile** operation cannot return zero because the parent process has an open handle to the write end of the pipe.</span></span>

<span data-ttu-id="7d0ea-128">Процедура перенаправления стандартного входного маркера аналогична процедуре перенаправления стандартного выходного маркера, за исключением того, что в качестве стандартного маркера ввода дочернего элемента используется маркер чтения канала.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-128">The procedure for redirecting the standard input handle is similar to that for redirecting the standard output handle, except that the pipe's read handle is used as the child's standard input handle.</span></span> <span data-ttu-id="7d0ea-129">В этом случае родительский процесс должен гарантировать, что дочерний процесс не наследует маркер записи.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-129">In this case, the parent process must ensure that the child process does not inherit the pipe's write handle.</span></span> <span data-ttu-id="7d0ea-130">Если это не сделано, операция [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) , выполняемая дочерним процессом, не может вернуть нуль, так как дочерний процесс имеет открытый обработчик для конца записи канала.</span><span class="sxs-lookup"><span data-stu-id="7d0ea-130">If this is not done, the [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) operation performed by the child process cannot return zero because the child process has an open handle to the write end of the pipe.</span></span>

<span data-ttu-id="7d0ea-131">Пример программы, использующей анонимные каналы для перенаправления стандартных дескрипторов дочернего процесса, см. в разделе [Создание дочернего процесса с перенаправленным входом и выходом](/windows/desktop/ProcThread/creating-a-child-process-with-redirected-input-and-output).</span><span class="sxs-lookup"><span data-stu-id="7d0ea-131">For an example program that uses anonymous pipes to redirect the standard handles of a child process, see [Creating a Child Process with Redirected Input and Output](/windows/desktop/ProcThread/creating-a-child-process-with-redirected-input-and-output).</span></span>

 

 
