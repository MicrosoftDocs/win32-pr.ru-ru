---
description: Синхронный ввод-вывод и асинхронный конвейерный ввод-вывод. Функции ReadFile, WriteFile, Трансактнамедпипе и Коннектнамедпипе могут выполнять операции ввода и вывода в канале синхронно или асинхронно.
ms.assetid: 5ab9bb7f-1f99-4041-bba8-2863f34dbcaf
title: Синхронный и перекрытый конвейерный ввод-вывод
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3becfb19dfe5fa49d4121246a576fb3200226b1a
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105693615"
---
# <a name="synchronous-and-overlapped-pipe-io"></a>Синхронный и перекрытый конвейерный ввод-вывод

Функции [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**трансактнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)и [**коннектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) могут выполнять операции ввода и вывода в канале синхронно или асинхронно. Если функция выполняется синхронно, она не возвращает значение до завершения выполняемой операции. Это означает, что выполнение вызывающего потока может быть заблокировано в течение неопределенного периода времени, пока оно ожидает завершения длительной операции. Когда функция выполняется асинхронно, она возвращается немедленно, даже если операция не была завершена. Это позволяет выполнять трудоемкую операцию в фоновом режиме, в то время как вызывающий поток может выполнять другие задачи.

Использование асинхронного ввода-вывода позволяет серверу канала использовать цикл, который выполняет следующие действия:

1.  Укажите несколько объектов событий в вызове функции Wait и дождитесь, пока одно из объектов не будет установлено в сигнальное состояние.
2.  Используйте возвращаемое значение функции Wait, чтобы определить, какая операция перекрытия завершена.
3.  Выполните задачи, необходимые для очистки завершенной операции, и инициируйте следующую операцию для этого обработчика канала. Это может привести к запуску другой операции перекрытия для одного и того же обработчика канала.

Перекрывающиеся операции позволяют одному каналу одновременно считывать и записывать данные, а в одном потоке выполнять одновременные операции ввода-вывода с несколькими дескрипторами каналов. Это позволяет однопотоковому серверу каналов эффективно работать с несколькими клиентами канала. Пример см. в разделе [сервер именованных каналов с перекрытием операций ввода-вывода](named-pipe-server-using-overlapped-i-o.md).

Чтобы сервер канала мог использовать синхронные операции для взаимодействия с несколькими клиентами, он должен создать отдельный поток для каждого клиента канала, чтобы один или несколько потоков могли выполняться в ожидании других потоков. Пример многопотокового сервера каналов, использующего синхронные операции, см. в разделе [многопотоковый сервер каналов](multithreaded-pipe-server.md).

## <a name="enabling-asynchronous-operation"></a>Включение асинхронной операции

Функции [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**трансактнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)и [**коннектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) могут выполняться асинхронно, только если включен режим перекрытия для указанного обработчика канала и указан допустимый указатель на структуру [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) . Если **перекрытый** указатель имеет **значение NULL**, возвращаемое значение функции может неправильно указывать на завершение операции. Поэтому настоятельно рекомендуется, чтобы при создании маркера с \_ \_ перекрытием флага файла и необходимости асинхронного поведения всегда задается допустимая структура **OVERLAPPED** .

Элемент **Хевент** указанной [**перекрывающейся**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) структуры должен содержать маркер для объекта события ручного сброса. Это объект синхронизации, созданный функцией [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa) . Поток, инициирующий операцию перекрытия, использует объект события для определения момента завершения операции. Не следует использовать дескриптор канала для синхронизации при выполнении одновременных операций с одним и тем же дескриптором, поскольку не существует способа узнать, какое завершение операции привело к сигналу дескриптора канала. Единственным надежным способом выполнения одновременных операций с одним и тем же обработчиком канала является использование отдельной **ПЕРЕкрывающейся** структуры с собственным объектом события для каждой операции. Дополнительные сведения об объектах событий см. в разделе [Синхронизация](/windows/desktop/Sync/synchronization).

Кроме того, можно получать уведомления о завершении операции перекрытия с помощью функций [**жеткуеуедкомплетионстатус**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) или [**жеткуеуедкомплетионстатусекс**](/windows/desktop/FileIO/getqueuedcompletionstatusex-func) . В этом случае вам не нужно назначать событие ручного сброса в структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) , и завершение происходит с обработчиком канала так же, как асинхронная операция чтения или записи. Дополнительные сведения см. в разделе [порты завершения ввода-вывода](/windows/desktop/FileIO/i-o-completion-ports).

Если операции [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**трансактнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)и [**коннектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) выполняются асинхронно, происходит одно из следующих событий.

-   Если операция завершается после возвращения функции, возвращаемое значение указывает на успешное или неуспешное выполнение операции. При возникновении ошибки возвращаемое значение равно нулю, а функция [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) возвращает нечто, отличное от "ошибка \_ ввода-вывода" \_ .
-   Если операция не была завершена при возврате функции, возвращаемое значение равно нулю, а [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) возвращает сообщение об ошибке \_ ввода-вывода \_ в ожидании. В этом случае вызывающий поток должен дождаться завершения операции. Чтобы определить результаты, вызывающий поток должен вызвать функцию [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) .

## <a name="using-completion-routines"></a>Использование подпрограмм завершения

Функции [**реадфиликс**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) и [**вритефиликс**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) предоставляют другую форму перекрывающихся операций ввода-вывода. В отличие от перекрывающихся функций [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) и [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) , использующих объект события для оповещения о завершении, расширенные функции задают *подпрограммы завершения*. Подпрограммы завершения — это функция, которая находится в очереди на выполнение после завершения операции чтения или записи. Подсистема завершения не выполняется до тех пор, пока поток, который вызвал **реадфиликс** и **вритефиликс** , не начнет асинхронную *операцию ожидания* , вызвав одну из [функций ожидания с оповещением](/windows/desktop/Sync/wait-functions) с параметром *фалертабле* , установленным в **значение true**. В операции ожидания с оповещением функции также возвращают, когда подсистема завершения **реадфиликс** или **вритефиликс** помещается в очередь на выполнение. Сервер канала может использовать расширенные функции для выполнения последовательности операций чтения и записи для каждого клиента, который подключается к нему. Каждая операция чтения или записи в последовательности указывает подпрограммы завершения, и каждая подпрограмма завершения инициирует следующий шаг в последовательности. Пример см. в разделе [сервер именованных каналов с помощью подпрограмм завершения](named-pipe-server-using-completion-routines.md).

 

 
