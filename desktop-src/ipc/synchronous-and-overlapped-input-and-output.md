---
description: Синхронный ввод-вывод и асинхронный конвейерный ввод-вывод. Функции ReadFile, WriteFile, Трансактнамедпипе и Коннектнамедпипе могут выполнять операции ввода и вывода в канале синхронно или асинхронно.
ms.assetid: 5ab9bb7f-1f99-4041-bba8-2863f34dbcaf
title: Синхронный и перекрытый конвейерный ввод-вывод
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3becfb19dfe5fa49d4121246a576fb3200226b1a
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105693615"
---
# <a name="synchronous-and-overlapped-pipe-io"></a><span data-ttu-id="2fd10-104">Синхронный и перекрытый конвейерный ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2fd10-104">Synchronous and Overlapped Pipe I/O</span></span>

<span data-ttu-id="2fd10-105">Функции [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**трансактнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)и [**коннектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) могут выполнять операции ввода и вывода в канале синхронно или асинхронно.</span><span class="sxs-lookup"><span data-stu-id="2fd10-105">The [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe), and [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) functions can perform input and output operations on a pipe either synchronously or asynchronously.</span></span> <span data-ttu-id="2fd10-106">Если функция выполняется синхронно, она не возвращает значение до завершения выполняемой операции.</span><span class="sxs-lookup"><span data-stu-id="2fd10-106">When a function runs synchronously, it does not return until the operation it is performing is completed.</span></span> <span data-ttu-id="2fd10-107">Это означает, что выполнение вызывающего потока может быть заблокировано в течение неопределенного периода времени, пока оно ожидает завершения длительной операции.</span><span class="sxs-lookup"><span data-stu-id="2fd10-107">This means that the execution of the calling thread can be blocked for an indefinite period while it waits for a time-consuming operation to be completed.</span></span> <span data-ttu-id="2fd10-108">Когда функция выполняется асинхронно, она возвращается немедленно, даже если операция не была завершена.</span><span class="sxs-lookup"><span data-stu-id="2fd10-108">When a function runs asynchronously, it returns immediately, even if the operation has not been completed.</span></span> <span data-ttu-id="2fd10-109">Это позволяет выполнять трудоемкую операцию в фоновом режиме, в то время как вызывающий поток может выполнять другие задачи.</span><span class="sxs-lookup"><span data-stu-id="2fd10-109">This enables a time-consuming operation to be executed in the background while the calling thread is free to perform other tasks.</span></span>

<span data-ttu-id="2fd10-110">Использование асинхронного ввода-вывода позволяет серверу канала использовать цикл, который выполняет следующие действия:</span><span class="sxs-lookup"><span data-stu-id="2fd10-110">Using asynchronous I/O enables a pipe server to use a loop that performs the following steps:</span></span>

1.  <span data-ttu-id="2fd10-111">Укажите несколько объектов событий в вызове функции Wait и дождитесь, пока одно из объектов не будет установлено в сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="2fd10-111">Specify multiple event objects in a call to the wait function, and wait for one of the objects to be set to the signaled state.</span></span>
2.  <span data-ttu-id="2fd10-112">Используйте возвращаемое значение функции Wait, чтобы определить, какая операция перекрытия завершена.</span><span class="sxs-lookup"><span data-stu-id="2fd10-112">Use the wait function's return value to determine which overlapped operation has finished.</span></span>
3.  <span data-ttu-id="2fd10-113">Выполните задачи, необходимые для очистки завершенной операции, и инициируйте следующую операцию для этого обработчика канала.</span><span class="sxs-lookup"><span data-stu-id="2fd10-113">Perform the tasks necessary to clean up the completed operation and initiate the next operation for that pipe handle.</span></span> <span data-ttu-id="2fd10-114">Это может привести к запуску другой операции перекрытия для одного и того же обработчика канала.</span><span class="sxs-lookup"><span data-stu-id="2fd10-114">This can involve starting another overlapped operation for the same pipe handle.</span></span>

<span data-ttu-id="2fd10-115">Перекрывающиеся операции позволяют одному каналу одновременно считывать и записывать данные, а в одном потоке выполнять одновременные операции ввода-вывода с несколькими дескрипторами каналов.</span><span class="sxs-lookup"><span data-stu-id="2fd10-115">Overlapped operations make it possible for one pipe to read and write data simultaneously and for a single thread to perform simultaneous I/O operations on multiple pipe handles.</span></span> <span data-ttu-id="2fd10-116">Это позволяет однопотоковому серверу каналов эффективно работать с несколькими клиентами канала.</span><span class="sxs-lookup"><span data-stu-id="2fd10-116">This enables a single-threaded pipe server to handle communications with multiple pipe clients efficiently.</span></span> <span data-ttu-id="2fd10-117">Пример см. в разделе [сервер именованных каналов с перекрытием операций ввода-вывода](named-pipe-server-using-overlapped-i-o.md).</span><span class="sxs-lookup"><span data-stu-id="2fd10-117">For an example, see [Named Pipe Server Using Overlapped I/O](named-pipe-server-using-overlapped-i-o.md).</span></span>

<span data-ttu-id="2fd10-118">Чтобы сервер канала мог использовать синхронные операции для взаимодействия с несколькими клиентами, он должен создать отдельный поток для каждого клиента канала, чтобы один или несколько потоков могли выполняться в ожидании других потоков.</span><span class="sxs-lookup"><span data-stu-id="2fd10-118">For a pipe server to use synchronous operations to communicate with more than one client, it must create a separate thread for each pipe client so that one or more threads can run while other threads are waiting.</span></span> <span data-ttu-id="2fd10-119">Пример многопотокового сервера каналов, использующего синхронные операции, см. в разделе [многопотоковый сервер каналов](multithreaded-pipe-server.md).</span><span class="sxs-lookup"><span data-stu-id="2fd10-119">For an example of a multithreaded pipe server that uses synchronous operations, see [Multithreaded Pipe Server](multithreaded-pipe-server.md).</span></span>

## <a name="enabling-asynchronous-operation"></a><span data-ttu-id="2fd10-120">Включение асинхронной операции</span><span class="sxs-lookup"><span data-stu-id="2fd10-120">Enabling Asynchronous Operation</span></span>

<span data-ttu-id="2fd10-121">Функции [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**трансактнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)и [**коннектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) могут выполняться асинхронно, только если включен режим перекрытия для указанного обработчика канала и указан допустимый указатель на структуру [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="2fd10-121">The [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe), and [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) functions can be performed asynchronously only if you enable overlapped mode for the specified pipe handle and specify a valid pointer to an [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="2fd10-122">Если **перекрытый** указатель имеет **значение NULL**, возвращаемое значение функции может неправильно указывать на завершение операции.</span><span class="sxs-lookup"><span data-stu-id="2fd10-122">If the **OVERLAPPED** pointer is **NULL**, the function return value can incorrectly indicate that the operation has been completed.</span></span> <span data-ttu-id="2fd10-123">Поэтому настоятельно рекомендуется, чтобы при создании маркера с \_ \_ перекрытием флага файла и необходимости асинхронного поведения всегда задается допустимая структура **OVERLAPPED** .</span><span class="sxs-lookup"><span data-stu-id="2fd10-123">Therefore, it is strongly recommended that if you create a handle with FILE\_FLAG\_OVERLAPPED and want asynchronous behavior, you should always specify a valid **OVERLAPPED** structure.</span></span>

<span data-ttu-id="2fd10-124">Элемент **Хевент** указанной [**перекрывающейся**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) структуры должен содержать маркер для объекта события ручного сброса.</span><span class="sxs-lookup"><span data-stu-id="2fd10-124">The **hEvent** member of the specified [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure must contain a handle to a manual-reset event object.</span></span> <span data-ttu-id="2fd10-125">Это объект синхронизации, созданный функцией [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa) .</span><span class="sxs-lookup"><span data-stu-id="2fd10-125">This is a synchronization object created by the [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa) function.</span></span> <span data-ttu-id="2fd10-126">Поток, инициирующий операцию перекрытия, использует объект события для определения момента завершения операции.</span><span class="sxs-lookup"><span data-stu-id="2fd10-126">The thread that initiates the overlapped operation uses the event object to determine when the operation has finished.</span></span> <span data-ttu-id="2fd10-127">Не следует использовать дескриптор канала для синхронизации при выполнении одновременных операций с одним и тем же дескриптором, поскольку не существует способа узнать, какое завершение операции привело к сигналу дескриптора канала.</span><span class="sxs-lookup"><span data-stu-id="2fd10-127">You should not use the pipe handle for synchronization when performing simultaneous operations on the same handle because there is no way of knowing which operation's completion caused the pipe handle to be signaled.</span></span> <span data-ttu-id="2fd10-128">Единственным надежным способом выполнения одновременных операций с одним и тем же обработчиком канала является использование отдельной **ПЕРЕкрывающейся** структуры с собственным объектом события для каждой операции.</span><span class="sxs-lookup"><span data-stu-id="2fd10-128">The only reliable technique for performing simultaneous operations on the same pipe handle is to use a separate **OVERLAPPED** structure with its own event object for each operation.</span></span> <span data-ttu-id="2fd10-129">Дополнительные сведения об объектах событий см. в разделе [Синхронизация](/windows/desktop/Sync/synchronization).</span><span class="sxs-lookup"><span data-stu-id="2fd10-129">For more information about event objects, see [Synchronization](/windows/desktop/Sync/synchronization).</span></span>

<span data-ttu-id="2fd10-130">Кроме того, можно получать уведомления о завершении операции перекрытия с помощью функций [**жеткуеуедкомплетионстатус**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) или [**жеткуеуедкомплетионстатусекс**](/windows/desktop/FileIO/getqueuedcompletionstatusex-func) .</span><span class="sxs-lookup"><span data-stu-id="2fd10-130">Also, you can be notified when an overlapped operation completes by using the [**GetQueuedCompletionStatus**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) or [**GetQueuedCompletionStatusEx**](/windows/desktop/FileIO/getqueuedcompletionstatusex-func) functions.</span></span> <span data-ttu-id="2fd10-131">В этом случае вам не нужно назначать событие ручного сброса в структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) , и завершение происходит с обработчиком канала так же, как асинхронная операция чтения или записи.</span><span class="sxs-lookup"><span data-stu-id="2fd10-131">In this case, you do not need to assign the manual-reset event in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure, and the completion happens against the pipe handle in the same way as an asynchronous read or write operation.</span></span> <span data-ttu-id="2fd10-132">Дополнительные сведения см. в разделе [порты завершения ввода-вывода](/windows/desktop/FileIO/i-o-completion-ports).</span><span class="sxs-lookup"><span data-stu-id="2fd10-132">For more information, see [I/O Completion Ports](/windows/desktop/FileIO/i-o-completion-ports).</span></span>

<span data-ttu-id="2fd10-133">Если операции [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**трансактнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)и [**коннектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) выполняются асинхронно, происходит одно из следующих событий.</span><span class="sxs-lookup"><span data-stu-id="2fd10-133">When [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe), and [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) operations are performed asynchronously, one of the following occurs:</span></span>

-   <span data-ttu-id="2fd10-134">Если операция завершается после возвращения функции, возвращаемое значение указывает на успешное или неуспешное выполнение операции.</span><span class="sxs-lookup"><span data-stu-id="2fd10-134">If the operation is complete when the function returns, the return value indicates the success or failure of the operation.</span></span> <span data-ttu-id="2fd10-135">При возникновении ошибки возвращаемое значение равно нулю, а функция [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) возвращает нечто, отличное от "ошибка \_ ввода-вывода" \_ .</span><span class="sxs-lookup"><span data-stu-id="2fd10-135">If an error occurs, the return value is zero and the [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) function returns something other than ERROR\_IO\_PENDING.</span></span>
-   <span data-ttu-id="2fd10-136">Если операция не была завершена при возврате функции, возвращаемое значение равно нулю, а [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) возвращает сообщение об ошибке \_ ввода-вывода \_ в ожидании.</span><span class="sxs-lookup"><span data-stu-id="2fd10-136">If the operation has not finished when the function returns, the return value is zero and [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns ERROR\_IO\_PENDING.</span></span> <span data-ttu-id="2fd10-137">В этом случае вызывающий поток должен дождаться завершения операции.</span><span class="sxs-lookup"><span data-stu-id="2fd10-137">In this case, the calling thread must wait until the operation has finished.</span></span> <span data-ttu-id="2fd10-138">Чтобы определить результаты, вызывающий поток должен вызвать функцию [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) .</span><span class="sxs-lookup"><span data-stu-id="2fd10-138">The calling thread must then call the [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) function to determine the results.</span></span>

## <a name="using-completion-routines"></a><span data-ttu-id="2fd10-139">Использование подпрограмм завершения</span><span class="sxs-lookup"><span data-stu-id="2fd10-139">Using Completion Routines</span></span>

<span data-ttu-id="2fd10-140">Функции [**реадфиликс**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) и [**вритефиликс**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) предоставляют другую форму перекрывающихся операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2fd10-140">The [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) functions provide another form of overlapped I/O.</span></span> <span data-ttu-id="2fd10-141">В отличие от перекрывающихся функций [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) и [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) , использующих объект события для оповещения о завершении, расширенные функции задают *подпрограммы завершения*.</span><span class="sxs-lookup"><span data-stu-id="2fd10-141">Unlike the overlapped [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) functions, which use an event object to signal completion, the extended functions specify a *completion routine*.</span></span> <span data-ttu-id="2fd10-142">Подпрограммы завершения — это функция, которая находится в очереди на выполнение после завершения операции чтения или записи.</span><span class="sxs-lookup"><span data-stu-id="2fd10-142">A completion routine is a function that is queued for execution when the read or write operation is finished.</span></span> <span data-ttu-id="2fd10-143">Подсистема завершения не выполняется до тех пор, пока поток, который вызвал **реадфиликс** и **вритефиликс** , не начнет асинхронную *операцию ожидания* , вызвав одну из [функций ожидания с оповещением](/windows/desktop/Sync/wait-functions) с параметром *фалертабле* , установленным в **значение true**.</span><span class="sxs-lookup"><span data-stu-id="2fd10-143">The completion routine is not executed until the thread that called **ReadFileEx** and **WriteFileEx** starts an *alertable wait operation* by calling one of the [alertable wait functions](/windows/desktop/Sync/wait-functions) with the *fAlertable* parameter set to **TRUE**.</span></span> <span data-ttu-id="2fd10-144">В операции ожидания с оповещением функции также возвращают, когда подсистема завершения **реадфиликс** или **вритефиликс** помещается в очередь на выполнение.</span><span class="sxs-lookup"><span data-stu-id="2fd10-144">In an alertable wait operation, the functions also return when a **ReadFileEx** or **WriteFileEx** completion routine is queued for execution.</span></span> <span data-ttu-id="2fd10-145">Сервер канала может использовать расширенные функции для выполнения последовательности операций чтения и записи для каждого клиента, который подключается к нему.</span><span class="sxs-lookup"><span data-stu-id="2fd10-145">A pipe server can use the extended functions to perform a sequence of read and write operations for each client that connects to it.</span></span> <span data-ttu-id="2fd10-146">Каждая операция чтения или записи в последовательности указывает подпрограммы завершения, и каждая подпрограмма завершения инициирует следующий шаг в последовательности.</span><span class="sxs-lookup"><span data-stu-id="2fd10-146">Each read or write operation in the sequence specifies a completion routine, and each completion routine initiates the next step in the sequence.</span></span> <span data-ttu-id="2fd10-147">Пример см. в разделе [сервер именованных каналов с помощью подпрограмм завершения](named-pipe-server-using-completion-routines.md).</span><span class="sxs-lookup"><span data-stu-id="2fd10-147">For an example, see [Named Pipe Server Using Completion Routines](named-pipe-server-using-completion-routines.md).</span></span>

 

 
