---
description: Если в метод DrawImage передается только левый верхний угол изображения, Windows GDI+ может масштабировать изображение, что приведет к снижению производительности.
ms.assetid: da571970-a4fc-4d4a-9264-0085d9807d66
title: Повышение производительности за счет предотвращения автоматического масштабирования
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 54b505043bf8a303a58c6fc5936a31d794052c78
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104985164"
---
# <a name="improving-performance-by-avoiding-automatic-scaling"></a>Повышение производительности за счет предотвращения автоматического масштабирования

Если в метод **DrawImage** передается только левый верхний угол изображения, Windows GDI+ может масштабировать изображение, что приведет к снижению производительности.

Следующий вызов метода **DrawImage** задает левый верхний угол (50, 30), но не задает прямоугольник назначения:


```
graphics.DrawImage(&image, 50, 30);  // upper-left corner at (50, 30)
```



Хотя это самая простая версия метода **DrawImage** с точки зрения количества обязательных аргументов, она не обязательно является самой эффективной. Если количество точек на дюйм на текущем устройстве отображения отличается от количества точек на дюйм на устройстве, где был создан образ, GDI+ масштабирует изображение таким образом, чтобы его физический размер на текущем устройстве отображался максимально близко к физическому размеру на устройстве, где оно было создано.

Если вы хотите предотвратить такое масштабирование, передайте ширину и высоту прямоугольника назначения методу **DrawImage** . В следующем примере одно и то же изображение рисуется дважды. В первом случае ширина и высота прямоугольника назначения не указываются, а изображение автоматически масштабируется. Во втором случае ширина и высота (измеряемая в пикселях) прямоугольника назначения указываются так же, как ширина и высота исходного изображения.


```
Image image(L"Texture.jpg");
graphics.DrawImage(&image, 10, 10);
graphics.DrawImage(&image, 120, 10, image.GetWidth(), image.GetHeight());
```



На следующем рисунке показано изображение, отображаемое дважды.

![снимок экрана окна, содержащего две версии одного изображения с разными шкалами](images/scaledtexture1.png)

 

 



