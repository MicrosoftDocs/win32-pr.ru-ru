---
description: Значение реестра может хранить данные в различных форматах.
ms.assetid: 5fd828d6-4d62-4823-a2f1-15782b5cd28c
title: Типы значений реестра
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: adc653e69c514bc77323704485e88f0a57eebaae
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "103910319"
---
# <a name="registry-value-types"></a><span data-ttu-id="4e1b5-103">Типы значений реестра</span><span class="sxs-lookup"><span data-stu-id="4e1b5-103">Registry Value Types</span></span>

<span data-ttu-id="4e1b5-104">Значение реестра может хранить данные в различных форматах.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-104">A registry value can store data in various formats.</span></span> <span data-ttu-id="4e1b5-105">Например, при хранении данных в значении реестра для экземпляра путем вызова функции [**RegSetValueEx**](/windows/desktop/api/Winreg/nf-winreg-regsetvalueexa) можно указать одно из следующих значений, чтобы указать тип сохраняемых данных.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-105">When you store data under a registry value, for instance by calling the [**RegSetValueEx**](/windows/desktop/api/Winreg/nf-winreg-regsetvalueexa) function, you can specify one of the following values to indicate the type of data being stored.</span></span> <span data-ttu-id="4e1b5-106">При извлечении значения реестра такие функции, как [**процедура RegQueryValueEx**](/windows/desktop/api/Winreg/nf-winreg-regqueryvalueexa) , используют эти значения для указания типа извлекаемых данных.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-106">When you retrieve a registry value, functions such as [**RegQueryValueEx**](/windows/desktop/api/Winreg/nf-winreg-regqueryvalueexa) use these values to indicate the type of data retrieved.</span></span>

<span data-ttu-id="4e1b5-107">В Winnt. h определены следующие типы значений реестра.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-107">The following registry value types are defined in Winnt.h.</span></span>



| <span data-ttu-id="4e1b5-108">Значение</span><span class="sxs-lookup"><span data-stu-id="4e1b5-108">Value</span></span>                                 | <span data-ttu-id="4e1b5-109">Тип</span><span class="sxs-lookup"><span data-stu-id="4e1b5-109">Type</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|---------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="4e1b5-110">\_двоичный файл REG</span><span class="sxs-lookup"><span data-stu-id="4e1b5-110">REG\_BINARY</span></span><br/>                | <span data-ttu-id="4e1b5-111">Двоичные данные в любой форме.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-111">Binary data in any form.</span></span><br/>                                                                                                                                                                                                                                                                                                                                                                                                     |
| <span data-ttu-id="4e1b5-112">REG \_ DWORD</span><span class="sxs-lookup"><span data-stu-id="4e1b5-112">REG\_DWORD</span></span><br/>                 | <span data-ttu-id="4e1b5-113">32-разрядное число.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-113">A 32-bit number.</span></span><br/>                                                                                                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="4e1b5-114">REG \_ DWORD с \_ прямым \_ порядком байтов</span><span class="sxs-lookup"><span data-stu-id="4e1b5-114">REG\_DWORD\_LITTLE\_ENDIAN</span></span><br/> | <span data-ttu-id="4e1b5-115">32-разрядный номер в формате с прямым порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-115">A 32-bit number in little-endian format.</span></span><br/> <span data-ttu-id="4e1b5-116">Windows предназначена для работы на архитектурных компьютерах с прямым порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-116">Windows is designed to run on little-endian computer architectures.</span></span> <span data-ttu-id="4e1b5-117">Таким образом, это значение определяется как REG \_ DWORD в файлах заголовков Windows.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-117">Therefore, this value is defined as REG\_DWORD in the Windows header files.</span></span><br/>                                                                                                                                                                                                                          |
| <span data-ttu-id="4e1b5-118">REG \_ байт с \_ обратным \_ порядком байтов</span><span class="sxs-lookup"><span data-stu-id="4e1b5-118">REG\_DWORD\_BIG\_ENDIAN</span></span><br/>    | <span data-ttu-id="4e1b5-119">32-разрядное число в формате с обратным порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-119">A 32-bit number in big-endian format.</span></span><br/> <span data-ttu-id="4e1b5-120">Некоторые системы UNIX поддерживают архитектуры с обратным порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-120">Some UNIX systems support big-endian architectures.</span></span><br/>                                                                                                                                                                                                                                                                                                                         |
| <span data-ttu-id="4e1b5-121">\_распаковать \_ SZ</span><span class="sxs-lookup"><span data-stu-id="4e1b5-121">REG\_EXPAND\_SZ</span></span><br/>            | <span data-ttu-id="4e1b5-122">Строка, завершающаяся нулем, которая содержит нераскрытные ссылки на переменные среды (например, "% PATH%").</span><span class="sxs-lookup"><span data-stu-id="4e1b5-122">A null-terminated string that contains unexpanded references to environment variables (for example, "%PATH%").</span></span> <span data-ttu-id="4e1b5-123">Это будет строка в Юникоде или ANSI в зависимости от того, используются ли функции Юникода или ANSI.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-123">It will be a Unicode or ANSI string depending on whether you use the Unicode or ANSI functions.</span></span> <span data-ttu-id="4e1b5-124">Чтобы развернуть ссылки на переменные среды, используйте функцию [**експанденвиронментстрингс**](/windows/win32/api/processenv/nf-processenv-expandenvironmentstringsa) .</span><span class="sxs-lookup"><span data-stu-id="4e1b5-124">To expand the environment variable references, use the [**ExpandEnvironmentStrings**](/windows/win32/api/processenv/nf-processenv-expandenvironmentstringsa) function.</span></span><br/>                                                                                 |
| <span data-ttu-id="4e1b5-125">Ссылка на REG \_</span><span class="sxs-lookup"><span data-stu-id="4e1b5-125">REG\_LINK</span></span><br/>                  | <span data-ttu-id="4e1b5-126">Строка в Юникоде, заканчивающаяся нулем, которая содержит целевой путь символьной ссылки, созданной путем вызова функции [**регкреатекэйекс**](/windows/desktop/api/Winreg/nf-winreg-regcreatekeyexa) с \_ параметром REG \_ Create \_ Link.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-126">A null-terminated Unicode string that contains the target path of a symbolic link that was created by calling the [**RegCreateKeyEx**](/windows/desktop/api/Winreg/nf-winreg-regcreatekeyexa) function with REG\_OPTION\_CREATE\_LINK.</span></span><br/>                                                                                                                                                                                                                          |
| <span data-ttu-id="4e1b5-127">REG \_ Multi \_ SZ</span><span class="sxs-lookup"><span data-stu-id="4e1b5-127">REG\_MULTI\_SZ</span></span><br/>             | <span data-ttu-id="4e1b5-128">Последовательность строк, завершающихся нулем, заканчивающаяся пустой строкой ( \\ 0).</span><span class="sxs-lookup"><span data-stu-id="4e1b5-128">A sequence of null-terminated strings, terminated by an empty string (\\0).</span></span><br/> <span data-ttu-id="4e1b5-129">Ниже представлен пример такого кода:</span><span class="sxs-lookup"><span data-stu-id="4e1b5-129">The following is an example:</span></span><br/> <span data-ttu-id="4e1b5-130">*Строка1* \\ 0 *строка2* \\ 0 *string3* \\ 0 *ластстринг* \\ 0 \\ 0</span><span class="sxs-lookup"><span data-stu-id="4e1b5-130">*String1*\\0 *String2*\\0 *String3*\\0 *LastString*\\0\\0</span></span><br/> <span data-ttu-id="4e1b5-131">Первый \\ 0 завершает первую строку, вторая — до последней \\ 0 — завершает последнюю строку, а последняя — \\ 0 — последовательность завершается.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-131">The first \\0 terminates the first string, the second to the last \\0 terminates the last string, and the final \\0 terminates the sequence.</span></span> <span data-ttu-id="4e1b5-132">Обратите внимание, что конечный Терминатор должен быть разделяться на длину строки.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-132">Note that the final terminator must be factored into the length of the string.</span></span><br/> |
| <span data-ttu-id="4e1b5-133">REG \_ None</span><span class="sxs-lookup"><span data-stu-id="4e1b5-133">REG\_NONE</span></span><br/>                  | <span data-ttu-id="4e1b5-134">Нет определенного типа значения.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-134">No defined value type.</span></span><br/>                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="4e1b5-135">REG \_ QWORD</span><span class="sxs-lookup"><span data-stu-id="4e1b5-135">REG\_QWORD</span></span><br/>                 | <span data-ttu-id="4e1b5-136">64-разрядное число.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-136">A 64-bit number.</span></span><br/>                                                                                                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="4e1b5-137">REG с обратным \_ \_ \_ порядком байтов</span><span class="sxs-lookup"><span data-stu-id="4e1b5-137">REG\_QWORD\_LITTLE\_ENDIAN</span></span><br/> | <span data-ttu-id="4e1b5-138">64-разрядный номер в формате с прямым порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-138">A 64-bit number in little-endian format.</span></span><br/> <span data-ttu-id="4e1b5-139">Windows предназначена для работы на архитектурных компьютерах с прямым порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-139">Windows is designed to run on little-endian computer architectures.</span></span> <span data-ttu-id="4e1b5-140">Таким образом, это значение определяется как REG \_ QWORD в файлах заголовков Windows.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-140">Therefore, this value is defined as REG\_QWORD in the Windows header files.</span></span><br/>                                                                                                                                                                                                                          |
| <span data-ttu-id="4e1b5-141">REG \_ SZ</span><span class="sxs-lookup"><span data-stu-id="4e1b5-141">REG\_SZ</span></span><br/>                    | <span data-ttu-id="4e1b5-142">Строка с нулевым символом в конце.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-142">A null-terminated string.</span></span> <span data-ttu-id="4e1b5-143">Это может быть строка в Юникоде или ANSI, в зависимости от того, используются ли функции Юникода или ANSI.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-143">This will be either a Unicode or an ANSI string, depending on whether you use the Unicode or ANSI functions.</span></span><br/>                                                                                                                                                                                                                                                                                       |



 

## <a name="string-values"></a><span data-ttu-id="4e1b5-144">Строковые значения</span><span class="sxs-lookup"><span data-stu-id="4e1b5-144">String Values</span></span>

<span data-ttu-id="4e1b5-145">Если данные имеют тип REG \_ SZ, REG \_ Multi \_ SZ или REG \_ expand \_ SZ, строка может быть не сохранена с соответствующими завершающими символами NULL.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-145">If data has the REG\_SZ, REG\_MULTI\_SZ, or REG\_EXPAND\_SZ type, the string may not have been stored with the proper terminating null characters.</span></span> <span data-ttu-id="4e1b5-146">Поэтому при чтении строки из реестра необходимо убедиться, что строка должна завершиться должным образом, прежде чем использовать ее. в противном случае он может перезаписать буфер.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-146">Therefore, when reading a string from the registry, you must ensure that the string is properly terminated before using it; otherwise, it may overwrite a buffer.</span></span> <span data-ttu-id="4e1b5-147">(Обратите внимание, что REG \_ НЕСКОЛЬКО \_ SZ строк должны иметь два завершающих нуль символа.)</span><span class="sxs-lookup"><span data-stu-id="4e1b5-147">(Note that REG\_MULTI\_SZ strings should have two terminating null characters.)</span></span>

<span data-ttu-id="4e1b5-148">При записи строки в реестр необходимо указать длину строки, включая завершающий нуль-символ ( \\ 0).</span><span class="sxs-lookup"><span data-stu-id="4e1b5-148">When writing a string to the registry, you must specify the length of the string, including the terminating null character (\\0).</span></span> <span data-ttu-id="4e1b5-149">Распространенная ошибка заключается в использовании функции **strlen** для определения длины строки, но чтобы забывать, что **strlen** возвращает только число символов в строке, не включая завершающее значение null.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-149">A common error is to use the **strlen** function to determine the length of the string, but to forget that **strlen** returns only the number of characters in the string, not including the terminating null.</span></span> <span data-ttu-id="4e1b5-150">Таким образом, длина строки должна быть вычислена следующим образом: `strlen( string ) + 1`</span><span class="sxs-lookup"><span data-stu-id="4e1b5-150">Therefore, the length of the string should be calculated as follows: `strlen( string ) + 1`</span></span>

<span data-ttu-id="4e1b5-151">Строка реестра с \_ несколькими \_ SZми заканчивается строкой длиной 0.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-151">A REG\_MULTI\_SZ string ends with a string of length 0.</span></span> <span data-ttu-id="4e1b5-152">Поэтому невозможно включить в последовательность строку нулевой длины.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-152">Therefore, it is not possible to include a zero-length string in the sequence.</span></span> <span data-ttu-id="4e1b5-153">Пустая последовательность будет определена следующим образом: \\ 0.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-153">An empty sequence would be defined as follows: \\0.</span></span>

<span data-ttu-id="4e1b5-154">В следующем примере рассматривается строка реестра с \_ несколькими \_ SZми.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-154">The following example walks a REG\_MULTI\_SZ string.</span></span>


```C++
#include <windows.h>
#include <tchar.h>
#include <stdio.h>

void SampleSzz(PTSTR pszz)
{
   _tprintf(_TEXT("\tBegin multi-sz string\n"));
   while (*pszz) 
   {
      _tprintf(_TEXT("\t\t%s\n"), pszz);
      pszz = pszz + _tcslen(pszz) + 1;
   }
   _tprintf(_TEXT("\tEnd multi-sz\n"));
}

int __cdecl main(int argc, char **argv)
{
   // Because the compiler adds a \0 at the end of quoted strings, 
   // there are two \0 terminators at the end. 

   _tprintf(_TEXT("Conventional multi-sz string:\n"));  
   SampleSzz(_TEXT("String1\0String2\0String3\0LastString\0"));

   _tprintf(_TEXT("\nTest case with no strings:\n"));  
   SampleSzz(_TEXT(""));

   return 0;
}
```



## <a name="byte-formats"></a><span data-ttu-id="4e1b5-155">Форматы байтов</span><span class="sxs-lookup"><span data-stu-id="4e1b5-155">Byte Formats</span></span>

<span data-ttu-id="4e1b5-156">В *формате с прямым порядком* байтов значение в байтах хранится в памяти с наименьшего байта («маленький конец») до самого большого байта.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-156">In *little-endian format*, a multi-byte value is stored in memory from the lowest byte (the "little end") to the highest byte.</span></span> <span data-ttu-id="4e1b5-157">Например, значение 0x12345678 хранится как (0x78 0x56 0x34 0x12) в формате с прямым порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-157">For example, the value 0x12345678 is stored as (0x78 0x56 0x34 0x12) in little-endian format.</span></span>

<span data-ttu-id="4e1b5-158">В *формате с обратным порядком байтов* многобайтовое значение хранится в памяти из самого длинного байта («Big-конец») до наименьшего байта.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-158">In *big-endian format*, a multi-byte value is stored in memory from the highest byte (the "big end") to the lowest byte.</span></span> <span data-ttu-id="4e1b5-159">Например, значение 0x12345678 сохраняется как (0x12 0x34 0x56 0x78) в формате с обратным порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="4e1b5-159">For example, the value 0x12345678 is stored as (0x12 0x34 0x56 0x78) in big-endian format.</span></span>

 

