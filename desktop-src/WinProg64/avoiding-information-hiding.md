---
title: Предотвращение скрытия информации
description: Иногда программы намеренно или непреднамеренно скрывают информацию из механизма маршалирования RPC.
ms.assetid: 016b9221-092d-4c25-a396-4f41dcdfb3cf
keywords:
- Обратная совместимость 64-разрядное программирование для Windows
- проблемы совместимости с 64-разрядным программированием Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2f4b9e4ba7ed5165378beb93005243af03f9e469
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104413224"
---
# <a name="avoiding-information-hiding"></a><span data-ttu-id="0c014-105">Предотвращение скрытия информации</span><span class="sxs-lookup"><span data-stu-id="0c014-105">Avoiding Information Hiding</span></span>

<span data-ttu-id="0c014-106">Иногда программы намеренно или непреднамеренно скрывают информацию из механизма маршалирования RPC.</span><span class="sxs-lookup"><span data-stu-id="0c014-106">Occasionally, programs deliberately or inadvertently hide information from the RPC marshaling engine.</span></span> <span data-ttu-id="0c014-107">Ниже приведен ряд примеров.</span><span class="sxs-lookup"><span data-stu-id="0c014-107">Some examples are as follows:</span></span>

-   <span data-ttu-id="0c014-108">Отправка структуры данных в виде блока байтов, не имеющего различий</span><span class="sxs-lookup"><span data-stu-id="0c014-108">Sending a data structure as an undifferentiated block of bytes</span></span>
-   <span data-ttu-id="0c014-109">Использование производительности с помощью побочного действия метода для передачи дополнительных данных по каналу передачи</span><span class="sxs-lookup"><span data-stu-id="0c014-109">Leveraging performance by using a side effect from a method to channel additional data across the wire</span></span>
-   <span data-ttu-id="0c014-110">Попытка маскировки маркера путем передачи его в виде **DWORD** или **ulong**</span><span class="sxs-lookup"><span data-stu-id="0c014-110">Attempting to disguise a handle by passing it as a **DWORD** or a **ULONG**</span></span>

<span data-ttu-id="0c014-111">Эти приемы почти гарантируют проблемы совместимости даже перед переносом приложения на 64-разрядную версию Windows.</span><span class="sxs-lookup"><span data-stu-id="0c014-111">These techniques are almost guaranteed to introduce compatibility problems even before you port your application to 64-bit Windows.</span></span>

<span data-ttu-id="0c014-112">Вместо того чтобы отправлять контекст сервера в виде **DWORD** в стандартном вызове удаленной процедуры, используйте контекстный маркер для предоставления непрозрачного маркера контексту сервера, который удерживается от имени клиента.</span><span class="sxs-lookup"><span data-stu-id="0c014-112">Instead of sending a server context as a **DWORD** in a standard remote procedure call, use a context handle to provide an opaque handle to a server context that is held on behalf of a client.</span></span> <span data-ttu-id="0c014-113">Контексты определяются идентификаторами GUID, определенными во время выполнения RPC, когда сервер создает контекстный обработчик для клиента.</span><span class="sxs-lookup"><span data-stu-id="0c014-113">Contexts are identified by GUIDs defined by the RPC run time when a server creates a context handle for a client.</span></span> <span data-ttu-id="0c014-114">Указатель не используется по каналу передачи, и операция полностью прозрачна в пределах 32-или 64-разрядной границы.</span><span class="sxs-lookup"><span data-stu-id="0c014-114">No pointer is used over the wire and the operation is completely transparent across 32- or 64-bit boundaries.</span></span> <span data-ttu-id="0c014-115">Дополнительные сведения об использовании дескрипторов контекста см. в разделе [дескрипторы контекста](/windows/desktop/Rpc/context-handles).</span><span class="sxs-lookup"><span data-stu-id="0c014-115">For more information on using context handles, see [Context Handles](/windows/desktop/Rpc/context-handles).</span></span>

<span data-ttu-id="0c014-116">Интерфейсы DCOM не могут использовать дескрипторы контекста, так как COM обеспечивает собственное управление контекстом.</span><span class="sxs-lookup"><span data-stu-id="0c014-116">DCOM interfaces cannot use context handles because COM provides its own context management.</span></span> <span data-ttu-id="0c014-117">Вместо создания маркера контекста можно передать указатель интерфейса на COM-объект.</span><span class="sxs-lookup"><span data-stu-id="0c014-117">Instead of creating a context handle, you can pass an interface pointer to the COM object.</span></span> <span data-ttu-id="0c014-118">Затем можно вызвать методы непосредственно через указатель интерфейса или поместить указатель внутрь других вызовов.</span><span class="sxs-lookup"><span data-stu-id="0c014-118">Then you can call the methods directly through the interface pointer or place the pointer inside other calls.</span></span> <span data-ttu-id="0c014-119">Чтобы освободить серверный объект, клиент вызывает метод **освобождения** интерфейса через указатель интерфейса.</span><span class="sxs-lookup"><span data-stu-id="0c014-119">To release the server object, the client calls the interface's **Release** method through the interface pointer.</span></span>

<span data-ttu-id="0c014-120">Опять же, могут возникнуть ситуации, когда нельзя изменить исходный дизайн кода, который вы переносите.</span><span class="sxs-lookup"><span data-stu-id="0c014-120">Again, there may be times when you cannot change the original design of the code that you are porting.</span></span> <span data-ttu-id="0c014-121">Если не существует способа избежать отправки указателя по каналу в виде **DWORD**, необходимо реализовать некоторую форму сопоставления на стороне сервера между значениями и указателями **DWORD** .</span><span class="sxs-lookup"><span data-stu-id="0c014-121">If there is no way to avoid sending a pointer across the wire as a **DWORD**, you will have to implement some form of server-side mapping between **DWORD** values and pointers.</span></span> <span data-ttu-id="0c014-122">Одним из способов сделать это является изменение указателей в клиентской части приложения на типы точности указателей, такие как **ulong \_ ptr** или **DWORD \_ ptr**.</span><span class="sxs-lookup"><span data-stu-id="0c014-122">One way to do this is to change the pointers in the client side application to pointer-precision types, such as **ULONG\_PTR** or **DWORD\_PTR**.</span></span> <span data-ttu-id="0c014-123">Затем используйте вызов MIDL в \[ [**\_ качестве**](/windows/desktop/Midl/call-as) \] атрибута, чтобы разместить указатели на канале как значения **DWORD** .</span><span class="sxs-lookup"><span data-stu-id="0c014-123">Then use the MIDL \[[**call\_as**](/windows/desktop/Midl/call-as)\] attribute to put the pointers on the wire as **DWORD** values.</span></span> <span data-ttu-id="0c014-124">Обертка на стороне клиента должна передавать аргументы только вместе.</span><span class="sxs-lookup"><span data-stu-id="0c014-124">The client-side wrapper need only pass the arguments along.</span></span> <span data-ttu-id="0c014-125">Оболочка на стороне сервера обрабатывает сопоставление обоих типов.</span><span class="sxs-lookup"><span data-stu-id="0c014-125">The server-side wrapper handles the mapping between both types.</span></span> <span data-ttu-id="0c014-126">Аналогичным образом можно использовать либо \[ атрибут [**передать \_ как**](/windows/desktop/Midl/transmit-as) , \] либо \[ атрибут [**представить \_ как**](/windows/desktop/Midl/represent-as) \] для преобразования данных в формат с обратной совместимостью для представления сети.</span><span class="sxs-lookup"><span data-stu-id="0c014-126">In a similar way, you can use either the \[[**transmit\_as**](/windows/desktop/Midl/transmit-as)\] attribute or the \[[**represent\_as**](/windows/desktop/Midl/represent-as)\] attribute to convert your data to a backward-compatible format for wire representation.</span></span>

<span data-ttu-id="0c014-127">Если обратная совместимость не является проблемой или если этот обработчик не используется для удаленных вызовов и вы уверены, что удаленные вызовы между 32 и 64-разрядными процессами никогда не будут выполняться, можно переопределить аргумент как **ULONG64**.</span><span class="sxs-lookup"><span data-stu-id="0c014-127">If backward-wire compatibility is not an issue or if the handle is not used for remote calls and you are sure that remote calls between 32- and 64-bit processes will never happen, you can redefine an argument as a **ULONG64**.</span></span> <span data-ttu-id="0c014-128">При необходимости можно изменить 32-разрядное приложение, чтобы передать пользователю **параметр DWORD** .</span><span class="sxs-lookup"><span data-stu-id="0c014-128">If necessary, you can modify the 32-bit application to pass a **DWORD** to the user.</span></span> <span data-ttu-id="0c014-129">Кроме того, можно создать отдельные заглушки из отдельных файлов IDL для каждой платформы, используя **DWORD** в 32-разрядной Windows и **ULONG64** в 64-разрядной версии Windows.</span><span class="sxs-lookup"><span data-stu-id="0c014-129">Alternatively, you can build separate stubs from separate IDL files for each platform using a **DWORD** on 32-bit Windows and a **ULONG64** on 64-bit Windows.</span></span>

 

 